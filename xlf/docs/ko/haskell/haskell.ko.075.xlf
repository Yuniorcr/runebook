<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt; ). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">파일의 행을 일련의 GHCi 명령으로 실행합니다. 이 명령은 &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt; 으로 설정 한 여러 줄 문장과 호환됩니다</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">쉘 명령 ⟨command⟩를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;IO String&lt;/code&gt; 유형의 계산으로 ⟨expr⟩ 을 실행 한 다음 결과 문자열을 GHCi 명령 목록으로 실행합니다. 여러 명령은 개행으로 구분됩니다. &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; 를&lt;/a&gt; 명령에 유용 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">빌더 실행</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">외부 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">실행은 한 단계 씩 진행될 수 있습니다. 평가자는 거의 모든 축소 후에 실행을 일시 중단하여 로컬 변수를 검사 할 수 있습니다. 이는 프로그램의 모든 지점에서 중단 점을 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">실행은 평가 모드에서 발생하는 각 평가 단계를 기억하지만 실제 중단 점에 도달 할 때까지 실행을 중단하지 않는 추적 모드에서 실행될 수 있습니다. 이 경우 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">중단 점에서 실행이 중지되었습니다. 프롬프트가 현재 중단 점에서 중지되었음을 표시하고 위치는 &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; 입니다. 위치를 더 명확히하기 위해 &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">실행 단계 마커</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">실행 전략</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">존재 테스트</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">iserv 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">절대 파일 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">명시 &lt;code&gt;forall&lt;/code&gt; 항상 필요하지 않습니다 - 참조 &lt;a href=&quot;#pattern-equiv-form&quot;&gt;패턴 서명 해당하는&lt;/a&gt; 이 섹션의 예를 들면, 또는 &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">레이아웃 대신 명시 적 괄호와 세미콜론을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">명시 적 목록 (예 : &lt;code&gt;[True, False]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">명시 적으로 양방향</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">명시 적으로 양방향 패턴 동의어는 허용되는 구문 측면에서 암시 적으로 양방향 것보다 더 큰 유연성을 제공합니다. 예를 들어 다음은 법적으로 암시 적으로 양방향 패턴 동의어가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">명시 적으로과 관련된 finaliser 실행 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . 종료 후이 값을 참조하면 유효하지 않은 메모리 참조가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">유형 수준의 자연의 지수.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">클래스 이름 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">클래스, 관련 유형 &lt;code&gt;GMap&lt;/code&gt; 및 멤버 함수를 &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;lookup&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 내보내기합니다 . 의 데이터 생성자 &lt;code&gt;GMap&lt;/code&gt; (이 경우 &lt;code&gt;GMapEither&lt;/code&gt; 는 ) 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">매우 크거나 재귀적인 기능에 대해서도 모든 전개를 공개하십시오.</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">id byunit-id⟩로 패키지 노출</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">패키지 노출 ⟨pkgpose</target>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">패키지 ⟨pkg⟩를 노출하고 불신으로 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">⟨pkg⟩ 패키지를 공개하고 신뢰할 수 있도록 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">플러그인을위한 ⟨pkg-id⟩ 노출</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">플러그인에 ⟨pkg⟩ 노출</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 플러그인 네임 스페이스에 패키지를 노출 하지만 패키지는 이름이 아닌 설치된 패키지 ID로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 플래그를 GHC에 전달합니다. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning 및 &lt;/a&gt;Renaming 모듈에 설명 된 Thinning 및 Renaming을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 패키지를 공개 하지만 패키지 이름은 이름이 아닌 단위 ID (즉 , 설치된 패키지 데이터베이스에있는 항목 의 &lt;code&gt;id&lt;/code&gt; 값 , 이전에 설치된 패키지 ID라고도 함)로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;code&gt;-package-id&lt;/code&gt; 플래그를 GHC에 전달합니다. &lt;code&gt;-package-id&lt;/code&gt; 는 &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning 및 Renaming 모듈에&lt;/a&gt; 설명 된 Thinning 및 Renaming을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟨pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수있는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟩pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수없는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">표현식 인용은 대부분의 Haskell 언어 구문을 허용합니다. 그러나 표현식 인용이 현재 지원하지 않는 일부 GHC 특정 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">표현식 스플 라이스 : 익명 및 명명 된 와일드 카드를 표현식 서명에 사용할 수 있습니다. 정규식 서명과 마찬가지로 추가 제약 조건 와일드 카드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">식 평가 모드. 이것은 명령 행에 주어진 단일 표현식 (evaluateexpr⟩)이 있다는 점을 제외하고는 대화식 모드와 매우 유사합니다. 자세한 내용은 &lt;a href=&quot;#eval-mode&quot;&gt;식 평가 모드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">정교하게 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">확장 된 유클리드 알고리즘.</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 의 확장 버전</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">새로운 유형으로 확장</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">원 자성을 여러 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 로 확장하는 것은 문제가 있으므로 더 복잡한 작업을 수행해야하는 경우 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">확장 가능한 예외</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">GHC의 Handle 구현을위한 외부 API</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 속성</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 속성</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 요소</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 요소</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 생성 및 실행을위한 추가 기능 . 그것들은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 성능을 응용 프로그램별로 미세 조정하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">추가 인스턴스</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">명령 행에서 normal &lt;code&gt;-llib&lt;/code&gt; 옵션을 사용하여 추가 라이브러리를 지정할 수 있습니다 . 여기에서 라이브러리 라는 용어 는 외부 객체 코드의 &lt;em&gt;라이브러리&lt;/em&gt; 를 의미합니다. Haskell 소스 코드의 라이브러리를 사용하려면 &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;모듈과 파일 이름을&lt;/a&gt; 참조하십시오 . 예를 들어 &quot;m&quot;라이브러리를로드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">추가 제약 조건 와일드 카드는 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추출 &lt;em&gt;N&lt;/em&gt; 번째의 (0- 기반) 사지 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; . &lt;em&gt;n&lt;/em&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; 의해보고 된대로 size보다 작아야합니다 .</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 을 추출하고 이에 대한 조치를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</target>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">두 가지 유형의 평등의 증거를 추출</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치의 단어에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 16 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 32 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 8 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">적용된 유형의 동등성에서 인수의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">적용된 형식의 동등성에서 형식 생성자의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 제외한 모든 것을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">비율의 분모를 축소 된 형태로 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">쌍의 첫 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">스트림의 첫 번째 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">오류 메시지에서 메시지 문자열 추출</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">축소 된 형태로 비율의 분자를 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">라이터 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">누적 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">스트림의 비어있는 꼬리를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">쌍의 두 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">분수 성분 추출</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">서브리스트 추출</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">누적 오류가있는 계산을위한 추출기.</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모두 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 를 추출합니다 . 이 함수는 필요한 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫고 쓰기 버퍼를 비우는 부작용이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</target>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">불변 배열의 경계를 추출합니다</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">소스 위치에서 열 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">복소수의 허수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">소스 위치에서 라인 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">구문 분석 오류에서 오류 메시지 목록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">소스 위치에서 소스 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">복소수의 실수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">구문 분석 오류에서 소스 위치를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">F. Lundh : 빠른 검색 알고리즘. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">동시성을 사용하거나 필요로하는 FFI 데이터 유형 및 작업 (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">FFI 지원은 기본적으로 활성화되어 있지만 &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 명시 적으로 활성화하거나 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">SimpleMAPI와 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">Win32 보안과 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">위에서 설명한 문제에 직면하여 일부 Haskell 프로그래머는 다음 버전의 클래스 선언과 같은 것을 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">실패는 실패의 원인 / 위치에 대한 정보를 기록합니다. 실패 값은 바운드 함수를 우회하고 다른 값은 바운드 함수의 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">패밀리 인스턴스는 클래스 인스턴스와 마찬가지로 암시 적으로 내보내집니다. 그러나 이것은 인스턴스의 헤드에만 적용되며 인스턴스가 정의한 데이터 생성자에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">팬인 : 두 개의 인수 화살표 사이에서 입력을 나누고 출력을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">팬 아웃 (Fanout) : 입력을 양쪽 화살표로 보내고 출력을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">기본 2에 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 빠른 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 로그 : integerLog2 # 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; 는 일반적으로 유용하며 나머지는 &lt;code&gt;fromRational&lt;/code&gt; 의 빠른 구현에만 필요합니다 . 그것들은 &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt; 에 필요 하므로이 모듈을 공개해야하지만 문서에는 표시되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">시스템 시계에 빠르게 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">빠른 문자 조작 기능.</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 대한 빠른 하위 문자열 검색 .</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 한 게으른 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대한 빠른 하위 문자열 검색 . 엄격한 구현에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">빠르고 확인되지 않은 비트 시프 팅 기능.</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">인수 화살표를 통해 표시된 입력을 공급하고 나머지는 변경되지 않은 채로 출력에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">모나드 내 상태의 현재 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">환경의 가치를 이끌어냅니다.</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">가장 접근하기 어려운 절</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">가장 적은 중복 조항</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">가장 적발 된 조항</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="translated">Field CapNo</target>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="translated">Field CapSetId</target>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="translated">Field String</target>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="translated">Field TaskId</target>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="translated">Field ThreadId</target>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="translated">Field Word16</target>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="translated">Field Word32</target>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="translated">Field Word32[]</target>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="translated">Field Word64</target>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="translated">Field Word8</target>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="translated">Field [String]</target>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">필드 명확성 제거는 punning과 결합 될 수 있습니다 (Puns &lt;a href=&quot;#record-puns&quot;&gt;기록&lt;/a&gt; 참조 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">선택기 기능 또는 레코드 업데이트에 사용되는 필드 이름은 범위에 해당 필드가 하나뿐이거나 다음 섹션에 설명 된대로 유형 서명이 제공되므로 모호하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">필드는 모호하지 않은 경우에만 선택기 함수로 사용될 수 있으므로 &lt;code&gt;S(x)&lt;/code&gt; 및 &lt;code&gt;T(x)&lt;/code&gt; 가 모두 범위에있는 경우 여전히 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 환경 변수의 경우 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; 이&lt;/a&gt; ⟨name⟩로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 이 옵션을 통과하면 &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">파일 &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; 은 현재 디렉토리 또는 상위 디렉토리 (그러나 사용자의 홈 디렉토리)에있는 경우.</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">파일 할당</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</target>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">닫을 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">파일 확장자 문자</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">파일 잠금</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">파일 모드 (예 : 권한).</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">파일 이름 조작</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">파일 이름 템플릿. 템플리트가 &quot;foo.ext&quot;인 경우 작성된 ​​파일은 &quot;fooXXX.ext&quot;이며 여기서 XXX는 임의의 숫자입니다. 여기에는 경로 구분 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">&quot;의미있는&quot;접미사 (예 : &lt;code&gt;.lhs&lt;/code&gt; 또는 &lt;code&gt;.o&lt;/code&gt; )가 있는 파일 이름은 해당 파일에 &quot;올바른 일&quot;이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">파일 옵션</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">파일 상태</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">파일 동기화</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">환경 변수 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt; 가 ⟨file⟩ 으로 설정된 경우 ⟨file⟩ 파일 .</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt; 옵션을 전달하면 ⟨file⟩ 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">파일 헤더 프라그 마는 파일을 사전 처리하기 전에 한 번만 읽습니다 (예 : cpp).</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">파일 이름 완성</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">(일반적으로 도트 (있는 경우 포함) 실행 파일의 파일 이름 확장자 &lt;code&gt;&quot;&quot;&lt;/code&gt; POSIX 시스템 및 &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; Windows 또는 OS / 2).</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">실행 파일 이름 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">파일 이름 / 디렉토리 기능</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">파일과 핸들</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">다른 접미사가있는 (또는 접미사가없는) 파일은 링커로 바로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 사용하여 BufferRange 를 채우 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">메모리 영역의 지정된 바이트 수를 바이트 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">필요한 값으로 메모리 영역 채우기</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 조치를 사용하여 다른 맵에서 키가 누락 된 항목을 필터링하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">최종 데이터 포인터</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">마무리 수단 (A)에 대한 후속 호출 준비 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ; (b) 종료자를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">약한 포인터를 완성하십시오. 반환 값은 새로운 세계 상태와 &quot;unboxed Maybe&quot;를 포함하는 Unboxed 튜플이며 &lt;code&gt;Int#&lt;/code&gt; 및 (아마도 잘못된) 마무리 작업으로 표시됩니다. &lt;code&gt;Int#&lt;/code&gt; 의 &lt;code&gt;1&lt;/code&gt; 이 종료 자이 유효 함을 나타냅니다. 종료 기의 반환 값 &lt;code&gt;b&lt;/code&gt; 는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">Finalizer &lt;em&gt;는&lt;/em&gt; 명시 적으로 만들어지고 &lt;code&gt;IORef&lt;/code&gt; 및 &lt;code&gt;MVar&lt;/code&gt; 와 같은 ID를 가진 유형에 안정적으로 사용될 &lt;em&gt;수&lt;/em&gt; 있습니다 . 그러나 이러한 유형 중 하나에 종료자를 배치하려면 해당 유형에 제공된 특정 조작 (예 : &lt;code&gt;mkWeakIORef&lt;/code&gt; 및 &lt;code&gt;addMVarFinalizer&lt;/code&gt; )을 사용해야 합니다 (비 균일 성은 우연이 아닙니다). 이러한 작업 은 외부 상자가 컴파일러에 의해 최적화 될 때 종료자를 상자 자체에 연결하지 못하기 때문에 상자 내부의 기본 객체 (예 : &lt;code&gt;MutVar#&lt;/code&gt; 의 경우 MutVar # ) 에 &lt;code&gt;IORef&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">마지막으로, GHC는 제약 조건 해결이 완료된 후 &lt;code&gt;tcPluginStop&lt;/code&gt; 을 호출 하여 플러그인이 할당 한 모든 자원을 처리 할 수 ​​있도록합니다 (예 : SMT 솔버 프로세스 종료).</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">마지막으로, &lt;code&gt;readFile'&lt;/code&gt; 예제 의 예외 안전 변형이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">마지막으로 &lt;code&gt;-main-is&lt;/code&gt; 플래그 또는 &lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 다른 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="translated">Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; . In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">마지막으로 &lt;code&gt;Just&lt;/code&gt; 결과가 맵으로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">마지막으로 &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ 옵션 은 컴파일러 생성 중간 C 파일 의 &lt;code&gt;.hc&lt;/code&gt; 파일 접미사를 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">마지막으로 현재 실행을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">마지막으로 단일 문자와 일치하는 기본 파서가 필요합니다.이 파서에서 임의로 복잡한 파서를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">마지막으로 디코더를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">대상 제약 조건 &lt;em&gt;과 일치&lt;/em&gt; 하는 모든 인스턴스 \ (I \)를 찾습니다 . 즉, 대상 제약 조건은 \ (I \)의 대체 인스턴스입니다. 이러한 인스턴스 선언이 &lt;em&gt;후보&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">해결되지 않은 모든 구속 조건을 찾으십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">나무의 깊이를 찾으십시오. 즉, 나무의 뿌리에서 가장 먼 잎까지의 가지 수 :</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">파일에 대한 시스템 별 제한 찾기</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">문자열에서 하위 문자열의 모든 (중복 될 수있는) 어커런스의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">트리에서 최대 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">형식은 그 사람 찾기 &lt;code&gt;(C a)&lt;/code&gt; 여기서 &lt;code&gt;a&lt;/code&gt; 형태 변수이며, 일반적인 유형의 변수 공유 그룹으로 그 제약을 분할 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">길이 찾기</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">회선 지향 사용자 상호 작용 세션을 완료하고 정리하십시오. &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 에 대한 기존 호출을 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">유한 그래프</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">유한 Int지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">유한 Int지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">유한 Int 세트</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">유한지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">유한지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">유한 세트</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">유한 시퀀스</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">첫 번째 인수는 후행 0을 잘라낼 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">결과의 첫 번째 성분은 &lt;code&gt;log2 n&lt;/code&gt; 이고 두 번째는 &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; 은 2의 거듭 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">첫 번째 목적지의 오프셋 (offset) &lt;em&gt;되지&lt;/em&gt; 사본 (즉, &lt;em&gt;하지&lt;/em&gt; 길이)</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">주어진 정량화되지 않은 제약 조건 &lt;code&gt;C t&lt;/code&gt; 가 있는지 확인하십시오 . 그렇다면 제약 조건을 해결하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">먼저 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 를 가져옵니다 . 이것은 안전하지 않은 모듈이지만 &lt;code&gt;M&lt;/code&gt; 은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 로 컴파일 되었으므로 &lt;code&gt;P&lt;/code&gt; 의 작성자는 해당 가져 오기를 담당합니다. &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 저자를 신뢰하므로이 수입은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="translated">First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt; . This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author, so this import is fine.</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">먼저, 모듈을 GHCi에로드하십시오 :</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">먼저 정의 된 매크로에서 이름과 정확히 일치하는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">첫째, 이전에는 불가능했던 해상도를 종료 할 수 있습니다. 예를 들어 일반 장미 데이터 유형에 대한 다음 인스턴스 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">고정 크기 빌더 기본 요소</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">고정 크기 프리미티브</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">고정 너비 16 진수</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">데이터 생성자와 마찬가지로 형식 생성자 또는 클래스에 대한 고정도를 선언 할 수 있습니다. 그러나 고 정성 선언에서 둘을 구별 할 수는 없습니다. 고 정성 선언은 데이터 생성자와 해당 유형 생성자의 고 정성을 설정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">고정 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">정착 성 조회</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">생성자의 고정</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">고정, 유형 동의어, 개방형 / 데이터 패밀리 선언은 일반적인 Haskell에서와 같이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">&quot;중지 후&quot;라고 말하는 깃발</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; 의 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">다양한 서브 시스템에서 디버깅 출력 및 추가 검사를 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">엄격한 생성자 필드 병합</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포인터 크기의 표현으로 엄격한 생성자 필드를 병합합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전 .</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">플로팅 렛 바인딩은 바인딩 사이트에 가깝습니다. 참조 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;하자 - 부동 : 바인딩을 이동하는 빠른 프로그램 (ICFP'96)을 얻었다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="translated">Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">플로트 방법</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">float / Int 변환, 랩핑 된 primops</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">플로팅 타입</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">제공된 쓰기 버퍼의 모든 데이터를 장치로 플러시합니다. 리턴 된 버퍼는 비어 있어야하며 쓰기 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; 의 버퍼를 비 웁니다 (있는 경우) . &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">제공된 쓰기 버퍼의 데이터를 차단하지 않고 장치로 플러시합니다. 쓴 바이트 수와 나머지 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">현재 버퍼를 비 웁니다. 이것은 청크 경계를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">버퍼 상태 플러시</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">암시 적 구문 분석 상태 플러시</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">monoid를 사용하여 목록을 접으십시오.</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">트리를 깊이 우선 순서대로 &quot;요약&quot;값으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">접어 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 대소 현명한 단지처럼 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">접는 동작</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">접기 및 순회</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">키 증가 순서로 접습니다.</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">마크 존스 (Mark Jones)의 제안에 따라, 그의 논문은 &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Haskell에있는 Haskell 타이핑에서&lt;/a&gt; 보다 일반적인 체계를 구현합니다. GHC &lt;em&gt;에서 종속성 분석은 명시 적 유형 서명이있는 변수에 대한 참조를 무시합니다.&lt;/em&gt; . 이 세분화 된 종속성 분석의 결과로 종속성 그룹이 더 작아지고 더 많은 바인딩이 유형 검사됩니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">ISO-10646 표준에 따라 &lt;code&gt;maxBound :: Char&lt;/code&gt; GHC의 Char 는 &lt;code&gt;0x10FFFF&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt; 의 권장 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">들면 및 &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; , 그들의 최대 공약수를 계산 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; 및 계수 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 만족 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; + &lt;em&gt;B &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g을&lt;/em&gt; . &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffDays&lt;/code&gt; (및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">들어 &lt;code&gt;Day&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">를 들면 &lt;code&gt;DayOfWeek&lt;/code&gt; (및 &lt;code&gt;Day&lt;/code&gt; 와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;LocalTime&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;NominalDiffTime&lt;/code&gt; 및 &lt;code&gt;DiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeOfDay&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeZone&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;ZonedTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용 &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; 및 &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 는 동의어이다 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">양방향 패턴 동의어의 경우, 패턴 동의어를 표현식으로 사용하는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">클래스의 경우 모든 유형 변수는 종류로 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">복소수를 들어 &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; 의 크기를 갖는 수이고 &lt;code&gt;z&lt;/code&gt; 반면, 그러나 실제 양 방향으로 배향 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 의 위상 갖는다 &lt;code&gt;z&lt;/code&gt; 하지만 단위 크기를.</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; : 최상위 레벨이있는 ​​데이터 유형의 경우 &lt;code&gt;::&lt;/code&gt; : 명시 적으로 정량화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">데이터 유형의 경우 모든 유형 변수는 종류로 주석을 달아야합니다. GADT 스타일 선언에는 종류 서명 ( 헤더에 최상위 수준 &lt;code&gt;::&lt;/code&gt; 이 있음)이있을 수도 있지만이 주석의 존재 여부는 선언에 완전한 서명이 있는지 여부에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">자세한 설명은 Levent Erkok의 논문, Monadic &lt;em&gt;Computations의 가치 재귀를&lt;/em&gt; 참조하십시오.&lt;em&gt;&lt;/em&gt; , Oregon Graduate Institute, 2002를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 에서 사용되는 알고리즘의 전체 사양 은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;이 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">완전한 작동 예제 는 GHC 소스 트리에서 &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">주어진 힙 크기 ( &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 옵션 사용)의 경우 압축은 실제로 더 적은 GC를 수행함으로써 GC 비용을 줄일 수 있습니다. 이는 라이브 데이터 대 힙 크기의 비율이 높을 때 (예 : 30 % 이상) 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">람다 바운드 또는 케이스 바운드 변수 x의 경우, 프로그래머는 x에 대해 명시적인 다형성 유형을 제공하거나 GHC의 유형 유추는 x의 유형에 그에 대한 전제가 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt; , all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">일반 &lt;code&gt;foreign export&lt;/code&gt; 의 경우 &lt;code&gt;M_stub.h&lt;/code&gt; 파일 에는 외국 수출 기능에 대한 C 프로토 타입이 포함됩니다. 예를 들어 다음 모듈을 컴파일하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">다품종 유형 군의 경우 유형과 유형이 다른지 확인합니다. 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">읽기 전용 상태는 &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">인터페이스가 동일한 엄격한 버전은 &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">형식 동의어의 경우 모든 형식 변수와 결과 형식에 모두 종류가 주석으로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">단방향 레코드 패턴 동의어의 경우 레코드 선택기를 정의하지만 레코드 업데이트 또는 구성은 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">예외 값 범위를 허용하는 변형에 대해서는 &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;지도 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 해당 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">모든 유형에 대해 (이 세 가지는 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 가 아니라 formatTime 에 의해 &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">거의 모든 현명한 프로그램의 경우 버그를 나타내며 다음과 같이 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">&quot;포장 할 수없는&quot; &lt;code&gt;U(...)&lt;/code&gt; 인수의 경우 내부 정보는 해당 구성 요소의 엄격 성을 알려줍니다. 따라서 인수가 쌍이고 &lt;code&gt;U(AU(LSS))&lt;/code&gt; 라고 표시되면 라고 표시되면&amp;ldquo;쌍의 첫 번째 구성 요소가 사용되지 않습니다. 두 번째 구성 요소는 세 개의 구성 요소 (첫 번째는 게으르고 두 번째 \ &amp;amp; 세 번째는 엄격함)로 포장 할 수 없습니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">들어 &lt;em&gt;인코딩의 효율적인 구현&lt;/em&gt; , (a) 약간의 시간이 결과 바이트 시퀀스 하스켈 값 변환에 소요되는 것이 중요 &lt;em&gt;하고&lt;/em&gt; 생성 된 시퀀스의 표현이 효율적으로 소비 될 수있는 것을 (b). &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 (a) O (1) 연결 연산과 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 기타 표준 Haskell 값에 대한 기본 인코딩의 효율적인 구현을 제공하여 지원 합니다. 그들은 (b) 결과를 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 제공함으로써 내부적 으로 연속 된 원시 메모리 &lt;em&gt;청크&lt;/em&gt; 에 대한 포인터의 링크 된 목록입니다 . 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 파일에 쓰거나 네트워크 소켓을 통해 전송하는 기능에 의해 효율적으로 사용될 수 있습니다. 각 청크 경계는 청크 본문을 소비하는 데 소비 된 작업에 대해 상환되어야하는 값 비싼 추가 작업 (예 : 시스템 호출)을 발생시킵니다. 그러므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 평균 청크 크기가 충분히 커지도록 특별한주의를 기울입니다. 충분히 큰 의미는 응용 프로그램에 따라 다릅니다. 현재 구현은 4kb에서 32kb 사이의 평균 청크 크기로 조정되며 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">열거의 경우, 0부터 n-1까지의 인덱스를 사용하여 nullary 생성자가 왼쪽에서 오른쪽으로 번호가 매겨지는 것으로 가정합니다. 이것은 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 정의한 것과 동일한 번호 입니다. 예를 들어 데이터 유형이 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">이것이 안전하지 않은 이유를 보여주는 예는 &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">예를 들어 &lt;code&gt;Recip.hs&lt;/code&gt; 라는 프로그램이 있습니다.이 프로그램 은 반복되는 부분을 괄호로 표시하여 역수의 정확한 십진수 표현을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">대화식 응용 프로그램의 경우 유휴 GC를 사용하는 것이 좋습니다. 이는 Haskell 계산이 수행되지 않을 때 유휴 시간에 종료자가 실행되고 교착 상태 스레드가 감지 될 수 있기 때문입니다. 또한 응용 프로그램이 사용 중일 때 GC가 발생할 가능성이 적으므로 응답 성이 향상 될 수 있습니다. 그러나 힙의 라이브 데이터 양이 특히 많으면 유휴 GC가 상당한 지연을 유발할 수 있으며 간격이 너무 작 으면 대화 형 응답성에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">가져온 모든 모듈의 경우 GHC에서는 가져 오기 명령문의 모듈 이름 &lt;a href=&quot;#search-path&quot;&gt;이 검색 경로에&lt;/a&gt; 지정된 전략을 사용하여 찾은 인터페이스 파일 (또는 소스 파일)의 모듈 이름과 정확히 일치해야 합니다 . 이는 대부분의 모듈에서 소스 파일 이름이 모듈 이름과 일치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">문자열 리터럴 많은 수의 애플리케이션의 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 병목이 될 수 있습니다. 이러한 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC 만 해당) 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">문자열 리터럴 수가 많은 응용 프로그램의 경우 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">기존 make 스크립트와의 호환성을 위해 &lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 연결 단계가 생략됩니다 ( &lt;code&gt;--make -no-link&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 유형이 &lt;code&gt;forall&lt;/code&gt; 로 시작하더라도 종류 변수를 명시 적으로 바인딩 할 필요 &lt;em&gt;는 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">이진 생성자</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 모두 에 대해 단계 번호에 인라인이 허용되는 시점이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">패턴 및 표현식 와일드 카드의 경우 &quot; &lt;code&gt;..&lt;/code&gt; &quot; &lt;em&gt;는 범위 내&lt;/em&gt; 누락 &lt;em&gt;된&lt;/em&gt; 레코드 필드로 확장 됩니다. 특히 &quot; &lt;code&gt;C {..}&lt;/code&gt; &quot; 의 확장 에는 다음 과 같은 경우에만 &lt;code&gt;f&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">상자 값 (포인터로 표시되는 값)의 경우 리프팅 된 유형 (&amp;perp;을 포함)과 리프팅되지 않은 유형 (하지 않은) 사이에 추가 구분이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">가변 길이 패딩을 포함 할 수있는 기능의 경우 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">For catching exceptions in pure (non- &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수 유형과의 단어 유형 ( &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 참조 )을 강제 변환 하면 부호가 아닌 표현이 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수형으로 또는 정수형으로 단어를 강제 변환하면 부호가 아닌 표현이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/etc/xdg&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.config&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/etc&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/usr/local/share/&lt;/code&gt; 및 &lt;code&gt;/usr/share/&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.local/share&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/usr/share&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">간단한 외부 이진 형식 (예 : C 구조)을 디코딩하고 생성하기 위해 이진이 사용될 수 있지만 일반적으로 복잡한 프로토콜에는 적합하지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 프리미티브를 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">Remote GHCi에 대한 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [Remote GHCi]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">합계 유형의 각 대안에 대해 이러한 필드로 구성된 레이아웃이 생성됩니다. 예를 들어 대안에 &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 필드가있는 경우 레이아웃에는 32 비트 워드, 32 비트 부동 소수점 및 포인터 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">각 가비지 콜렉션에 대해 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">트리의 각 노드에 대해 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;rootLabel&lt;/code&gt; 에 적용하고 &lt;code&gt;f&lt;/code&gt; 를 각 &lt;code&gt;subForest&lt;/code&gt; 에 적용한 결과를 적용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">빈 데이터 유형의 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 이 표현으로 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">이 주제에 대한 자세한 내용은 &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;SIGINT / SIGQUIT의 올바른 처리&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">이런 방식으로 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; &lt;code&gt;A.hs&lt;/code&gt; 모든 모듈 A.hs 에 대해 소스 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 있어야합니다 . 이 파일에는 약어 버전의 &lt;code&gt;A.hs&lt;/code&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">예를 들어, &lt;code&gt;-l-ag&lt;/code&gt; 는 GC 이벤트 ( &lt;code&gt;g&lt;/code&gt; )를 제외한 모든 이벤트 클래스 ( &lt;code&gt;-a&lt;/code&gt; )를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">예를 들어, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; 는 크기가 1kb 이하인 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 복사하고 그렇지 않으면 직접 삽입합니다. 이는 직접 삽입 된 1025 바이트, 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사이에 항상 단일 바이트가있을 수 있기 때문에 생성 된 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 평균 청크 크기는 513 바이트만큼 낮을 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; 는 &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; 아니라 f (\ a-&amp;gt; ab) 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">예를 들어, 처음 20 개의 정수와 2의 거듭 제곱을 인쇄하는 프로그램은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">예를 들어 트리의 사용자 정의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">예를 들어, GHC로 다음 모듈을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;foo&lt;/code&gt; 프로그램을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">예를 들어, 함수와 함께 사용하도록 의도되지 않은 유형 클래스를 고려해 보았지만 사용자는 실수로 함수 유형에서 함수를 사용했습니다. 그런 다음 누락 된 인스턴스에 대한 표준 GHC 메시지를받는 대신 EDSL에 고유 한보다 친숙한 메시지를 생성하는 것이 좋습니다. 마찬가지로, 유형 레벨 함수의 감소는 오류로 인해 중단 될 수 있습니다.이 시점에서 모호한 유형에 대한 일반적인 오류보다는 EDSL 특정 오류를보고하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">예를 들어, &lt;code&gt;:time&lt;/code&gt; 이라는 이름의 매크로 가 있고 쉘에 &lt;code&gt;:t 3&lt;/code&gt; 을 입력 한 경우 어떻게됩니까? 명령을 완료하는 데 사용하는 현재 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음과 같은 병렬 버전 인 이전 버전 인 &lt;code&gt;nfib&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">예를 들어 다음 정의를 고려하십시오 ( &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">예를 들어 데이터 유형이 주어지면</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 &lt;code&gt;hist&lt;/code&gt; 는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 hist는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">예를 들어, 선언이 주어지면</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">예를 들어 다음은 GHC의 &lt;code&gt;nofib&lt;/code&gt; 벤치 마크 제품군 에서 &lt;code&gt;sphere&lt;/code&gt; 프로그램을 위해 생성 된 힙 프로파일입니다 .</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">예를 들어, 다음은 네트워크 소켓에서 클라이언트 연결을 수신하고 클라이언트 연결 핸들에서 클라이언트 입력을 에코하는 데 &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;에코 서버를&lt;/a&gt; 구현하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">예를 들어, GHC 가 &lt;code&gt;-odir&lt;/code&gt; 또는 &lt;code&gt;-hidir&lt;/code&gt; 플래그 없이 &lt;code&gt;src/A/B/C.hs&lt;/code&gt; 파일에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈을 컴파일하는 경우 인터페이스 파일은 &lt;code&gt;src/A/B/C.hi&lt;/code&gt; 및 오브젝트에 배치됩니다. 에서 파일 &lt;code&gt;src/A/B/C.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">예를 들어, 인터페이스가 가져온 값의 유형에 놓여 있다면 GHC는 가져 오기 모듈에 대한 더프 코드를 생성 할 수 있습니다. &lt;em&gt;이것은 인터페이스 내부의 pragma에도 적용됩니다! &lt;/em&gt;pragma가 거짓말을하는 경우 (예 : 값의 &quot;arity&quot;에 대해) 더프 코드가 발생할 수 있습니다. 또한 유형이 다르더라도 자질이 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">예를 들어 다음 데이터 유형이 범위 내에있는 경우</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">예를 들어, 패키지 스펙에서 Haskell 라이브러리를 &lt;code&gt;HSfoo&lt;/code&gt; 로 지정하면 GHC가 실제로 사용하는 다양한 라이브러리가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">예를 들어, 프로그램의 핵심을 검사하고 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 것을 관찰하는 경우 . &lt;code&gt;-dinline-check foo&lt;/code&gt; 를 전달 하면 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 이유에 대한 보고서가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">예를 들어,이 동작이있는 80 열 터미널에서는 다음이 이중 간격 대신 단일 간격으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">예를 들어 다음 프로그램에서 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;f'&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">예를 들어, 항목은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">예를 들어, 동일한 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 을 여러 번 호출 하면 동일한 입력 히스토리가 공유됩니다. 반대로 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; 에 대한 여러 번의 호출 은 동일한 히스토리 파일을 공유하지 않는 한 고유 한 히스토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">예를 들어, 가능한 응용 프로그램 중 하나는 사전을 구체화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 기억이 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">예를 들어, 때때로 다음을 사용하여 &quot;클래스 동의어&quot;의 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">예를 들어, 검색 경로가 디렉토리가 있다고 가정 해 &lt;code&gt;d1&lt;/code&gt; , &lt;code&gt;d2&lt;/code&gt; 와 &lt;code&gt;d3&lt;/code&gt; , 우리는에 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모듈의 소스 파일을 찾고 모드 &lt;code&gt;A.B.C&lt;/code&gt; . GHC는 &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; , &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; , &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; 등을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; 와 같이 &quot; &lt;code&gt;&quot;::&quot;&lt;/code&gt; 하위 문자열에서 분할하려는 문자열이 있다고 가정하십시오 . &lt;code&gt;&quot;::&quot;&lt;/code&gt; 의 색인을 검색하고 해당 색인 전후에 하위 문자열을 사용하는 대신 &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">예를 들어, 파일을 읽으려고하는데 파일이 없으면 &quot;&quot;가 포함 된 것처럼 계속 진행하십시오. 모든 예외를 포착하고 핸들러에서 &quot;&quot;를 반환하려는 유혹을받을 수 있습니다. 그러나 이것은 모든 종류의 바람직하지 않은 결과를 초래합니다. 예를 들어, 사용자가 적절한 순간에 control-C를 누르면 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 예외가 발생하고 파일에 &quot;&quot;가 포함되어 있다는 확신하에 프로그램이 계속 실행됩니다. 마찬가지로, 다른 스레드가 파일을 읽는 스레드를 종료하려고하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 예외가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">예를 들어 다음 데이터 형식의 생성자 필드</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">예를 들어, 데이터 유형 &lt;code&gt;2 * A&lt;/code&gt; 및 &lt;code&gt;A + A&lt;/code&gt; 는 동형이지만 일부 계산은보다 자연스럽게 표현됩니다. 두 세계를 최대한 활용하기 위해 하나를 구현으로 선택한 다음 사용자가 원하는 경우 다른 표현을 사용할 수 있도록 패턴 동의어 세트를 제공 할 수 있습니다. 그런 다음 패턴 일치 검사기에 &lt;code&gt;LeftChoice&lt;/code&gt; 와 &lt;code&gt;RightChoice&lt;/code&gt; 모두에서 일치하는 함수 가 총계 임을 알리기 위해 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">예를 들어, 다음 코드는 GHC에서 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">예를 들어, 다음 옵션은 &lt;code&gt;Branch&lt;/code&gt; 및 &lt;code&gt;Leaf&lt;/code&gt; 생성자로 제한된 리테이너 프로파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">예를 들어, 이것들은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">예를 &lt;code&gt;Monad&lt;/code&gt; 코드에는 Monad 제약 조건 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">예 를 &lt;code&gt;#fullname&lt;/code&gt; 인스턴스는 #fullname 을 사용하여 &lt;code&gt;Person&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 필드에 액세스 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">예를 들어 &lt;code&gt;f x&lt;/code&gt; 의 값을 반환 하지만 먼저 메시지를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">예를 들어, CFI를 사용하여 FFI 및 전처리를 활성화하려면 :</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">예를 들어 간단한 &lt;code&gt;ls&lt;/code&gt; 명령 을 실행하려면</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">예를 들어, &lt;code&gt;network&lt;/code&gt; 패키지를 사용하는 &lt;code&gt;Foo.o&lt;/code&gt; 및 &lt;code&gt;Main.o&lt;/code&gt; 객체로 구성된 프로그램을 연결 하려면 GHC에 &lt;code&gt;-package&lt;/code&gt; 플래그를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">예를 들어 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 Haskell 프로그램을로드하고 실행하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">예를 들어, YYYY-MM-DD 형식으로 날짜를 구문 분석하고 월과 날짜에 선택적 선행 0을 갖도록 허용하려면 ( &lt;code&gt;%m&lt;/code&gt; 및 &lt;code&gt;%d&lt;/code&gt; 사용 된 &lt;code&gt;-&lt;/code&gt; 수정 자에 유의 ) :</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">예를 들어, 프로세스를 시작하고 문자열을 stdin에 공급하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">예를 들어 문자열을 토큰 화하려면 구분 기호를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">예를 들어 직접 재귀를 사용하여 계승 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">예를 들어, 모듈 A를 컴파일 할 때 B가 A를 직접 또는 간접적으로 가져 오지 않으면 B에서 가져온 템플릿 Haskell 함수 만 실행할 수 있습니다. 그 이유는 분명해야합니다. B를 실행하려면 A를 컴파일하고 실행해야하지만 현재 A를 타입 검사하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 보기 흉하지만 문제가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">네 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z.z'&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 이고 __GLASGOW_HASKELL_PATCHLEVEL2__ 값은 정수 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">단사 형 가족에 대한 자세한 내용은 하스켈 심포지엄 2015 종이를 참조 &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;하스켈에 대한 단사 유형의 가족&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">그러나 숨겨진 패키지의 경우 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 플래그를 사용하여 패키지를로드하도록 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역사적 이유로 보존 된 값은 / 강제 / 강제 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그들을 강제로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 하려면 preserveMissing '을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">예를 들어 간단한 프로필은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">예를 들어 다음과 같은 유형의 제품군이있는 경우</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; 로 프로그램을 실행하면 &lt;code&gt;hello-world.hp&lt;/code&gt; 라는 힙 프로파일 과 hello-world.prof 라는 비용 중심 프로파일이 &lt;code&gt;hello-world.prof&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">예를 들어, &lt;code&gt;-fno-specialise -O1&lt;/code&gt; 의 예를 들어보십시오 . 에도 불구하고 &lt;code&gt;-fno-specialise&lt;/code&gt; 명령 줄에 나타나는 전문화는 여전히 활성화됩니다. &lt;code&gt;-O1&lt;/code&gt; 이 &lt;code&gt;-fspecialise&lt;/code&gt; 를 암시 하고 이전 플래그를 대체 하는 경우 입니다. 반대로 &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; 는 예상대로 전문화없이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">예를 들어, 형식 서명의 첫 번째 와일드 카드 는 다음과 같은 오류 메시지를 생성 &lt;code&gt;not'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">예를 들어, 우리의 응용 프로그램에 더 유용한 오류 메시지를 제공하기 위해이 인터페이스를 사용할 수있는 &lt;code&gt;show&lt;/code&gt; 같은 불포화 기능에,</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; 클래스 에 속하는 모나드의 경우 GHC는 재귀 바인딩을 허용하는 확장 된 do-notation 버전을 제공합니다. &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; (언어 프라 그마 : &lt;code&gt;RecursiveDo&lt;/code&gt; 는 ) 키워드를 도입, 필요한 구문 지원을 제공 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 각각 표기의 높고 낮은 수준. &lt;code&gt;do&lt;/code&gt; 표현식의 바인딩과 달리 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 에 의해 도입 된 바인딩 은 일반적인 let-expression과 매우 유사하게 재귀 적으로 정의됩니다. 새로운 키워드 &lt;code&gt;mdo&lt;/code&gt; 로 인해이 표기법을 &lt;em&gt;mdo-notation이라고도&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">이 기능에 대한 자세한 내용은 Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones 및 Stephanie Weirich의 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki 페이지&lt;/a&gt; 또는 원본 &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">자세한 내용은 Conor McBride 및 Ross Paterson의 &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">GHC에 의해 생성 된 디버그 정보에 대한 자세한 내용은 Peter Wortmann의 박사 논문, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;* 최적화 된 Haskell 프로파일 링 : 인과 분석 및 구현 *을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">틱 틱틱 프로파일 링에 대한 자세한 내용은 &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;&quot;틱 키틱&quot;프로파일 링 사용 (구현 자용)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">API 사용과 샘플 및 참조에 대한 자세한 내용은 &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">자세한 내용 은이 라이브러리 디자인의 기초 가되는 &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 . 1995 년 고급 기능 프로그래밍에서 John Hughes의 / The Pretty-printing Library의 디자인 /.</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 새로운 SYB 위키 ( &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB)&lt;/a&gt; 를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 . @since 4.9.0.0</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">더 많은 동기 부여와 세부 사항은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; 페이지 또는 &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">대부분의 응용 프로그램에서는 다음 &lt;code&gt;Settings&lt;/code&gt; 플래그 를 대신 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">대부분의 응용 프로그램 (예 : REPL)의 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 가 올바른 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">대부분의 배열 유형의 경우이 작업은 O ( &lt;em&gt;n&lt;/em&gt; )이며 여기서 &lt;em&gt;n&lt;/em&gt; 은 배열의 크기입니다. 그러나 diffarray 패키지는이 작업이 업데이트 수에있어 복잡성을 갖는 배열 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">중첩 된 &lt;code&gt;foralls&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">newtypes를 들어, &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 와 &lt;code&gt;Bounded&lt;/code&gt; 항상 사용 파생 &lt;code&gt;newtype&lt;/code&gt; 이란 도없이, 전략을 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 이 가능. (주식 전략을 사용하여 파생 된 인스턴스와 눈에 띄는 차이가 없어야합니다.)</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">필수가 아닌 파일 (예 : 캐시) &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.cache&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ). 사용자 별 &lt;code&gt;/var/cache&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Haskell finalizer를 이식 할 수없는 지원에 대해서는 &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">개방형 및 폐쇄 형 패밀리의 경우 결과의 이름을 지정하지만 주입 주석을 건너 뛰어도됩니다. 주입 형 주석이없는 명명 된 결과가 연관된 유형 동의어 기본값으로 해석되는 연관된 유형 동의어의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">다른 모든 유형 클래스의 경우 :</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">다른 문서는 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">1 부에서는 &lt;code&gt;Encode'&lt;/code&gt; 클래스를 정의합니다 . 놀랍게도이 클래스는 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 종류 의 유형 생성자 &lt;code&gt;f&lt;/code&gt; 에 대해 매개 변수화 됩니다. 이것은 기술입니다. 모든 표현 유형 생성자는 종류 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 를 기본 종류로 사용합니다. 그러나 type 인수는 사용되지 않습니다. 이것은 나중에 언젠가 변경 될 수 있습니다. 클래스는 하나의 방법이 있고, 우리는 우리가 우리의 최종적인 기능을 갖고 싶어 유형을 사용하지만, 우리는 제네릭 형식 인수의 발생 대체 와 &lt;code&gt;f p&lt;/code&gt; 합니다 ( &lt;code&gt;p&lt;/code&gt; 는 , 그것은 사용되지 않습니다 어떤 인수입니다). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">필드가 많은 레코드의 경우와 같이 각 필드를 개별적으로 레코드 패턴으로 기록하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">단일 생성자 데이터 유형의 경우 파생 인스턴스 선언은 Haskell 2010 보고서의 19 장, 섹션 2 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html)&lt;/a&gt; 에서 튜플에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">어떤 이유로 Mingw는 &lt;code&gt;readline&lt;/code&gt; 라이브러리 와 함께 제공 되지만 &lt;code&gt;readline&lt;/code&gt; 헤더 와 함께 제공되지 않습니다 . 결과적으로 GHC (Hugs와 같은)는 Windows에서 대화식 입력에 &lt;code&gt;readline&lt;/code&gt; 을 사용하지 않습니다 . emacs 쉘 ​​버퍼를 사용하여 정밀한 시뮬레이션을 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">일부 특수 사용 사례의 경우 어떤 이벤트가 포함되는지 더 세밀하게 제어 할 수 있습니다. ⟨플래그⟩는 기록 할 이벤트 클래스를 나타내는 0 개 이상의 문자 시퀀스입니다. 현재 활성화 / 비활성화 할 수있는 이벤트 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">일부 값의 경우 순서가 아닌 목록 내용에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">스파크 이벤트의 경우 샘플링 및 완전 정확도의 두 가지 모드가 있습니다. 각 스파크의 수명주기에는 다양한 이벤트가 있으며 일반적으로 생성 및 실행이지만 더 뛰어난 가능성이 있습니다. 샘플링 된 모드에서 각 종류의 스파크 이벤트 발생 횟수는 빈번한 간격으로 샘플링됩니다. 완전 정확한 모드에서는 모든 스파크 이벤트가 개별적으로 기록됩니다. 후자는 런타임 오버 헤드가 높으며 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">기술적 인 이유로 GHCi 는 해석되는 모듈에 대해서만 &lt;code&gt;*&lt;/code&gt; 양식을 지원할 수 있습니다 . 컴파일 된 모듈 및 패키지 모듈은 현재 범위에 대한 내보내기에만 기여할 수 있습니다. GHCi가 해석 된 버전의 모듈을 로드하도록하려면 모듈을로드 할 때 &lt;code&gt;*&lt;/code&gt; 를 추가하십시오 ( 예 &lt;code&gt;:load *M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">기술적 인 이유로 바이트 코드 컴파일러는 최적화 패스 중 하나와 잘 상호 작용하지 않으므로 인터프리터를 사용할 때 최적화를 비활성화했습니다. 이는 큰 손실이 아닙니다. 최적화가 설정된 상태에서 해석하는 대신 빠르게 진행해야하는 코드 비트를 컴파일하면 훨씬 더 큰 승리를 거둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Bad Int&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같이 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Ex&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같은 것을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">첫 번째 트러스트 정의의 경우, GHC는 안전한 언어에 의해 부과 된 제한을 통해 트러스트 보증을 제공합니다. 신뢰의 두 번째 정의의 경우 보증은 처음에 모듈 작성자가 제공합니다. 그런 다음 클라이언트 C는 모듈이 상주하는 패키지를 신뢰 함을 표시하여 모듈 작성자를 신뢰하도록 설정합니다.이 신뢰 체인은 GHC가 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 컴파일 된 모듈을 보증하지 않으므로 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">문자열 데이터 자체의 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;ByteString&lt;/code&gt; 은 요소 당 하나의 바이트를 사용하며 가장 가까운 단어로 반올림됩니다. 예를 들어 오버 헤드를 포함하여 길이 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 은 32 비트 플랫폼에서 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 바이트를, 64 비트 플랫폼에서 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">이 모나드 변압기의 경우 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 자연스럽게 변환됩니다. 즉 모나드 변환 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a ,</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">이러한 이유로 GHC는 &lt;code&gt;tryPutMVar&lt;/code&gt; 에 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 대한 외부 API를 제공하며 C / C ++에서 Haskell 스레드를 저렴하고 비동기 적으로 깨울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt; ) when assigning costs.</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">이러한 이유로 GDB가 제공하는 소스 위치를 해석 할 때는주의해야합니다. 이러한 위치는 일반적으로 &quot;정확한&quot;의미이지만 항상 유용한 것은 아닙니다. 이러한 이유로 Haskell을 대상으로하는 프로파일 링 도구는 비용을 할당 할 때 표준 소스 위치 정보를 GHC 특정 주석 ( &lt;code&gt;-g2&lt;/code&gt; 로 방출)으로 보완해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">세 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 입니다.</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">위 의 &lt;code&gt;foo2&lt;/code&gt; 의 서명과 같이 &lt;em&gt;둘 이상의 요소&lt;/em&gt; 의 유형 레벨 목록의 경우 , 그 의미가 모호하지 않기 때문에 인용 부호는 생략 될 수 있습니다. 그러나 &lt;code&gt;foo0&lt;/code&gt; 및 &lt;code&gt;foo1&lt;/code&gt; 에서 와 같이 하나 또는 제로 요소 목록의 경우 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;[Int]&lt;/code&gt; 유형 이 Haskell에서 기존 의미를 갖기 때문에 따옴표가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">유형과 클래스의 경우 GHCi는이를 언급하는 인스턴스도 요약합니다. 관련이없는 정보를 표시하지 않으려면 (a) 헤드가 ⟨name⟩을 언급하고 (b) 인스턴스에 언급 된 다른 모든 항목이 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 의 결과로 범위가 한정된 경우에만 표시됩니다 . 또는 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">단항 생성자</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 같은 제한되지 않은 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">GHCi와 함께 사용하려면 각 라이브러리에 객체 파일도 있어야합니다. 오브젝트 파일 이름 에는 &lt;code&gt;lib&lt;/code&gt; 접 두부 가 &lt;em&gt;없으며&lt;/em&gt; 플랫폼의 일반 오브젝트 접미 부가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">의 값 &lt;code&gt;n&lt;/code&gt; 1보다 큰 우리가 사용 &lt;code&gt;par&lt;/code&gt; 평가할 스레드를 촉발 &lt;code&gt;nfib (n-1)&lt;/code&gt; 다음과 같이 사용할 &lt;code&gt;pseq&lt;/code&gt; 을 평가하기 위해 부모 스레드를 강제로 &lt;code&gt;nfib (n-2)&lt;/code&gt; 이 두 함께 추가 가기 전에 하위 식. 이 분할 및 정복 방식에서는 계산의 한 분기에 대해서만 새 스레드를 생성합니다 (부모가 다른 분기를 평가하도록 두는 것). 또한 부모는 표현식 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 에서 &lt;code&gt;n1&lt;/code&gt; &lt;em&gt;보다 먼저 &lt;/em&gt; &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 평가 하도록 &lt;code&gt;pseq&lt;/code&gt; 를 사용해야합니다 . 식을 &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; 로 재정렬하는 것만으로는 충분하지 않습니다.&lt;em&gt;&lt;/em&gt;컴파일러는 추가 항목을 왼쪽에서 오른쪽으로 평가하는 코드를 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">버전 들어 &lt;code&gt;x.y.z&lt;/code&gt; GHC의 값 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 은 (⟨y⟩ 너무 GHC 버전 6.2 예를 들어, 선두 제로 첨가 한 자릿수이면, 정수 ⟨xyy⟩이다 &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ). &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC 버전 번호 지정 정책에&lt;/a&gt; 대한 추가 정보 .</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">GHC가 값을 인라인하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">힘 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 일반적인 형태입니다.</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 강제 실행하고 변경되지 않은 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">TH를 통해 GHC가 지원하는 외국 형식</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">내부적으로 UTF-16을 사용하는 외부 함수 는 문자 대신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 단위로 인덱스를 반환 할 수 있습니다 . 이러한 함수는 유니 코드 문자열의 유효성을 유지하기 위해 필요한 경우 오프셋을 조정하므로 이러한 인덱스와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">구성 가능한 인코딩으로 CString에 대한 외부 마샬링 지원</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">스레드를 포크하고 스레드가 종료 되려고 할 때 예외 또는 리턴 값으로 제공된 함수를 호출하십시오. 이 함수는 비동기 예외를 마스킹하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">포크와 실행</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">스레드를 포크하고 죽입니다.</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">포크와 같은</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">크기와 위상의 극 성분에서 복소수를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">공식적으로 말하면, Haskell 98에서 프로그램의 엔티티 (함수, 유형 또는 클래스)는 프로그램이 정의 된 모듈 이름 쌍과 이름으로 고유하게 식별됩니다. GHC에서 엔티티는 패키지, 모듈 및 이름의 트리플로 고유하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">공식적으로, 클래스 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 는 에서 bifunctor 나타냅니다 &lt;code&gt;Hask&lt;/code&gt; &amp;gt; - &lt;code&gt;Hask&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">C 스타일의 형식화 문자열을 사용하여 가변 개수의 인수를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt; 에 따라 문자열을 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">형식 문자열.</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값의 포맷터입니다 .</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">서식 덤프</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">숫자를 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">숫자를 ASCII 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">두 정수의 비율을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">다행히 GHC는 두 가지 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">다행히도 디버거에는 일반 인쇄 명령 인 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 가 포함되어 변수의 실제 런타임 값을 검사하고 해당 유형을 재구성 할 수 있습니다. 우리가 &lt;code&gt;left&lt;/code&gt; 시도하면 :</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">분수 나누기.</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">분수 리터럴은 translation이 &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; 인 것을 제외하고는 동일한 방식으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">실수를 지원하는 분수.</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; 또는 &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt; 의 &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt; 함수 로 할당 된 메모리 블록을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 무료 데이터</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">캐시 된 디버그 데이터를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">콜 스택을 고정하여 추가 콜 사이트가 추가되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">가변 배열을 고정시킵니다. 나중에 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 를 변경하지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">지정된 &lt;code&gt;CallStack&lt;/code&gt; 에서 스택을 고정하여 더 이상의 콜 사이트가 밀리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">신선한 이름</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">오름차순 목록에서</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">내림차순 목록에서</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">정렬되지 않은 목록에서</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; 와 다른 모듈에서</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">의미 적 관점에서 :</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">구문 관점에서 :</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">여기에서 정수 유형의 모든 인수에 f를 적용하고 결과를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">문자열에서 생성자로 또는 그 반대로 : 모든 데이터 유형</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">로부터 &lt;code&gt;x1==x2&lt;/code&gt; 우리 필요 &lt;code&gt;Eq a&lt;/code&gt; 미세하다. &lt;code&gt;c1==c2&lt;/code&gt; 부터 우리 는 오늘날 Haskell에서 &lt;em&gt;좋지 않은 &lt;/em&gt; &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; 가 &lt;em&gt;필요&lt;/em&gt; 합니다. 우리는 그러한 제약을 해결할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">부터 &lt;code&gt;x==x&lt;/code&gt; 우리가 필요로 &lt;code&gt;Eq (m Int)&lt;/code&gt; 제약 조건을하지만, 상황은 우리가 알아낼 수있는 방법 제공 &lt;code&gt;Ord (m a)&lt;/code&gt; 제약. 그러나 주어진 제약 조건에서 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; 우리는 모든 a에 대한 두 번째 주어진 제약을 도출 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; 이고, 그로부터 &lt;code&gt;Eq (m Int)&lt;/code&gt; 를 쉽게 풀 수 있습니다 . 이 프로세스는 슈퍼 클래스가 이미 작동하는 방식과 매우 유사합니다. &lt;code&gt;Ord a&lt;/code&gt; 제약이 주어지면 두 번째로 &lt;code&gt;Eq a&lt;/code&gt; 제약이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">초록에서 :</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;ByteString&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;ByteString&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">컴파일러 플러그인과 같은 프론트 엔드 플러그인은 등록 된 플러그인으로 내보내집니다. 그러나 컴파일러 모듈과 달리 프론트 엔드 플러그인은 &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; 유형의 최소한 하나의 식별자 &lt;code&gt;frontendPlugin&lt;/code&gt; 을 내보내는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="translated">Full list of currently supported flags:</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">기능 구성.</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">함수 포인터</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능. 첫 번째 인수는 단어 왼쪽의 줄 내용을 반대로 한 것입니다. 두 번째 주장은 완성 될 단어입니다.</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">코딩 오류 처리를위한 함수 유형 두 가지 입력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">기능 유형. 마지막 유형 매개 변수는 &lt;em&gt;공변량&lt;/em&gt; 위치 에서 발생하는 한 함수 유형의 어느 곳에 나 나타날 수 있습니다 . 이것이 의미하는 바를 설명하기 위해 다음 세 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">기능 종속성은 Mark Jones가 &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt; 에 설명 된대로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">기능적 의존성은 클래스 선언 구문에서 세로 막대로 소개됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">기능적 의존성은 문제를 복잡하게합니다. 우리가 가지고 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">튜플 데이터 형식과 관련된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">파일 시스템 조작 및 조회를 위해 POSIX 표준에 의해 정의 된 기능. 기본 POSIX 기능의 이름은 가능할 때마다 표시됩니다. 다양한 오류 조건에 대한 자세한 설명과 함께 POSIX 기능에 대한보다 완전한 문서는 일반적으로 시스템 매뉴얼 페이지 또는 &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (무료 등록 필요)에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">여러 표준 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">몇 가지 표준 인코딩을 사용하여 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 지연 &lt;code&gt;ByteString&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">추적 및 실행 모니터링 기능.</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">&lt;code&gt;GHC.Stack&lt;/code&gt; 모듈의 함수 는 현재 스택을 가져 와서 렌더링하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">MAPI DLL에서로드 된 함수</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">문자열의 함수</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">타입 리터럴의 함수</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">컴파일러에 의해 융합 될 수있는 함수는 &quot;융합 대상&quot;이라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">텍스트 데이터를 읽을 때 자주 사용되는 기능.</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">펑터 및 모나드 클래스</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순회 할 수있는 데이터 구조를 나타내는 펑터.</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">이 &lt;code&gt;let&lt;/code&gt; 문에 추가 바인딩을 추가 할 수 있으므로 GHCi는 프롬프트를 변경하여 다음 줄이 이전 줄을 계속한다는 것을 나타냅니다. 참고 레이아웃은 지금이 더 바인딩을 추가, 효과에 있음을 &lt;code&gt;let&lt;/code&gt; 우리가 그들을 줄을있다 :</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">또한 모든 정의는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt; &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; &lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 GHC를 사용하면 이벤트 로그 데이터 ( &lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 참조 )가 사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 를&lt;/a&gt; 통해 작성 되는 방식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">또한 GHC는 메타 데이터로 소스 코드에 주석을 달 때 사용할 수있는 간단한 주석 메커니즘을 제공하며, 나중에 컴파일러 API 또는 컴파일러 플러그인으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">또한 GHCi는 다음과 같은 경우 I / O 작업 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">또한 아래 스케치와 같이 불안정한 인터페이스를 사용하여 컴파일 된 프로그램을 실행하는 데 큰 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">또한 별개의 어휘 유형 변수는 별개의 유형 변수를 나타냅니다. 이는 모든 프로그래머가 작성한 유형 서명 (자유 범위 지정 유형 변수를 포함하는 서명 포함)이 &lt;em&gt;엄격한&lt;/em&gt; 유형을 나타냅니다 . 즉, 유형은 유형 검사기에 완전히 알려져 있으며 추론이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">또한 모든 유형 생성자에 대해 유형 생성자 아래에서 강제 할 수있는 인스턴스가 있습니다. 예를 들어, &lt;code&gt;D&lt;/code&gt; 는 역할이 &lt;code&gt;nominal&lt;/code&gt; , &lt;code&gt;representational&lt;/code&gt; resp 를 갖는 세 가지 유형 인수를 가진 프로토 타입 유형 생성자 ( &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; ) 라고하자 . &lt;code&gt;phantom&lt;/code&gt; . 그런 다음 양식의 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">또한 닫는 &lt;code&gt;#-}&lt;/code&gt; 은 여는 &lt;code&gt;{-#&lt;/code&gt; 오른쪽의 열에서 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">또한, 유형 &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;Typeable&lt;/code&gt; 인스턴스 를 갖도록 제한됩니다 . 따라서 다음은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">또한 다음과 같은 기능을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">게으른 &lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">&lt;code&gt;integer_gmp&lt;/code&gt; 의 이후 버전은 더 이상 음수 &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 값을 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="translated">GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC 스타일 응답 파일.</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="translated">GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC는 (대부분) Haskell Foreign Function Interface를 따르며, 그 정의는 &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt; 의 Haskell Report의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC ( 항상 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 )는 &quot;충분히 작은&quot;기능 / 값을 인라인 (또는 &quot;펼치기&quot;)하려고 시도하여 호출 오버 헤드를 피하고 다른 더 놀라운 최적화를 노출시킵니다. GHC에는 많은 벤치 마크를 사용하여 오랜 기간 동안 조정 된 휴리스틱 세트가 있으며 호출 사이트에서 함수를 인라인하는 것이 유리한 시점을 결정합니다. 휴리스틱은 함수가 유익 할 때 함수를 인라인하도록 설계되었지만 과도한 코드 팽창이 발생하지 않습니다. 함수가 너무 크게 보이면 인라인되지 않으며 특정 크기보다 큰 함수는 인터페이스 파일로 정의를 내 보내지 않아도됩니다. 이러한 휴리스틱 결정을 제어하는 ​​일부 임계 값은 플래그를 사용하여 변경할 수 있습니다 ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;플랫폼 독립 플래그 -f *&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8은 타입 레벨 자연수를 포함한 산술 표현을 평가할 수 있습니다. 이러한 표현은 유형, 가정 &lt;code&gt;(+), (*), (^)&lt;/code&gt; 하여 더하기, 곱하기 및 지수를 사용하여 구성 할 수 있습니다 . 번호를 사용하여 비교 될 수있다 &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; , 승격 부울 값, 또는 반환을 &lt;code&gt;(&amp;lt;=)&lt;/code&gt; , 제약으로 번호를 비교한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8은 종류와 종류가 실제로는 동일하다고 선언함으로써 종류 다형성의 아이디어를 확장합니다. GHC 내의 어떤 것도 유형과 종류를 구별하지 않습니다. 이것에 대해 생각하는 또 다른 방법은 &lt;code&gt;Bool&lt;/code&gt; 유형 과 &quot;promoted kind&quot; &lt;code&gt;Bool&lt;/code&gt; 이 실제로 동일하다는 것입니다. ( &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;'True&lt;/code&gt; ' 라는 용어 는 표현식에서 사용하고 후자는 유형에서 사용할 수 있기 때문에 여전히 구별됩니다.) 유형과 종류의 구별이 부족하다는 것은 의존적으로 유형이 지정된 언어의 특징입니다. 완전 의존적으로 유형이 지정된 언어는 표현과 유형의 차이를 제거하지만 GHC에서 수행하는 것은 다른 날의 이야기입니다.</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2는 모듈 서명 ( &lt;code&gt;hsig&lt;/code&gt; 파일)을 지원하므로 , 모듈 구현 대신 서명을 작성하여 나중에 구현 선택을 연기 할 수 있습니다. 이 기능은 &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 없이 사용할 수 없습니다 . 이 매뉴얼 항목은 서명의 구문과 의미에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC 확장 : 이것은 GHC 특정 확장을 얻는 승인 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC 주 : 전화를하기 위해 &lt;code&gt;waitForProcess&lt;/code&gt; 을 시스템의 다른 모든 스레드를 차단하지 않고, 당신이 프로그램을 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">GHC는 현재 &lt;strong&gt;의심스러운 경우 거부를&lt;/strong&gt; 채택 합니다. 우리는 그것이 실제로 얼마나 고통 스러운지 알 수 있으며 필요하다면 더 야심 찬 것을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">GHC는 스레드가 &lt;code&gt;foreign export&lt;/code&gt; 를 통해 Haskell 함수를 호출 할 때 소량의 스레드 로컬 메모리를 할당합니다 . 이 메모리는 일반적으로 &lt;code&gt;hs_exit()&lt;/code&gt; 까지 해제되지 않습니다 . Haskell에 대한 후속 호출이 빠르도록 메모리가 캐시됩니다. 그러나 응용 프로그램이 오래 실행되고 Haskell을 호출하는 새 스레드가 반복적으로 생성되는 경우 Haskell 함수 호출을 완료 한 스레드에서이 메모리가 해제되도록 할 수 있습니다. 이렇게하려면 메모리를 해제 할 스레드에서 &lt;code&gt;hs_thread_done()&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC를 사용하면 레코드 구문과 함께 존재도 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC를 사용하면 숫자 리터럴을 10 진수, 8 진수, 16 진수, 2 진수 또는 부동 소수점 표기법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC는 독립형 수 &lt;code&gt;deriving&lt;/code&gt; 으로 사용 선언, &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC를 사용하면 형식 생성자, 클래스 및 형식 변수가 연산자가되고 식과 매우 유사하게 접두사가 작성 될 수 있습니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC는 또한 가시적 인 종류 적용을 허용하는데, 여기서 사용자는 종류 인수가 종류 다형성 경우에 인스턴스화되도록 선언 할 수 있습니다. 사용법은 위에서 지정한 것처럼 용어 수준에서 보이는 유형 응용 프로그램과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC는 두 종류의 잠재적으로 다른 종류와 관련된 &lt;em&gt;종류 이종의&lt;/em&gt; 평등 도 지원합니다 . 이기종 평등의 철자가 &lt;code&gt;~~&lt;/code&gt; 입니다. 차이점을 더 잘 이해하기 위해 &lt;code&gt;~&lt;/code&gt; 와 &lt;code&gt;~~&lt;/code&gt; 의 종류는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC는 항상 인스턴스 의 &lt;em&gt;마지막&lt;/em&gt; 매개 변수 ( 이 예에서는 &lt;code&gt;Foo&lt;/code&gt; )를 인스턴스가 파생되는 유형으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC는 두려운 단일 형성 제한 (Haskell 보고서의 섹션 4.5.5)을 암시 적 매개 변수에 적용합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC는 소스 파일이 ASCII 또는 UTF-8 전용이고 다른 인코딩은 인식되지 않는다고 가정합니다. 그러나 주석에서 유효하지 않은 UTF-8 시퀀스는 무시되므로 주석이 아닌 소스 코드가 ASCII 인 경우 Latin-1과 같은 다른 인코딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC는 가비지 수집기를 사용하여 스레드가 교착 상태를 감지하려고합니다. 도달 할 수없는 스레드 (실제 객체의 포인터를 따라 찾을 수 없음)는 교착 상태 여야하며이 경우 스레드에 예외가 전송됩니다. 스레드가 교착 상태에있는 방식에 따라 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 은 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC는 컴파일 할 때 Haskell 소스 파일에 대한 풍부한 정보를 작성합니다. 확장 인터페이스 파일은 IDE와 같은 외부 도구가 구문 분석, 유형 검사 및 이름 바꾸기를 피할 수 있도록이 정보 중 일부를 디스크에 유지하는 방법입니다. 이 파일들은</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC는 각 인터페이스 파일 및 인터페이스 파일 내의 각 선언에 대한 지문 (사실 MD5 해시)을 계산합니다. 또한 모든 인터페이스 파일에 파일을 마지막으로 컴파일 할 때 사용한 모든 지문 목록을 유지합니다. 소스 파일의 수정 날짜가 &lt;code&gt;.o&lt;/code&gt; 파일 날짜 보다 빠르면 (즉, 파일이 마지막으로 컴파일 된 이후 소스가 변경되지 않은 경우) 재 컴파일 검사가 켜져 있으면 GHC는 영리합니다. 이것은 이번에 필요한 것에 대한 지문과 마지막에 필요한 것에 대한 지문 (컴파일되는 모듈의 인터페이스 파일에서 수집)을 비교합니다. 모두 동일하면 &quot;컴파일이 필요하지 않습니다&quot;라는 프로세스의 초기에 컴파일이 중지됩니다. 정말 아름다운 광경입니다!</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="translated">GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; , which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC는 코드가 내보내지지 않았다는 것을 알고 있으면 좀 더 공격적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC는 많은 라이브러리와 함께 제공됩니다. 이것들은 별도의 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC는 시간 및 공간 프로파일 링 시스템과 함께 제공되므로&amp;ldquo;프로그램이 왜 느린가요?&amp;rdquo;또는&amp;ldquo;프로그램이 왜 메모리를 많이 사용합니까?&amp;rdquo;와 같은 질문에 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC는 일부 프로그램 구성을 천천히 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC는 부동 소수점 환경을 완전히 무시하며 런타임은이를 수정하거나 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC 는 현재 디렉토리에 하위 디렉토리 &lt;code&gt;.hpc&lt;/code&gt; 를 생성하고 컴파일 된 각 모듈마다 하나씩 HPC 색인 ( &lt;code&gt;.mix&lt;/code&gt; ) 파일을 저장합니다. 이 파일들에 대해 걱정할 필요가 없습니다. 파일에는 프로그램 실행 후 컴파일 된 모듈의 적용 범위 데이터를 생성하기 위해 &lt;code&gt;hpc&lt;/code&gt; 도구에 필요한 정보 가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC는 현재 동의어를 확장하기 전에 종류 검사를 수행합니다 (변경 될 수도 있음).</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHC는 현재 규칙 LHS를 표현식과 일치시키기 위해 매우 간단한 구문 일치 알고리즘을 사용합니다. 그것은 LHS 및 발현을 구문 상으로 모듈로 알파 변환으로 만드는 치환을 추구한다. 필요한 경우 표현식이 아닌 패턴 (규칙)이 확장됩니다. (표현식을 확장하면 게으름 버그가 발생할 수 있습니다.) 그러나 베타 변환 (고차 매칭이라고 함)은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC 는이 이론적 근거에 근거하여 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 명확하게 설명합니다. 보다 정형화 된 것을 만들기 위해 패턴 일치 검사기가 일부 데이터 유형 생성자 &lt;code&gt;T&lt;/code&gt; 에 대한 생성자 세트를 요청 하면 검사기는 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC는 프로그램에서 어떤 구체적인 유형 수준 리터럴이 사용되고 있는지 알게 되 자마자 제약 조건을 해제합니다. 이것은 임의의 유형 표현식이 아닌 &lt;em&gt;리터럴&lt;/em&gt; 에만 작동합니다 . 예를 들어, 상기 형태의 제약 조건 &lt;code&gt;KnownNat (a + b)&lt;/code&gt; 것이다 &lt;em&gt;하지&lt;/em&gt; 단순화 될 &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; 대신, GHC는 &lt;code&gt;a + b&lt;/code&gt; 를 일정한 값으로 단순화 할 수있을 때까지 제약 조건을 그대로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC에서는 데이터 유형 매개 변수가 아닌 유형 변수를 언급하는 컨텍스트가있는 데이터 유형을 가질 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHC는 Haskell 98에 의해 요구되는 바에 따라 구문 분석하는 동안 표현에서 고정도 해결을 수행하지 않습니다 (하스켈 2010에서는 아님). 예를 들어, Haskell 98 보고서에 따르면 다음 표현은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">각 컴파일마다 GHC를 다시 시작할 필요가 없으므로 컴파일간에 정보를 캐시 할 수 있습니다. &lt;code&gt;ghc --make&lt;/code&gt; 를 사용하여 다중 모듈 프로그램을 컴파일하면 각 소스 파일에서 개별적으로 &lt;code&gt;ghc&lt;/code&gt; 를 실행하는 것보다 최대 2 배 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="translated">GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC는 완전한 게으름을 구현하지 않습니다. on에서 최적화되고 &lt;code&gt;-fno-full-laziness&lt;/code&gt; 가 제공되지 않으면 루프에서 반복 계산을 추출하는 것과 같이 공유를 증가시키는 일부 변환이 수행됩니다. 이것들은 완전히 게으른 구현과 동일한 변환입니다. 차이점은 GHC가 완전히 게으름을 지속적으로 적용하지 않으므로 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC는 인라인이 영원히 지속될 수 없음을 보장합니다. 모든 상호 재귀 그룹 은 절대 인라인되지 않은 하나 이상의 &lt;em&gt;루프 차단기에&lt;/em&gt; 의해 차단됩니다 ( &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;GHC 인라이너의 비밀, 2002 년 7 월 12 일 JFP 12 (4) 참조&lt;/a&gt; ). GHC는 &lt;code&gt;INLINE&lt;/code&gt; pragma를 루프 차단기로 사용하여 기능을 선택하지 않지만, 선택이 없으면 INLINE 기능도 선택할 수 있으며,이 경우 &lt;code&gt;INLINE&lt;/code&gt; pragma는 무시됩니다. 예를 들어, 자체 재귀 함수의 경우 루프 차단기는 함수 자체 만 될 수 있으므로 &lt;code&gt;INLINE&lt;/code&gt; pragma는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC는 내장 ghc 패키지를 통해 내부 API를 사용자에게 공개합니다. Haskell 코드를 프로그래밍 방식으로 분석하거나 컴파일하기 위해 GHC의 전체 컴파일 드라이버를 활용하는 프로그램을 작성할 수 있습니다. 또한, GHC는 GHC의 내부 중간 표현 인 Core를보고 변경할 수있는 모듈 인 컴파일 중에 컴파일러 플러그인을로드 할 수있는 기능을 제공합니다. 플러그인은 실험 최적화 또는 분석에 적합하며 많은 경우에 컴파일러 개발에 대한 진입 장벽을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC는 추가 호출 규칙 &lt;code&gt;prim&lt;/code&gt; 을 사용하여 FFI를 확장합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC는 자동으로 파생 될 수있는 몇 가지 클래스를 추가하여이 목록을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC에는 런타임시 공유 라이브러리를 찾는 데 사용되는 메소드를 선택하기 위한 &lt;code&gt;-dynload&lt;/code&gt; 링크 플래그가 있습니다. 현재 두 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC는 포괄적 인 옵티 마이저를 가지고 있으므로 실제로 사용하고 싶을 때 (그리고 여유 시간이있을 때) GHC는 매우 빠른 코드를 생성 할 수 있습니다. 또는 기본 옵션은 생성 된 코드를 최적화하기 위해 너무 많은 노력을 기울이지 않으면 서 가능한 한 빨리 컴파일하는 것입니다 (GHC는 아마도 빠른 컴파일러라고 설명하지는 않습니다 :-).</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC에는 &lt;code&gt;Typeable&lt;/code&gt; 클래스 와 관련된 제약 조건을 배출하는 사용자 정의 솔버가 있으며 필기 인스턴스는 금지되어 있습니다. 이를 통해 프로그래머는 가짜 인스턴스를 작성하여 형식 시스템을 전복시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC에는 특별한 동작을 가진 몇 가지 내장 기능이 있습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; , use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . To reverse &lt;code&gt;-Werror&lt;/code&gt; , which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC에는 컴파일 중에 생성 될 수있는 치명적이지 않은 오류 메시지 유형 (예 : 경고)을 선택하는 여러 옵션이 있습니다. 일부 옵션은 개별 경고를 제어하고 다른 옵션은 경고 모음을 제어합니다. 개인 경고 해제하려면 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; 사용 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . 모든 경고를 오류로 만드는``-Werror ''를 되돌리려면 -Wwarn을 사용 &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC는 서명 자체를 모듈로 내보내기하지 않고 서명에 명시 적 내보내기 목록이있을 때 사용되는 &lt;em&gt;시그너처 thinning&lt;/em&gt; 을 실험적으로 지원 합니다. 이 경우 내보내기 목록 &lt;em&gt;은&lt;/em&gt; 병합 &lt;em&gt;후&lt;/em&gt; 최종 내보내기 목록에 적용됩니다 . 특히 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일 의 본문에 선언되지 않은 엔터티를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC는 매우 색다른 지원이 &lt;em&gt;impredicative 다형성&lt;/em&gt; 활성화, &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; 을&lt;/a&gt; . 이 일 경우,이는 것을 의미 &lt;em&gt;할 수&lt;/em&gt; 다형성 유형을 통해 다형성 다형성 유형의 기능과의 파라미터 데이터 구조를 호출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC에는 컴파일 타임에 컴파일러 플러그인을로드 할 수있는 기능이 있습니다. 이 기능은 &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; 에서 제공하는 기능과 유사하며 사용자가 제약 조건 솔버의 동작을 조정하고 컴파일 파이프 라인을 검사 및 수정하며 GHC의 중간 언어 인 Core를 변환 및 검사 할 수있는 플러그인을 작성할 수 있습니다. 플러그인은 실험 분석 또는 최적화에 적합하며 GHC의 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC는 사용자 제공, GHC 제공 및 시스템 제공 ( 예 : &lt;code&gt;-lm&lt;/code&gt; math 라이브러리)을 포함하여 다양한 라이브러리와 코드를 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC에는 GHCi &lt;a href=&quot;ghci#ghci&quot;&gt;사용에&lt;/a&gt; 설명 된 대화식 Haskell 인터프리터 (GHCi라고도 함) 와 &lt;a href=&quot;using#using-ghc&quot;&gt;GHC 사용&lt;/a&gt; 전체에 설명 된 배치 컴파일러가 있습니다. 실제로 GHC는 대화식 또는 배치 시스템을 제공하기 위해 다른 옵션으로 실행되는 단일 프로그램으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHC 홈페이지</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC는 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 최적화를 설정하면 어설 션을 무시합니다 . 즉, 형태의 표현 &lt;code&gt;assert pred e&lt;/code&gt; 로 다시 작성합니다 &lt;code&gt;e&lt;/code&gt; . &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 어설 션을 비활성화 할 수도 있습니다. &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하면 최적화가 설정된 경우에도 어설 션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC는 Haskell 2010 보고서의 FFI 장에 대한 여러 GHC 특정 확장을 구현합니다. 이러한 확장은 &lt;a href=&quot;#ffi-ghcexts&quot;&gt;FHC 장에 대한 GHC 확장에&lt;/a&gt; 설명되어 있지만 이러한 기능을 사용하는 프로그램은 이식 가능하지 않습니다. 따라서 이러한 기능은 가능하면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="translated">GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt; . For example, the type</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC는 선점 형 멀티 태스킹을 구현합니다. 스레드 실행은 임의 방식으로 인터리브됩니다. 보다 구체적으로, 스레드는 일부 메모리를 할당 할 때마다 선점 될 수 있습니다. 불행히도 할당이없는 타이트 루프가 다른 스레드를 잠그는 경향이 있음을 의미합니다 (단, 병리학 적 벤치 마크 스타일 코드에서만 발생 함).</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC는 동시 및 병렬 프로그래밍을 지원하기 위해 Haskell에 대한 몇 가지 주요 확장 기능을 구현합니다. 먼저 용어를 설정합시다 :</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHC는 타입 함수 나 타입 변수가 관련 될 때이 테스트를 보수적으로 구현합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC에는 컴파일 타임에 임의의 프로세스를 실행할 수있는 다양한 플래그가 포함되어 있습니다. 이러한 예 중 하나는 &lt;a href=&quot;phases#pre-processor&quot;&gt;사용자 지정 전 처리기&lt;/a&gt; 플래그입니다. 또 다른 하나는 템플릿 Haskell이 IO 작업을 포함하여 컴파일시 Haskell 코드를 실행하는 기능입니다. Safe Haskell &lt;em&gt;은 이러한 위험을 해결하지 못합니다&lt;/em&gt; (템플릿 Haskell은 허용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC에는 대칭 공유 메모리 다중 프로세서 (SMP)에서 Haskell 프로그램을 병렬로 실행할 수있는 기능이 포함되어 있습니다. 기본적으로 GHC는 하나의 프로세서에서 프로그램을 실행합니다. 당신이 병렬로 실행하려는 경우 당신은 당신의 프로그램을 연결해야 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , 그리고 RTS와 실행 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션; &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용&lt;/a&gt; 참조 ). 런타임은 사용 가능한 OS 스레드 중에서 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS 옵션으로 지정한 수만큼 병렬로 실행중인 Haskell 스레드를 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 여러 단계로 구성된 대규모 프로그램입니다. 아래 나열된 &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; 플래그를 사용하여 다양한 컴파일 단계에서 정보를 덤프하도록 GHC에 지시 할 수 있습니다 . 이들 중 일부는 많은 출력을 생성하는 경향이 있습니다. &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; 을&lt;/a&gt; 전달하여 표준 출력이 막히지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC는 기본 데이터 유형과 작업에 기반을두고 있습니다. 하스켈 자체에서 정의 될 수 없다는 의미에서 &quot;원시적&quot;. 이 코드를 사용하여 빠른 코드를 작성할 수는 있지만 일반적으로 더 높은 수준의 언어 기능 및 라이브러리를 사용하는 것이 훨씬 덜 고통스럽고 장기적으로 더 만족 스럽습니다. 운 좋게도, 작성한 코드는 어떠한 경우에도 효율적인 언 박스 버전에 최적화됩니다. 그렇지 않다면, 우리는 그것에 대해 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC 자체는 Haskell 프로그램이므로 옵션을 GHC 런타임 시스템에 직접 전달해야하는 경우 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 묶을 수 있습니다 ( &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;컴파일 된 프로그램 실행&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHC는 놀랍게도 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 가&lt;/a&gt; 없는 일반 컴파일에 적합합니다 !</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC는 작업 중복에 대해 매우 신중합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC는 인터페이스 파일에 매우 민감합니다. 예를 들어 비표준 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 선택하면 꽤 끔찍한 일이 발생합니다. 당신이 설정 한 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude 옵션 당신은 당신이 무엇을하고 있는지 알지 못한다면, 컴파일러는 거의 확실하게 죽을 것이다.</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC는 프로그램을 최적화 할 때 규칙을 계속 적용하려고합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHC는 특히 두 가지 패키지 데이터베이스에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC를 사용하면 컴파일시 &lt;code&gt;-with-rtsopts&lt;/code&gt; 플래그 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )를 사용하여 프로그램의 기본 RTS 옵션을 변경할 수 있습니다 . 이를위한 일반적인 용도는 프로그램에 기본보다 큰 기본 힙 및 / 또는 스택 크기를 제공하는 것입니다. 예를 들어, 설정 &lt;code&gt;-H128m -K64m&lt;/code&gt; 와 링크 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHC를 사용하면 런타임 시스템에서 호출하는 &quot;후크&quot;를 컴파일하여 특정 프로그램에 대한 특정 RTS 설정을 기초적으로 제어 할 수 있습니다. RTS에는 이러한 후크에 대한 스텁 정의가 포함되어 있지만 자체 버전을 작성하고 GHC 명령 행에서 링크하면 기본값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 언어 확장으로이 제한을 해제합니다 . 제한은 처음에는 꽤 어리석은 일이므로 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC는 단일 생성자 데이터 유형을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC는 거주하는 모든 유형의 유형 (유형 생성자 또는 유형 레벨 데이터와 구별됨)이 해당 유형의 값의 런타임 표현을 알려주는 특성을 유지합니다. 이 데이터 유형은 런타임 값의 선택을 인코딩합니다. 참고 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; 의해 매개 변수화된다 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; 을 ; 이것은 타입의 종류가 런타임 표현을 인코딩한다는 사실에 의해 우리가 의미하는 바입니다.</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC는 규칙의 LHS와 RHS가 동일한 의미를 갖는지 검증하려고 시도하지 않습니다. 그것은 일반적으로 결정 불가능하며 가장 흥미로운 경우에는 불가능합니다. 책임은 전적으로 프로그래머의 책임입니다!</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC는 규칙이 합리적이거나 종료되는지 확인하려고 시도하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC는 &lt;code&gt;.debug_info&lt;/code&gt; 섹션 에서 다음 표준 DIE를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">C를 통해 컴파일 할 때 GHC에 더 이상 외부 헤더 파일이 포함되지 않으므로이 검사는 수행되지 않습니다. &lt;a href=&quot;codegens#native-code-gen&quot;&gt;기본 코드 생성기&lt;/a&gt; ( &lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; )와 호환되고 FFI 사양을 엄격하게 준수하도록 변경되었습니다. FFI 호출에는 매크로 확장 및 C 헤더 파일을 사용할 때 적용될 수있는 기타 CPP 변환이 적용되지 않아야합니다. 이 접근 방식은 또한 모듈 및 패키지 경계에 걸쳐 외래 호출의 인라인을 단순화합니다. 외래 호출의 인라인 버전을 컴파일 할 때 헤더 파일을 사용할 필요가 없으므로 컴파일러는 어떤 상황에서도 외래 호출을 자유롭게 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC는 일반적으로 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 가져옵니다 . 그렇지 않은 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; 옵션을 지정하십시오. 아이디어는 Prelude를 직접 가져올 수 있다는 것입니다. 그러나 &lt;code&gt;Prelude&lt;/code&gt; 라고하지 마십시오 . Haskell 모듈 네임 스페이스는 단순하므로 Prelude 모듈과 충돌해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC 참고 : 가비지 수집기가 프로그램에 의해 참조되지 않은 것으로 감지되면 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 자동으로 닫힙니다. 그러나이 동작에 의존하는 것은 일반적으로 권장되지 않습니다. 가비지 수집기는 예측할 수 없습니다. 가능하면 명시 적 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 를 사용하여 더 이상 필요하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫으십시오 . GHC는 현재 파일 디스크립터가 부족할 때 파일 디스크립터를 비우려고 시도하지 않으며, 이것이 발생하지 않도록하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC 참고 : 기능의 수 는 프로그램이 시작될 때 &lt;code&gt;+RTS -N&lt;/code&gt; 옵션으로 지정됩니다 . 기본 운영 체제에서 지원하는 경우 &lt;code&gt;+RTS -qa&lt;/code&gt; 를 사용하여 기능을 실제 프로세서 코어에 고정 할 수 있지만 실제로는 불필요하지만 (실제로 성능이 저하 될 수 있으며 실험이 권장됩니다).</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. mallocForeignPtr과 같이 가비지 수집 힙에 고정 된 메모리를 사용합니다. mallocForeignPtr과 달리 mallocPlainForeignPtr로 작성된 ForeignPtr은 종료자를 갖지 않습니다. mallocPlainForeignPtr로 작성된 ForeignPtr에 종료자를 추가 할 수 없습니다. 이는 Haskell 내부에만 존재하는 ForeignPtr (예 : 묶음 문자열 용으로 만들어진 것)에 유용합니다. 이런 방식으로 생성 된 ForeignPtr에 종료자를 추가하거나 이러한 포인터를 완료하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대신 GHC를 사용하면 &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; 확장자를 사용하여 유형 변수가 명시 적으로 바인딩 된 모든 유형 변수를 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHC는 이제 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 이러한 인스턴스를 대신 파생 시킬 수 있으므로</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHC는 이제 STM (Software Transactional Memory)이라는 동시 Haskell 스레드의 활동을 조정하는 새로운 방법을 지원합니다. &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM 논문은&lt;/a&gt; 훌륭한 STM이 무엇인지 소개 및 사용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHC는이 모든 일을 도와주는 도움의 손길을 제공합니다. 사용자 소스에서 &lt;code&gt;assert&lt;/code&gt; 를 사용할 때마다 :</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHC는 &lt;em&gt;설치된&lt;/em&gt; 패키지에 대해서만 알고 있습니다. 설치된 패키지는 패키지 데이터베이스에 존재합니다. 패키지 데이터베이스 또는 패키지의 특정 세트가 GHC에 볼 수 있습니다 제어 패키지 데이터베이스에 대한 자세한 내용 및 방법을 참조 &lt;a href=&quot;#package-databases&quot;&gt;패키지 데이터베이스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHC는 다음과 같이 암시 적 정량을 수행합니다. 명시 적으로 &lt;code&gt;forall&lt;/code&gt; 이없는 경우에만 사용자 작성 유형의 가장 바깥 레벨 (유일) 에서 GHC는 아직 범위에 포함되지 않은 유형에 언급 된 모든 유형 변수를 찾고이를 보편적으로 정량화합니다. 예를 들어 다음 쌍은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e903f8397c8f5bbb60d7d8d13ff6bba05d63b1b1" translate="yes" xml:space="preserve">
          <source>GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt;, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</source>
          <target state="translated">GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt; , one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</target>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHC는 호출 될 때마다 종속성을 다시 계산하므로 종속성이 소스와 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHC는이 규칙을 두 가지 방법으로 완화합니다.</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC는 &lt;code&gt;a&lt;/code&gt; 의 종류가 &lt;code&gt;Type&lt;/code&gt; 이 아니라 종류 변수 &lt;code&gt;k&lt;/code&gt; 여야 한다는 오류를보고합니다 . 모든 형식에 대한 형식 서명을 보면 &lt;code&gt;forall a. Proxy a&lt;/code&gt; Proxy a , GHC는 &lt;code&gt;Type&lt;/code&gt; 으로 제한되지 않고 종류를 일반화해야 한다고 가정 &lt;code&gt;a&lt;/code&gt; . 함수 정의는 형식 서명보다 더 구체적으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1031c0bc27b3b9bb273d87c196ba3e6cd2a9cd" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt; , not &lt;code&gt;Type&lt;/code&gt; . This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt; , GHC assumes &lt;code&gt;a&lt;/code&gt; &amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt; . The function definition is then rejected for being more specific than its type signature.</target>
        </trans-unit>
        <trans-unit id="3372876691ddf4da952bbb863dd592b0bdfda843" translate="yes" xml:space="preserve">
          <source>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</source>
          <target state="translated">GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</target>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC는 상호 재귀 모듈 &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;을 컴파일하는 방법에&lt;/a&gt; 설명 된대로 상호 재귀 모듈 사이에서 재귀 루프를 절단하기 위해 &lt;code&gt;hs-boot&lt;/code&gt; 파일을 사용해야 합니다 . 하스켈 보고서는 다음과 같이 버그보다 악의가 없다고 말합니다 ( &lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;5.7 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건을 세 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건을 세 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHC는 &lt;code&gt;HasCallStack&lt;/code&gt; 제약 조건을 두 단계로 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">GHC는 때때로 몇 가지 플래그로 구성 할 수있는 유형이 지정된 구멍에 유효한 구멍 맞춤을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHC는 &lt;em&gt;종류&lt;/em&gt; 및 유형이 모두 일치 하는 &lt;em&gt;종류 색인&lt;/em&gt; 유형 패밀리를 지원 합니다. GHC는 때때로 사용자가 제공 한 친절한 서명이 &lt;em&gt;없으면&lt;/em&gt; 이 동작을 추론 &lt;em&gt;하지 않을&lt;/em&gt; 것입니다. &lt;em&gt;그렇게하지 않으면&lt;/em&gt; 때로는 비 주체 유형을 유추 할 수 있습니다. 실제로, 우리는 종류-인덱싱을 다형성 재귀의 형태로 볼 수 있는데, 여기에서 타입은 자체 정의에서 가장 일반적인 종류가 아닌 다른 종류로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHC는 &lt;em&gt;어휘 범위가 지정된 유형 변수를&lt;/em&gt; 지원 하지만 일부 유형 서명은 단순히 쓰기가 불가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC는 형식과 리터럴 텍스트에 따라 해석이 달라질 수있는 식별자 형식의 &lt;em&gt;오버로드 된 레이블을&lt;/em&gt; 지원 합니다. 때 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 의&lt;/a&gt; 확장이 활성화되어, 오버로드 된 라벨은 예를 들어, 접두사 해시 쓸 수 &lt;code&gt;#foo&lt;/code&gt; . 이 표현식의 유형은 &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC는 &lt;em&gt;오버로드 된 문자열 리터럴을&lt;/em&gt; 지원합니다 . 일반적으로 문자열 리터럴에는 &lt;code&gt;String&lt;/code&gt; 유형이 있지만 오버로드 된 문자열 리터럴이 활성화 된 경우 ( &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; 사용&lt;/a&gt; ) 문자열 리터럴의 유형은 &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHC는 &lt;em&gt;목록 표기법의 오버로드를&lt;/em&gt; 지원합니다 . 목록 구성에 대한 표기법을 다시 살펴 보겠습니다. Haskell에서는 목록 표기법을 다음 7 가지 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC는 특별한 옵션이나 특정 방식으로 컴파일 된 라이브러리를 요구하지 않고 기본적으로 동시 하스켈을 지원합니다. Concurrent Haskell의 지원 라이브러리에 액세스하려면 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent를&lt;/a&gt; 가져 오십시오 . Concurrent Haskell에 대한 자세한 내용은 해당 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88817a222e891093a054f7b9fd3592132552247b" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</target>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC는 &lt;code&gt;!pat&lt;/code&gt; 작성된 &lt;em&gt;bang 패턴&lt;/em&gt; 이라고하는 패턴 일치 확장을 지원합니다 . 하스켈 프라임은 뱅 패턴을 고려하고 있습니다. &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;하스켈 주요 기능 설명은&lt;/a&gt; 아래의 내용보다 더 많은 논의와 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHC는 &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;Char&lt;/code&gt; 를 포함한 여러 기본 산술 요소 유형에 대해 언 &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;박스형&lt;/a&gt; 요소의 배열을 지원합니다 . 자세한 내용은 Data.Array.Unboxed 라이브러리를 참조하십시오. 이러한 배열은 &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; 라이브러리의 표준 Haskell 98 배열을 사용하는 것보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHC는 동시성과 병렬 처리를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHC는 여러 백엔드 코드 생성기를 지원합니다. 이것은 GHC가 사용하는 마지막 중간 표현 (단순한 C와 같은 Cmm이라는 형식)을 가져와 실행 코드로 컴파일하는 컴파일러의 일부입니다. GHC가 지원하는 백엔드가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC는 유형 수준에서 숫자 및 문자열 리터럴을 지원하므로 미리 정의 된 많은 유형 수준 상수에 편리하게 액세스 할 수 있습니다. 숫자 리터럴은 &lt;code&gt;Nat&lt;/code&gt; 이고 문자열 리터럴은 &lt;code&gt;Symbol&lt;/code&gt; 입니다. 이 기능은 &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; 언어 확장으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHC는 동시성, 외부 함수 인터페이스, 예외, 다중 매개 변수 유형 클래스와 같은 유형 시스템 확장, 로컬 범용 및 실존 적 수량화, 기능 종속성, 범위 유형 변수 및 명시 적 언 박스형 유형을 포함한 다양한 언어 확장을 지원합니다. 이것들은 모두 &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC 언어 기능에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHC는 SMP (대칭 멀티 프로세서)에서 Haskell 프로그램의 병렬 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHC는 여러 pragma 또는 소스 코드에 배치 된 컴파일러에 대한 지침을 지원합니다. Pragma는 일반적으로 프로그램의 의미에 영향을 미치지 않지만 생성 된 코드의 효율성에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHC는 상호 재귀 모듈의 컴파일을 지원합니다. 이 섹션에서는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHC는 다음 언어 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC는 유형 매개 변수에 대해 공칭, 표현 및 팬텀의 세 가지 역할을 지원합니다. 유형 매개 변수가 명목상의 역할을하는 경우, 다른 두 유형이 실제로 다르지 않아야합니다. 유형 계열 축소 후 동일해야합니다. 유형 매개 변수에 표현 역할이있는 경우 두 유형이 모두 동일한 표현을 가져야합니다. ( &lt;code&gt;T&lt;/code&gt; 의 첫 번째 매개 변수의 역할이 표현적인 경우, &lt;code&gt;Age&lt;/code&gt; 와 &lt;code&gt;Int&lt;/code&gt; 가 동일한 표현을 갖기 때문에 &lt;code&gt;T Age Bool c&lt;/code&gt; 와 &lt;code&gt;T Int Bool c&lt;/code&gt; 는 동일한 표현을 갖습니다.) 유형 매개 변수가 가상 역할을하는 경우 추가 정보.</target>
        </trans-unit>
        <trans-unit id="739585d733fbd90b635381ce1f62b05fe70f7220" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt; &amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</target>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHC는 보수적 인 입장을 취합니다. 첫 번째는 받아들이지 만 세 번째는받지 않습니다. 규칙은 이것입니다. 유추 인스턴스 컨텍스트의 각 제약 조건은 반복없이 유형 변수로만 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">그런 다음 GHC는 이러한 각 세트를 사용하여 패턴 적용 범위를 확인합니다. 이 세트 중 하나라도 경고없이 패턴 적용 범위 검사기를 통과하면 완료됩니다. 각 세트가 하나 이상의 경고를 생성하는 경우 GHC는 결과의 수준에 따라 경고 세트 중 하나를 선택해야합니다. 결과는 다음 순서로 우선 순위가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHC는 우리가 &lt;em&gt;유추 된&lt;/em&gt; 것과 &lt;em&gt;지정된&lt;/em&gt; 유형 변수 라고 부르는 것을 구별 합니다. 보이는 유형 응용 프로그램으로 인스턴스화 할 때는 지정된 유형 변수 만 사용할 수 있습니다. 예제는 이것을 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">GHC는 &quot;Derivable type classes&quot;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105에 정의 된 일반 클래스의 구현을 사용했습니다. 이것은 &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍에 대한&lt;/a&gt; 보다 일반적인 지원 으로 제거 및 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">GHC는 기본적으로 복사 가비지 수집기를 사용합니다. &amp;ldquo;GC 중에 복사 된 바이트&amp;rdquo;는 가비지 수집 중에 복사해야하는 바이트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC는 &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; 를 사용하여 인스턴스 확인이 종료되도록합니다. 수량화 된 제약 조건에 맞게 이러한 규칙을 어떻게 수정합니까? 두 가지 방법으로.</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">GHC의 8.8 정의 문서화되지 않은 기능의 이전 버전 &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; 및 &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; 대신 &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; 및 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; . 해당 이름은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC는 INLINE으로 표시되지 않은 모든 내 보낸 기능에 대해 &lt;code&gt;SCC&lt;/code&gt; 주석을 자동으로 추가 합니다. 인라인 기능에 코스트 센터가 필요한 경우 수동으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC는 INLINE으로 표시되지 않은 모든 최상위 바인딩에 대해 &lt;code&gt;SCC&lt;/code&gt; 주석을 자동으로 추가 합니다. 인라인 기능에 코스트 센터가 필요한 경우 수동으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">나중에 추가 할 수 있기 때문에 GHC가 이에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">GHC는 다음과 같은 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHC는이 주장을 다시 작성하여 주장이 이루어진 출처 위치를 포함 시키며,</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">기본 내보내기 목록에는 Haskell 보고서가 일반적으로 요구하는 것처럼 기본 내보내기 목록에 &lt;code&gt;main&lt;/code&gt; 대신 &lt;code&gt;program&lt;/code&gt; 이 포함되므로 GHC는 &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; 로이 모듈을 성공적으로 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">GHC의 &lt;code&gt;-main-is&lt;/code&gt; 옵션을 사용하여 최상위 엔트리 포인트 이름을 &lt;code&gt;main&lt;/code&gt; 에서 다른 변수 로 변경할 수 있습니다 . 기본 모듈을 컴파일 할 때 &lt;code&gt;-main-is&lt;/code&gt; 를 사용하여 기본 진입 점의 이름을 바꾸면 GHC는 기본 내보내기 목록의 대체 이름도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">GHC의 동작은 옵션에 의해 제어되며, 역사적 이유로 때때로 명령 행 플래그 또는 인수라고도합니다. 옵션은 세 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">GHC의 동작은 먼저 모드 플래그에 의해 제어됩니다. 이러한 플래그 중 하나만 제공 할 수 있지만 반드시 명령 행에서 첫 번째 옵션 일 필요는 없습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">GHC의 컴파일 된 출력은 일반적으로 마지막 실행 컴파일 단계에 따라 &lt;code&gt;.hc&lt;/code&gt; , &lt;code&gt;.o&lt;/code&gt; 등 파일 로 들어갑니다 . &lt;code&gt;-o file&lt;/code&gt; 옵션 은 마지막 실행 단계의 출력을 ⟨file⟩로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">GHC의 기본 동작은 &lt;em&gt;정확히 하나의 인스턴스가 해결하려는 제약 조건과 일치해야한다는 것입니다&lt;/em&gt; . 예를 들어 제약 조건 &lt;code&gt;C Int Bool&lt;/code&gt; 은 인스턴스 (A) 및 (B)와 일치하므로 거부됩니다. 반면 &lt;code&gt;C Int Char&lt;/code&gt; 일치하는 경우에만 (A) 따라서 (A)가 선택된다.</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">GHC의 구현은 대문자 또는 소문자가 아닌 유니 코드 알파벳 문자가 여전히 &lt;code&gt;isAlpha&lt;/code&gt; 에 의해 알파벳으로 식별된다는 점에서 Haskell 98 정의와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">GHC의 &lt;code&gt;array&lt;/code&gt; 구현은 목록의 마지막 (인덱스, 값) 쌍에서 배열 슬롯의 값을 가져 오며 중복을 검사하지 않습니다. 그 이유는 순수하고 단순하며 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">정수 유형에 대한 GHC의 &lt;code&gt;Read&lt;/code&gt; 클래스 구현 은 16 진 및 8 진 리터럴을 허용합니다 (Haskell 98 보고서의 코드는 그렇지 않습니다). 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHC의 mdo-notation 구현은 &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell&lt;/a&gt; 에 대한 재귀 적 수행 문서에 설명 된대로 원래의 번역과 밀접한 관련 이 있으며, 이는 &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;모나 딕 계산에서의 가치 재귀&lt;/a&gt; 작업에 기반합니다 . 또한 GHC 는 다음에 설명하는 것처럼 &lt;code&gt;rec&lt;/code&gt; 키워드로 플래그가 낮은 하위 구문을 사용하여 이전 논문에서 설명한 구문을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">GHC의 인라이너는 데이터 유형을 통해 재귀를 인코딩하는 표준 방법을 사용하여 비 종료로 설득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">GHC 옵티마이 저는 종료되지 않는 재 작성 규칙 ( &lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; )을 작성 하거나 데이터 유형을 통해 재귀를 코딩하는 경우 ( &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC의 버그&lt;/a&gt; ) 덜 만족할 수 있습니다 . 컴파일러가 무한 루프에 빠지지 않도록하기 위해 옵티마이 저는 &quot;틱 카운트&quot;를 수행하고이 카운트가 초과되면 인라이닝 규칙을 적용하지 않습니다. 한계는 프로그램 크기의 배수로 설정되므로 큰 프로그램은 더 많은 눈금을 얻습니다. &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; 플래그는 승수를 변경할 수 있습니다. 기본값은 100입니다. 100보다 큰 숫자는 더 많은 눈금을 제공하고 100보다 작은 숫자는 더 적은 눈금을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">GHC의 병렬 처리 지원은 런타임 시스템에서 많은 실험과 조정의 결과로 6.12.1에서 개선되었습니다. 우리는 여전히 그것이 당신에게 얼마나 잘 작동하는지 듣고 싶으며, 벤치마킹 제품군에 추가 할 병렬 프로그램을 수집하는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">GHC의 프로파일 링 시스템은 코스트 센터에 비용을 할당합니다. 비용은 단순히 식을 평가하는 데 필요한 시간 또는 공간 (메모리)입니다. 코스트 센터는 표현식 주위의 프로그램 주석입니다. 주석이 달린 표현식에 의해 발생 된 모든 비용은 둘러싸는 코스트 센터에 할당됩니다. 또한 GHC는 런타임에 특정 표현식에 대한 엔 클로징 코스트 센터 스택을 기억하고 비용 속성의 콜 트리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">GHC의 프로파일 링 시스템은 &quot;비용 센터 스택&quot;을 지원합니다. 이는 콜 그래프와 같은 구조로 Haskell 프로그램의 프로파일을 보는 방법입니다. 자세한 내용은 &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">GHC의 런타임 시스템은 실행중인 Haskell 프로그램에서 스택 추적 정보를 수집하는 기능을 기본적으로 지원합니다. 현재 &lt;code&gt;elfutils&lt;/code&gt; 패키지 의 &lt;code&gt;libdw&lt;/code&gt; 라이브러리를 사용할 수 있어야합니다. 물론, 디버그 정보가 실행 파일과 종속 라이브러리에서 사용 가능하지 않으면 역 추적은 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34ecd7773e52e6b1108977b176ca3c2b9e8f2456" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</target>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC의 런타임 시스템은 협업 멀티 태스킹을 구현하며, 프로그램이 할당 될 때만 컨텍스트 전환이 발생할 수 있습니다. 이는 할당되지 않은 프로그램은 컨텍스트 전환이되지 않을 수 있음을 의미합니다. 일관성이없는 상태를 관찰 한 후 교착 상태가 발생할 수있는 STM을 사용하는 프로그램의 경우 특히 그렇습니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;문제 # 367&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">GHC의 유형 시스템은 유형에서 &lt;em&gt;임의의 등급의&lt;/em&gt; 명시 적 범용 정량을 지원합니다. 예를 들어 다음 유형이 모두 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">GHC의 어레이 구현.</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">GHC의 동시성 구현</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">GHC의 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 데이터 유형 구현</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">기본적으로 GHC는 더 이상 cygwin에 의존하지 않지만 기본 Windows 프로그램입니다. 그것은 mingw를 사용하여 빌드되었으며, 하스켈 소스를 컴파일하는 동안 mingw의 GHC를 사용하지만 (cygwin의 bash에서 호출하더라도) 여기에서 중요한 것은 다른 일반 Windows 프로그램과 마찬가지로 GHC 또는 실행 파일도 아닙니다. Cygwin의 유닉스 계층 구조를 알고 있습니다. GHC는 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\\&lt;/code&gt; 를 경로 구분 기호로 행복하게 받아들이지 만 &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; 또는 &lt;code&gt;/bin/bash&lt;/code&gt; 등 을 찾을 수있는 곳을 모릅니다 . Cygwin의 bash 내에서 또는 Cygwin에서 실행되는 make-session에서 GHC를 사용할 때 모든 종류의 재미가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="6b49fe46f1283625854f08ffa7ba78c6c9050030" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 Haskell 표현을 대화식으로 평가하고 프로그램을 해석 할 수있는 GHC의 대화식 환경입니다. &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs에&lt;/a&gt; 대해 잘 알고 있다면 GHCi와 함께 집에있을 것입니다. 그러나 GHCi 또한 대화식 로딩 컴파일 된 코드에 대한 지원뿐만 아니라, 모든 보유지지 &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; GHC이 제공하는 언어를 확장한다. GHCi에는 대화식 디버거도 포함되어 있습니다 &lt;a href=&quot;#ghci-debugger&quot;&gt;(GHCi 디버거&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">GHCi는 실제로 프롬프트에서 단순한 표현이 아닌 진술을 받아들입니다. 즉, 값과 함수를 이름에 바인딩하여 향후 식이나 명령문에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCi는 실제로 &lt;em&gt;두 가지&lt;/em&gt; 옵션 세트를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCi는 명령 행에서 일반 객체 파일 ( 플랫폼에 따라 &lt;code&gt;.o&lt;/code&gt; 또는 &lt;code&gt;.obj&lt;/code&gt; ) 또는 정적 아카이브 ( &lt;code&gt;.a&lt;/code&gt; )를 로드 할 수도 있습니다 . 오브젝트 파일 또는 라이브러리 이름을 명령 행에 추가하십시오. Windows에서 GHCi는 &lt;code&gt;big-obj&lt;/code&gt; 형식 도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">GHCi는 프로파일 링 시스템을 사용하여 해석 된 코드를 실행할 때 스택 추적 정보를 수집 할 수 있습니다. 스택 추적에 액세스하려면 다음과 같이 GHCi를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b50b888b5a01174ea88ffe286c7e481b07e9ce3d" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</target>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">GHCi 명령은 모두&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo;로 시작 하며 단일 명령 이름과 0 개 이상의 매개 변수로 구성됩니다. 명령 이름은 축약 될 수 있으며, 더 일반적으로 사용되는 명령을 위해 모호성이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="cdeb81402d6c2b81eaa4ac1ca68fa6f4bf53dc3f" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</source>
          <target state="translated">GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi에는 변수 값을 검사하기 위해 실행중인 계산을 중지 할 수있는 간단한 명령 스타일 디버거가 포함되어 있습니다. 디버거는 GHCi에 통합되어 있으며 기본적으로 켜져 있습니다. 디버깅 기능을 활성화하기 위해 플래그가 필요하지 않습니다. 한 가지 주요 제한 사항이 있습니다. 중단 점 및 단일 스테핑은 해석 된 모듈에서만 사용 가능합니다. 컴파일 된 코드는 디버거에 보이지 않습니다 &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCi는 프롬프트에서 단순한 표현 평가 이상의 기능을 수행합니다. 일부 &lt;code&gt;a&lt;/code&gt; 에 대해 &lt;code&gt;IO a&lt;/code&gt; 유형의 표현식을 입력하면 GHCi가이를 IO 계산으로 &lt;em&gt;실행&lt;/em&gt; 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCi는 범위가있는 모듈 의 &lt;code&gt;default&lt;/code&gt; 선언을 존중하지 않습니다 . 대신 명령 행에 입력 된 표현식의 경우 항상 기본 기본 유형 동작을 얻습니다. 즉, &lt;code&gt;default(Int,Double)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi는로드 &lt;code&gt;Main&lt;/code&gt; 모듈을하고 프롬프트가 변경되었습니다 &lt;code&gt;*Main&amp;gt;&lt;/code&gt; 프롬프트에서 입력 한 표현의 현재 상황이 발생한 것을 나타 내기 위해서 &lt;code&gt;Main&lt;/code&gt; (우리가 설명 할 것이다 우리가로드 모듈 무슨 &lt;code&gt;*&lt;/code&gt; 수단 나중에 &lt;a href=&quot;#ghci-scope&quot;&gt;범위에 정말 무엇 프롬프트에서?&lt;/a&gt; ). 이제 &lt;code&gt;Main.hs&lt;/code&gt; 의 함수와 관련된 표현식을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e7e52195cfae2c519c03e23e784d7a20ae2e810" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; ), and additionally a binding for the result of the expression ( &lt;code&gt;_result&lt;/code&gt; ). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi는 브레이크 포인트가 배치 된 표현 의 자유 변수 &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; 에 대한 바인딩 ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; )을 추가로 제공했으며, 추가로 표현 결과에 대한 바인딩 ( &lt;code&gt;_result&lt;/code&gt; )을 제공했습니다. 이러한 변수는 GHCi에서 정의 할 수있는 다른 변수와 같습니다. 프롬프트에서 입력하는 표현식에 사용할 수 있으며 &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; 등으로 유형을 요청할 수 있습니다 . 그러나 한 가지 중요한 차이점이 있습니다. 이러한 변수에는 부분 유형 만있을 수 있습니다. 예를 들어, 우리는의 값을 표시하려고하면 &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi는 전체 라인을 평가할 표현식으로 해석합니다. 표현식은 여러 줄에 걸쳐 있지 않을 수 있습니다. Enter 키를 누르면 GHCi가이를 평가하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">GHCi는 &lt;code&gt;ghci&lt;/code&gt; 또는 &lt;code&gt;ghc --interactive&lt;/code&gt; 명령으로 호출됩니다 . 명령 행에 하나 이상의 모듈 또는 파일 이름을 지정할 수도 있습니다. 이는 GHCi 프롬프트에서 &lt;code&gt;:load modules&lt;/code&gt; 을 말한 것처럼 GHCi에 지정된 모듈 또는 파일 이름 (및 이들이 의존하는 모든 모듈)을 로드 하도록 지시합니다 ( &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi 명령&lt;/a&gt; 참조 ). 예를 들어 GHCi를 시작하고 최상위 모듈이 &lt;code&gt;Main.hs&lt;/code&gt; 파일에있는 프로그램을로드하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCi 옵션은 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; set을 사용하여 설정 하고 &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; 을&lt;/a&gt; 사용하여 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCi는 다른 결합들 중에서 &lt;code&gt;f&lt;/code&gt; 가 범위 내에 있다고 말한다 . 그러나 해당 유형은 아직 완전히 알려지지 않았으므로 인수에 적용 할 수 없습니다. 그럼에도 불구하고 첫 번째 인수의 유형은 &lt;code&gt;x&lt;/code&gt; 의 유형과 동일 하며 결과 유형은 &lt;code&gt;_result&lt;/code&gt; 와 공유됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">GHCi는 &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; 을 후드 아래에서 사용합니다 . 무엇보다도 GHCi 히스토리에서 복제본을 제거하도록 구성 할 수 있습니다. &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline 사용자 환경 설정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCi는 범위 내에있는 이름을 탭 완성합니다. 당신이 GHCi를 실행하고 입력하는 경우, 예를 들어, &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; 다음 GHCi가로 확장됩니다 &lt;code&gt;Just&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">가비지 콜렉션에는 실제 상주보다 많은 메모리가 필요합니다. 이 요소는 사용중인 가비지 수집 알고리즘의 종류에 따라 다릅니다. 표준 세대 복사 수집기의 주요 GC에는 일반적으로 \ (3L \) 바이트의 메모리가 필요합니다. 여기서 \ (L \)는 라이브 데이터의 양입니다. 기본적으로 (RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 옵션 참조 ) 수집하기 전에 이전 세대의 크기를 두 배 (\ (2L \))로 늘리고 추가로 \ (L \) 바이트가 필요하기 때문입니다. 라이브 데이터. 압축 콜렉션을 사용하는 경우 ( &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 참조 )이 값은 \ (2L \)로 줄어들고 &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 옵션 을 조정하여 더 줄일 수 있습니다 . 할당 영역의 크기도 추가하십시오 ( &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">일반 수량 세마포어</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">일반적인 결합 기능</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">수퍼 클래스 메소드에 대한 일반 정의</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 접기는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 인스턴스를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb698a6fdef53a2047596be60a1e1ba2d67960a" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">일반 마샬링 유틸리티</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">일반 렌더링</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">범용 유한 시퀀스.</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">리스트 함수의 일반화</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">일반화 된 대수 데이터 형식 생성자가 더 풍부한 반환 형식을 가질 수 있도록하여 일반 대수 데이터 형식을 일반화합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">일반화 된 목록 이해는 SQL에 익숙한 정렬 및 그룹화와 같은 조작을 허용하기 위해 목록 이해 구문 설탕을 더욱 향상시킵니다. 그것들은 우리가 사용하는 구문이 논문과 약간 다르다는 것을 제외하고는 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;포괄적 인 이해 : &quot;순서 순&quot;과 &quot;그룹 순&quot;&lt;/a&gt; 에 대한 이해에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Control.Exception의 일반화</target>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">고차 종류의 일반 캐스트</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">건의 성 평등을 사용하는 일반화 된 형식 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">표현 평등을 사용하는 일반화 된 형식 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">일반화 된 기능</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
