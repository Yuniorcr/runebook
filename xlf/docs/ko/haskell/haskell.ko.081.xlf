<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="01b9f449ab6343ea54f02e26f1e9faf3b8a4900b" translate="yes" xml:space="preserve">
          <source>Parse a time value given a format string. See &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석하십시오. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;data-time-format#v:parseTimeM&quot;&gt;parseTimeM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2bcd9fc04842aba6ce12e98373cf3b96da5c978b" translate="yes" xml:space="preserve">
          <source>Parse a value in either extended or basic format</source>
          <target state="translated">확장 또는 기본 형식으로 값을 구문 분석</target>
        </trans-unit>
        <trans-unit id="2960f380b30894cf9484ebfaf5167a7bcf5265fb" translate="yes" xml:space="preserve">
          <source>Parse a value in the format</source>
          <target state="translated">형식으로 값을 구문 분석</target>
        </trans-unit>
        <trans-unit id="9f1ffb1644b47f32b305b727b8e2f0c4183a5335" translate="yes" xml:space="preserve">
          <source>Parse errors</source>
          <target state="translated">구문 분석 오류</target>
        </trans-unit>
        <trans-unit id="7d315fdee5a3dc981c3a0b2bb2a2a03e5b911e53" translate="yes" xml:space="preserve">
          <source>Parse the most commonly used ISO 8601 format.</source>
          <target state="translated">가장 일반적으로 사용되는 ISO 8601 형식을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="ba0d4aca2cb647cf93798740ced61a0bfc954e4c" translate="yes" xml:space="preserve">
          <source>Parse the specified lexeme and continue as specified. Esp useful for nullary constructors; e.g. &lt;code&gt;choose [(&quot;A&quot;, return A), (&quot;B&quot;, return B)]&lt;/code&gt; We match both Ident and Symbol because the constructor might be an operator eg &lt;code&gt;(:~:)&lt;/code&gt;</source>
          <target state="translated">지정된 lexeme를 구문 분석하고 지정된대로 계속하십시오. null 생성자에 유용한 Esp; 예를 들어 &lt;code&gt;choose [(&quot;A&quot;, return A), (&quot;B&quot;, return B)]&lt;/code&gt; 하십시오. 생성자가 연산자 일 수 있기 때문에 Ident와 Symbol을 모두 일치시킵니다 &lt;code&gt;(:~:)&lt;/code&gt; 예 : (: ~ :)</target>
        </trans-unit>
        <trans-unit id="df633b0d4b46131792d5ed485e94f872474b0ba2" translate="yes" xml:space="preserve">
          <source>ParseError</source>
          <target state="translated">ParseError</target>
        </trans-unit>
        <trans-unit id="e74c212b67cd9480fc62438093300cf8d7822087" translate="yes" xml:space="preserve">
          <source>ParseTime</source>
          <target state="translated">ParseTime</target>
        </trans-unit>
        <trans-unit id="6b8eadf238999f4577c899508ccf16700302cf3d" translate="yes" xml:space="preserve">
          <source>Parsec</source>
          <target state="translated">Parsec</target>
        </trans-unit>
        <trans-unit id="93d479a55d45ca812192b9c77cc2d7af365791e8" translate="yes" xml:space="preserve">
          <source>Parsec compatibility module</source>
          <target state="translated">파섹 호환성 모듈</target>
        </trans-unit>
        <trans-unit id="0ebbdba417d24c756ec9c6928e541e59b0910456" translate="yes" xml:space="preserve">
          <source>ParsecT</source>
          <target state="translated">ParsecT</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="7a7dcdbfe4da553cb0bcd34e1518876f24101cf8" translate="yes" xml:space="preserve">
          <source>Parser from ParseLib with Hugs:</source>
          <target state="translated">포옹으로 ParseLib 파서 :</target>
        </trans-unit>
        <trans-unit id="e72f7d0405a8ed6b01d53d0eb6448cf48e5195fa" translate="yes" xml:space="preserve">
          <source>ParserT monad transformer and Parser type</source>
          <target state="translated">파서 T 모나드 변압기 및 파서 유형</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="028c9661ab1e61cb4cec3408691389cf51931b07" translate="yes" xml:space="preserve">
          <source>Parses a CRLF (see &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:crlf&quot;&gt;crlf&lt;/a&gt;&lt;/code&gt;) or LF (see &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:newline&quot;&gt;newline&lt;/a&gt;&lt;/code&gt;) end-of-line. Returns a newline character ('\n').</source>
          <target state="translated">CRLF ( &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:crlf&quot;&gt;crlf&lt;/a&gt;&lt;/code&gt; 참조 ) 또는 LF ( &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:newline&quot;&gt;newline&lt;/a&gt;&lt;/code&gt; 참조 ) 끝 행을 구문 분석합니다 . 줄 바꿈 문자 ( '\ n')를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d0fe9ef051a87bd91f7557d4ccd0b8aa18260b8" translate="yes" xml:space="preserve">
          <source>Parses a alphabetic or numeric Unicode characters according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt; 에 따라 알파벳 또는 숫자 유니 코드 문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9deeeeaf087ec53d20f87cb865f75c4b16fddfbf" translate="yes" xml:space="preserve">
          <source>Parses a alphabetic or numeric Unicode characters according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isAlphaNum&quot;&gt;isAlphaNum&lt;/a&gt;&lt;/code&gt; 에 따라 알파벳 또는 숫자 유니 코드 문자를 구문 분석합니다 . 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ec0ce986154232212bbae5b429b845073d2f256" translate="yes" xml:space="preserve">
          <source>Parses a carriage return character ('\r') followed by a newline character ('\n'). Returns a newline character.</source>
          <target state="translated">캐리지 리턴 문자 ( '\ r')와 개행 문자 ( '\ n')를 구문 분석합니다. 줄 바꿈 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fcd7bd8ab3c7f5c13d44837c892a5fb90c8df7f" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or 'A' and 'F'). Returns the parsed character.</source>
          <target state="translated">16 진 숫자 ( 'a'와 'f'또는 'A'와 'F'사이의 숫자 또는 문자)를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc1d6a166fc0a683ffa31ab7722f3e4d373d0800" translate="yes" xml:space="preserve">
          <source>Parses a lower case character (according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt; 에 따라 소문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb6d66af149d4f2597f57f132fa38ff395ba24cb" translate="yes" xml:space="preserve">
          <source>Parses a lower case character (according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">소문자를 구문 분석합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isLower&quot;&gt;isLower&lt;/a&gt;&lt;/code&gt; 에 따라 ). 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fea022f0b2ddc5b11db2fc69fd4e212597b724d" translate="yes" xml:space="preserve">
          <source>Parses a newline character ('\n'). Returns a newline character.</source>
          <target state="translated">개행 문자 ( '\ n')를 구문 분석합니다. 줄 바꿈 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb63a33324f0ad8223e6e2bee48f6654bd369140" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the decimal system. Returns the value of the number.</source>
          <target state="translated">10 진수 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5df553864aa00be005f0685bbc7543dc85668e7b" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the hexadecimal system. The number should be prefixed with &quot;x&quot; or &quot;X&quot;. Returns the value of the number.</source>
          <target state="translated">16 진수 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 앞에 &quot;x&quot;또는 &quot;X&quot;를 붙여야합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fdb8835ffaf98232d803de2c75c7f642b6b9764" translate="yes" xml:space="preserve">
          <source>Parses a non-negative whole number in the octal system. The number should be prefixed with &quot;o&quot; or &quot;O&quot;. Returns the value of the number.</source>
          <target state="translated">8 진법 시스템에서 음이 아닌 정수를 구문 분석합니다. 숫자 앞에 &quot;o&quot;또는 &quot;O&quot;를 붙여야합니다. 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="702ae31de69c688b66eaaac89301521608613ccc" translate="yes" xml:space="preserve">
          <source>Parses a tab character ('\t'). Returns a tab character.</source>
          <target state="translated">탭 문자 ( '\ t')를 구문 분석합니다. 탭 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9324545ed792c080b35aa8a66315fcacf5866ec" translate="yes" xml:space="preserve">
          <source>Parses a time value given a format string. Supports the same %-codes as &lt;code&gt;formatTime&lt;/code&gt;, including &lt;code&gt;%-&lt;/code&gt;, &lt;code&gt;%_&lt;/code&gt; and &lt;code&gt;%0&lt;/code&gt; modifiers, however padding widths are not supported. Case is not significant in the input string. Some variations in the input are accepted:</source>
          <target state="translated">지정된 형식 문자열로 시간 값을 구문 분석합니다. &lt;code&gt;%-&lt;/code&gt; , &lt;code&gt;%_&lt;/code&gt; 및 &lt;code&gt;%0&lt;/code&gt; 수정자를 포함하여 &lt;code&gt;formatTime&lt;/code&gt; 과 동일한 % 코드를 지원 하지만 패딩 너비는 지원되지 않습니다. 입력 문자열에서 대소 문자가 중요하지 않습니다. 입력의 일부 변형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="05a240ec2c4ee54b0aafba8944a0f8fd2d337fdb" translate="yes" xml:space="preserve">
          <source>Parses a white space character (any character which satisfies &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt;) Returns the parsed character.</source>
          <target state="translated">공백 문자를 구문 분석합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt; 를 충족시키는 모든 문자 ) 구문 분석 된 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d903820e65a3e9a2aa9445b7aba2e9d2375393f9" translate="yes" xml:space="preserve">
          <source>Parses a white space character (any character which satisfies &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt;) Returns the parsed character.</source>
          <target state="translated">공백 문자를 구문 분석합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isSpace&quot;&gt;isSpace&lt;/a&gt;&lt;/code&gt; 를 충족하는 모든 문자 ) 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2249741f599993c9ad36b1f2a0b1cf7813b2acd1" translate="yes" xml:space="preserve">
          <source>Parses an ASCII digit. Returns the parsed character.</source>
          <target state="translated">ASCII 숫자를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c370ae0764a200203299326c366ffab380d2d3ab" translate="yes" xml:space="preserve">
          <source>Parses an alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">알파벳순의 유니 코드 문자 (소문자, 대문자 및 제목 문자와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt; 에 따른 대소 문자가없는 스크립트 및 수정 자 문자 ) 를 구문 분석 합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d33286169144156c705451434bd3458f2c243164" translate="yes" xml:space="preserve">
          <source>Parses an alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">알파벳 유니 코드 문자 (소문자, 대문자 및 제목 대문자와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt; 에 따른 대소 문자가없는 스크립트 및 수정 자 문자 ) 를 구문 분석 합니다. 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b02856d3ea3b460a7fe547f16d9711dbfd09488" translate="yes" xml:space="preserve">
          <source>Parses an octal digit (a character between '0' and '7'). Returns the parsed character.</source>
          <target state="translated">8 진수 ( '0'과 '7'사이의 문자)를 구문 분석합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33366516b691b44fa5ef3fef5829a9e0268ab2e5" translate="yes" xml:space="preserve">
          <source>Parses an upper case letter (according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt; 에 따라 대문자를 구문 분석합니다 . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70ed6ac072bae182bcb0c4097a1ee90360d81c38" translate="yes" xml:space="preserve">
          <source>Parses an upper case letter (according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt;). Returns the parsed character.</source>
          <target state="translated">대문자를 구문 분석합니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#v:isUpper&quot;&gt;isUpper&lt;/a&gt;&lt;/code&gt; 에 따라 ). 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f20d25499201ff10834936ff90921a8f64cf44d5" translate="yes" xml:space="preserve">
          <source>Parses and returns the specified character.</source>
          <target state="translated">지정된 문자를 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10734aa6302a05d65e718e02f8812ae26f28348b" translate="yes" xml:space="preserve">
          <source>Parses and returns the specified string.</source>
          <target state="translated">지정된 문자열을 구문 분석하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6fafa4ab77dbc509075d8350b5ba85d1892f213" translate="yes" xml:space="preserve">
          <source>Parses any white space. White space consists of &lt;em&gt;zero&lt;/em&gt; or more occurrences of a &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt;, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공백을 구문 분석합니다. 공백은 &lt;em&gt;0&lt;/em&gt; 개 이상의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt; 발생 , 행 주석 또는 블록 (다중 행) 주석으로 구성됩니다. 블록 주석은 중첩 될 수 있습니다. 주석이 시작되고 종료되는 방법은 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7901356594fa3bfff82ffd8d1edc90fccbbbe877" translate="yes" xml:space="preserve">
          <source>Parses any white space. White space consists of &lt;em&gt;zero&lt;/em&gt; or more occurrences of a &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt;, a line comment or a block (multi line) comment. Block comments may be nested. How comments are started and ended is defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공백을 구문 분석합니다. 공백은 &lt;em&gt;0&lt;/em&gt; 개 이상의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:space&quot;&gt;space&lt;/a&gt;&lt;/code&gt; 발생 , 행 주석 또는 블록 (다중 행) 주석으로 구성됩니다. 블록 주석은 중첩 될 수 있습니다. 주석이 시작되고 종료되는 방법은 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e703e840a13f17d4e0aa6d6407f1c2c408c1f58" translate="yes" xml:space="preserve">
          <source>Parses one or more occurrences of the given parser.</source>
          <target state="translated">주어진 파서의 하나 이상의 발생을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9d53b4cf7f3be2a61b0e8567c529b4e5312e73c2" translate="yes" xml:space="preserve">
          <source>Parses the first one or more characters satisfying the predicate. Fails if none, else succeeds exactly once having consumed all the characters Hence NOT the same as (many1 (satisfy p))</source>
          <target state="translated">술어를 만족시키는 첫 번째 하나 이상의 문자를 구문 분석합니다. 하나도 없으면 모든 문자를 사용한 후 정확히 한 번 성공하므로 (many1 (satisfy p))와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ea87d4852d98a90a7eae890a816dda2be9b64c4" translate="yes" xml:space="preserve">
          <source>Parses the first zero or more characters satisfying the predicate. Always succeeds, exactly once having consumed all the characters Hence NOT the same as (many (satisfy p))</source>
          <target state="translated">술어를 만족시키는 처음 0 개 이상의 문자를 구문 분석합니다. 모든 캐릭터를 정확히 한 번 소비하면 항상 성공하므로 (많은 (만족스러운 p))</target>
        </trans-unit>
        <trans-unit id="572002c6d8895463e970cc35f3fcfe00a42feb77" translate="yes" xml:space="preserve">
          <source>Parses zero or more occurrences of the given parser.</source>
          <target state="translated">주어진 구문 분석기가 0 번 이상 발생하는 구문을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="22a3a9fff72c57faae1e1019e01bc253d1b1b0fd" translate="yes" xml:space="preserve">
          <source>Parsing and counting</source>
          <target state="translated">파싱과 카운팅</target>
        </trans-unit>
        <trans-unit id="ba8c1940ba355106d471b605df97a6aaed96283a" translate="yes" xml:space="preserve">
          <source>Parsing of &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, producing values.</source>
          <target state="translated">값을 생성하는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구문 분석 .</target>
        </trans-unit>
        <trans-unit id="d9978c1c7b4b043b4e8ba4d6fd699578663835c5" translate="yes" xml:space="preserve">
          <source>Parsing of &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, producing values.</source>
          <target state="translated">값을 생성하는 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 구문 분석 .</target>
        </trans-unit>
        <trans-unit id="146ac34ef08d750fbdfddd6a4da5cec9cef4309b" translate="yes" xml:space="preserve">
          <source>Partial type signatures (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;) work nicely with visible type application. If you want to specify only the second type argument to &lt;code&gt;wurble&lt;/code&gt;, then you can say &lt;code&gt;wurble @_ @Int&lt;/code&gt;. The first argument is a wildcard, just like in a partial type signature. However, if used in a visible type application/visible kind application, it is &lt;em&gt;not&lt;/em&gt; necessary to specify &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; and your code will not generate a warning informing you of the omitted type.</source>
          <target state="translated">부분 유형 서명 ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )은 보이는 유형 응용 프로그램과 잘 작동합니다. 당신 만 두 번째 유형 인수 지정하려면 &lt;code&gt;wurble&lt;/code&gt; 을 , 당신은 말할 수 &lt;code&gt;wurble @_ @Int&lt;/code&gt; . 첫 번째 인수는 부분 형식 서명과 마찬가지로 와일드 카드입니다. 그러나 표시 유형 응용 프로그램 / 표시 유형 응용 프로그램에서 사용되는 경우 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 를 지정할 필요 가 &lt;em&gt;없으며&lt;/em&gt; 코드에서 생략 된 유형을 알리는 경고가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fba127279063c3a22121b9b4cb6f20bc4417959" translate="yes" xml:space="preserve">
          <source>Partial type signatures are allowed for bindings, pattern and expression signatures, except that extra-constraints wildcards are not supported in pattern or expression signatures. In the following example a wildcard is used in each of the three possible contexts.</source>
          <target state="translated">패턴 또는 표현식 서명에서 추가 제약 조건 와일드 카드가 지원되지 않는 것을 제외하고 바인딩, 패턴 및 표현식 서명에 부분 유형 서명이 허용됩니다. 다음 예에서는 세 가지 가능한 컨텍스트 각각에 와일드 카드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99197905e62274bd86f62c48326e7d56161c0bff" translate="yes" xml:space="preserve">
          <source>Partial type signatures can also be used in &lt;a href=&quot;#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; splices.</source>
          <target state="translated">부분 유형 서명은 &lt;a href=&quot;#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; 스플 라이스 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd1d72bf2e9837a6f932897368ed11b7f1f0901d" translate="yes" xml:space="preserve">
          <source>PartialTypeSignatures</source>
          <target state="translated">PartialTypeSignatures</target>
        </trans-unit>
        <trans-unit id="edf72a43b1f566581c4c8c61fcedab5c2b680b1f" translate="yes" xml:space="preserve">
          <source>Partially-applied type synonym.</source>
          <target state="translated">부분적으로 적용되는 유형 동의어.</target>
        </trans-unit>
        <trans-unit id="cb737fe624c5231bedfcaa54cdb5adc3c111d709" translate="yes" xml:space="preserve">
          <source>Partitions a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; into two lists. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted, in order, to the first component of the output. Similarly the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted to the second component of the output.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 의 목록을 두 개의 목록으로 분할 합니다. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소는 순서대로 출력의 첫 번째 구성 요소로 추출됩니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소가 출력의 두 번째 구성 요소로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7cd56f2a2a3f47830760edfb89946eb7b9e2cd1" translate="yes" xml:space="preserve">
          <source>Pass</source>
          <target state="translated">Pass</target>
        </trans-unit>
        <trans-unit id="b656895c2b247f1e0e70e028d10540d37d0e6599" translate="yes" xml:space="preserve">
          <source>Pass vector value in vector registers for function calls</source>
          <target state="translated">함수 호출을 위해 벡터 레지스터에 벡터 값 전달</target>
        </trans-unit>
        <trans-unit id="c54625ea849b5bef109f8ba0d861127d6f59b6f9" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to &lt;code&gt;windres&lt;/code&gt; when embedding manifests on Windows. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windows에 매니페스트를 포함 할 때 ⟨option⟨을 &lt;code&gt;windres&lt;/code&gt; 에 전달하십시오. &lt;a href=&quot;#options-linker&quot;&gt;연결에 영향을주는 옵션의 &lt;/a&gt; &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8e81975f1a1782e659196379fb59c4474c28b85" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to CPP (makes sense only if &lt;code&gt;-cpp&lt;/code&gt; is also on).</source>
          <target state="translated">⟨option⟩을 CPP로 전달하십시오 ( &lt;code&gt;-cpp&lt;/code&gt; 도 켜져있는 경우에만 의미 가 있습니다).</target>
        </trans-unit>
        <trans-unit id="1ea097fe05a9a04a2624d60c283feabd36342c47" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the C compiler.</source>
          <target state="translated">compileroption⟩을 C 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="84280cb2173bd4a147ed2710a0aa106da9c6e256" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the C++ compiler.</source>
          <target state="translated">⟨option⟩을 C ++ 컴파일러에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5f2245e044e2ee9c7852e79e8e7a89e223c413d0" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the DLL generator.</source>
          <target state="translated">⟨option⟩을 DLL 생성기로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3e2650a6a6f4302b3800e44c6e47bf2e4cf0ce70" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the LLVM compiler.</source>
          <target state="translated">⟨option⟩을 LLVM 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b7042edda33fdbf17c12be5107e2f71d34b5db58" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the LLVM optimiser.</source>
          <target state="translated">⟨옵션⟩을 LLVM 최적화 프로그램에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87ef00b3846b0862a7242d922be5b1f78c247481" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the assembler.</source>
          <target state="translated">⟨option⟩을 어셈블러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c14b71df065b66ba63fa6a047ddbfc4df7c5f0" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the custom pre-processor (see &lt;a href=&quot;#pre-processor&quot;&gt;Options affecting a Haskell pre-processor&lt;/a&gt;).</source>
          <target state="translated">⟨option⟩을 사용자 정의 전처리기에 전달하십시오 ( &lt;a href=&quot;#pre-processor&quot;&gt;Haskell 전처리&lt;/a&gt; 기에 영향을주는 옵션 참조 ).</target>
        </trans-unit>
        <trans-unit id="d4e91bac9331b7ddc74206f5303bffcecba44d00" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the interpreter sub-process (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). A common use for this is to pass RTS options e.g., &lt;code&gt;-opti+RTS -opti-A64m&lt;/code&gt;, or to enable verbosity with &lt;code&gt;-opti-v&lt;/code&gt; to see what messages are being exchanged by GHC and the interpreter.</source>
          <target state="translated">⟨option⟩을 인터프리터 서브 프로세스에 전달하십시오 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 이를위한 일반적인 용도는 RTS 옵션 (예 : &lt;code&gt;-opti+RTS -opti-A64m&lt;/code&gt; )을 전달하거나 &lt;code&gt;-opti-v&lt;/code&gt; 를 통해 자세한 정보 를 표시하여 GHC와 인터프리터가 어떤 메시지를 교환하고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="123e7106bfca8a16ebd4af1ce4024a5589cb8353" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the linker when merging object files. In the case of a standard &lt;code&gt;ld&lt;/code&gt;-style linker this should generally include the &lt;code&gt;-r&lt;/code&gt; flag.</source>
          <target state="translated">개체 파일을 병합 할 때 ⟨option⟩을 링커에 전달합니다. 표준 &lt;code&gt;ld&lt;/code&gt; 스타일 링커 의 경우 일반적으로 &lt;code&gt;-r&lt;/code&gt; 플래그를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7477215f28d252ddc7702887bc7fd7f09e390008" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the linker.</source>
          <target state="translated">⟨option⟩을 링커에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="ad6fb68d25dbefa94a70ca45187327b9fda1d37c" translate="yes" xml:space="preserve">
          <source>Pass ⟨option⟩ to the literate pre-processor</source>
          <target state="translated">preoption⟩을 문맹 퇴치 전처리기에 전달</target>
        </trans-unit>
        <trans-unit id="b3edfb19da259e0de688de612c935956f2c99d75" translate="yes" xml:space="preserve">
          <source>Passed to the C compiler.</source>
          <target state="translated">C 컴파일러에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="8be3c943b1609fffbfc51aad666d0a04adf83c9d" translate="yes" xml:space="preserve">
          <source>Password</source>
          <target state="translated">Password</target>
        </trans-unit>
        <trans-unit id="702f90f9120506c7fbea366d22307493c04740b3" translate="yes" xml:space="preserve">
          <source>Password -- may be empty or fake if shadow is in use (pw_passwd)</source>
          <target state="translated">비밀번호-섀도우를 사용중인 경우 비어 있거나 가짜 일 수 있습니다 (pw_passwd)</target>
        </trans-unit>
        <trans-unit id="22002d5b59087455e3e7a19bdb64f504fafce246" translate="yes" xml:space="preserve">
          <source>Pat</source>
          <target state="translated">Pat</target>
        </trans-unit>
        <trans-unit id="eb730bfcc87dd3826515b26e8682ec5987a8eee0" translate="yes" xml:space="preserve">
          <source>PatQ</source>
          <target state="translated">PatQ</target>
        </trans-unit>
        <trans-unit id="9b6958725be0676bc2831daffab79014db1e02d1" translate="yes" xml:space="preserve">
          <source>PatSynArgs</source>
          <target state="translated">PatSynArgs</target>
        </trans-unit>
        <trans-unit id="e528cddb6d761afbae92bc5520282c106e797b9b" translate="yes" xml:space="preserve">
          <source>PatSynArgsQ</source>
          <target state="translated">PatSynArgsQ</target>
        </trans-unit>
        <trans-unit id="fe6ca4a2046e9092fc8b91acbe65f2196eafaf25" translate="yes" xml:space="preserve">
          <source>PatSynDir</source>
          <target state="translated">PatSynDir</target>
        </trans-unit>
        <trans-unit id="a00df6fba9cdb213b7e8fda3d468202a26221183" translate="yes" xml:space="preserve">
          <source>PatSynDirQ</source>
          <target state="translated">PatSynDirQ</target>
        </trans-unit>
        <trans-unit id="f84514555442628f00d3e5269a9f8b67460106af" translate="yes" xml:space="preserve">
          <source>PatSynType</source>
          <target state="translated">PatSynType</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="de556ff45621853b72f3cba9bbc16ba72c53c17f" translate="yes" xml:space="preserve">
          <source>PathNameLimit</source>
          <target state="translated">PathNameLimit</target>
        </trans-unit>
        <trans-unit id="74b7902cc01d30f193138477b0b3be38408b6f9e" translate="yes" xml:space="preserve">
          <source>PathVar</source>
          <target state="translated">PathVar</target>
        </trans-unit>
        <trans-unit id="c605d6954cb5f7d896d41bcc8529b02fa99e63c3" translate="yes" xml:space="preserve">
          <source>Pathname conventions vary from system to system. In particular, the directory separator is &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; on Unix systems and &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo; on Windows systems. In the sections that follow, we shall consistently use &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; as the directory separator; substitute this for the appropriate character for your system.</source>
          <target state="translated">경로 이름 규칙은 시스템마다 다릅니다. 특히 디렉토리 구분 기호는 Unix 시스템에서 &amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;이고 Windows 시스템에서 &amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;입니다. 다음 섹션에서는 디렉토리 구분자로 &quot; &lt;code&gt;/&lt;/code&gt; &quot;를 일관되게 사용합니다 . 시스템에 적합한 문자로 이것을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="011311874049b892a9a1e123a9582477aceacecd" translate="yes" xml:space="preserve">
          <source>Paths specified using the &lt;code&gt;-L ⟨dir⟩&lt;/code&gt; command-line option,</source>
          <target state="translated">&lt;code&gt;-L ⟨dir⟩&lt;/code&gt; 명령 행 옵션을 사용하여 지정된 경로</target>
        </trans-unit>
        <trans-unit id="32c2dd7f8e76f04657fd849dcf202fe7562da7ba" translate="yes" xml:space="preserve">
          <source>Paths with a drive letter are &lt;em&gt;legacy&lt;/em&gt; paths. The drive letters are actually meaningless to the kernel. Just like Unix operating systems, drive letters are just a mount point. You can view your mount points by using the &lt;strong&gt;mountvol&lt;/strong&gt; command.</source>
          <target state="translated">드라이브 문자가있는 경로 는 &lt;em&gt;레거시&lt;/em&gt; 경로입니다. 드라이브 문자는 실제로 커널에게는 의미가 없습니다. Unix 운영 체제와 마찬가지로 드라이브 문자는 마운트 지점 일뿐입니다. &lt;strong&gt;mountvol&lt;/strong&gt; 명령 을 사용하여 마운트 지점을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="c986f82232ab7547ffc16ab2d32c4eed2d129027" translate="yes" xml:space="preserve">
          <source>Pattern &lt;code&gt;P1&lt;/code&gt; can only match against a value of type &lt;code&gt;Maybe Bool&lt;/code&gt;, so function &lt;code&gt;f&lt;/code&gt; is rejected because the type signature is &lt;code&gt;Maybe a&lt;/code&gt;. (To see this, imagine expanding the pattern synonym.)</source>
          <target state="translated">패턴 &lt;code&gt;P1&lt;/code&gt; 은 &lt;code&gt;Maybe Bool&lt;/code&gt; 유형의 값과 만 일치 할 수 있으므로 유형 서명이 &lt;code&gt;Maybe a&lt;/code&gt; 이므로 함수 &lt;code&gt;f&lt;/code&gt; 가 거부 됩니다. (이를 보려면 패턴 동의어를 확장한다고 가정하십시오.)</target>
        </trans-unit>
        <trans-unit id="02736a97b0f28b320047652ff9db6e4230fbb7da" translate="yes" xml:space="preserve">
          <source>Pattern Synonyms (sub constructs)</source>
          <target state="translated">패턴 동의어 (하위 구성)</target>
        </trans-unit>
        <trans-unit id="cc7430cf470514ab4cb77ac5dbdcb450d6be72dc" translate="yes" xml:space="preserve">
          <source>Pattern in Haskell given in &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 에 주어진 Haskell의 패턴</target>
        </trans-unit>
        <trans-unit id="006f91db2b8fd81b325a7a341c644b6d5a498639" translate="yes" xml:space="preserve">
          <source>Pattern match on a type constructor</source>
          <target state="translated">형식 생성자에서의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="429f1b07411fa0d99aa1398b100abdf4c33d79a4" translate="yes" xml:space="preserve">
          <source>Pattern match on a type constructor including its instantiated kind variables.</source>
          <target state="translated">인스턴스화 된 종류 변수를 포함하여 형식 생성자의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="6bca3430dd62bc5373edba36f1b7fdbacb161c1c" translate="yes" xml:space="preserve">
          <source>Pattern splices introduce variable binders but scoping of variables in expressions inside the pattern&amp;rsquo;s scope is only checked when a splice is run. Note that pattern splices that occur outside of any quotation brackets are run at compile time. Pattern splices occurring inside a quotation bracket are &lt;em&gt;not&lt;/em&gt; run at compile time; they are run when the bracket is spliced in, sometime later. For example,</source>
          <target state="translated">패턴 스플 라이스에는 가변 바인더가 도입되지만 패턴 범위 내 표현식의 변수 범위는 스플 라이스가 실행될 때만 확인됩니다. 따옴표 괄호 밖에서 발생하는 패턴 스플 라이스는 컴파일 타임에 실행됩니다. 따옴표로 묶는 패턴 스플 라이스 는 컴파일 타임에 실행 &lt;em&gt;되지 않습니다&lt;/em&gt; . 브라켓이 연결될 때, 나중에 언젠가 실행됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a6afa01cf2dd70cd7e0003f6ed14c46fc954840d" translate="yes" xml:space="preserve">
          <source>Pattern splices: anonymous and named wildcards can be used in pattern signatures. Note that &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; has to be enabled to allow pattern signatures. Extra-constraints wildcards are not supported, just like in regular pattern signatures.</source>
          <target state="translated">패턴 스플 라이스 : 익명 및 명명 된 와일드 카드를 패턴 서명에 사용할 수 있습니다. 참고 것을 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 패턴 서명을 할 수 있도록 활성화해야합니다. 일반 패턴 서명에서와 같이 추가 제약 조건 와일드 카드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f77741e8cc6b9f0b1d51a80487612daf3480f01" translate="yes" xml:space="preserve">
          <source>Pattern synonym declaration</source>
          <target state="translated">패턴 동의어 선언</target>
        </trans-unit>
        <trans-unit id="87f1062186506aaa4f45d8a2e88afacdc300284d" translate="yes" xml:space="preserve">
          <source>Pattern synonym declarations can only occur in the top level of a module. In particular, they are not allowed as local definitions.</source>
          <target state="translated">패턴 동의어 선언은 모듈의 최상위 레벨에서만 발생할 수 있습니다. 특히, 로컬 정의로 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2c3bb10828440ff7c7e123c5c710d07e5748ac9" translate="yes" xml:space="preserve">
          <source>Pattern synonym examples</source>
          <target state="translated">패턴 동의어 예</target>
        </trans-unit>
        <trans-unit id="c5e40750951e5693f88641df15605c5bd88c4b78" translate="yes" xml:space="preserve">
          <source>Pattern synonym type signature</source>
          <target state="translated">패턴 동의어 유형 서명</target>
        </trans-unit>
        <trans-unit id="51c5410ff060e342b214a06f194717b99df3b318" translate="yes" xml:space="preserve">
          <source>Pattern synonym types interact with TH when (a) reifying a pattern synonym, (b) pretty printing, or (c) specifying a pattern synonym's type signature explicitly:</source>
          <target state="translated">패턴 동의어 유형은 (a) 패턴 동의어 수정, (b) 예쁜 인쇄 또는 (c) 패턴 동의어의 유형 서명을 명시 적으로 지정할 때 TH와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="f1ad9c9cdb2599bd5e1fe2e83cbb8368c9be95f6" translate="yes" xml:space="preserve">
          <source>Pattern synonyms</source>
          <target state="translated">패턴 동의어</target>
        </trans-unit>
        <trans-unit id="f284b9c8384401a92e74a36de73bee9bba48c472" translate="yes" xml:space="preserve">
          <source>Pattern synonyms are enabled by the language extension &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt;, which is required for defining them, but &lt;em&gt;not&lt;/em&gt; for using them. More information and examples of pattern synonyms can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">패턴 동의어는 언어 확장 인 &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; 에&lt;/a&gt; 의해 사용 가능하며 이를 정의하는 데 필요하지만 사용 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 패턴 동의어에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3892448115b360ea1d603f7a781a0d734d72148a" translate="yes" xml:space="preserve">
          <source>Pattern synonyms are enabled by the language extension &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt;, which is required for defining them, but &lt;em&gt;not&lt;/em&gt; for using them. More information and examples of pattern synonyms can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">패턴 동의어는 언어 확장 &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt; 에서 사용 가능합니다. 이는이를 정의하는 데 필요하지만 사용 &lt;em&gt;에는&lt;/em&gt; 필요 &lt;em&gt;하지 않습니다&lt;/em&gt; . 패턴 동의어에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0924abc7007f369091850e500801334d4015307f" translate="yes" xml:space="preserve">
          <source>Pattern synonyms are not supported.</source>
          <target state="translated">패턴 동의어는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34d581f8945b7df9b46a71872a91832ad9199e66" translate="yes" xml:space="preserve">
          <source>Pattern synonyms cannot be defined recursively.</source>
          <target state="translated">패턴 동의어는 재귀 적으로 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dc90cc727d872f8ad295d8c8e70891697a625b4" translate="yes" xml:space="preserve">
          <source>Pattern synonyms enable giving names to parametrized pattern schemes. They can also be thought of as abstract constructors that don&amp;rsquo;t have a bearing on data representation. For example, in a programming language implementation, we might represent types of the language as follows:</source>
          <target state="translated">패턴 동의어를 사용하면 매개 변수화 된 패턴 체계에 이름을 지정할 수 있습니다. 또한 데이터 표현과 관련이없는 추상 생성자로 생각할 수 있습니다. 예를 들어, 프로그래밍 언어 구현에서 다음과 같이 언어 유형을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21344d9f424a665540813e111458633c97a5bdc" translate="yes" xml:space="preserve">
          <source>Pattern synonyms permit abstracting from the representation to expose matchers that behave in a constructor-like manner with respect to pattern matching. We can create pattern synonyms for the known types we care about, without committing the representation to them (note that these don&amp;rsquo;t have to be defined in the same module as the &lt;code&gt;Type&lt;/code&gt; type):</source>
          <target state="translated">패턴 동의어는 표현에서 추상화하여 패턴 일치와 관련하여 생성자와 유사한 방식으로 동작하는 매처를 노출시킵니다. 우리는 관심있는 알려진 유형에 대한 표현 동의를 만들 수 있습니다 (표현을 커밋하지 않음 ). 이러한 &lt;code&gt;Type&lt;/code&gt; 은 유형 유형 과 동일한 모듈에서 정의 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b5e68af793661029a634f35b2a59b11f9b9320" translate="yes" xml:space="preserve">
          <source>PatternGuards</source>
          <target state="translated">PatternGuards</target>
        </trans-unit>
        <trans-unit id="b082623c56fa21b4be183e2556bcea6fc12a68f9" translate="yes" xml:space="preserve">
          <source>PatternMatchFail</source>
          <target state="translated">PatternMatchFail</target>
        </trans-unit>
        <trans-unit id="8b4c340e8567284d5ccd5a9a1b9deca1c715a890" translate="yes" xml:space="preserve">
          <source>PatternSynonyms</source>
          <target state="translated">PatternSynonyms</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="5aa426e2424e04e94a5a3e7b592a1b40bfa6724a" translate="yes" xml:space="preserve">
          <source>Pc: Punctuation, Connector</source>
          <target state="translated">PC : 문장 부호, 커넥터</target>
        </trans-unit>
        <trans-unit id="30297337298c9a17c0e9ce8ff4fbffe4052874dd" translate="yes" xml:space="preserve">
          <source>Pd: Punctuation, Dash</source>
          <target state="translated">Pd : 문장 부호, 대시</target>
        </trans-unit>
        <trans-unit id="a80098f29b2d23293bbe78beff8b9cdca1b4c011" translate="yes" xml:space="preserve">
          <source>Pe: Punctuation, Close</source>
          <target state="translated">Pe : 구두점, 닫기</target>
        </trans-unit>
        <trans-unit id="d2ade9ac589ddabb36b03a6f5440ab0dd29693cc" translate="yes" xml:space="preserve">
          <source>Per default the events are written to &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; though the mechanism for writing event log data can be overridden with a custom &lt;code&gt;EventLogWriter&lt;/code&gt;.</source>
          <target state="translated">기본적으로 이벤트는 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; 에 기록되지만 이벤트 로그 데이터를 쓰는 메커니즘은 사용자 정의 &lt;code&gt;EventLogWriter&lt;/code&gt; 로 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31566e3d063dad33b6e08c2f7f3e776d7e1473fd" translate="yes" xml:space="preserve">
          <source>Per default the events are written to &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; though the mechanism for writing event log data can be overriden with a custom &lt;code&gt;EventLogWriter&lt;/code&gt;.</source>
          <target state="translated">이벤트 로그 데이터 작성 메커니즘을 사용자 정의 &lt;code&gt;EventLogWriter&lt;/code&gt; 로 대체 할 수 있지만 기본적으로 이벤트는 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7ef19e5bbcb51e651936b58513fef51416adde3" translate="yes" xml:space="preserve">
          <source>Perform a series of STM actions atomically.</source>
          <target state="translated">일련의 STM 작업을 원자 적으로 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2c9ff4fe99f8968fc212ca25889a616ce793a23b" translate="yes" xml:space="preserve">
          <source>Perform compilation in parallel when possible. GHC will use up to ⟨N⟩ threads during compilation. If N is omitted, then it defaults to the number of processors. Note that compilation of a module may not begin until its dependencies have been built.</source>
          <target state="translated">가능하면 컴파일을 병렬로 수행하십시오. GHC는 컴파일하는 동안 최대 ⟨N⟩ 스레드를 사용합니다. N을 생략하면 기본값은 프로세서 수입니다. 종속 모듈이 빌드 될 때까지 모듈 컴파일이 시작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f08a49b25677e2e61a727558011649fabe0e79a8" translate="yes" xml:space="preserve">
          <source>Perform other memory allocation, including in the GC, from node-local memory.</source>
          <target state="translated">노드 로컬 메모리에서 GC를 포함하여 다른 메모리 할당을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c8aeaee99f19647da8cbc145bb54bbe2aea3ac7" translate="yes" xml:space="preserve">
          <source>Perform some computation without adding new entries to the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 새 항목을 추가하지 않고 계산을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc6f40aca7e3932befef5ea8a6cf34162fbd455b" translate="yes" xml:space="preserve">
          <source>Perform some simplification of a built up &lt;code&gt;GDoc&lt;/code&gt;.</source>
          <target state="translated">빌드 된 &lt;code&gt;GDoc&lt;/code&gt; 의 단순화를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="a40043065024f7a1212f7fbbfa9112c036c35b22" translate="yes" xml:space="preserve">
          <source>Performance information</source>
          <target state="translated">성능 정보</target>
        </trans-unit>
        <trans-unit id="2195bce8153488b859e69e630a7482f89cfcc5de" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;fdatasync(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;fdatasync(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="b7a0417e81aba8bc8d001bca03740cbc7548d90f" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;fsync(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;fsync(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="b29525a36bb807819b75d77b028444eec3dd3744" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;posix_fadvise(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 조작을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="abc537c00b7a43d3addf179337e100cbe868862f" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;posix_fallocate(2)&lt;/code&gt; operation on file-descriptor.</source>
          <target state="translated">파일 디스크립터에서 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="979b1f14628086440e0d691aadba7221f17405ab" translate="yes" xml:space="preserve">
          <source>Performs completions from the given line state.</source>
          <target state="translated">주어진 회선 상태에서 완료를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d6f5806ebaf90276049ece561409944ce93d2f6e" translate="yes" xml:space="preserve">
          <source>PermParser</source>
          <target state="translated">PermParser</target>
        </trans-unit>
        <trans-unit id="4636c20125232583a78fcf9bd2b7beb3e0ee79a6" translate="yes" xml:space="preserve">
          <source>PermissionDenied</source>
          <target state="translated">PermissionDenied</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="d8940d325390445ba152697d12492c72d0b04785" translate="yes" xml:space="preserve">
          <source>Permit definition of instances which may lead to type-checker non-termination.</source>
          <target state="translated">유형 검사기가 종료되지 않을 수있는 인스턴스 정의를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="393bb39440da7f4d26358355203d3146a3259f99" translate="yes" xml:space="preserve">
          <source>Permute</source>
          <target state="translated">Permute</target>
        </trans-unit>
        <trans-unit id="bf005fa540ff716e77993a2f382021660a60dc6a" translate="yes" xml:space="preserve">
          <source>Pf: Punctuation, Final quote</source>
          <target state="translated">Pf : 문장 부호, 최종 견적</target>
        </trans-unit>
        <trans-unit id="130c4886394ecb032566d46f2ceb00d5633b56b7" translate="yes" xml:space="preserve">
          <source>PhantomR</source>
          <target state="translated">PhantomR</target>
        </trans-unit>
        <trans-unit id="5c5efd35d4de06a56cd9d8bce7ff35054fbfb6e4" translate="yes" xml:space="preserve">
          <source>Phase of the compilation system</source>
          <target state="translated">컴파일 시스템의 단계</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="9e4383ed7770bf7128e27cfd3770dcc6a2f9ac77" translate="yes" xml:space="preserve">
          <source>Pi: Punctuation, Initial quote</source>
          <target state="translated">Pi : 문장 부호, 초기 견적</target>
        </trans-unit>
        <trans-unit id="6dc7779c6f76a5529f40811ad41c4010cc153569" translate="yes" xml:space="preserve">
          <source>Picking the right capability will help avoid unnecessary context switches. Ideally you should pass the capability that the thread that will be woken up last ran on, which you can find by calling &lt;code&gt;threadCapability&lt;/code&gt; in Haskell.</source>
          <target state="translated">올바른 기능을 선택하면 불필요한 컨텍스트 전환을 피할 수 있습니다. 이상적으로 마지막으로 깨어 난 스레드가 Haskell에서 &lt;code&gt;threadCapability&lt;/code&gt; 를 호출하여 찾을 수있는 기능을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b18587952820d0dbe6bad15e1dae415748031e5" translate="yes" xml:space="preserve">
          <source>Pico</source>
          <target state="translated">Pico</target>
        </trans-unit>
        <trans-unit id="f298de9cea75ea5230dda5d9d28b4989aaf746f4" translate="yes" xml:space="preserve">
          <source>Pid</source>
          <target state="translated">Pid</target>
        </trans-unit>
        <trans-unit id="00dae071c082bb73eaed17b4bb3429280e110e8c" translate="yes" xml:space="preserve">
          <source>Pipe</source>
          <target state="translated">Pipe</target>
        </trans-unit>
        <trans-unit id="24a740d84ffcf739518c3074866ef1329aa79368" translate="yes" xml:space="preserve">
          <source>PipeBufferLimit</source>
          <target state="translated">PipeBufferLimit</target>
        </trans-unit>
        <trans-unit id="785af2a4ad3c4ee912623c6e0b6d4299ea305bf6" translate="yes" xml:space="preserve">
          <source>Pipes</source>
          <target state="translated">Pipes</target>
        </trans-unit>
        <trans-unit id="9e0a7d72506eac8eb62beb562cc0a99b2b58da61" translate="yes" xml:space="preserve">
          <source>PkgName</source>
          <target state="translated">PkgName</target>
        </trans-unit>
        <trans-unit id="323e26c5cebb97e7dbf03cace1de3f19bb3506f8" translate="yes" xml:space="preserve">
          <source>Place each generated function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section&amp;rsquo;s name in the output file.</source>
          <target state="translated">대상이 임의의 섹션을 지원하는 경우 생성 된 각 함수 또는 데이터 항목을 출력 파일의 자체 섹션에 배치하십시오. 함수 이름 또는 데이터 항목 이름에 따라 출력 파일의 섹션 이름이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7dccde26d3e873a5cc6c187e13a2e64082046864" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;INLINE&lt;/code&gt; pragmas on certain functions that are used a lot can have a dramatic effect. See &lt;a href=&quot;glasgow_exts#inline-pragma&quot;&gt;INLINE pragma&lt;/a&gt;.</source>
          <target state="translated">많이 사용되는 특정 기능 에 &lt;code&gt;INLINE&lt;/code&gt; pragma를 배치 하면 극적인 효과를 낼 수 있습니다. &lt;a href=&quot;glasgow_exts#inline-pragma&quot;&gt;인라인 pragma를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5104db6573a7bcd152469e6c86edf365a7ccbe8" translate="yes" xml:space="preserve">
          <source>Placing a &lt;code&gt;.ghci&lt;/code&gt; file in a directory with a Haskell project is a useful way to set certain project-wide options so you don&amp;rsquo;t have to type them every time you start GHCi: eg. if your project uses multi-parameter type classes, scoped type variables, and CPP, and has source files in three subdirectories A, B and C, you might put the following lines in &lt;code&gt;.ghci&lt;/code&gt;:</source>
          <target state="translated">Haskell 프로젝트가있는 디렉토리에 &lt;code&gt;.ghci&lt;/code&gt; 파일을 배치하는 것은 GHCi 를 시작할 때마다 입력하지 않아도되는 특정 프로젝트 전체 옵션을 설정하는 유용한 방법입니다. 프로젝트가 다중 매개 변수 유형 클래스, 범위 유형 변수 및 CPP를 사용하고 세 개의 서브 디렉토리 A, B 및 C에 소스 파일이있는 경우 다음 행을 &lt;code&gt;.ghci&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c995f73efb3edc21d7f6d4456e31809091cc4f7" translate="yes" xml:space="preserve">
          <source>Platform differences</source>
          <target state="translated">플랫폼 차이</target>
        </trans-unit>
        <trans-unit id="f47156297a84abbf7baa9ecfe8129e469a19a3f7" translate="yes" xml:space="preserve">
          <source>Please advise us of other &amp;ldquo;helpful hints&amp;rdquo; that should go here!</source>
          <target state="translated">여기에 가야 할 다른&amp;ldquo;유용한 힌트&amp;rdquo;를 알려주십시오!</target>
        </trans-unit>
        <trans-unit id="7eaa184d05b12ec4d0c22d4d64c1a97838a9baab" translate="yes" xml:space="preserve">
          <source>Please also note that when doing incremental compilation (by &lt;code&gt;ghc --make&lt;/code&gt; or &lt;code&gt;ghc -c&lt;/code&gt;), this directory is where GHC looks into to find extended interface files.</source>
          <target state="translated">또한 증분 컴파일 ( &lt;code&gt;ghc --make&lt;/code&gt; 또는 &lt;code&gt;ghc -c&lt;/code&gt; )을 수행 할 때이 디렉토리는 GHC가 확장 인터페이스 파일을 찾기 위해 찾는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="35f5a17562e092a639487a7dbd4558ee40520423" translate="yes" xml:space="preserve">
          <source>Please also note that when doing incremental compilation (by &lt;code&gt;ghc --make&lt;/code&gt; or &lt;code&gt;ghc -c&lt;/code&gt;), this directory is where GHC looks into to find interface files.</source>
          <target state="translated">또한 증분 컴파일 ( &lt;code&gt;ghc --make&lt;/code&gt; 또는 &lt;code&gt;ghc -c&lt;/code&gt; )을 수행 할 때이 디렉토리는 GHC가 인터페이스 파일을 찾기 위해 찾는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="fc75381c4117eac8071f7754c526f344d1d5cfd7" translate="yes" xml:space="preserve">
          <source>Please also note that when doing incremental compilation, this directory is where GHC looks into to find object files from previous builds.</source>
          <target state="translated">또한 증분 컴파일을 수행 할 때이 디렉토리는 GHC가 이전 빌드에서 오브젝트 파일을 찾기 위해 조사하는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="506c81a0d84a987facc6b6cad61df64acf77c49e" translate="yes" xml:space="preserve">
          <source>Please do not confuse &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, respectively. The latter are for exceptions built into GHC, by default, and are mostly used from within the IO monad. They do not interact with the &quot;exceptions&quot; in this package at all. This package allows you to define a new kind of exception control mechanism which does not necessarily need your code to be placed in the IO monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 를 각각 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 와 혼동하지 마십시오 . 후자는 기본적으로 GHC에 내장 된 예외에 대한 것이며 IO 모나드 내에서 주로 사용됩니다. 그들은이 패키지의 &quot;예외&quot;와 전혀 상호 작용하지 않습니다. 이 패키지를 사용하면 IO 모나드에 코드를 배치 할 필요가없는 새로운 종류의 예외 제어 메커니즘을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c692e6e78b4a6c4d677fe5be7d6b2a1582726f5d" translate="yes" xml:space="preserve">
          <source>Please do not confuse &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, respectively. The latter are for exceptions built into GHC, by default, and are mostly used from within the IO monad. They do not interact with the &quot;exceptions&quot; in this package at all. This package allows you to define a new kind of exception control mechanism which does not necessarily need your code to be placed in the IO monad.</source>
          <target state="translated">혼동하지 마십시오 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 와. 후자는 기본적으로 GHC에 내장 된 예외를위한 것이며 대부분 IO 모나드 내에서 사용됩니다. 이들은이 패키지의 &quot;예외&quot;와 전혀 상호 작용하지 않습니다. 이 패키지를 사용하면 IO 모나드에 코드를 배치 할 필요가없는 새로운 종류의 예외 제어 메커니즘을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c73afae87542d6e8cd63fcf7f4fddd71f7004f" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5600a929920bed98ead548566e18fe4443f663d1" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e69690c3be83e6b82a76a0137695bb5c56adc7bc" translate="yes" xml:space="preserve">
          <source>Please make sure you know what is going on when using &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt;, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용할 때 무슨 일이 일어나고 있는지 알고 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="11da447f43cf46de988876b5572b594db0d725d8" translate="yes" xml:space="preserve">
          <source>Please report any overly-slow GHC-compiled programs. Since GHC doesn&amp;rsquo;t have any credible competition in the performance department these days it&amp;rsquo;s hard to say what overly-slow means, so just use your judgement! Of course, if a GHC compiled program runs slower than the same program compiled with NHC or Hugs, then it&amp;rsquo;s definitely a bug.</source>
          <target state="translated">지나치게 느린 GHC 컴파일 프로그램을보고하십시오. GHC는 요즘 퍼포먼스 부서에서 경쟁이 치열하지 않기 때문에 너무 느리게 무엇을 의미하는지 말하기는 어렵 기 때문에 판단을 사용하십시오! 물론, GHC 컴파일 프로그램이 NHC 또는 Hugs로 컴파일 된 동일한 프로그램보다 느리게 실행된다면, 이는 분명히 버그입니다.</target>
        </trans-unit>
        <trans-unit id="fe030bc44cd445dd18c598d2cb1edf112abb8e3c" translate="yes" xml:space="preserve">
          <source>Please report line-number errors that you find particularly unhelpful.</source>
          <target state="translated">특히 도움이되지 않는 줄 번호 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="4bd277cac9b50a94c530d065fbd95d2bb254e2e7" translate="yes" xml:space="preserve">
          <source>Please see the GHC API documentation for more about how to use internal APIs, etc.</source>
          <target state="translated">내부 API 사용 방법 등에 대한 자세한 내용은 GHC API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cda26be1b0861c9ec0b102448fed676a99b6b48e" translate="yes" xml:space="preserve">
          <source>Please, oh please, use the &lt;code&gt;-v&lt;/code&gt; option when reporting bugs! Knowing that you ran the right bits in the right order is always the first thing we want to verify.</source>
          <target state="translated">버그를보고 할 때는 &lt;code&gt;-v&lt;/code&gt; 옵션을 사용하십시오 . 올바른 순서대로 올바른 비트를 실행했음을 아는 것이 항상 가장 먼저 확인하려는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f4d3ab5a5554b6ec4bae40adfb407a50ae52738" translate="yes" xml:space="preserve">
          <source>Plugin code runs in the &lt;code&gt;TcPluginM&lt;/code&gt; monad, which provides a restricted interface to GHC API functionality that is relevant for typechecker plugins, including &lt;code&gt;IO&lt;/code&gt; and reading the environment. If you need functionality that is not exposed in the &lt;code&gt;TcPluginM&lt;/code&gt; module, you can use &lt;code&gt;unsafeTcPluginTcM :: TcM a -&amp;gt; TcPluginM a&lt;/code&gt;, but are encouraged to contact the GHC team to suggest additions to the interface. Note that &lt;code&gt;TcPluginM&lt;/code&gt; can perform arbitrary IO via &lt;code&gt;tcPluginIO :: IO a -&amp;gt; TcPluginM a&lt;/code&gt;, although some care must be taken with side effects (particularly in &lt;code&gt;tcPluginSolve&lt;/code&gt;). In general, it is up to the plugin author to make sure that any IO they do is safe.</source>
          <target state="translated">플러그인 코드는 &lt;code&gt;TcPluginM&lt;/code&gt; 모나드 에서 실행되며 &lt;code&gt;IO&lt;/code&gt; 및 환경 읽기를 포함하여 유형 검사기 플러그인과 관련된 GHC API 기능에 대한 제한된 인터페이스를 제공 합니다. &lt;code&gt;TcPluginM&lt;/code&gt; 모듈에 노출되지 않은 기능이 필요한 경우 &lt;code&gt;unsafeTcPluginTcM :: TcM a -&amp;gt; TcPluginM a&lt;/code&gt; 를 사용할 수 있지만 GHC 팀에 연락하여 인터페이스 추가를 제안하는 것이 좋습니다. 참고 &lt;code&gt;TcPluginM&lt;/code&gt; 를 통해 임의의 IO 수행 &lt;code&gt;tcPluginIO :: IO a -&amp;gt; TcPluginM a&lt;/code&gt; 일부주의 (특히에 부작용주의해야하지만 &lt;code&gt;tcPluginSolve&lt;/code&gt; ). 일반적으로 플러그인 작성자는 IO가 안전한지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a02b13ee0dd37a4f7f44345efb7f4d0b31df1b9" translate="yes" xml:space="preserve">
          <source>Plugin modules live in a separate namespace from the user import namespace. By default, these two namespaces are the same; however, there are a few command line options which control specifically plugin packages:</source>
          <target state="translated">플러그인 모듈은 사용자 가져 오기 네임 스페이스와 별도의 네임 스페이스에 있습니다. 기본적으로이 두 네임 스페이스는 동일합니다. 그러나 특별히 플러그인 패키지를 제어하는 ​​몇 가지 명령 줄 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76e0a28ea1fdb9e9e6ad3248cf9ef3d98836e8e" translate="yes" xml:space="preserve">
          <source>Plugins are modules that export at least a single identifier, &lt;code&gt;plugin&lt;/code&gt;, of type &lt;code&gt;GhcPlugins.Plugin&lt;/code&gt;. All plugins should &lt;code&gt;import GhcPlugins&lt;/code&gt; as it defines the interface to the compilation pipeline.</source>
          <target state="translated">플러그인은 최소한 &lt;code&gt;GhcPlugins.Plugin&lt;/code&gt; 유형 의 단일 식별자 &lt;code&gt;plugin&lt;/code&gt; 을 내보내는 모듈입니다 . 모든 플러그인은 &lt;code&gt;import GhcPlugins&lt;/code&gt; 를 가져와야합니다 컴파일 파이프 라인에 대한 인터페이스를 정의 할 때 를 합니다.</target>
        </trans-unit>
        <trans-unit id="50a78f3b1666118502953351a9e4c0ece78555a4" translate="yes" xml:space="preserve">
          <source>Plugins are provided with all available constraints (including equalities and typeclass constraints), but it is easy for them to discard those that are not relevant to their domain, because they need return only those constraints for which they have made progress (either by solving or contradicting them).</source>
          <target state="translated">플러그인에는 사용 가능한 모든 제약 조건 (등식 및 유형 클래스 제약 조건 포함)이 제공되지만 도메인과 관련이없는 제약 조건은 버릴 수 있습니다. 모순).</target>
        </trans-unit>
        <trans-unit id="bcfecc84377584d4ad3cb1e967e83c8d968b6d81" translate="yes" xml:space="preserve">
          <source>Plugins can be added on the command line with the &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt; option where ⟨module⟩ is a module in a registered package that exports the plugin. Arguments can be passed to the plugins with the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; option. The list of enabled plugins can be reset with the &lt;a href=&quot;#ghc-flag--fclear-plugins&quot;&gt;&lt;code&gt;-fclear-plugins&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 명령 행에 추가 할 수 있습니다. 여기서 ⟨module⟩은 플러그인을 내보내는 등록 된 패키지의 모듈입니다. &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 인수를 플러그인에 전달할 수 있습니다 . 활성화 된 플러그인 목록은 &lt;a href=&quot;#ghc-flag--fclear-plugins&quot;&gt; &lt;code&gt;-fclear-plugins&lt;/code&gt; 를&lt;/a&gt; 사용하여 재설정 할 수 있습니다. 옵션을 .</target>
        </trans-unit>
        <trans-unit id="9dae985525fa5c1bd52094480c5fadf0801829a6" translate="yes" xml:space="preserve">
          <source>Plugins cannot optimize/inspect C--, nor can they implement things like parser/front-end modifications like GCC, apart from limited changes to the constraint solver. If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">플러그인은 C--를 최적화 / 검사 할 수 없으며 제약 솔버의 제한된 변경 사항을 제외하고 GCC와 같은 파서 / 프론트 엔드 수정과 같은 것을 구현할 수 없습니다. 이러한 제한 사항 중 하나라도 너무 부담 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;스럽다고 생각되면 GHC 팀에 한마디 부탁드립니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c33bcc738bc3d4e4633fbe0d574f0b8c7bf15d" translate="yes" xml:space="preserve">
          <source>Plugins cannot optimize/inspect C-\-, nor can they implement things like parser/front-end modifications like GCC, apart from limited changes to the constraint solver. If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">플러그인은 C-\-를 최적화 / 검사 할 수 없으며 제약 조건 솔버의 제한된 변경 외에 GCC와 같은 파서 / 프런트 엔드 수정과 같은 것을 구현할 수 없습니다. 이러한 제한 사항 중 하나라도 너무 성가 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;시다고 생각되면 GHC 팀에게 소리 지르십시오.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="657ba732d1e87d8b93008540bca513f726773ecb" translate="yes" xml:space="preserve">
          <source>Plugins do not work with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;. If you need to run plugins with &lt;code&gt;-fexternal-interpreter&lt;/code&gt; let GHC developers know in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;#14335&lt;/a&gt;.</source>
          <target state="translated">플러그인은 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 와 함께 작동하지 않습니다 . &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 로 플러그인을 실행해야하는 경우 GHC 개발자에게 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;# 14335&lt;/a&gt; 에서 알려 주십시오 .</target>
        </trans-unit>
        <trans-unit id="1acd4a0590b84ad78012a8281aa3759223cdd151" translate="yes" xml:space="preserve">
          <source>Plugins do not work with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;. If you need to run plugins with &lt;code&gt;-fexternal-interpreter&lt;/code&gt; let GHC developers know in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;Issue #14335&lt;/a&gt;.</source>
          <target state="translated">플러그인은 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 와 함께 작동하지 않습니다 . &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 를 사용 하여 플러그인을 실행해야하는 경우 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14335&quot;&gt;문제 # 14335&lt;/a&gt; 에서 GHC 개발자에게 알리십시오. .</target>
        </trans-unit>
        <trans-unit id="0d1483c843780c87aec4fd3aa51d7d94a8b96a4e" translate="yes" xml:space="preserve">
          <source>Po: Punctuation, Other</source>
          <target state="translated">Po : 구두점, 기타</target>
        </trans-unit>
        <trans-unit id="f79a28423ed1ae0232efb54ad41227d0955084f3" translate="yes" xml:space="preserve">
          <source>Point</source>
          <target state="translated">Point</target>
        </trans-unit>
        <trans-unit id="a7f9dff21b1ddcdcf80248743f347d8d0da9bd72" translate="yes" xml:space="preserve">
          <source>Pointer equality.</source>
          <target state="translated">포인터 평등.</target>
        </trans-unit>
        <trans-unit id="c8e8cc6922489fcddbf0a22dd3e2de7b10d8bd37" translate="yes" xml:space="preserve">
          <source>Polar form</source>
          <target state="translated">극지 형태</target>
        </trans-unit>
        <trans-unit id="08ec06c8c3d316a130a751bea478b9d8cd36463e" translate="yes" xml:space="preserve">
          <source>Poll the semaphore until it is available, then lock it. Unlike semWait, this will block only the current thread rather than the entire process.</source>
          <target state="translated">사용 가능할 때까지 세마포어를여십시오. 그런 다음 잠그십시오. semWait와 달리 전체 프로세스가 아닌 현재 스레드 만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="f60030530d452b22d889af65e4dbea1ad5231ba6" translate="yes" xml:space="preserve">
          <source>PolyKinds</source>
          <target state="translated">PolyKinds</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="41b680d741ab1eaec7b7f722d04d7131ec90b3b5" translate="yes" xml:space="preserve">
          <source>Pool management</source>
          <target state="translated">수영장 관리</target>
        </trans-unit>
        <trans-unit id="71deae26a59f4c366e9d565ae1eea4f3ace4a347" translate="yes" xml:space="preserve">
          <source>Pools are currently implemented using &lt;code&gt;malloc/free&lt;/code&gt;, so while they might be a more convenient way to structure your memory allocation than using one of the other forms of allocation, they won&amp;rsquo;t be any more efficient. We do plan to provide an improved-performance implementation of Pools in the future, however.</source>
          <target state="translated">풀은 현재 &lt;code&gt;malloc/free&lt;/code&gt; 를 사용하여 구현됩니다. 되므로 다른 형태의 할당 중 하나를 사용하는 것보다 메모리 할당을 구성하는 것이 더 편리한 방법 일 수 있지만 더 효율적이지 않습니다. 그러나 향후 개선 된 풀 구현을 제공 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="2df5eed666ad15052a9c4b2714990bcfc3e1bfe4" translate="yes" xml:space="preserve">
          <source>Pop the ByteString we have constructed so far, if any, yielding a new chunk in the result ByteString.</source>
          <target state="translated">지금까지 생성 한 ByteString을 팝하면 결과 ByteString에 새로운 청크가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fe9afec2cdc2c7d8517084a2d65a63864d25ccaa" translate="yes" xml:space="preserve">
          <source>Pop the most recent call-site off the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 가장 최근의 콜 사이트를 팝하십시오 .</target>
        </trans-unit>
        <trans-unit id="184d55340a7ea9436efac0e4b30658a294cc194c" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator on the tag, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 비교기를 사용하여 큐에서 가장 작은 요소를 팝하여 비교기가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치를 지연시킵니다 .</target>
        </trans-unit>
        <trans-unit id="0c1beba4a0f9fa2d27717b6fdfbe4fe2c7701db7" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator on the tag, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">태그에 제공된 비교기를 사용하여 큐에서 가장 작은 요소를 팝하고 비교기가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치로 연기합니다 .</target>
        </trans-unit>
        <trans-unit id="2b8d7b36ba997a86666ef5b0a2e955a7f3121f1d" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator on the tag.</source>
          <target state="translated">제공된 비교기를 사용하여 대기열에서 가장 작은 요소를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d0305355484ccbf0a5332dd6a8f21a5cc2b3e243" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 비교기를 사용하여 비교기에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치를 지연시키면서 큐에서 가장 작은 요소를 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="01d0a772369a2f419cd1206d689c75ab3f892dbb" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator, deferring to the item's original position when the comparator returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 비교기를 사용하여 비교기가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:EQ&quot;&gt;EQ&lt;/a&gt;&lt;/code&gt; 를 반환 할 때 항목의 원래 위치로 연기하여 대기열에서 가장 작은 요소를 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="ecde65687583e5067a6f236eb0adeaea9fb3c926" translate="yes" xml:space="preserve">
          <source>Pop the smallest element from the queue, using the supplied comparator.</source>
          <target state="translated">제공된 비교기를 사용하여 큐에서 가장 작은 요소를 팝하십시오.</target>
        </trans-unit>
        <trans-unit id="b307b88c84327b1804aee227595be53342245965" translate="yes" xml:space="preserve">
          <source>Portability</source>
          <target state="translated">Portability</target>
        </trans-unit>
        <trans-unit id="1bacaf21b2fe90b21bbc565ba919a04acd5baee5" translate="yes" xml:space="preserve">
          <source>Portable</source>
          <target state="translated">Portable</target>
        </trans-unit>
        <trans-unit id="89d8f29ace289b18dbbef31338d9cf587f44295f" translate="yes" xml:space="preserve">
          <source>Portable to Hugs and GHC. Requires MPTCs</source>
          <target state="translated">포옹과 GHC에 휴대용. MPTC 필요</target>
        </trans-unit>
        <trans-unit id="d67331323a539f65439ac2219e811fa90a48d4a1" translate="yes" xml:space="preserve">
          <source>Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009</source>
          <target state="translated">저작권 : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009</target>
        </trans-unit>
        <trans-unit id="3db8887ea19a282f0bf7fbe5de701083bec25186" translate="yes" xml:space="preserve">
          <source>Portions obtained from hbc (c) Lennart Augusstson</source>
          <target state="translated">hbc (c) Lennart Augusstson에서 얻은 부분</target>
        </trans-unit>
        <trans-unit id="c9b1b30d011fe2b612eff7c95b1c553cdf039f7c" translate="yes" xml:space="preserve">
          <source>Pos</source>
          <target state="translated">Pos</target>
        </trans-unit>
        <trans-unit id="cf1c85adba548e8d681255278976584a7e4a44de" translate="yes" xml:space="preserve">
          <source>Position</source>
          <target state="translated">Position</target>
        </trans-unit>
        <trans-unit id="718239faf2c7ad4b5be8fc3d53f933e6298dd64c" translate="yes" xml:space="preserve">
          <source>Position in file</source>
          <target state="translated">파일에서의 위치</target>
        </trans-unit>
        <trans-unit id="a98f91ff888a0baac961ccc11866ac56d92f3491" translate="yes" xml:space="preserve">
          <source>Position independent executables are required by some platforms as they enable address-space layout randomization (ASLR), a common security measure. They can also be useful as they can be dynamically loaded and used as shared libraries by other executables.</source>
          <target state="translated">위치 독립적 인 실행 파일은 일반적인 보안 수단 인 ASLR (Address-space Layout Randomization)을 지원하므로 일부 플랫폼에서 필요합니다. 또한 다른 실행 파일에서 동적으로로드하여 공유 라이브러리로 사용할 수 있으므로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a42e40e7381223e58fc6699427898624e3d568b" translate="yes" xml:space="preserve">
          <source>Position independent executables should be dynamically-linked (e.g. built with &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and only loaded into other dynamically-linked executables to ensure that only one &lt;code&gt;libHSrts&lt;/code&gt; is present if loaded into the address space of another Haskell process.</source>
          <target state="translated">위치 독립적 실행 파일은 동적으로 연결되어야합니다 (예 : &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 으로&lt;/a&gt; 빌드 되고 다른 동적 연결 실행 파일에만로드되어 하나의 &lt;code&gt;libHSrts&lt;/code&gt; 만 보장됨) 다른 Haskell 프로세스의 주소 공간에로드 된 경우 존재 로드 됨).</target>
        </trans-unit>
        <trans-unit id="f21a0136d6ab8fb27cd7d944927f57c96bb35706" translate="yes" xml:space="preserve">
          <source>PosixVersion</source>
          <target state="translated">PosixVersion</target>
        </trans-unit>
        <trans-unit id="6662b9da87a72fea9bd249c0718c63c20d41c5e4" translate="yes" xml:space="preserve">
          <source>Postcomposition with a pure function (right-to-left variant).</source>
          <target state="translated">순수한 기능을 사용한 후 처리 (오른쪽에서 왼쪽으로 변형)</target>
        </trans-unit>
        <trans-unit id="68b34bc77c96ccaa5d23f02c3788537d21fd9171" translate="yes" xml:space="preserve">
          <source>Postcomposition with a pure function.</source>
          <target state="translated">순수한 기능으로 사후 구성.</target>
        </trans-unit>
        <trans-unit id="c4450a1082e97ad779541d6b592b90e8113cd10b" translate="yes" xml:space="preserve">
          <source>PostfixOperators</source>
          <target state="translated">PostfixOperators</target>
        </trans-unit>
        <trans-unit id="5190c068a9cfa9fe6dafeaa183d9b2aaef45c829" translate="yes" xml:space="preserve">
          <source>Ppr</source>
          <target state="translated">Ppr</target>
        </trans-unit>
        <trans-unit id="0c19dcec06f6c91c0f2eff83d377b3454295bda3" translate="yes" xml:space="preserve">
          <source>PprM</source>
          <target state="translated">PprM</target>
        </trans-unit>
        <trans-unit id="38f93d32853eca4603a582eb7a404079e10b855d" translate="yes" xml:space="preserve">
          <source>Pragma</source>
          <target state="translated">Pragma</target>
        </trans-unit>
        <trans-unit id="6a503249a0dda8aeffc97783a04cdefe488d7002" translate="yes" xml:space="preserve">
          <source>Pragmas all take the form &lt;code&gt;{-# word ... #-}&lt;/code&gt; where ⟨word⟩ indicates the type of pragma, and is followed optionally by information specific to that type of pragma. Case is ignored in ⟨word⟩. The various values for ⟨word⟩ that GHC understands are described in the following sections; any pragma encountered with an unrecognised ⟨word⟩ is ignored. The layout rule applies in pragmas, so the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">Pragma는 모두 &lt;code&gt;{-# word ... #-}&lt;/code&gt; 형식을 취합니다. 여기서 ⟨word⟩는 pragma의 유형을 나타내고 선택적으로 해당 유형의 pragma에 특정한 정보가옵니다. ⟨word⟩에서 대소 문자는 무시됩니다. GHC가 이해하는 &quot;word&quot;에 대한 다양한 값은 다음 섹션에 설명되어 있습니다. 인식 할 수없는 ⟨word⟩가있는 pragma는 무시됩니다. 레이아웃 규칙은 pragma에 적용되므로 닫는 &lt;code&gt;#-}&lt;/code&gt; 은 여는 &lt;code&gt;{-#&lt;/code&gt; 의 오른쪽 열에서 시작해야합니다 . .</target>
        </trans-unit>
        <trans-unit id="de91c36fde9f78913dd737b3ac96a872a8cf867b" translate="yes" xml:space="preserve">
          <source>Pre-defined directories</source>
          <target state="translated">사전 정의 된 디렉토리</target>
        </trans-unit>
        <trans-unit id="b7f5558e808991eda01cbcf863b6fb9f860df9c3" translate="yes" xml:space="preserve">
          <source>Pre-emption</source>
          <target state="translated">Pre-emption</target>
        </trans-unit>
        <trans-unit id="616e1d6e6f47b2dc96ac1a5ae54540016239b6ef" translate="yes" xml:space="preserve">
          <source>Pre-processing is optional, the &lt;a href=&quot;phases#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; flag turns it on. See &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt; for more details.</source>
          <target state="translated">사전 처리는 선택 사항이며 &lt;a href=&quot;phases#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt; 플래그는이를 설정합니다. &lt;a href=&quot;phases#c-pre-processor&quot;&gt;C 전처리기에 영향을주는 옵션을&lt;/a&gt; 참조하십시오. 하십시오.</target>
        </trans-unit>
        <trans-unit id="b56df0dc547f1c3c9c6bdf3cf6bc836ae75d592f" translate="yes" xml:space="preserve">
          <source>Prec</source>
          <target state="translated">Prec</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="69d353b33ac29db4cf194048bdbcd68112b6f57f" translate="yes" xml:space="preserve">
          <source>Precedence operations</source>
          <target state="translated">우선 순위 작업</target>
        </trans-unit>
        <trans-unit id="6e9db1fa77d52cf522ad8a7a915070250aa06a60" translate="yes" xml:space="preserve">
          <source>Precedences</source>
          <target state="translated">Precedences</target>
        </trans-unit>
        <trans-unit id="7d4c782369e2a524fee0cc4b706316c8a2f516ce" translate="yes" xml:space="preserve">
          <source>Precomposition with a pure function (right-to-left variant).</source>
          <target state="translated">순수한 기능으로 사전 구성 (오른쪽에서 왼쪽으로 변형)</target>
        </trans-unit>
        <trans-unit id="7efe8aecf7d7ec9a6579a56c2d3f073a07aea88e" translate="yes" xml:space="preserve">
          <source>Precomposition with a pure function.</source>
          <target state="translated">순수한 기능으로 사전 구성.</target>
        </trans-unit>
        <trans-unit id="754ba6611e7bacba5a9fb90876697ee505efa3e8" translate="yes" xml:space="preserve">
          <source>Pred</source>
          <target state="translated">Pred</target>
        </trans-unit>
        <trans-unit id="7b11e8e297f569849de36b44d30fcbbb4fbbe8ad" translate="yes" xml:space="preserve">
          <source>PredQ</source>
          <target state="translated">PredQ</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="5d3249c48d800f447f533f0fa317e54353a59d06" translate="yes" xml:space="preserve">
          <source>Predicate determining whether the first argument is inside the second argument.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수 안에 있는지 판별하는 술어.</target>
        </trans-unit>
        <trans-unit id="55b56b7a38f2aaf5493f86b3d26035da3508b3bb" translate="yes" xml:space="preserve">
          <source>Predicate to select exceptions</source>
          <target state="translated">예외를 선택하는 술어</target>
        </trans-unit>
        <trans-unit id="74ff649a3a1be6633677b33ec66e3623a45738d8" translate="yes" xml:space="preserve">
          <source>Predicates</source>
          <target state="translated">Predicates</target>
        </trans-unit>
        <trans-unit id="96b847cc7746c0d1f7662c2ba5e962da4df9bff5" translate="yes" xml:space="preserve">
          <source>Predicates on documents</source>
          <target state="translated">문서의 술어</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="10a0703c5e9784ab6072eefca5e5d67b8bab1aea" translate="yes" xml:space="preserve">
          <source>PrefixI</source>
          <target state="translated">PrefixI</target>
        </trans-unit>
        <trans-unit id="3d7f56ffea75d06f65599fca02fef48b1a3c121a" translate="yes" xml:space="preserve">
          <source>Prefs</source>
          <target state="translated">Prefs</target>
        </trans-unit>
        <trans-unit id="2d8e8af65e69e615c74499754307d13c9b3e4bab" translate="yes" xml:space="preserve">
          <source>Prelude</source>
          <target state="translated">Prelude</target>
        </trans-unit>
        <trans-unit id="17951797c095385f82b7ed2be1b0b9cbd50b504e" translate="yes" xml:space="preserve">
          <source>Prepares an empty write buffer. This lets the device decide how to set up a write buffer: the buffer may need to point to a specific location in memory, for example. This is typically used by the client when switching from reading to writing on a buffered read/write device.</source>
          <target state="translated">빈 쓰기 버퍼를 준비합니다. 이를 통해 장치는 쓰기 버퍼 설정 방법을 결정할 수 있습니다. 버퍼는 예를 들어 메모리의 특정 위치를 가리켜 야 할 수 있습니다. 이는 일반적으로 버퍼링 된 읽기 / 쓰기 장치에서 읽기에서 쓰기로 전환 할 때 클라이언트가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e756fbcebaf305207bf892820ae2fb41ad4bdd3f" translate="yes" xml:space="preserve">
          <source>Prepend an element to the stream.</source>
          <target state="translated">스트림 앞에 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="24451f10c39a033b9d567c3384a201089e447d0e" translate="yes" xml:space="preserve">
          <source>Present a visual alert using the &lt;code&gt;flash&lt;/code&gt; capability.</source>
          <target state="translated">&lt;code&gt;flash&lt;/code&gt; 사용하여 시각적 경고 표시 기능을 .</target>
        </trans-unit>
        <trans-unit id="0f1fbb34fcfce7c17bb348ece516318a4a36a3e4" translate="yes" xml:space="preserve">
          <source>Presently, only standard constraints, tuples and type synonyms for those two sorts of constraint are permitted in instance contexts and superclasses (without extra flags). The reason is that permitting more general constraints can cause type checking to loop, as it would with these two programs:</source>
          <target state="translated">현재, 두 가지 종류의 제약 조건에 대한 표준 제약 조건, 튜플 및 형식 동의어 만 인스턴스 컨텍스트 및 수퍼 클래스 (추가 플래그없이)에서 허용됩니다. 더 일반적인 제약 조건을 허용하면 다음 두 프로그램에서와 같이 유형 검사가 반복 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3a533287e20f4ecff2b1e94d9ecd624990690055" translate="yes" xml:space="preserve">
          <source>Preserve, unchanged, the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목은 변경하지 않고 그대로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f7adbbb69e916ea1927afb55f2ecddd2cc7a5f" translate="yes" xml:space="preserve">
          <source>Pretty</source>
          <target state="translated">Pretty</target>
        </trans-unit>
        <trans-unit id="9bfe234869187d35c7a0ae4cca314aded4bb1a5b" translate="yes" xml:space="preserve">
          <source>Pretty much anyone who uses this function is in a state of sin because whether or not a character is encodable will, in general, depend on the context in which it occurs.</source>
          <target state="translated">이 기능을 사용하는 사람은 거의 대부분 죄의 상태에 있습니다. 왜냐하면 캐릭터의 인코딩 가능 여부는 일반적으로 그것이 발생하는 상황에 달려 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9a3ba5e8fa76ce9f1f76507bf772a40b2714f091" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 인쇄 .</target>
        </trans-unit>
        <trans-unit id="6dedd939f5eb8f17de16de0deb9579148f161282" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 을 예쁘게 인쇄 .</target>
        </trans-unit>
        <trans-unit id="d2157c3e2c2e08e7d9469e18b1d6d2509fdc1116" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 인쇄 .</target>
        </trans-unit>
        <trans-unit id="24a5908c42be14f75c50cae9cb71fef066d896a2" translate="yes" xml:space="preserve">
          <source>Pretty print a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 을 예쁘게 인쇄 .</target>
        </trans-unit>
        <trans-unit id="296539186fb752a49f377917ff5a8b60910cd510" translate="yes" xml:space="preserve">
          <source>Pretty print a value with the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; 로 값을 예쁘게 인쇄 레벨 .</target>
        </trans-unit>
        <trans-unit id="dee0fe2bf13d7aeaf670d551f0f8e724a8229133" translate="yes" xml:space="preserve">
          <source>Pretty print a value with the &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:prettyNormal&quot;&gt;prettyNormal&lt;/a&gt;&lt;/code&gt; 로 값을 예쁘게 인쇄 레벨 .</target>
        </trans-unit>
        <trans-unit id="3902ef81760a73ba152aafba884456ad6ae55826" translate="yes" xml:space="preserve">
          <source>Pretty print the type. &lt;code&gt;ShowType :: k -&amp;gt; ErrorMessage&lt;/code&gt;</source>
          <target state="translated">유형을 예쁘게 인쇄하십시오. &lt;code&gt;ShowType :: k -&amp;gt; ErrorMessage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d1c61942f4d68589a44b45a71c4f04ff54f0e46" translate="yes" xml:space="preserve">
          <source>Pretty printing class, simlar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; but nicer looking.</source>
          <target state="translated">예쁜 인쇄 수업, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 것과 비슷 비슷하지만 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb9fb477d57eb6faf402bf1e5b55cd7c5bcd432d" translate="yes" xml:space="preserve">
          <source>Pretty printing class, simlar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; but nicer looking.</source>
          <target state="translated">예쁜 인쇄 수업, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 비슷하지만 더 멋지게 보입니다.</target>
        </trans-unit>
        <trans-unit id="fa35ad6c9b5033404eb8f0e2bfca62d78aef25b2" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 와 비슷한 방식으로 사용됩니다 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="6003344bfaa462ef2829aa012e40d0f204fd8d4b" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 와 비슷한 방식으로 사용됩니다 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="7605fec354fe6f4bc05aa4679861cd3ca163d486" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 에서와 유사한 방식으로 사용됩니다. 클래스 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2ed9c1885cc6441472c3a338a7ff234773679fa" translate="yes" xml:space="preserve">
          <source>Pretty printing class. The precedence level is used in a similar way as in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class. Minimal complete definition is either &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예쁜 인쇄 수업. 우선 순위 수준은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 에서와 유사한 방식으로 사용됩니다. 클래스 . 최소 완전한 정의는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrintPrec&quot;&gt;pPrintPrec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespjclass#v:pPrint&quot;&gt;pPrint&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce0b905e0e2fe34c10df06c3257897a0d4174db5" translate="yes" xml:space="preserve">
          <source>Pretty printing via &lt;code&gt;&lt;a href=&quot;language-haskell-th-ppr#v:pprPatSynType&quot;&gt;pprPatSynType&lt;/a&gt;&lt;/code&gt; abbreviates a pattern synonym's type unambiguously in concrete syntax: The rule of thumb is to print initial empty universals and the required context as &lt;code&gt;() =&amp;gt;&lt;/code&gt;, if existentials and a provided context follow. If only universals and their required context, but no existentials are specified, only the universals and their required context are printed. If both or none are specified, so both (or none) are printed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-ppr#v:pprPatSynType&quot;&gt;pprPatSynType&lt;/a&gt;&lt;/code&gt; 을 통한 예쁜 인쇄 는 구체적인 구문에서 패턴 동의어의 유형을 명확하게 줄여줍니다. &lt;code&gt;() =&amp;gt;&lt;/code&gt; 좋습니다. 유니버설과 필수 컨텍스트 만 있지만 실재가 지정되지 않은 경우 유니버설과 필수 컨텍스트 만 인쇄됩니다. 둘 다 지정하거나 지정하지 않으면 둘 다 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="913403112273ef6e2854bcf0f8c908964725c43b" translate="yes" xml:space="preserve">
          <source>Pretty prints a pattern synonym type signature</source>
          <target state="translated">패턴 동의어 형식 서명을 예쁘게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d4e682f695f1f2c1d3c722dd6d5b3b250860bb3f" translate="yes" xml:space="preserve">
          <source>Pretty prints a pattern synonym's type; follows the usual conventions to print a pattern synonym type compactly, yet unambiguously. See the note on &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:PatSynType&quot;&gt;PatSynType&lt;/a&gt;&lt;/code&gt; and the section on pattern synonyms in the GHC user's guide for more information.</source>
          <target state="translated">Pretty는 패턴 동의어 유형을 인쇄합니다. 일반적인 동의어에 따라 패턴 동의어 유형을 간결하면서도 명확하게 인쇄합니다. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:PatSynType&quot;&gt;PatSynType&lt;/a&gt;&lt;/code&gt; 에 대한 참고 사항을 참조하십시오 및 GHC 사용자 안내서의 패턴 동의어에 대한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7763808de129b1653f86f4b6c4478b1be06d267" translate="yes" xml:space="preserve">
          <source>Pretty typeclass</source>
          <target state="translated">예쁜 타입 클래스</target>
        </trans-unit>
        <trans-unit id="9e53c1cac90b48260e445d3942d8dc757e8a9ad1" translate="yes" xml:space="preserve">
          <source>Pretty-printer</source>
          <target state="translated">Pretty-printer</target>
        </trans-unit>
        <trans-unit id="299e09a4ecf7d0f0c71dd28f182c4640d6372f53" translate="yes" xml:space="preserve">
          <source>PrettyLevel</source>
          <target state="translated">PrettyLevel</target>
        </trans-unit>
        <trans-unit id="cfad1a2758e3a164bd5b4b3f7f8ff793ee9e089b" translate="yes" xml:space="preserve">
          <source>Prevent loading of the user&amp;rsquo;s local package database in the initial stack.</source>
          <target state="translated">초기 스택에서 사용자의 로컬 패키지 데이터베이스가로드되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="82f73f32fff7781aec7b0b514e54e58cf7551ee7" translate="yes" xml:space="preserve">
          <source>Prevents the compiler from applying the monomorphism restriction to bindings lacking explicit type signatures.</source>
          <target state="translated">컴파일러가 명시 적 형식 서명이없는 바인딩에 단일 제한을 적용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="9628fe995a8e090e6fd2edb95cb73c1eb15224d5" translate="yes" xml:space="preserve">
          <source>Previous versions of GHC accepted &lt;code&gt;OPTIONS&lt;/code&gt; rather than &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, but that is now deprecated.</source>
          <target state="translated">이전 버전의 GHC는 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 대신 &lt;code&gt;OPTIONS&lt;/code&gt; 를 허용 했지만 이제는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91406666c314d5f229091e983a7d1e2bee142e52" translate="yes" xml:space="preserve">
          <source>Previously we discussed annotation pragmas (&lt;a href=&quot;#annotation-pragmas&quot;&gt;Source annotations&lt;/a&gt;), which we mentioned could be used to give compiler plugins extra guidance or information. Annotations for a module can be retrieved by a plugin, but you must go through the modules &lt;code&gt;ModGuts&lt;/code&gt; in order to get it. Because annotations can be arbitrary instances of &lt;code&gt;Data&lt;/code&gt; and &lt;code&gt;Typeable&lt;/code&gt;, you need to give a type annotation specifying the proper type of data to retrieve from the interface file, and you need to make sure the annotation type used by your users is the same one your plugin uses. For this reason, we advise distributing annotations as part of the package which also provides compiler plugins if possible.</source>
          <target state="translated">이전에 우리는 주석 프라 그마 ( &lt;a href=&quot;#annotation-pragmas&quot;&gt;Source annotations&lt;/a&gt; )에 대해 논의 했는데, 우리는 컴파일러 플러그인에 추가적인 지침이나 정보를 제공하는 데 사용될 수 있다고 언급했다. 모듈에 대한 주석은 플러그인에 의해 검색 될 수 있지만, 모듈 을 얻으려면 &lt;code&gt;ModGuts&lt;/code&gt; 모듈을 거쳐야 합니다. 주석은 &lt;code&gt;Data&lt;/code&gt; 및 &lt;code&gt;Typeable&lt;/code&gt; 의 임의 인스턴스 일 수 있으므로 일 수 있으므로 인터페이스 파일에서 검색 할 적절한 데이터 유형을 지정하는 유형 주석을 제공해야하며 사용자가 사용하는 주석 유형이 플러그인과 동일한 지 확인해야합니다. 사용합니다. 따라서 가능한 경우 컴파일러 플러그인도 제공하는 패키지의 일부로 주석을 배포하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c4a698fc939e769737cd9fa4869e3c7f6a0dd613" translate="yes" xml:space="preserve">
          <source>Prim</source>
          <target state="translated">Prim</target>
        </trans-unit>
        <trans-unit id="097f7b8f054d460e64f528c1af758136a46531eb" translate="yes" xml:space="preserve">
          <source>PrimMVar</source>
          <target state="translated">PrimMVar</target>
        </trans-unit>
        <trans-unit id="b7683822a291cb2b58d760a6c293578f8d5053f1" translate="yes" xml:space="preserve">
          <source>Primality tests</source>
          <target state="translated">원시성 테스트</target>
        </trans-unit>
        <trans-unit id="82232b5d4e89a2db12db9f128d9da3055f65c345" translate="yes" xml:space="preserve">
          <source>Primarily, this module consists of an interface to the C-land dynamic linker.</source>
          <target state="translated">기본적으로이 모듈은 C-land 동적 링커에 대한 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0889b00639729e1c129ac932d18003c7a198375f" translate="yes" xml:space="preserve">
          <source>Primary format character.</source>
          <target state="translated">기본 형식 문자</target>
        </trans-unit>
        <trans-unit id="d2a03ab0b74a812f6fdc4dae75971c24107ba46b" translate="yes" xml:space="preserve">
          <source>Primary group ID (pw_gid)</source>
          <target state="translated">기본 그룹 ID (pw_gid)</target>
        </trans-unit>
        <trans-unit id="7607b51c8e1274c8fe1e933fecba18513d4f362a" translate="yes" xml:space="preserve">
          <source>PrimaryLANGID</source>
          <target state="translated">PrimaryLANGID</target>
        </trans-unit>
        <trans-unit id="cdd32e5e2d189473b1b0376cb2f1fe6ef6aad406" translate="yes" xml:space="preserve">
          <source>Primitive (unboxed) types cannot be defined in Haskell, and are therefore built into the language and compiler. Primitive types are always unlifted; that is, a value of a primitive type cannot be bottom. (Note: a &amp;ldquo;boxed&amp;rdquo; type means that a value is represented by a pointer to a heap object; a &amp;ldquo;lifted&amp;rdquo; type means that terms of that type may be bottom. See the next paragraph for an example.) We use the convention (but it is only a convention) that primitive types, values, and operations have a &lt;code&gt;#&lt;/code&gt; suffix (see &lt;a href=&quot;#magic-hash&quot;&gt;The magic hash&lt;/a&gt;). For some primitive types we have special syntax for literals, also described in the &lt;a href=&quot;#magic-hash&quot;&gt;same section&lt;/a&gt;.</source>
          <target state="translated">기본 (비 박스) 유형은 Haskell에서 정의 할 수 없으므로 언어 ​​및 컴파일러에 내장되어 있습니다. 기본 유형은 항상 해제됩니다. 즉, 기본 유형의 값은 맨 아래가 될 수 없습니다. (참고 : &quot;박스형&quot;유형은 값이 힙 객체에 대한 포인터로 표시됨을 의미하고 &quot;리프팅&quot;유형은 해당 유형의 용어가 하단 일 수 있음을 의미합니다. 예를 들어 다음 단락을 참조하십시오. (그러나 기본 형식, 값 및 작업에는 &lt;code&gt;#&lt;/code&gt; 접미사가 있습니다 ( &lt;a href=&quot;#magic-hash&quot;&gt;매직 해시&lt;/a&gt; 참조 )). 일부 기본 유형의 경우 리터럴에 대한 특수 구문이 있으며 &lt;a href=&quot;#magic-hash&quot;&gt;동일한 섹션&lt;/a&gt; 에도 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81e9ce0c637b5622aea322e7cbd9b861a8cb4dc6" translate="yes" xml:space="preserve">
          <source>Primitive Documents</source>
          <target state="translated">기본 문서</target>
        </trans-unit>
        <trans-unit id="f422d79426f666f61a7d39fe5b03b368a8e73a13" translate="yes" xml:space="preserve">
          <source>Primitive bytecode type.</source>
          <target state="translated">기본 바이트 코드 유형.</target>
        </trans-unit>
        <trans-unit id="c1c26c88e959f52e5cf4888bbad7bcf524b8820f" translate="yes" xml:space="preserve">
          <source>Primitive combinators</source>
          <target state="translated">기본 조합기</target>
        </trans-unit>
        <trans-unit id="2e21eceae717d39a08de608f7fc31fb7d5627808" translate="yes" xml:space="preserve">
          <source>Primitive movement capabilities</source>
          <target state="translated">원시 운동 기능</target>
        </trans-unit>
        <trans-unit id="c2de126cf4ab0cd60ff18f3b3c4a2455396c348e" translate="yes" xml:space="preserve">
          <source>Primitive operations</source>
          <target state="translated">원시 작업</target>
        </trans-unit>
        <trans-unit id="7e8cb2eba99c97514ca435a92c7b1f3eff1bdea3" translate="yes" xml:space="preserve">
          <source>Primitive values are often represented by a simple bit-pattern, such as &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;. But this is not necessarily the case: a primitive value might be represented by a pointer to a heap-allocated object. Examples include &lt;code&gt;Array#&lt;/code&gt;, the type of primitive arrays. Thus, &lt;code&gt;Array#&lt;/code&gt; is an unlifted, boxed type. A primitive array is heap-allocated because it is too big a value to fit in a register, and would be too expensive to copy around; in a sense, it is accidental that it is represented by a pointer. If a pointer represents a primitive value, then it really does point to that value: no unevaluated thunks, no indirections. Nothing can be at the other end of the pointer than the primitive value. A numerically-intensive program using unboxed types can go a &lt;em&gt;lot&lt;/em&gt; faster than its &amp;ldquo;standard&amp;rdquo; counterpart&amp;mdash;we saw a threefold speedup on one example.</source>
          <target state="translated">기본 값은 종종 &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; 과 같은 간단한 비트 패턴으로 표시됩니다 . 그러나 반드시 그런 것은 아닙니다. 프리미티브 값은 힙 할당 객체에 대한 포인터로 표시 될 수 있습니다. 예는 기본 배열 유형 인 &lt;code&gt;Array#&lt;/code&gt; 입니다. 따라서 &lt;code&gt;Array#&lt;/code&gt; 리프팅되지 않은 박스 형식입니다. 프리미티브 배열은 레지스터에 맞지 않는 값이 너무 커서 복사하기에는 너무 비싸기 때문에 힙 할당됩니다. 어떤 의미에서는 포인터로 표시되는 것이 우연입니다. 포인터가 프리미티브 값을 나타내는 경우 실제로는 해당 값을 가리 킵니다. 평가되지 않은 썽크가없고 간접적 인 것이 없습니다. 포인터의 다른 끝에는 기본 값 이외의 값이있을 수 없습니다. 박스 형태가 아닌 유형을 사용하는 수치 집약적 인 프로그램 은&amp;ldquo;표준&amp;rdquo; 프로그램 보다 &lt;em&gt;훨씬&lt;/em&gt; 빠를 수 있습니다 . 한 예에서 3 배의 속도 향상이있었습니다.</target>
        </trans-unit>
        <trans-unit id="ffafa88c6f976297b9421ad4171675a387b485a2" translate="yes" xml:space="preserve">
          <source>Primitives</source>
          <target state="translated">Primitives</target>
        </trans-unit>
        <trans-unit id="66914127445228947976717f3559fb76a49308ac" translate="yes" xml:space="preserve">
          <source>Primitives and basic combinators</source>
          <target state="translated">프리미티브 및 기본 콤비 네이터</target>
        </trans-unit>
        <trans-unit id="0f20585a9b902d862530a747335f7e0f0fd615e0" translate="yes" xml:space="preserve">
          <source>Primitives are available to decode words of various sizes, both big and little endian.</source>
          <target state="translated">프리미티브는 빅 엔디안과 리틀 엔디안 등 다양한 크기의 단어를 해독하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11324a450fecb745dc9a0165fed6d81224cd078" translate="yes" xml:space="preserve">
          <source>Print &lt;code&gt;RuntimeRep&lt;/code&gt; parameters as they appear; otherwise, they are defaulted to &lt;code&gt;'LiftedRep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RuntimeRep&lt;/code&gt; 매개 변수가 나타나는대로 인쇄 하십시오 . 그렇지 않으면 기본값은 &lt;code&gt;'LiftedRep&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eeb81239159c8f60639d490579db34ba47cedde5" translate="yes" xml:space="preserve">
          <source>Print &lt;code&gt;RuntimeRep&lt;/code&gt; variables in types which are runtime-representation polymorphic.</source>
          <target state="translated">&lt;code&gt;RuntimeRep&lt;/code&gt; 변수를 런타임 표현 다형성 유형으로 인쇄 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7f33c02cf627c59368ecbf1b10534cd5ee7098" translate="yes" xml:space="preserve">
          <source>Print GHC&amp;rsquo;s numeric version number only.</source>
          <target state="translated">GHC의 숫자 버전 번호 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="5a8565f8c11652d5f9aaf3cf4b7da14d30635811" translate="yes" xml:space="preserve">
          <source>Print a full list of the module dependencies to stdout. (This is the standard verbosity flag, so the list will also be displayed with &lt;code&gt;-v3&lt;/code&gt; and &lt;code&gt;-v4&lt;/code&gt;; see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;.)</source>
          <target state="translated">모듈 종속성의 전체 목록을 stdout에 인쇄하십시오. (이것은 표준 상세 표시 플래그이므로 목록도 &lt;code&gt;-v3&lt;/code&gt; 및 &lt;code&gt;-v4&lt;/code&gt; 와 함께 표시됩니다 . &lt;a href=&quot;using#options-help&quot;&gt;상세 옵션&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="80be7ba4189d5acb5419cc416166ad88b14a93ab" translate="yes" xml:space="preserve">
          <source>Print a one-line string including GHC&amp;rsquo;s version number.</source>
          <target state="translated">GHC의 버전 번호를 포함하여 한 줄짜리 문자열을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2bc805e229391602d4747b2b177e7eedc95c2396" translate="yes" xml:space="preserve">
          <source>Print a one-line summary of the size of the Core program at the end of the optimisation pipeline</source>
          <target state="translated">최적화 파이프 라인 끝에서 핵심 프로그램 크기의 한 줄 요약을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="568fb95ae04c3a3502b02cfb9ffd902745997992" translate="yes" xml:space="preserve">
          <source>Print a one-line summary of the size of the Core program at the end of the optimisation pipeline.</source>
          <target state="translated">최적화 파이프 라인 끝에서 핵심 프로그램 크기의 한 줄 요약을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="6606d0f053fe23bd0db8aac9087cd16974cb24e2" translate="yes" xml:space="preserve">
          <source>Print coercions in types</source>
          <target state="translated">유형의 강제 인쇄</target>
        </trans-unit>
        <trans-unit id="0432cd36a550ecbc08a2b9824c1b63189a9b6ee6" translate="yes" xml:space="preserve">
          <source>Print explicit &lt;code&gt;forall&lt;/code&gt; quantification in types. See also &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;-XExplicitForAll&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">명시 적으로 인쇄 &lt;code&gt;forall&lt;/code&gt; 종류 정량화. &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;-XExplicitForAll&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="37d21fefc9ecda651a1fad5250210b879a85ecad" translate="yes" xml:space="preserve">
          <source>Print explicit &lt;code&gt;forall&lt;/code&gt; quantification in types. See also &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">명시 적으로 인쇄 &lt;code&gt;forall&lt;/code&gt; 종류 정량화. &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="43d90f3662f54252f7284d92a4b10054139a2658" translate="yes" xml:space="preserve">
          <source>Print explicit kind foralls and kind arguments in types. See also &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt;&lt;code&gt;-XKindSignatures&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">모든 종류의 종류와 종류에 대한 명백한 종류를 인쇄하십시오. &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt; &lt;code&gt;-XKindSignatures&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e56540a92be164f6f8a1c47dd5d494997f195e34" translate="yes" xml:space="preserve">
          <source>Print explicit kind foralls and kind arguments in types. See also &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">명시 적 종류 forall 및 종류 인수를 형식으로 인쇄합니다. &lt;a href=&quot;glasgow_exts#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ccc5df58f6562a5f05e5a96496e219a954a057a2" translate="yes" xml:space="preserve">
          <source>Print extra information from typechecker.</source>
          <target state="translated">형식 검사기에서 추가 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="1c689b67035c8c53f98145aff3c638fb305e66de" translate="yes" xml:space="preserve">
          <source>Print information about the compiler.</source>
          <target state="translated">컴파일러에 대한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c17674ed7a508bc28415982ff7aee239af184532" translate="yes" xml:space="preserve">
          <source>Print out each pass name as it happens</source>
          <target state="translated">각 패스 이름을 인쇄하십시오</target>
        </trans-unit>
        <trans-unit id="6346e07b56af6623e4a5cded288d10867e65bab0" translate="yes" xml:space="preserve">
          <source>Print out each pass name, its runtime and heap allocations as it happens. Note that this may come at a slight performance cost as the compiler will be a bit more eager in forcing pass results to more accurately account for their costs.</source>
          <target state="translated">각 패스 이름, 런타임 및 힙 할당을 인쇄하십시오. 컴파일러는 패스 결과를보다 정확하게 계산하기 위해 패스 결과를 조금 더 간절히 원하기 때문에 약간의 성능 비용이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4bdf4d18e7fa5c826928aec79e1ccb449c15ff" translate="yes" xml:space="preserve">
          <source>Print out summary of what kind of information the renamer had to bring in.</source>
          <target state="translated">이름 변경자가 가져와야 할 정보의 종류를 요약하여 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="bc9a53e87cca6954b36dc36c0f11d367ea1e424e" translate="yes" xml:space="preserve">
          <source>Print out usage information.</source>
          <target state="translated">사용법 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="b2c88a9f866c4e0f0dc02f44c6ee50187a966424" translate="yes" xml:space="preserve">
          <source>Print single alternative case expressions as strict lets.</source>
          <target state="translated">엄격한 대안으로 단일 대체 사례 표현식을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb7a347c6a4aa8013e70856b20c399cd1c29ff8" translate="yes" xml:space="preserve">
          <source>Print single alternative case expressions as though they were strict let expressions. This is helpful when your code does a lot of unboxing.</source>
          <target state="translated">단일 대체 사례 표현식이 엄격한 let 표현식 인 것처럼 인쇄하십시오. 이것은 코드가 많은 언 박싱을 수행 할 때 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2d376b6f72267ae8b071df5ba4178bc23f3f30f8" translate="yes" xml:space="preserve">
          <source>Print the name of each compilation phase as it is executed. (equivalent to &lt;a href=&quot;debugging#ghc-flag--dshow-passes&quot;&gt;&lt;code&gt;-dshow-passes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">실행될 때 각 컴파일 단계의 이름을 인쇄하십시오. ( &lt;a href=&quot;debugging#ghc-flag--dshow-passes&quot;&gt; &lt;code&gt;-dshow-passes&lt;/code&gt; &lt;/a&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="2d35a116b4eacba35aab727296180081e67d78e2" translate="yes" xml:space="preserve">
          <source>Print the path to GHC&amp;rsquo;s library directory. This is the top of the directory tree containing GHC&amp;rsquo;s libraries, interfaces, and include files (usually something like &lt;code&gt;/usr/local/lib/ghc-5.04&lt;/code&gt; on Unix). This is the value of &lt;code&gt;$libdir&lt;/code&gt; in the package configuration file (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;).</source>
          <target state="translated">GHC 라이브러리 디렉토리의 경로를 인쇄하십시오. 이것은 GHC의 라이브러리, 인터페이스 및 포함 파일 (일반적 으로 Unix의 &lt;code&gt;/usr/local/lib/ghc-5.04&lt;/code&gt; 와 같은 것)을 포함하는 디렉토리 트리의 최상위입니다 . 패키지 구성 파일 의 &lt;code&gt;$libdir&lt;/code&gt; 값입니다 ( &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7dddff095a26ddf9987f527bca4da1fdb41bb6b7" translate="yes" xml:space="preserve">
          <source>Print the supported command line options. This flag can be used for autocompletion in a shell.</source>
          <target state="translated">지원되는 명령 행 옵션을 인쇄하십시오. 이 플래그는 쉘에서 자동 완성에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de10c90956a31b467677165023124cbf6667b11" translate="yes" xml:space="preserve">
          <source>Print the supported language extensions.</source>
          <target state="translated">지원되는 언어 확장을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="0536d584c0b1d66d30f2000068d79cde18e65738" translate="yes" xml:space="preserve">
          <source>Print values of type &lt;code&gt;Word#&lt;/code&gt; and &lt;code&gt;Word64#&lt;/code&gt; (but not values of type &lt;code&gt;Int#&lt;/code&gt; and &lt;code&gt;Int64#&lt;/code&gt;) in hexadecimal instead of decimal. The hexadecimal is zero-padded to make the length of the representation a power of two. For example: &lt;code&gt;0x0A0A##&lt;/code&gt;, &lt;code&gt;0x000FFFFF##&lt;/code&gt;, &lt;code&gt;0xC##&lt;/code&gt;. This flag may be helpful when you are producing a bit pattern that to expect to work correctly on a 32-bit or a 64-bit architecture. Dumping hexadecimal literals after optimizations and constant folding makes it easier to confirm that the generated bit pattern is correct.</source>
          <target state="translated">10 진수 대신 16 진수로 &lt;code&gt;Word#&lt;/code&gt; 및 &lt;code&gt;Word64#&lt;/code&gt; 유형 ( &lt;code&gt;Int#&lt;/code&gt; 및 &lt;code&gt;Int64#&lt;/code&gt; 유형의 값이 아님)의 값을 인쇄하십시오 . 16 진수는 0으로 채워져 표현 길이를 2의 거듭 제곱으로 만듭니다. 예를 들어 &lt;code&gt;0x0A0A##&lt;/code&gt; , &lt;code&gt;0x000FFFFF##&lt;/code&gt; , &lt;code&gt;0xC##&lt;/code&gt; 입니다. 이 플래그는 32 비트 또는 64 비트 아키텍처에서 올바르게 작동 할 것으로 예상되는 비트 패턴을 생성 할 때 유용 할 수 있습니다. 최적화 및 상수 폴딩 후 16 진 리터럴을 덤프하면 생성 된 비트 패턴이 올바른지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8fc49ee76dfe430eaaae5d2c003a633432f9f0" translate="yes" xml:space="preserve">
          <source>Print values of type &lt;code&gt;Word#&lt;/code&gt; in hexadecimal.</source>
          <target state="translated">&lt;code&gt;Word#&lt;/code&gt; 유형의 값을 16 진수로 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7be34b673808f2d48e5ab2574882b799d823a21" translate="yes" xml:space="preserve">
          <source>PrintfArg</source>
          <target state="translated">PrintfArg</target>
        </trans-unit>
        <trans-unit id="7089bc7979848c154683cd0084ff2f7d3644e64b" translate="yes" xml:space="preserve">
          <source>PrintfType</source>
          <target state="translated">PrintfType</target>
        </trans-unit>
        <trans-unit id="78c20ed70f591c5b802ec52da8af22641a65cb47" translate="yes" xml:space="preserve">
          <source>Printing Functions</source>
          <target state="translated">인쇄 기능</target>
        </trans-unit>
        <trans-unit id="81c35c214270ee006f5c56860fe38a2f038e3898" translate="yes" xml:space="preserve">
          <source>Prints a one-line summary of timing statistics for the GHC run. This option is equivalent to &lt;code&gt;+RTS -tstderr&lt;/code&gt;, see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">GHC 실행에 대한 타이밍 통계의 한 줄 요약을 인쇄합니다. 이 옵션은 &lt;code&gt;+RTS -tstderr&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a32b1200253fea3bdcc41abafe3985fec209486" translate="yes" xml:space="preserve">
          <source>Prints a value without forcing its evaluation. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; may be used on values whose types are unknown or partially known, which might be the case for local variables with polymorphic types at a breakpoint. While inspecting the runtime value, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; attempts to reconstruct the type of the value, and will elaborate the type in GHCi&amp;rsquo;s environment if possible. If any unevaluated components (thunks) are encountered, then &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds a fresh variable with a name beginning with &lt;code&gt;_t&lt;/code&gt; to each thunk. See &lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt; for more information. See also the &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt;&lt;code&gt;:sprint&lt;/code&gt;&lt;/a&gt; command, which works like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; but does not bind new variables.</source>
          <target state="translated">평가하지 않고 값을 인쇄합니다. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 유형을 알 수 없거나 부분적으로 알려진 값에 사용될 수 있으며, 이는 중단 점에서 다형성 유형을 갖는 지역 변수의 경우 일 수 있습니다. 런타임 값을 검사하는 동안 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 값의 유형을 재구성하려고 시도하며 가능한 경우 GHCi 환경에서 유형을 정교하게합니다. 평가되지 않은 구성 요소 (썽크)가 발견되면 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 는 이름이 &lt;code&gt;_t&lt;/code&gt; 로 시작하는 새로운 변수 를 각 썽크에 바인딩합니다 . 자세한 내용은 &lt;a href=&quot;#breakpoints&quot;&gt;중단 점 및 변수 검사&lt;/a&gt; 를 참조하십시오. &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 같이 작동 하지만 새 변수를 바인딩하지 않는 &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt; &lt;code&gt;:sprint&lt;/code&gt; &lt;/a&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1901cde8b08fed8941230e3f83f1c3cf4a834d5a" translate="yes" xml:space="preserve">
          <source>Prints a value without forcing its evaluation. &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt;&lt;code&gt;:sprint&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, with the difference that unevaluated subterms are not bound to new variables, they are simply denoted by &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">평가하지 않고 값을 인쇄합니다. &lt;a href=&quot;#ghci-cmd-:sprint&quot;&gt; &lt;code&gt;:sprint&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 유사하며 , 평가되지 않은 하위 용어가 새 변수에 바인딩되지 않는다는 점에서 차이는 단순히 &lt;code&gt;_&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac4afe4944ea3331a3d2c608c60d31227edcb709" translate="yes" xml:space="preserve">
          <source>Prints the latest available version of package ⟨P⟩.</source>
          <target state="translated">사용 가능한 최신 버전의 패키지 ⟨P⟩를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7595d277dda450dbba120e42b0d8f0d521de9f36" translate="yes" xml:space="preserve">
          <source>Prints the value of ⟨identifier⟩ in the same way as &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. Unlike &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; evaluates each thunk that it encounters while traversing the value. This may cause exceptions or infinite loops, or further breakpoints (which are ignored, but displayed).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 &quot;identifier&quot;값을 인쇄 합니다. 달리 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; 값을 통과하면서 발생하는 각 썽크을 평가한다. 이로 인해 예외 또는 무한 루프 또는 추가 중단 점 (무시되지만 표시됨)이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61486fb3c29083825fc530e85db902f694779e3" translate="yes" xml:space="preserve">
          <source>PrioIOAvailable</source>
          <target state="translated">PrioIOAvailable</target>
        </trans-unit>
        <trans-unit id="cbad2d411713243f18b25f4ad0c20cdf1f597155" translate="yes" xml:space="preserve">
          <source>Prior to GHC 8.10, when passing an &lt;code&gt;ArrayArray#&lt;/code&gt; argument to a foreign function, the foreign function would see a pointer to the &lt;code&gt;StgMutArrPtrs&lt;/code&gt; rather than just the payload.</source>
          <target state="translated">GHC 8.10 이전에는 &lt;code&gt;ArrayArray#&lt;/code&gt; 인수를 외부 함수에 전달할 때 외부 함수가 페이로드가 아닌 &lt;code&gt;StgMutArrPtrs&lt;/code&gt; 에 대한 포인터를 볼 수 있었습니다 .</target>
        </trans-unit>
        <trans-unit id="fabfc2adbe5a1490690f6f40c6d623b433df0934" translate="yes" xml:space="preserve">
          <source>Prior to version 1.4.0.0, the default implementation of the &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method was defined as</source>
          <target state="translated">버전 1.4.0.0 이전에는 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 메소드 의 기본 구현 이 다음과 같이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="cda4f4476ac13bb2ae7bc15ee6736ba96cc21c68" translate="yes" xml:space="preserve">
          <source>PrivateUse</source>
          <target state="translated">PrivateUse</target>
        </trans-unit>
        <trans-unit id="77a4e6819b3e432af8190d38019f1fa2de3878fb" translate="yes" xml:space="preserve">
          <source>Probalistic Miller-Rabin primality test.</source>
          <target state="translated">Probalistic Miller-Rabin 원시성 테스트.</target>
        </trans-unit>
        <trans-unit id="52ec5a32c2a80f826813962523827657c92e7c45" translate="yes" xml:space="preserve">
          <source>ProcRetHandles</source>
          <target state="translated">ProcRetHandles</target>
        </trans-unit>
        <trans-unit id="59240a07db79f390a176a1da2a0e4e73723df8cb" translate="yes" xml:space="preserve">
          <source>Proceed as normal, but do not delete any intermediate files.</source>
          <target state="translated">정상적으로 진행되지만 중간 파일은 삭제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3413e1941d2b768b5d94e902b36b50f24a0b9e21" translate="yes" xml:space="preserve">
          <source>Process completion</source>
          <target state="translated">프로세스 완료</target>
        </trans-unit>
        <trans-unit id="78730cfe630ab980fa7c67900c84883cadf329d1" translate="yes" xml:space="preserve">
          <source>Process environment</source>
          <target state="translated">공정 환경</target>
        </trans-unit>
        <trans-unit id="c650b71115a88a0c6c8c39f8cb70327da49c6469" translate="yes" xml:space="preserve">
          <source>Process groups</source>
          <target state="translated">프로세스 그룹</target>
        </trans-unit>
        <trans-unit id="e19a92ef9380a074cb7ab3ec33973d7ac5dd17b1" translate="yes" xml:space="preserve">
          <source>Process status</source>
          <target state="translated">공정 상태</target>
        </trans-unit>
        <trans-unit id="450d3838ec09ee134c6165b911e3bfce5c2da9f2" translate="yes" xml:space="preserve">
          <source>Process the command-line, and return the list of values that matched (and those that didn't). The arguments are:</source>
          <target state="translated">명령 행을 처리하고 일치하는 값과 일치하지 않는 값의 목록을 리턴하십시오. 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="165237f99277fa9f8a75372d3b27ef4e2226ebb6" translate="yes" xml:space="preserve">
          <source>Process times</source>
          <target state="translated">처리 시간</target>
        </trans-unit>
        <trans-unit id="b8940363e3104375a16f75f2a6c0076297b5bcc8" translate="yes" xml:space="preserve">
          <source>ProcessAccessRights</source>
          <target state="translated">ProcessAccessRights</target>
        </trans-unit>
        <trans-unit id="6feb0f0bc2fdaddeeb0ce66961c31fda1b5189f4" translate="yes" xml:space="preserve">
          <source>ProcessEntry32</source>
          <target state="translated">ProcessEntry32</target>
        </trans-unit>
        <trans-unit id="3c0317db948b70e6ca821af4a8b48f2b33ee6e46" translate="yes" xml:space="preserve">
          <source>ProcessGroupID</source>
          <target state="translated">ProcessGroupID</target>
        </trans-unit>
        <trans-unit id="21e8dd5d13542f0c6a51fa47c09f48b388d00925" translate="yes" xml:space="preserve">
          <source>ProcessHandle</source>
          <target state="translated">ProcessHandle</target>
        </trans-unit>
        <trans-unit id="2f4686b1023443590b468cf68975e34698d5dce7" translate="yes" xml:space="preserve">
          <source>ProcessHandle__</source>
          <target state="translated">ProcessHandle__</target>
        </trans-unit>
        <trans-unit id="5906efeedbc929caae1ebc56efbb67f6db7d732f" translate="yes" xml:space="preserve">
          <source>ProcessID</source>
          <target state="translated">ProcessID</target>
        </trans-unit>
        <trans-unit id="0e72272456a5dfc962478aaa4cd24c7dbdabd6cf" translate="yes" xml:space="preserve">
          <source>ProcessId</source>
          <target state="translated">ProcessId</target>
        </trans-unit>
        <trans-unit id="01ccef775dbbfe8438822cf4c77cb31753b62e29" translate="yes" xml:space="preserve">
          <source>ProcessId, number of threads, parent ProcessId, process base priority, path of executable file</source>
          <target state="translated">ProcessId, 스레드 수, 상위 ProcessId, 프로세스 기본 우선 순위, 실행 파일 경로</target>
        </trans-unit>
        <trans-unit id="14d4e6622d64799268058fe065228ec4cdce7733" translate="yes" xml:space="preserve">
          <source>ProcessInput</source>
          <target state="translated">ProcessInput</target>
        </trans-unit>
        <trans-unit id="b1f9a72a478a9193ff3d8c1d61ee84b82b8b55d5" translate="yes" xml:space="preserve">
          <source>ProcessOutput</source>
          <target state="translated">ProcessOutput</target>
        </trans-unit>
        <trans-unit id="b85a49842dd03687134a104f7f2c219a332fd41b" translate="yes" xml:space="preserve">
          <source>ProcessStatus</source>
          <target state="translated">ProcessStatus</target>
        </trans-unit>
        <trans-unit id="6f22a38212f7ae729981dc2920c82da11507b5bd" translate="yes" xml:space="preserve">
          <source>ProcessTimes</source>
          <target state="translated">ProcessTimes</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="d9138d8dd701d266606ca4c3ec53b292b58d6a6e" translate="yes" xml:space="preserve">
          <source>Processing Strings into Html friendly things.</source>
          <target state="translated">HTML 친화적 인 것으로 문자열 처리.</target>
        </trans-unit>
        <trans-unit id="31e08f0a5d6400f5a893fc895b0737af9fc1c866" translate="yes" xml:space="preserve">
          <source>Processor features</source>
          <target state="translated">프로세서 기능</target>
        </trans-unit>
        <trans-unit id="51346a24d3f29d2ffa996e556945ed4655cf318e" translate="yes" xml:space="preserve">
          <source>ProcessorFeature</source>
          <target state="translated">ProcessorFeature</target>
        </trans-unit>
        <trans-unit id="3fb1ad2abc3a670a4b947bec2fed69232206dac4" translate="yes" xml:space="preserve">
          <source>Produce &amp;ldquo;ticky-ticky&amp;rdquo; statistics at the end of the program run (only available if the program was linked with &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;). The ⟨file⟩ business works just like on the &lt;a href=&quot;#rts-flag--S%20%5B%E2%9F%A8file%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-S [⟨file⟩]&lt;/code&gt;&lt;/a&gt; RTS option, above.</source>
          <target state="translated">프로그램 실행이 끝날 때 &quot;ticky-ticky&quot;통계를 생성합니다 (프로그램이 &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt; 와 연결된 경우에만 사용 가능 ). ⟨file⟩ 비즈니스는 위의 &lt;a href=&quot;#rts-flag--S%20%5B%E2%9F%A8file%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; &lt;/a&gt; RTS 옵션과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6cf463b6f4624fb94cd58e7897c4e59d5fb1fb3f" translate="yes" xml:space="preserve">
          <source>Produce DWARF debug information in compiled object files. ⟨n⟩ can be 0, 1, or 2, with higher numbers producing richer output. If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">컴파일 된 객체 파일에서 DWARF 디버그 정보를 생성합니다. ⟨n⟩은 0, 1 또는 2 일 수 있으며 숫자가 많을수록 더 풍부한 출력을 생성합니다. ⟨n⟩을 생략하면 레벨 2로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="311b86090be24794748573ba1bb8b1841bef8144" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Frameset.</source>
          <target state="translated">XHTML 1.0 프레임 세트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f0bce322e51b0e5e1f30cc905d309ee358c3950a" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Strict.</source>
          <target state="translated">XHTML 1.0 Strict를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="feb762b8a956256336a4059b532f2566785ff8e7" translate="yes" xml:space="preserve">
          <source>Produces XHTML 1.0 Transitional.</source>
          <target state="translated">XHTML 1.0 과도기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dd3b86d1ef21b9fb2e1edc30f524e7afb491b1ad" translate="yes" xml:space="preserve">
          <source>Product</source>
          <target state="translated">Product</target>
        </trans-unit>
        <trans-unit id="9436b2fdb0e7c34a33a3c91d959bba1406290a1a" translate="yes" xml:space="preserve">
          <source>ProductType</source>
          <target state="translated">ProductType</target>
        </trans-unit>
        <trans-unit id="0c7c0674cb4b4821337188133a7e093a0462c24f" translate="yes" xml:space="preserve">
          <source>Products, lifted to functors.</source>
          <target state="translated">펑터로 들어 올려 진 제품.</target>
        </trans-unit>
        <trans-unit id="45873739b5a096f14b6618d0351cf66a0fc902fa" translate="yes" xml:space="preserve">
          <source>Products: encode multiple arguments to constructors</source>
          <target state="translated">제품 : 생성자에 여러 인수를 인코딩</target>
        </trans-unit>
        <trans-unit id="3baa38b5927954f86d772798f9128466bb7cb156" translate="yes" xml:space="preserve">
          <source>ProfFlags</source>
          <target state="translated">ProfFlags</target>
        </trans-unit>
        <trans-unit id="684ae62f53358a3d6fa087ccc73007ad4415d51e" translate="yes" xml:space="preserve">
          <source>Profiling a program is a three-step process:</source>
          <target state="translated">프로그램 프로파일 링은 3 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="8b0bf225ec1be7116f5172952f591da561f081d7" translate="yes" xml:space="preserve">
          <source>Profiling call stacks</source>
          <target state="translated">프로파일 링 콜 스택</target>
        </trans-unit>
        <trans-unit id="182323e605505b651eaa881921e0342a44be8b4d" translate="yes" xml:space="preserve">
          <source>Program arguments</source>
          <target state="translated">프로그램 인수</target>
        </trans-unit>
        <trans-unit id="f0abc2008747749add9fef13512caaf5675a5840" translate="yes" xml:space="preserve">
          <source>Programmers using the &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API should be aware that EAGAIN exceptions may occur for non-blocking IO!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-posix-io#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API를 사용하는 프로그래머 는 비 차단 IO에 대해 EAGAIN 예외가 발생할 수 있음을 알고 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="6e4856079c43518428585d9f6f55af53723c39a0" translate="yes" xml:space="preserve">
          <source>Programmers using the &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API should be aware that EAGAIN exceptions may occur for non-blocking IO!</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdRead&quot;&gt;fdRead&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:fdWrite&quot;&gt;fdWrite&lt;/a&gt;&lt;/code&gt; API를 사용하는 프로그래머 는 비 차단 IO에 대해 EAGAIN 예외가 발생할 수 있음을 알고 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="f5db4bda11e8bec3e596786fc436f585dc33173f" translate="yes" xml:space="preserve">
          <source>Programs compiled with &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; may fail a bit more eagerly than one might expect. For instance,</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 프로그램 은 예상보다 조금 더 실패 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ec0bc39a0924b82acddd145c4bb3e23cd22b3bc0" translate="yes" xml:space="preserve">
          <source>Progress will usually be made by skipping the first element of the &lt;code&gt;from&lt;/code&gt; buffer. This function should only be called if you are certain that you wish to do this skipping and if the &lt;code&gt;to&lt;/code&gt; buffer has at least one element of free space. Because this function deals with decoding failure, it assumes that the from buffer has at least one element.</source>
          <target state="translated">일반적으로 &lt;code&gt;from&lt;/code&gt; 버퍼 의 첫 번째 요소를 건너 뛰어 진행 합니다. 이 함수는이 건너 뛰기를하려는 것이 확실하고 &lt;code&gt;to&lt;/code&gt; 버퍼에 여유 공간이 하나 이상있는 경우에만 호출해야 합니다. 이 함수는 디코딩 실패를 처리하기 때문에 from 버퍼에 하나 이상의 요소가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a01e7be7e338ce65feff32bc980eb7c0c7eb6754" translate="yes" xml:space="preserve">
          <source>Projection to the other functor.</source>
          <target state="translated">다른 functor로 투사.</target>
        </trans-unit>
        <trans-unit id="aaf4dfbf169435dac06d1f7571397f1db30f3f9a" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right (cf. &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">왼쪽에서 오른쪽으로 모나드 인수를 스캔하여 모나드에 함수를 승격하십시오 ( &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="90322d805d75363f5e2ba902de35d5fb3e329291" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right (cf. &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">왼쪽에서 오른쪽으로 모나드 인수를 스캔하여 모나드에 함수를 승격하십시오 ( &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM2&quot;&gt;liftM2&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5b1e023440a1d1251cab82a65c8a674a9ce8f45f" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad, scanning the monadic arguments from left to right. For example,</source>
          <target state="translated">모나드 인수를 왼쪽에서 오른쪽으로 스캔하여 함수를 모나드로 승격하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f05ff30359fcf6d0cd737c9742b3ce528d2a61e0" translate="yes" xml:space="preserve">
          <source>Promote a function to a monad.</source>
          <target state="translated">함수를 모나드로 승격하십시오.</target>
        </trans-unit>
        <trans-unit id="bb699540cce051f9cc1055d53e69e00d6ddd26ac" translate="yes" xml:space="preserve">
          <source>PromotedConsT</source>
          <target state="translated">PromotedConsT</target>
        </trans-unit>
        <trans-unit id="6c11a71a788afd02567c23eab945ff6f9118b661" translate="yes" xml:space="preserve">
          <source>PromotedNilT</source>
          <target state="translated">PromotedNilT</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="0cbea5295e2b199673171bae00d25211a4daa049" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only). The default definition uses &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 대체 할 것을 제안했습니다 (GHC 만 해당). 기본 정의는 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . 정의 인스턴스 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 이 또한 정의해야 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 을 로 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c383bc233d01d9f33a1db1df2275ceb34c0bb2c" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only).</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 대체 할 것을 제안했습니다 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="25cf3b2ae91b78e363c940dfba15d79fbbffe0a5" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only). The default definition uses &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 대체 할 것을 제안했습니다 (GHC 만 해당). 기본 정의는 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 를 사용 합니다 . 정의 인스턴스 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 이 또한 정의해야 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 을 로 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f8243ce4f1bb9b8bfb0f67f0f3ba9911430da3" translate="yes" xml:space="preserve">
          <source>Proposed replacement for &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; using new-style parsers (GHC only).</source>
          <target state="translated">새로운 스타일의 파서를 사용하여 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 대체 할 것을 제안했습니다 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="a22e8bd59e18b97a41af964d0ba41a98b37ab76a" translate="yes" xml:space="preserve">
          <source>Propositional equality</source>
          <target state="translated">제안 평등</target>
        </trans-unit>
        <trans-unit id="a96dd404b246333ac1350164ef1732587afa0abb" translate="yes" xml:space="preserve">
          <source>Propositional equality. If &lt;code&gt;a :~: b&lt;/code&gt; is inhabited by some terminating value, then the type &lt;code&gt;a&lt;/code&gt; is the same as the type &lt;code&gt;b&lt;/code&gt;. To use this equality in practice, pattern-match on the &lt;code&gt;a :~: b&lt;/code&gt; to get out the &lt;code&gt;Refl&lt;/code&gt; constructor; in the body of the pattern-match, the compiler knows that &lt;code&gt;a ~ b&lt;/code&gt;.</source>
          <target state="translated">제안 평등. 경우 &lt;code&gt;a :~: b&lt;/code&gt; 일부 종단 값 살고 다음 타입 &lt;code&gt;a&lt;/code&gt; 타입과 동일 &lt;code&gt;b&lt;/code&gt; . 실제로이 동등성을 사용하려면 &lt;code&gt;a :~: b&lt;/code&gt; 의 패턴 일치를 사용 하여 &lt;code&gt;Refl&lt;/code&gt; 생성자 를 가져옵니다 . 패턴 일치 본문에서 컴파일러는 &lt;code&gt;a ~ b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcb3452df3c76dae9ccbe4cb023c0ba8d83c8c7a" translate="yes" xml:space="preserve">
          <source>ProtectSectionFlags</source>
          <target state="translated">ProtectSectionFlags</target>
        </trans-unit>
        <trans-unit id="a48acfe3b05f29ef5d32e9c4686c610f7573d3ab" translate="yes" xml:space="preserve">
          <source>ProtocolError</source>
          <target state="translated">ProtocolError</target>
        </trans-unit>
        <trans-unit id="f505fd6f5c51f1f0eb05dff31b6b08cb2672b51b" translate="yes" xml:space="preserve">
          <source>Provide a Semigroup for an arbitrary Monoid.</source>
          <target state="translated">임의의 Monoid에 대한 세미 그룹을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d826fc994ddc518cced2dcde7f6017e636b0aac9" translate="yes" xml:space="preserve">
          <source>Provide an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action with the current value of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; will be empty for the duration that the action is running.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 현재 값으로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치를 제공하십시오 . &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 작업이 실행되고있는 기간 동안 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d318ed93837d829decf4e305a098deca627cd45c" translate="yes" xml:space="preserve">
          <source>Provide sendInput function and INPUT types.</source>
          <target state="translated">sendInput 기능 및 INPUT 유형을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="08b1b035b9a9a2acbcca06ac2bc748267d24aace" translate="yes" xml:space="preserve">
          <source>Provided for backwards compatibility. The tok type is ignored.</source>
          <target state="translated">이전 버전과의 호환성을 위해 제공됩니다. 톡 타입은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bc9561c0283aa709c213cb1d134bcbaf33279f" translate="yes" xml:space="preserve">
          <source>Provided that you also specify &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), the &lt;code&gt;forall b&lt;/code&gt; scopes over the definition of &lt;code&gt;foo&lt;/code&gt;, and in particular over the type signature for &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 지정할 것을 제공 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 을&lt;/a&gt; ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 적 유형 변수를 범위&lt;/a&gt; ) &lt;code&gt;forall b&lt;/code&gt; 의 정의를 통해 스코프 &lt;code&gt;foo&lt;/code&gt; 는 , 및의 형태 서명을 통해 특히 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e2d81ac00c42bbf57971469cfadfc86bb02898" translate="yes" xml:space="preserve">
          <source>Provided you compiled this plugin and registered it in a package (with cabal for instance,) you can then use it by just specifying &lt;code&gt;-fplugin=DoNothing.Plugin&lt;/code&gt; on the command line, and during the compilation you should see GHC say &amp;lsquo;Hello&amp;rsquo;.</source>
          <target state="translated">이 플러그인을 컴파일하고 패키지에 등록한 경우 (예 &lt;code&gt;-fplugin=DoNothing.Plugin&lt;/code&gt; 명령 행에 -fplugin = DoNothing.Plugin 을 지정하여 사용할 수 있으며 컴파일 중에 GHC에 'Hello'라고 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="91cdb89ab74dded95989b9c01dab7eab785914db" translate="yes" xml:space="preserve">
          <source>Provided you have compiled this plugin and registered it in a package, you can just use it by specifying &lt;code&gt;--frontend DoNothing.FrontendPlugin&lt;/code&gt; on the command line to GHC.</source>
          <target state="translated">이 플러그인을 컴파일하고 패키지에 등록한 경우 명령 행에서 &lt;code&gt;--frontend DoNothing.FrontendPlugin&lt;/code&gt; 을 GHC에 지정하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97713c7be8cb2223c431b97c899d5f61eca5a254" translate="yes" xml:space="preserve">
          <source>Provides a collection of pretty printer combinators, a set of API's that provides a way to easily print out text in a consistent format of your choosing.</source>
          <target state="translated">일관된 형식으로 텍스트를 쉽게 인쇄 할 수있는 API 세트 인 예쁜 프린터 조합기 모음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3569e2937eb1626a3038f9ca0b0bd6a7c4988dd" translate="yes" xml:space="preserve">
          <source>Provides one possible concrete representation for &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt;. For a version with &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt;&lt;code&gt;= [1,2,3]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt;&lt;code&gt;= [&quot;tag1&quot;,&quot;tag2&quot;]&lt;/code&gt;, the output will be &lt;code&gt;1.2.3-tag1-tag2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 에 대한 하나의 가능한 구체적인 표현을 제공합니다 . 와 버전 &lt;code&gt;&lt;a href=&quot;data-version#v:versionBranch&quot;&gt;versionBranch&lt;/a&gt;&lt;/code&gt; &lt;code&gt;= [1,2,3]&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-version#v:versionTags&quot;&gt;versionTags&lt;/a&gt;&lt;/code&gt; &lt;code&gt;= [&quot;tag1&quot;,&quot;tag2&quot;]&lt;/code&gt; , 출력은 것 &lt;code&gt;1.2.3-tag1-tag2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f537eae177b03bcfe703fb9eae32845fd317076" translate="yes" xml:space="preserve">
          <source>Provides the standard warnings plus</source>
          <target state="translated">표준 경고와 함께 제공</target>
        </trans-unit>
        <trans-unit id="0bd63287653bab9cbabb2d0d820a7d6b107dd1f0" translate="yes" xml:space="preserve">
          <source>Providing &lt;code&gt;-pgmi /path/to/iserv-proxy&lt;/code&gt;, &lt;code&gt;-pgmo ⟨option⟩&lt;/code&gt; and &lt;code&gt;-pgmo ⟨port⟩&lt;/code&gt; in addition to &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; will then make ghc go through the proxy instead.</source>
          <target state="translated">제공 &lt;code&gt;-pgmi /path/to/iserv-proxy&lt;/code&gt; , &lt;code&gt;-pgmo ⟨option⟩&lt;/code&gt; 및 &lt;code&gt;-pgmo ⟨port⟩&lt;/code&gt; 에 추가 &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 다음 대신 프록시를 통해 GHC 이동을하게됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e9e18be4d476228c864a05eb9ce60a2f180d98" translate="yes" xml:space="preserve">
          <source>Providing input</source>
          <target state="translated">입력 제공</target>
        </trans-unit>
        <trans-unit id="e29e8eedc748840bd27ace9f3607818fa75df015" translate="yes" xml:space="preserve">
          <source>Provisional</source>
          <target state="translated">Provisional</target>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="2da1b11ef737c06a07580fdc89d729829ccbcd4b" translate="yes" xml:space="preserve">
          <source>Proxy can even hold types of higher kinds,</source>
          <target state="translated">프록시는 더 높은 종류의 유형을 보유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="010320dc44b945f1389c719222db299dcff6de12" translate="yes" xml:space="preserve">
          <source>Proxy#</source>
          <target state="translated">Proxy#</target>
        </trans-unit>
        <trans-unit id="1ba5ef48b66f74ab8376d1e1f5b429151921ef64" translate="yes" xml:space="preserve">
          <source>Ps: Punctuation, Open</source>
          <target state="translated">시 : 구두점, 공개</target>
        </trans-unit>
        <trans-unit id="aee53da1d005df2b730db32fdeb589f79f6dcef6" translate="yes" xml:space="preserve">
          <source>Pseudoterminal operations</source>
          <target state="translated">의사 터미널 연산</target>
        </trans-unit>
        <trans-unit id="90c83157f6f4a1cfac097841eb12dca4943e9e58" translate="yes" xml:space="preserve">
          <source>Ptr</source>
          <target state="translated">Ptr</target>
        </trans-unit>
        <trans-unit id="6ae22c161ea98cdfc51e0fe5643ee1613027f054" translate="yes" xml:space="preserve">
          <source>Public API</source>
          <target state="translated">퍼블릭 API</target>
        </trans-unit>
        <trans-unit id="7f59b284c28fa26b669e4ff42d0673d94b35db1d" translate="yes" xml:space="preserve">
          <source>Public representation of constructors</source>
          <target state="translated">생성자의 공개 표현</target>
        </trans-unit>
        <trans-unit id="b6c8b265dd1cdc6347d98f2b84d442a954eb9c33" translate="yes" xml:space="preserve">
          <source>Public representation of datatypes</source>
          <target state="translated">데이터 유형의 공개 표현</target>
        </trans-unit>
        <trans-unit id="3a2bbb378012d44dd1acf3c097c561543bbe6aa6" translate="yes" xml:space="preserve">
          <source>Punctuation or reserved symbol, e.g. &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">문장 부호 또는 예약 기호 (예 : &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dfef0dd557351856f42ce75d6f0e19c19a4c0ef" translate="yes" xml:space="preserve">
          <source>Puns and other patterns can be mixed in the same record:</source>
          <target state="translated">Puns 및 기타 패턴은 동일한 레코드에서 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="126aca4de6cf9f540218b2f37eb0a5ee3e8ee157" translate="yes" xml:space="preserve">
          <source>Puns are not necessarily supported:</source>
          <target state="translated">Puns가 반드시 지원되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f9f539fc385ba1011d4c087559f3df068ae7d719" translate="yes" xml:space="preserve">
          <source>Puns can be used wherever record patterns occur (e.g. in &lt;code&gt;let&lt;/code&gt; bindings or at the top-level).</source>
          <target state="translated">기록 패턴이 발생하는 곳 말장난 (예에서 사용할 수 &lt;code&gt;let&lt;/code&gt; 바인딩 또는 최상위 레벨에서).</target>
        </trans-unit>
        <trans-unit id="6b611b1b174cd71f53f8fab72d5be8b17f1336a4" translate="yes" xml:space="preserve">
          <source>Purity</source>
          <target state="translated">Purity</target>
        </trans-unit>
        <trans-unit id="9a02d38905933d4f8be56965d4333c36eabb3bcc" translate="yes" xml:space="preserve">
          <source>Push a call-site onto the stack.</source>
          <target state="translated">콜 사이트를 스택에 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7fd768e4fe7bd6bb51e495079370749b0bfeabc8" translate="yes" xml:space="preserve">
          <source>Put</source>
          <target state="translated">Put</target>
        </trans-unit>
        <trans-unit id="31cfeabab1a1a50a1974ce9355eca97ad84b2ad5" translate="yes" xml:space="preserve">
          <source>Put a data item back onto a channel, where it will be the next item read.</source>
          <target state="translated">데이터 항목을 다시 채널에 넣고 다음 항목을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f2671cfd2bf701d44ddbd6aed0423a20b49e9b05" translate="yes" xml:space="preserve">
          <source>Put a data item back onto a channel, where it will be the next item read. Blocks if the queue is full.</source>
          <target state="translated">데이터 항목을 다시 채널에 넣고 다음 항목을 읽습니다. 큐가 가득 찬 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="0488379e7024b984e65d02dffd4763eb7cd460ed" translate="yes" xml:space="preserve">
          <source>Put a value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 현재 가득 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 는 것이다 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd93b0ceaf0ed39d5195f954abbfc8d76b2a79d6" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="42a8fc7267ae8c1ccb347fa39255e3fe7bc6ca11" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 입력합니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c94d281c3905d94e39b3d263b1cf9b6250c58bee" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="33e8d3ac33132ba689a91323286fa0c8d9cd0c54" translate="yes" xml:space="preserve">
          <source>Put a value into an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently full, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; will wait until it becomes empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 값을 넣 습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 가득, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 은 비어 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="73b3278fe6bb373e8f3ee5addd3728dbee9dc19b" translate="yes" xml:space="preserve">
          <source>Put merely lifts Builder into a Writer monad, applied to ().</source>
          <target state="translated">Put은 Builder를 Writer 모나드로 들어 올리고 ()에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="798e33a0a2f8665389e39345a5dfc2a745e465a9" translate="yes" xml:space="preserve">
          <source>Put something inside an HTML element.</source>
          <target state="translated">HTML 요소 안에 무언가를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="40d8d868890674e2158985b5244b5e97bbdc32ef" translate="yes" xml:space="preserve">
          <source>Put to run</source>
          <target state="translated">뛰다</target>
        </trans-unit>
        <trans-unit id="b438a3bf094fbf042e7f48cbd844a202bc700f5d" translate="yes" xml:space="preserve">
          <source>Put two pieces of error message next to each other.</source>
          <target state="translated">두 개의 오류 메시지를 나란히 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="353d5eefcc26e9ede7b76010beb4c768d6085770" translate="yes" xml:space="preserve">
          <source>PutM</source>
          <target state="translated">PutM</target>
        </trans-unit>
        <trans-unit id="f84ae14fa11d241b306d7b6dacccea9c11140d12" translate="yes" xml:space="preserve">
          <source>Putting a strictness annotation (&lt;code&gt;!&lt;/code&gt;) on a constructor field helps in two ways: it adds strictness to the program, which gives the strictness analyser more to work with, and it might help to reduce space leaks.</source>
          <target state="translated">생성자 필드에 엄격 주석 ( &lt;code&gt;!&lt;/code&gt; )을 넣으면 다음과 같은 두 가지 방법으로 도움이됩니다. 프로그램에 엄격을 추가하여 엄격 분석기를 더 많이 사용할 수있게하며 공간 누출을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d65a7ee4d88fd2fe1e2a7a6c25c43f4bace4b92" translate="yes" xml:space="preserve">
          <source>Putting info tables directly next to entry code is a useful performance optimisation that is not available on all platforms. This field tells you whether the program has been compiled with this optimisation. (Usually yes, except on unusual platforms.)</source>
          <target state="translated">입력 코드 바로 옆에 정보 테이블을 배치하는 것은 모든 플랫폼에서 사용할 수없는 유용한 성능 최적화입니다. 이 필드는 프로그램이이 최적화로 컴파일되었는지 여부를 알려줍니다. (특별한 플랫폼을 제외하고 일반적으로 예)</target>
        </trans-unit>
        <trans-unit id="fc4647bde0eb248bbe66e4e9d89dc56ee1bf2032" translate="yes" xml:space="preserve">
          <source>Putting inter-dependencies of the form &lt;code&gt;Foo.o : Bar.hi&lt;/code&gt; into your &lt;code&gt;Makefile&lt;/code&gt; by hand is rather error-prone. Don&amp;rsquo;t worry, GHC has support for automatically generating the required dependencies. Add the following to your &lt;code&gt;Makefile&lt;/code&gt;:</source>
          <target state="translated">형태의 상호 의존성 퍼팅 &lt;code&gt;Foo.o : Bar.hi&lt;/code&gt; 당신에 &lt;code&gt;Makefile&lt;/code&gt; 손으로 오히려 오류가 발생하기 쉬운입니다. 걱정하지 마십시오. GHC는 필요한 종속성을 자동으로 생성하도록 지원합니다. &lt;code&gt;Makefile&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="b1bf446133c15f6e0cfb6c252c0760ca97cc2113" translate="yes" xml:space="preserve">
          <source>QException</source>
          <target state="translated">QException</target>
        </trans-unit>
        <trans-unit id="5c3e1075bb5ff5f786a2750d2110c97ca76bdb40" translate="yes" xml:space="preserve">
          <source>QList</source>
          <target state="translated">QList</target>
        </trans-unit>
        <trans-unit id="5063349bbf20d077106dd5a047c6294b3d6faa07" translate="yes" xml:space="preserve">
          <source>QResult</source>
          <target state="translated">QResult</target>
        </trans-unit>
        <trans-unit id="1b9473a808c71ad809b076a8f41d58515d649af1" translate="yes" xml:space="preserve">
          <source>QSem</source>
          <target state="translated">QSem</target>
        </trans-unit>
        <trans-unit id="83666298382103e09a359d83713e8de361f9fe1b" translate="yes" xml:space="preserve">
          <source>QSemN</source>
          <target state="translated">QSemN</target>
        </trans-unit>
        <trans-unit id="5979a484b578a0eaaccbbaa187d6db5be875c706" translate="yes" xml:space="preserve">
          <source>QState</source>
          <target state="translated">QState</target>
        </trans-unit>
        <trans-unit id="a8e2772564815455b855b5402a2b67edaeece741" translate="yes" xml:space="preserve">
          <source>QualBinBox</source>
          <target state="translated">QualBinBox</target>
        </trans-unit>
        <trans-unit id="6e364224ed95e99cc9c0e9bc962a7e7788451d4f" translate="yes" xml:space="preserve">
          <source>Qualified names are not handled properly</source>
          <target state="translated">정규화 된 이름이 올바르게 처리되지 않습니다</target>
        </trans-unit>
        <trans-unit id="c78f05422fd2f2885a1a8363abe3991f2f66b957" translate="yes" xml:space="preserve">
          <source>Quantified</source>
          <target state="translated">Quantified</target>
        </trans-unit>
        <trans-unit id="98d966bd103c45a24b72c82c92fc882386ac5126" translate="yes" xml:space="preserve">
          <source>Quantified constraints can potentially lead to overlapping local axioms. Consider for instance the following example:</source>
          <target state="translated">정량화 된 구속 조건은 잠재적으로 국소 공리가 겹칠 수 있습니다. 예를 들어 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e07c2ce6f83e492712da4fb9336c9693d0145f90" translate="yes" xml:space="preserve">
          <source>Quantified constraints enable this property to be made explicit in the &lt;code&gt;Trans&lt;/code&gt; class declaration:</source>
          <target state="translated">정량화 된 제약 조건을 통해 &lt;code&gt;Trans&lt;/code&gt; 클래스 선언 에서이 속성을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="313f18ee6bfe32a684a3623fe9ec8d0285e1564b" translate="yes" xml:space="preserve">
          <source>QuantifiedConstraints</source>
          <target state="translated">QuantifiedConstraints</target>
        </trans-unit>
        <trans-unit id="38dd040ad4dd1961b970e417a446a2cd00ec0112" translate="yes" xml:space="preserve">
          <source>Quantity semaphores in which each thread may wait for an arbitrary &quot;amount&quot;.</source>
          <target state="translated">각 스레드가 임의의 &quot;금액&quot;을 기다릴 수있는 수량 세마포어.</target>
        </trans-unit>
        <trans-unit id="ef37116e9e2794514df2a30b389623e522929de7" translate="yes" xml:space="preserve">
          <source>Quasi</source>
          <target state="translated">Quasi</target>
        </trans-unit>
        <trans-unit id="78b42522f21485e6763e2011e69bf1fb6467d5cd" translate="yes" xml:space="preserve">
          <source>Quasi-quotation allows patterns and expressions to be written using programmer-defined concrete syntax; the motivation behind the extension and several examples are documented in &amp;ldquo;&lt;a href=&quot;http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf&quot;&gt;Why It&amp;rsquo;s Nice to be Quoted: Quasiquoting for Haskell&lt;/a&gt;&amp;rdquo; (Proc Haskell Workshop 2007). The example below shows how to write a quasiquoter for a simple expression language.</source>
          <target state="translated">준 따옴표는 프로그래머 정의 콘크리트 구문을 사용하여 패턴과 표현을 작성할 수 있도록합니다. 확장에 대한 동기 부여와 몇 가지 예는&amp;ldquo; &lt;a href=&quot;http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf&quot;&gt;인용하기 좋은 이유 : Haskell에 대한 Quaquota&lt;/a&gt; &amp;rdquo;(Proc Haskell Workshop 2007)에 설명되어 있습니다. 아래 예제는 간단한 표현 언어를위한 준 따옴표를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aeae4316f159225a12a41875ed5cda162b6be2c0" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for declarations, invoked by top-level quotes</source>
          <target state="translated">최상위 인용 부호로 호출 된 선언을위한 준 따옴표</target>
        </trans-unit>
        <trans-unit id="7c4eccaa645a118a37207f34bc767fc3a301a004" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for expressions, invoked by quotes like &lt;code&gt;lhs = $[q|...]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lhs = $[q|...]&lt;/code&gt; 와 같은 따옴표로 호출 된 표현식의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="cdfa152b402869c6f7ce110c7260465306996f0c" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for patterns, invoked by quotes like &lt;code&gt;f $[q|...] = rhs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f $[q|...] = rhs&lt;/code&gt; 와 같은 따옴표로 호출 된 패턴의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="2f1c81121c7c915fc9fe161e70133e5fd79fdc0f" translate="yes" xml:space="preserve">
          <source>Quasi-quoter for types, invoked by quotes like &lt;code&gt;f :: $[q|...]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f :: $[q|...]&lt;/code&gt; 와 같은 따옴표로 호출 된 형식의 준 따옴표</target>
        </trans-unit>
        <trans-unit id="654d8edecc919612fe0b6f4ce5f5f07b94d042af" translate="yes" xml:space="preserve">
          <source>QuasiQuoter</source>
          <target state="translated">QuasiQuoter</target>
        </trans-unit>
        <trans-unit id="36eafab474a9ed345234950640432af8a19c94cf" translate="yes" xml:space="preserve">
          <source>QuasiQuotes</source>
          <target state="translated">QuasiQuotes</target>
        </trans-unit>
        <trans-unit id="d4a0b7daa1a07138f6cd3dd945862252eb44e73e" translate="yes" xml:space="preserve">
          <source>Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in the example, &lt;code&gt;expr&lt;/code&gt; cannot be defined in &lt;code&gt;Main.hs&lt;/code&gt; where it is used, but must be imported.</source>
          <target state="translated">Quasquoters는 Template Haskell과 동일한 단계 제한을 준수해야합니다. 예를 들어 &lt;code&gt;expr&lt;/code&gt; 은 &lt;code&gt;Main.hs&lt;/code&gt; 에서 사용되는 곳 에서 정의 할 수 없지만 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="702b96b7b97e9c49a9631b74e04d25040710ddfc" translate="yes" xml:space="preserve">
          <source>Queries the current state of the stopped child flag.</source>
          <target state="translated">중지 된 자식 플래그의 현재 상태를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="6fafa7df09744bce9b17c8089123f793f4571cfc" translate="yes" xml:space="preserve">
          <source>Query the status of a breakpoint (True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; enabled)</source>
          <target state="translated">중단 점 상태 조회 (True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; enabled)</target>
        </trans-unit>
        <trans-unit id="3caf953d995669733dac7e8ef33e2624ffc487eb" translate="yes" xml:space="preserve">
          <source>Query whether the current runtime system supports the eventlog (e.g. whether the current executable was linked with &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt;) and, if it is supported, whether it is currently logging.</source>
          <target state="translated">현재 런타임 시스템이 이벤트 로그를 지원하는지 여부 (예 : 현재 실행 파일이 &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; 와 연결되었는지 여부 ) 및 지원되는 경우 현재 로깅 중인지 여부를 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="ec6aec17edf79a10c680aff1016df32c0c809598" translate="yes" xml:space="preserve">
          <source>Querying file status</source>
          <target state="translated">파일 상태 조회</target>
        </trans-unit>
        <trans-unit id="e1568d2084e4729e281ef2ad2782d446f7281246" translate="yes" xml:space="preserve">
          <source>Querying sizes</source>
          <target state="translated">쿼리 크기</target>
        </trans-unit>
        <trans-unit id="ec159e90e6803b6d4ebd5f32c771f6ca6e6e74a9" translate="yes" xml:space="preserve">
          <source>Querying the compiler</source>
          <target state="translated">컴파일러 쿼리</target>
        </trans-unit>
        <trans-unit id="bfaa4612023c5d1f8ccc9c95a3472712517c8262" translate="yes" xml:space="preserve">
          <source>Querying the user environment</source>
          <target state="translated">사용자 환경 쿼리</target>
        </trans-unit>
        <trans-unit id="18607581d63ad915cd6c4d5d3071d782b7938ac8" translate="yes" xml:space="preserve">
          <source>Question: How does GHC find the filename which contains module ⟨M⟩? Answer: it looks for the file &lt;code&gt;M.hs&lt;/code&gt;, or &lt;code&gt;M.lhs&lt;/code&gt;. This means that for most modules, the module name must match the filename. If it doesn&amp;rsquo;t, GHCi won&amp;rsquo;t be able to find it.</source>
          <target state="translated">질문 : GHC는 모듈 ⟨M⟩을 포함하는 파일 이름을 어떻게 찾습니까? 답 : 파일 &lt;code&gt;M.hs&lt;/code&gt; 또는 &lt;code&gt;M.lhs&lt;/code&gt; 를 찾습니다 . 이는 대부분의 모듈에서 모듈 이름이 파일 이름과 일치해야 함을 의미합니다. 그렇지 않으면 GHCi가 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d325fcd919384f395c02751e03d2cd0288b98cca" translate="yes" xml:space="preserve">
          <source>Queue</source>
          <target state="translated">Queue</target>
        </trans-unit>
        <trans-unit id="2e03f68003ba792e4b7e5bce0358c5b5efca5a74" translate="yes" xml:space="preserve">
          <source>QueueSelector</source>
          <target state="translated">QueueSelector</target>
        </trans-unit>
        <trans-unit id="1a2285d8881f226e13430515a9dd2b9fb6294200" translate="yes" xml:space="preserve">
          <source>Quit</source>
          <target state="translated">Quit</target>
        </trans-unit>
        <trans-unit id="29a754ad4dc6f5eb686a9faa7923466078bf2956" translate="yes" xml:space="preserve">
          <source>Quits GHCi. You can also quit by typing</source>
          <target state="translated">GHCi를 종료합니다. 다음을 입력하여 종료 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b074b09be2d5847dd9450d55b6f0788a6c3fd1b4" translate="yes" xml:space="preserve">
          <source>Quits GHCi. You can also quit by typing &lt;code&gt;Control-D&lt;/code&gt; at the prompt.</source>
          <target state="translated">GHCi를 종료합니다. 프롬프트에서 &lt;code&gt;Control-D&lt;/code&gt; 를 입력하여 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="fe89b57ca741803edb678214b1b10b8b1688ab79" translate="yes" xml:space="preserve">
          <source>R. N. Horspool: Practical Fast Searching in Strings. Software - Practice and Experience 10, 501-506 (1980)</source>
          <target state="translated">RN Horspool : 문자열에서 실용적인 빠른 검색. 소프트웨어-실습 및 경험 10, 501-506 (1980)</target>
        </trans-unit>
        <trans-unit id="3bb8e3918a18086493d1beb88c7c61f2cff4fd6b" translate="yes" xml:space="preserve">
          <source>R. S. Boyer, J. S. Moore: A Fast String Searching Algorithm. Communications of the ACM, 20, 10, 762-772 (1977)</source>
          <target state="translated">RS Boyer, JS Moore : 빠른 문자열 검색 알고리즘. ACM의 커뮤니케이션, 20, 10, 762-772 (1977)</target>
        </trans-unit>
        <trans-unit id="bcd7a25b27aa3490f6e6a5d52d0d7b57716a72c0" translate="yes" xml:space="preserve">
          <source>R.Paterson@city.ac.uk</source>
          <target state="translated">R.Paterson@city.ac.uk</target>
        </trans-unit>
        <trans-unit id="75248a6efd7ebc0c173be4c755f47f7ae4c4606a" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS ARROW</source>
          <target state="translated">오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="81f0ce7bb79894a5b7e3f20200c1491ae057a5b6" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS ARROW-TAIL</source>
          <target state="translated">오른쪽 화살표 화살표</target>
        </trans-unit>
        <trans-unit id="d43d55d9c58cbcc25eb6620ba1f32e960004091e" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS DOUBLE ARROW</source>
          <target state="translated">오른쪽 화살표 더블 화살표</target>
        </trans-unit>
        <trans-unit id="6140cdacfd2f40b8e8a4d0ef59628fa58ba4df25" translate="yes" xml:space="preserve">
          <source>RIGHTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">오른쪽 화살표 더블 화살표</target>
        </trans-unit>
        <trans-unit id="54561fd891ee8d3bc3718283afdce5d24a9fb9d4" translate="yes" xml:space="preserve">
          <source>RS</source>
          <target state="translated">RS</target>
        </trans-unit>
        <trans-unit id="dff6d1ab4ff535388a3b81748b7e0a759af5b5d4" translate="yes" xml:space="preserve">
          <source>RTLDFlags</source>
          <target state="translated">RTLDFlags</target>
        </trans-unit>
        <trans-unit id="222fd2e5cef2e782850e7e961d3e145177fe55f7" translate="yes" xml:space="preserve">
          <source>RTLD_GLOBAL</source>
          <target state="translated">RTLD_GLOBAL</target>
        </trans-unit>
        <trans-unit id="596d9fed4ec6cd3691a13e454f91e5510fb9bd15" translate="yes" xml:space="preserve">
          <source>RTLD_LAZY</source>
          <target state="translated">RTLD_LAZY</target>
        </trans-unit>
        <trans-unit id="58a6bc97fe1b40864bb1226977041584bdd3246e" translate="yes" xml:space="preserve">
          <source>RTLD_LOCAL</source>
          <target state="translated">RTLD_LOCAL</target>
        </trans-unit>
        <trans-unit id="240dca00b5fccdf8eb9307a95d72a4564efd9a1f" translate="yes" xml:space="preserve">
          <source>RTLD_NOW</source>
          <target state="translated">RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="21a3039e72db0527495ff86a20122cd08a41b0ee" translate="yes" xml:space="preserve">
          <source>RTS options taken from the &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-6&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable can be overridden by options given on the command line.</source>
          <target state="translated">&lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-6&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; 환경 변수 에서 가져온 RTS 옵션 은 명령 행에 제공된 옵션으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12038ce4fed76d468c97d3909bb5fa9da8cf36c1" translate="yes" xml:space="preserve">
          <source>RTSFlags</source>
          <target state="translated">RTSFlags</target>
        </trans-unit>
        <trans-unit id="398bdf865c486238761fe9e04c7014d7a95a8878" translate="yes" xml:space="preserve">
          <source>RTSStats</source>
          <target state="translated">RTSStats</target>
        </trans-unit>
        <trans-unit id="173ca40143a1db6b32512b7856cb8403ae881b82" translate="yes" xml:space="preserve">
          <source>RWS</source>
          <target state="translated">RWS</target>
        </trans-unit>
        <trans-unit id="5ed8266ce8d63f9438aafb5e6787b68efadeccab" translate="yes" xml:space="preserve">
          <source>RWS computation to execute</source>
          <target state="translated">실행할 RWS 계산</target>
        </trans-unit>
        <trans-unit id="f1d8da392a9a97e4cb7c42ad2ccf6346e818ebc4" translate="yes" xml:space="preserve">
          <source>RWST</source>
          <target state="translated">RWST</target>
        </trans-unit>
        <trans-unit id="a618f78473842a7cf11f602fffdd35c35387d1a3" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="ce7820312231ab0cd45ab4d865cc302018e42e8e" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="280c8919cbe0b13ce2a3de884857678191c0df1d" translate="yes" xml:space="preserve">
          <source>Raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">올려 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="933e208c50a30fc4995b36847c474fa5bd3740b5" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; with a printf-specific prefix on the message string.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 메시지 문자열의 printf와 특정 접두사를.</target>
        </trans-unit>
        <trans-unit id="00474a4582227a35d8a8ed6e6d74aed95e4bfcf8" translate="yes" xml:space="preserve">
          <source>Raises an error if given an empty list.</source>
          <target state="translated">빈 목록이 제공되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a21adad3deb90b02b29a429bf48fc817d912767f" translate="yes" xml:space="preserve">
          <source>Raising Errors</source>
          <target state="translated">오류 발생</target>
        </trans-unit>
        <trans-unit id="80befa94c0796e21097bf414e22daac761f1ac3a" translate="yes" xml:space="preserve">
          <source>Ralf Hinze and Ross Paterson, &lt;a href=&quot;http://staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;&quot;Finger trees: a simple general-purpose data structure&quot;&lt;/a&gt;, &lt;em&gt;Journal of Functional Programming&lt;/em&gt; 16:2 (2006) pp 197-217.</source>
          <target state="translated">Ralf Hinze와 Ross Paterson, &lt;a href=&quot;http://staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;&quot;핑거 트리 : 간단한 범용 데이터 구조&quot;&lt;/a&gt; , &lt;em&gt;Journal of Functional Programming&lt;/em&gt; 16 : 2 (2006) pp 197-217.</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="646152cf5c1a35e596164cfc5a137c57f6a78564" translate="yes" xml:space="preserve">
          <source>RangeQ</source>
          <target state="translated">RangeQ</target>
        </trans-unit>
        <trans-unit id="5f87625ea4411af78505260124c7f6d2a45e06b0" translate="yes" xml:space="preserve">
          <source>RankNTypes</source>
          <target state="translated">RankNTypes</target>
        </trans-unit>
        <trans-unit id="693f44324e1039b8be2752916af17049a0ad5dd9" translate="yes" xml:space="preserve">
          <source>Rather than generating code to call &lt;code&gt;f&lt;/code&gt; according to the platform&amp;rsquo;s ABI, we instead call &lt;code&gt;f&lt;/code&gt; using the C API defined in the header &lt;code&gt;header.h&lt;/code&gt;. Thus &lt;code&gt;f&lt;/code&gt; can be called even if it may be defined as a CPP &lt;code&gt;#define&lt;/code&gt; rather than a proper function.</source>
          <target state="translated">플랫폼의 ABI에 따라 &lt;code&gt;f&lt;/code&gt; 를 호출하는 코드를 생성하는 대신 header &lt;code&gt;header.h&lt;/code&gt; 에 정의 된 C API를 사용하여 &lt;code&gt;f&lt;/code&gt; 를 호출 합니다. 따라서 &lt;code&gt;f&lt;/code&gt; 는 적절한 함수가 아니라 CPP &lt;code&gt;#define&lt;/code&gt; 으로 정의되어 있어도 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09e0a509143e1597ce0e4b1a260f1ca99da1f7c7" translate="yes" xml:space="preserve">
          <source>Rather than using &lt;code&gt;(== &lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt;, use this. Test if something is a path separator.</source>
          <target state="translated">오히려 사용하지 않고 &lt;code&gt;(== &lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt; , 이것을 사용한다. 경로 구분 기호인지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ed194d2af1d0512a43b9882e2bf53085c69471c2" translate="yes" xml:space="preserve">
          <source>Rather than using &lt;code&gt;(== &lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt;, use this. Test if something is a path separator.</source>
          <target state="translated">오히려 사용하지 않고 &lt;code&gt;(== &lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;)&lt;/code&gt; , 이것을 사용한다. 경로 구분 기호인지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="794f65e9d2064ab6bfab0fa351dcff2763db23d3" translate="yes" xml:space="preserve">
          <source>Ratio</source>
          <target state="translated">Ratio</target>
        </trans-unit>
        <trans-unit id="06abf42877351e1e2ad74c308971eb560fc0aab7" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fffe46763de726cdd41fc5ca5f40572f607297e" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1304ccb2873b49ac5ad2857447e7d4958a9afc" translate="yes" xml:space="preserve">
          <source>Ratio of line length to ribbon length. A ribbon refers to the characters on a line &lt;em&gt;excluding&lt;/em&gt; indentation. So a &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; of 100, with a &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;2.0&lt;/code&gt; would only allow up to 50 characters of ribbon to be displayed on a line, while allowing it to be indented up to 50 characters.</source>
          <target state="translated">선 길이와 리본 길이의 비율. 리본은 들여 쓰기를 &lt;em&gt;제외한&lt;/em&gt; 줄의 문자를 나타냅니다 . 따라서 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;2.0&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 100은 한 줄 에 최대 50 자까지 리본을 표시하는 동시에 최대 50 자까지 들여 쓰기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9365e2d43f2f4d7432550032b047d13acc7dc0" translate="yes" xml:space="preserve">
          <source>RatioZeroDenominator</source>
          <target state="translated">RatioZeroDenominator</target>
        </trans-unit>
        <trans-unit id="28f8f8c0856fcd5b648ff5e28234ee17ac5b1a2e" translate="yes" xml:space="preserve">
          <source>Rational</source>
          <target state="translated">Rational</target>
        </trans-unit>
        <trans-unit id="405213edafc737f5ab6efbcc9727c7dbc43be834" translate="yes" xml:space="preserve">
          <source>Rational numbers, with numerator and denominator of some &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 유형 의 분자 및 분모가있는 유리수입니다 .</target>
        </trans-unit>
        <trans-unit id="66898ef89145e3251520fcffa27276a730264b3d" translate="yes" xml:space="preserve">
          <source>Rational numbers, with numerator and denominator of some &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 유형 의 분자 및 분모가있는 유리수입니다 .</target>
        </trans-unit>
        <trans-unit id="998e2594b8623ea11ad1729045ff4b74f17b5bbb" translate="yes" xml:space="preserve">
          <source>Raw buffers</source>
          <target state="translated">원시 버퍼</target>
        </trans-unit>
        <trans-unit id="25fb73f383d3356e6e16bbb4088572623344a39b" translate="yes" xml:space="preserve">
          <source>Raw pointer of array version of &lt;code&gt;&lt;a href=&quot;system-win32-automation-input#v:sendInput&quot;&gt;sendInput&lt;/a&gt;&lt;/code&gt;. Use this function to support non-list sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-win32-automation-input#v:sendInput&quot;&gt;sendInput&lt;/a&gt;&lt;/code&gt; 배열 버전의 원시 포인터입니다 . 리스트가 아닌 순서를 지원하려면이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cee6901eb5dcf876205fb0f25887ebe12845d3fb" translate="yes" xml:space="preserve">
          <source>Raw read/write operations on file descriptors</source>
          <target state="translated">파일 디스크립터에 대한 원시 읽기 / 쓰기 조작</target>
        </trans-unit>
        <trans-unit id="157fea958671982fd82ff04ec9ed8c09a6ef6b39" translate="yes" xml:space="preserve">
          <source>RawBuffer</source>
          <target state="translated">RawBuffer</target>
        </trans-unit>
        <trans-unit id="a8a5d4f060e1544d5944caadfd158d5a2d980db6" translate="yes" xml:space="preserve">
          <source>RawCharBuffer</source>
          <target state="translated">RawCharBuffer</target>
        </trans-unit>
        <trans-unit id="8da7c86459d153b460979db3219ab54db7fdba1e" translate="yes" xml:space="preserve">
          <source>RawDevice</source>
          <target state="translated">RawDevice</target>
        </trans-unit>
        <trans-unit id="0f11c5246f5cfda145cd94cc2026acc7a8f85d00" translate="yes" xml:space="preserve">
          <source>RawFilePath</source>
          <target state="translated">RawFilePath</target>
        </trans-unit>
        <trans-unit id="84f85043304c606b67a09190e7260a74e66b4111" translate="yes" xml:space="preserve">
          <source>RawIO</source>
          <target state="translated">RawIO</target>
        </trans-unit>
        <trans-unit id="e601d52c0dfeb733b64b16fa8cfb0f09d668768c" translate="yes" xml:space="preserve">
          <source>RawObject</source>
          <target state="translated">RawObject</target>
        </trans-unit>
        <trans-unit id="64cb694cae0bed8753db87912cef88672b156273" translate="yes" xml:space="preserve">
          <source>RcBcc</source>
          <target state="translated">RcBcc</target>
        </trans-unit>
        <trans-unit id="8c924ffc452540914b6a5f1c353b075e91bb1bc7" translate="yes" xml:space="preserve">
          <source>RcCc</source>
          <target state="translated">RcCc</target>
        </trans-unit>
        <trans-unit id="af90b8ce4325e3befb6865f737325cee4b2f3074" translate="yes" xml:space="preserve">
          <source>RcOriginal</source>
          <target state="translated">RcOriginal</target>
        </trans-unit>
        <trans-unit id="4ad7b36332eb45b360b8020417e1bfa69bfb1958" translate="yes" xml:space="preserve">
          <source>RcTo</source>
          <target state="translated">RcTo</target>
        </trans-unit>
        <trans-unit id="3407f4aa246ee23f71ca756ee8cf2ad566b1ba31" translate="yes" xml:space="preserve">
          <source>Re-compile your program for profiling with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, and probably one of the options for adding automatic annotations: &lt;a href=&quot;#ghc-flag--fno-prof-auto&quot;&gt;&lt;code&gt;-fprof-auto&lt;/code&gt;&lt;/a&gt; is the most common &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션과 자동 주석 추가 옵션 중 하나를 사용하여 프로파일 링을 위해 프로그램을 다시 컴파일하십시오 . &lt;a href=&quot;#ghc-flag--fno-prof-auto&quot;&gt; &lt;code&gt;-fprof-auto&lt;/code&gt; &lt;/a&gt; 가 가장 일반적인 &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8173c1f1a663cdea3e376c90c48dd90dcb46e19a" translate="yes" xml:space="preserve">
          <source>Re-compile your program for profiling with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, and probably one of the options for adding automatic annotations: &lt;a href=&quot;#ghc-flag--fprof-auto&quot;&gt;&lt;code&gt;-fprof-auto&lt;/code&gt;&lt;/a&gt; is the most common &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션으로 프로파일 링 할 프로그램 과 자동 주석 추가 옵션 중 하나를 다시 컴파일하십시오 . &lt;a href=&quot;#ghc-flag--fprof-auto&quot;&gt; &lt;code&gt;-fprof-auto&lt;/code&gt; &lt;/a&gt; 가 가장 일반적입니다 &lt;a href=&quot;#id5&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="436cf278924bc8efee40d02b4519461683e18994" translate="yes" xml:space="preserve">
          <source>Re-creates the binary cache file &lt;code&gt;package.cache&lt;/code&gt; for the selected database. This may be necessary if the cache has somehow become out-of-sync with the contents of the database (&lt;code&gt;ghc-pkg&lt;/code&gt; will warn you if this might be the case).</source>
          <target state="translated">선택한 데이터베이스에 대한 이진 캐시 파일 &lt;code&gt;package.cache&lt;/code&gt; 를 다시 만듭니다 . 캐시가 어떻게 든 데이터베이스의 내용과 동기화되지 않은 경우 필요할 수 있습니다 (이 경우 &lt;code&gt;ghc-pkg&lt;/code&gt; 가 경고합니다).</target>
        </trans-unit>
        <trans-unit id="7ed12af550b46e901d403b9d0f93291b0cf629f6" translate="yes" xml:space="preserve">
          <source>Re-exported monoids from Data.Monoid</source>
          <target state="translated">Data.Monoid에서 다시 내보내기 된 monoid</target>
        </trans-unit>
        <trans-unit id="2d04bfb5540a406fa1d417f909b39524de219c43" translate="yes" xml:space="preserve">
          <source>Re-run your program with &lt;code&gt;+RTS -S&lt;/code&gt;, and remove all doubt! (You&amp;rsquo;ll see the heap usage get bigger and bigger&amp;hellip;) (Hmmm&amp;hellip; this might be even easier with the &lt;code&gt;-G1&lt;/code&gt; RTS option; so&amp;hellip; &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;+RTS -S&lt;/code&gt; 로 프로그램을 다시 실행 하고 모든 의심을 제거하십시오! (힙 사용량이 점점 커지는 것을 볼 수 있습니다&amp;hellip;) (흠&amp;hellip; &lt;code&gt;-G1&lt;/code&gt; RTS 옵션을 사용하면 더 쉬울 수 있습니다 . 그래서&amp;hellip; &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="34d929a541c0f1ece950e385b483a59027154870" translate="yes" xml:space="preserve">
          <source>Re-run your program with &lt;code&gt;+RTS -S&lt;/code&gt;, and remove all doubt! (You&amp;rsquo;ll see the heap usage get bigger and bigger...) (Hmmm... this might be even easier with the &lt;code&gt;-G1&lt;/code&gt; RTS option; so... &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;+RTS -S&lt;/code&gt; 로 프로그램을 다시 실행 하고 의심을 모두 제거하십시오! (힙 사용량이 점점 커짐을 알 수 있습니다 ...) (음 ... &lt;code&gt;-G1&lt;/code&gt; RTS 옵션을 사용하면 훨씬 쉬울 수 있습니다 . 그래서 .... / &lt;code&gt;./a.out +RTS -S -G1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b39c69b57883ad20cea20e29a43c91838fc5dece" translate="yes" xml:space="preserve">
          <source>ReFS doesn't support hard link currently.</source>
          <target state="translated">ReFS는 현재 하드 링크를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852b438f91ad9eb2cdd84419a675a216d543c687" translate="yes" xml:space="preserve">
          <source>Read</source>
          <target state="translated">Read</target>
        </trans-unit>
        <trans-unit id="7e60df3ad56b5aa492c15c3cbc3edcd1117e2890" translate="yes" xml:space="preserve">
          <source>Read 16-bit int; offset in bytes.</source>
          <target state="translated">16 비트 정수 읽기; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="1a4eb9eb868bf67f4408ba141c666e2672927ff4" translate="yes" xml:space="preserve">
          <source>Read 16-bit integer; offset in 16-bit words.</source>
          <target state="translated">16 비트 정수를 읽습니다. 16 비트 워드로 오프셋.</target>
        </trans-unit>
        <trans-unit id="b0d87fc9401988038e38b59862ea5b5ccde17d68" translate="yes" xml:space="preserve">
          <source>Read 16-bit word; offset in 16-bit words.</source>
          <target state="translated">16 비트 단어를 읽습니다. 16 비트 워드로 오프셋.</target>
        </trans-unit>
        <trans-unit id="779a27810169b39b14218816baff4c582c906214" translate="yes" xml:space="preserve">
          <source>Read 16-bit word; offset in bytes.</source>
          <target state="translated">16 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="4f4589f1ce718b81895e29adc9bfbd6c1f69bec7" translate="yes" xml:space="preserve">
          <source>Read 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 비트 문자를 읽습니다. 4 바이트 단어로 오프셋합니다.</target>
        </trans-unit>
        <trans-unit id="3d7bb4f3250d94c66276a215dac19da0ee208ceb" translate="yes" xml:space="preserve">
          <source>Read 31-bit character; offset in bytes.</source>
          <target state="translated">31 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="25ab04b7ce5915f4baa82606d8db15948630ae37" translate="yes" xml:space="preserve">
          <source>Read 32-bit int; offset in bytes.</source>
          <target state="translated">32 비트 int를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="6fe96383ba999aacbde564c1a83fb114d382eaa7" translate="yes" xml:space="preserve">
          <source>Read 32-bit integer; offset in 32-bit words.</source>
          <target state="translated">32 비트 정수를 읽습니다. 32 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="60b8324b1d2cdc5721569c3a299a8daf64f2deb2" translate="yes" xml:space="preserve">
          <source>Read 32-bit word; offset in 32-bit words.</source>
          <target state="translated">32 비트 단어를 읽습니다. 32 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="62fb98bafc343247ad56086482aff05792ef6f4a" translate="yes" xml:space="preserve">
          <source>Read 32-bit word; offset in bytes.</source>
          <target state="translated">32 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="d25a05e0ae959c82425e5422cb88b2cc0c3499b2" translate="yes" xml:space="preserve">
          <source>Read 64-bit int; offset in bytes.</source>
          <target state="translated">64 비트 int를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="5ff8b18e5826d1303bd5d1539c0e10e751fc2467" translate="yes" xml:space="preserve">
          <source>Read 64-bit integer; offset in 64-bit words.</source>
          <target state="translated">64 비트 정수를 읽습니다. 64 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="950cbae1770d68c7ff3f938a1bb875fcf874e61e" translate="yes" xml:space="preserve">
          <source>Read 64-bit word; offset in 64-bit words.</source>
          <target state="translated">64 비트 단어를 읽습니다. 64 비트 워드에서 오프셋.</target>
        </trans-unit>
        <trans-unit id="403ce44704144796890a2dd162b7d4b6bd35606a" translate="yes" xml:space="preserve">
          <source>Read 64-bit word; offset in bytes.</source>
          <target state="translated">64 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="9bda208a006c005a311a9525872635ddcfb5a7e7" translate="yes" xml:space="preserve">
          <source>Read 8-bit character; offset in bytes.</source>
          <target state="translated">8 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="74ea30c59bd47b466db1dd2696f98867a27d8056" translate="yes" xml:space="preserve">
          <source>Read 8-bit integer; offset in bytes.</source>
          <target state="translated">8 비트 정수를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="66a3f6514090ac475eac95df9cd8e70ae4d2125d" translate="yes" xml:space="preserve">
          <source>Read 8-bit word; offset in bytes.</source>
          <target state="translated">8 비트 단어를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="52978387bdf57684002ff4fbf9d9b0b3152378e4" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (without sign) from byte-array in base-256 representation.</source>
          <target state="translated">기본 -256 표현의 바이트 배열에서 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (부호 없음)를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="128adcb084eec4344924afe5344cdb69c152d311" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (without sign) from memory location at &lt;code&gt;&lt;em&gt;addr&lt;/em&gt;&lt;/code&gt; in base-256 representation.</source>
          <target state="translated">기본 256 표현으로 &lt;code&gt;&lt;em&gt;addr&lt;/em&gt;&lt;/code&gt; 의 메모리 위치에서 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; (부호 없음)를 읽습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc13cfab1d6d4894e1d0814d5699acd61f42785d" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; from a given file. If there is an error reading the file, the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultPrefs&quot;&gt;defaultPrefs&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 파일에서 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 를 읽습니다 . 파일을 읽는 동안 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultPrefs&quot;&gt;defaultPrefs&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e82d63ab81fecdb435939dcaf6fe495b71d99f5" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="811c646ce78dc8053eececaa8235f624c4c104fa" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9ab54e44cbd0dec1e70996cdb4b7e93cc2071d0a" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="af24bb57706a7419040b51a8e704131723223ed4" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;n&lt;/code&gt; bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;n&lt;/code&gt; 바이트를 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f0b3e5b42103757d24b17f7c7998ff8f3f963bcd" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">&lt;code&gt;.tix&lt;/code&gt; 파일을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6d077a34945c77709ea02aa252897b606577a202" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 및 호스트 엔디안을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2b511be32215f170b894b91b783fc72e7c9eff82" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e270fdae5bb0b921134960c127b008cca47ba123" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="31eb10e403ca406961ff361d1965030257ca16fd" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 와 호스트 엔디안을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ed181842c2d246c2be3b1cafa56c033e14b6ade7" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="450296dc083818a06097a7554a45768d187ae2a3" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="fed4ac78abb685c542391281d20196e4c779e56d" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 직접 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5234a0eeb8c72238d54687b0b6b7f23ba2958b11" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n 개까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc2ed709a624a8004bd6878cf10a70498433b5d" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 직접 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbb8eb90662ec335f6b3d2f0ee3cc28e2d9fe7c" translate="yes" xml:space="preserve">
          <source>Read a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; directly from the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This is far more efficient than reading the characters into a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and then using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; if EOF has been reached.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 직접 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 읽습니다 . 이것은 문자를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 읽은 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하는 것보다 훨씬 효율적 입니다. 첫 번째 인수는 읽을 핸들이고 두 번째 인수는 읽을 바이트 수입니다. 읽은 바이트를 최대 n 개까지 반환하거나 EOF에 도달하면 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="41385428cb32efc10102354ba6b654e89a2182a7" translate="yes" xml:space="preserve">
          <source>Read a Word16 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word16 읽기</target>
        </trans-unit>
        <trans-unit id="c7059262c6e0dd247842136bc035dbe7fac3eb07" translate="yes" xml:space="preserve">
          <source>Read a Word16 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word16 읽기</target>
        </trans-unit>
        <trans-unit id="325ed0dff978da255c416ca5e04ee8469ca4aade" translate="yes" xml:space="preserve">
          <source>Read a Word32 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word32 읽기</target>
        </trans-unit>
        <trans-unit id="9b384ff4a6ad39dcdd029a9762666669ec5b057f" translate="yes" xml:space="preserve">
          <source>Read a Word32 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word32 읽기</target>
        </trans-unit>
        <trans-unit id="91270ca67d57bd1bdbeb755930779fcca71583f5" translate="yes" xml:space="preserve">
          <source>Read a Word64 in big endian format</source>
          <target state="translated">빅 엔디안 형식의 Word64 읽기</target>
        </trans-unit>
        <trans-unit id="5d9a29132fd85c218ab3569276165a1ce2167da2" translate="yes" xml:space="preserve">
          <source>Read a Word64 in little endian format</source>
          <target state="translated">리틀 엔디안 형식의 Word64 읽기</target>
        </trans-unit>
        <trans-unit id="1dbaa4f5cf708506376d639753739c1d852b4bf9" translate="yes" xml:space="preserve">
          <source>Read a Word8 from the monad state</source>
          <target state="translated">모나드 상태에서 Word8 읽기</target>
        </trans-unit>
        <trans-unit id="33687198d0edb29afd53e4ee85d109db96503e2f" translate="yes" xml:space="preserve">
          <source>Read a character from the standard input device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 문자를 읽습니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b45a0fa5c6ee23b88df0d595555f79b07588df7b" translate="yes" xml:space="preserve">
          <source>Read a character from the standard input device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 문자를 읽습니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hGetChar&quot;&gt;hGetChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="0719ab4b706ee893ead8217fca15c3f09a2af0ce" translate="yes" xml:space="preserve">
          <source>Read a decimal integer. The input must begin with at least one decimal digit, and is consumed until a non-digit or end of string is reached.</source>
          <target state="translated">십진 정수를 읽습니다. 입력은 하나 이상의 10 진수로 시작해야하며, 숫자가 아니거나 문자열 끝에 도달 할 때까지 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="54e6d350ae56550c44862ac311a367be600fae92" translate="yes" xml:space="preserve">
          <source>Read a file and return its contents as a string. The file is read lazily, as with &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 읽고 그 내용을 문자열로 반환하십시오. &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 와 같이 파일을 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d91c0d58a076465748276893ce00cc9dcf0e0387" translate="yes" xml:space="preserve">
          <source>Read a handle's entire contents strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들의 전체 내용을 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 엄격히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ddde23fb0886b2069060468faf3bddb7c72b3d9d" translate="yes" xml:space="preserve">
          <source>Read a handle's entire contents strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">핸들의 전체 내용을 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 엄격히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7439e315f02f450400e229e67923aa01c829dd88" translate="yes" xml:space="preserve">
          <source>Read a hexadecimal integer, consisting of an optional leading &lt;code&gt;&quot;0x&quot;&lt;/code&gt; followed by at least one hexadecimal digit. Input is consumed until a non-hex-digit or end of string is reached. This function is case insensitive.</source>
          <target state="translated">선택적인 선행 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 와 하나 이상의 16 진수 로 구성되는 16 진 정수를 읽습니다 . 16 진수가 아닌 숫자 또는 문자열 끝에 도달 할 때까지 입력이 소비됩니다. 이 기능은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d6ef962b6540180679caac9f11ba078a87836f5" translate="yes" xml:space="preserve">
          <source>Read a line from a handle</source>
          <target state="translated">핸들에서 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5f19303cec3e7c471d3d195797816309df8f8f1f" translate="yes" xml:space="preserve">
          <source>Read a line from stdin.</source>
          <target state="translated">stdin에서 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c0d47f6d713637753c2bcc367aaff8c0fce318ee" translate="yes" xml:space="preserve">
          <source>Read a line from the standard input device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 라인을 읽습니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="5743e14432024dc17ab0cc94bee7428d51f61dfb" translate="yes" xml:space="preserve">
          <source>Read a line from the standard input device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 입력 장치에서 라인을 읽습니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="01c713600966b0fbf993236e350a166e304141fa" translate="yes" xml:space="preserve">
          <source>Read a mix file.</source>
          <target state="translated">믹스 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="be8f10751cbc4efc5cde4e6e7e38e5094e226876" translate="yes" xml:space="preserve">
          <source>Read a rational number.</source>
          <target state="translated">유리수를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="73f99dea456cdd98d70103431dec12bab6720d82" translate="yes" xml:space="preserve">
          <source>Read a single chunk of strict text from a buffer. Used by both the strict and lazy implementations of hGetContents.</source>
          <target state="translated">버퍼에서 하나의 엄격한 텍스트 덩어리를 읽습니다. hGetContents의 엄격하고 지연된 구현 모두에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3128563cca70a9b1fe0217abc816e305e4d7489c" translate="yes" xml:space="preserve">
          <source>Read a single line from a handle.</source>
          <target state="translated">핸들에서 한 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="adf69306cc90a31c382146419718b352ccd6cad6" translate="yes" xml:space="preserve">
          <source>Read a single line of input from a handle, constructing a list of decoded chunks as we go. When we're done, transform them into the destination type.</source>
          <target state="translated">핸들에서 한 줄의 입력을 읽고 디코딩 된 청크 목록을 구성합니다. 완료되면 대상 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="25654588f3da8aeac6ef5d8db3b62a836c06fa32" translate="yes" xml:space="preserve">
          <source>Read a single line of user input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 한 줄의 사용자 입력을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="3567b42f426069b714bcc5bc523c87fce4bcee1a" translate="yes" xml:space="preserve">
          <source>Read a specific file after the usual startup files. May be specified repeatedly for multiple inputs. &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; does not apply to these files.</source>
          <target state="translated">일반적인 시작 파일 후에 특정 파일을 읽습니다. 여러 입력에 대해 반복적으로 지정할 수 있습니다. &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt; 는 이러한 파일에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfdfe120d485085e70e78fc48c39eb13447bb5f0" translate="yes" xml:space="preserve">
          <source>Read a specific file after the usual startup files. Maybe be specified repeatedly for multiple inputs.</source>
          <target state="translated">일반적인 시작 파일 후에 특정 파일을 읽습니다. 여러 입력에 대해 반복적으로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbdbb8f86925718238233077f610fe66a832424a" translate="yes" xml:space="preserve">
          <source>Read a string representation of a character, using Haskell source-language escape conventions, and convert it to the character that it encodes. For example:</source>
          <target state="translated">Haskell 소스 언어 이스케이프 규칙을 사용하여 문자의 문자열 표현을 읽고이를 인코딩하는 문자로 변환하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f45ab2992a7f92c89c2d67b45445d7594627e828" translate="yes" xml:space="preserve">
          <source>Read a string representation of a character, using Haskell source-language escape conventions. For example:</source>
          <target state="translated">Haskell 소스 언어 이스케이프 규칙을 사용하여 문자의 문자열 표현을 읽으십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59574f2898f4af82703bca7202a821293d4ffcc1" translate="yes" xml:space="preserve">
          <source>Read a value from a memory area regarded as an array of values of the same kind. The first argument specifies the start address of the array and the second the index into the array (the first element of the array has index &lt;code&gt;0&lt;/code&gt;). The following equality holds,</source>
          <target state="translated">동일한 종류의 값 배열로 간주되는 메모리 영역에서 값을 읽습니다. 첫 번째 인수는 배열의 시작 주소를 지정하고 두 번째 인수는 배열의 색인을 지정합니다 (배열의 첫 번째 요소는 색인 &lt;code&gt;0&lt;/code&gt; ). 다음과 같은 평등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02dae23f91c992be0064ed7d86e41766eb8e894" translate="yes" xml:space="preserve">
          <source>Read a value from a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">기본 주소 및 오프셋으로 지정된 메모리 위치에서 값을 읽습니다. 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b0aa0bd28f22ee1301ca31df70c736ff3ee306" translate="yes" xml:space="preserve">
          <source>Read a value from an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 에서 값 읽기</target>
        </trans-unit>
        <trans-unit id="4d64cf50eadebd9d63f648489fffc060e93dade0" translate="yes" xml:space="preserve">
          <source>Read a value from the given memory location.</source>
          <target state="translated">주어진 메모리 위치에서 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c895abdcb0525ce203fd7be7a0c13f00f62176b5" translate="yes" xml:space="preserve">
          <source>Read a value in either extended or basic format</source>
          <target state="translated">확장 또는 기본 형식으로 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f6e13344b410105e46fe8c0c3bb31ba832250e46" translate="yes" xml:space="preserve">
          <source>Read a value in the format</source>
          <target state="translated">형식으로 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="dd0b7cb834d846fc1947e62e526ff39953f44c07" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of immutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">변경 불가능한 스칼라 배열의 지정된 인덱스에서 벡터를 읽습니다. 오프셋은 스칼라 요소입니다.</target>
        </trans-unit>
        <trans-unit id="f79c6c6b83c77de14c0bf3ded60c02c747a26da6" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of immutable array.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 벡터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5615bbd35bd929521c39374f2e2a2232ced11f9c" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">스칼라의 가변 배열의 지정된 인덱스에서 벡터를 읽습니다. 오프셋은 스칼라 요소입니다.</target>
        </trans-unit>
        <trans-unit id="4e9fe50a296114dc2b02bd5ca2a79c2f895b774b" translate="yes" xml:space="preserve">
          <source>Read a vector from specified index of mutable array.</source>
          <target state="translated">가변 배열의 지정된 인덱스에서 벡터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a7742b39ce7421c6d47b0effa4450918bdd45632" translate="yes" xml:space="preserve">
          <source>Read additional &lt;code&gt;.ghci&lt;/code&gt; files</source>
          <target state="translated">추가 &lt;code&gt;.ghci&lt;/code&gt; 파일 읽기</target>
        </trans-unit>
        <trans-unit id="d233243d198088b2c0450f8380c909a760fb25ad" translate="yes" xml:space="preserve">
          <source>Read address; offset in bytes.</source>
          <target state="translated">읽기 주소; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="3197b5d5666bc282a5115cbbd8185c4015503c26" translate="yes" xml:space="preserve">
          <source>Read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4df9c1fd5f4c008b55e24b1254682c338fd5c8b5" translate="yes" xml:space="preserve">
          <source>Read an Int16 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int16을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6f267e0ba7feb196316db561014fb8a100f37edc" translate="yes" xml:space="preserve">
          <source>Read an Int16 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int16을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="92b6e9e32f49c87b97a18f7e91eae119f1d1535e" translate="yes" xml:space="preserve">
          <source>Read an Int32 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int32를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="295f966253d453f4fa2a13a40bcdb60b3120732b" translate="yes" xml:space="preserve">
          <source>Read an Int32 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int32를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2a4319e745da1df1fb9ab6def619894697620e21" translate="yes" xml:space="preserve">
          <source>Read an Int64 in big endian format.</source>
          <target state="translated">빅 엔디안 형식의 Int64를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7bff0912bbb59ea521663a0f1057dd5874ce2fbf" translate="yes" xml:space="preserve">
          <source>Read an Int64 in little endian format.</source>
          <target state="translated">리틀 엔디안 형식의 Int64를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9d00ac172a382dbde434bc4bef4d834e10046dba" translate="yes" xml:space="preserve">
          <source>Read an Int8 from the monad state</source>
          <target state="translated">모나드 상태에서 Int8 읽기</target>
        </trans-unit>
        <trans-unit id="29b4fc30960f16d120ae6224ddf706485760e8de" translate="yes" xml:space="preserve">
          <source>Read an element from a mutable array</source>
          <target state="translated">가변 배열에서 요소 읽기</target>
        </trans-unit>
        <trans-unit id="184940591a216fa9ea649f7763278eb44f8d0931" translate="yes" xml:space="preserve">
          <source>Read an entire file &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The Handle will be held open until EOF is encountered.</source>
          <target state="translated">전체 파일을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . EOF에 도달 할 때까지 핸들이 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="03f1e6feeff9a1725dd05ae88ec08afc7c1d72b9" translate="yes" xml:space="preserve">
          <source>Read an entire file &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The Handle will be held open until EOF is encountered.</source>
          <target state="translated">전체 파일을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . EOF에 도달 할 때까지 핸들이 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60570cd035ce237ccf2437d4bfb920a02e53853c" translate="yes" xml:space="preserve">
          <source>Read an entire file strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 파일을 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 완전히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="001be63528cff4e4b1bbe0b696c612c20323c3ab" translate="yes" xml:space="preserve">
          <source>Read an entire file strictly into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 파일을 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 완전히 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="cf17dfd1f6fadf4d500465addd8a6f58eeb87931" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we fail to parse an integer, we want to return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="be0da86fe87d3545be65bcc3b1ff13160afc8f22" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we fail to parse an integer, we want to return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수 읽기 . 정수 구문 분석에 실패하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab42205d653354d10c40dc2129358edaf0340a6a" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we fail to parse an integer, we want to return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8b7be0938cfa7ae7ce0d40e3b9c4c39227699e7a" translate="yes" xml:space="preserve">
          <source>Read an integer from a string using &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt;. If we succeed, return twice the integer; that is, apply &lt;code&gt;(*2)&lt;/code&gt; to it. If instead we fail to parse an integer, return &lt;code&gt;0&lt;/code&gt; by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 를 사용하여 문자열에서 정수를 읽 습니다 . 성공하면 정수의 두 배를 반환합니다. 즉, &lt;code&gt;(*2)&lt;/code&gt; 를 적용 하십시오. 대신 정수를 구문 분석하지 못하면 기본적으로 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0e1b310d39697280b0ca5896c55c8f8ddd9e208" translate="yes" xml:space="preserve">
          <source>Read an optional leading sign character (&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'+'&lt;/code&gt;) and apply it to the result of applying the given reader.</source>
          <target state="translated">선택적인 선행 부호 문자 ( &lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'+'&lt;/code&gt; )를 읽고 주어진 리더를 적용한 결과에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="de974586f48684c65e0aed99e88a68bca9babb04" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in decimal notation.</source>
          <target state="translated">부호없는 숫자를 10 진수 표기법으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="edd8a422da79ea12a97bd88bd774c6fa6d5e779c" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in hexadecimal notation. Both upper or lower case letters are allowed.</source>
          <target state="translated">부호없는 숫자를 16 진수 표기법으로 읽으십시오. 대문자 또는 소문자 모두 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5feb144c8f7999d7fc0752e59f4bdec2cd116666" translate="yes" xml:space="preserve">
          <source>Read an unsigned number in octal notation.</source>
          <target state="translated">8 진수 표기법으로 부호없는 숫자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6ad141bb083704baa04592db003358950eddce08" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;MutVar#&lt;/code&gt;. Result is not yet evaluated.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 내용을 읽습니다 . 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="44f0e5c6fc9d1c23f9c6ed2b599b6b8d8e417ef0" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;TVar#&lt;/code&gt; outside an STM transaction</source>
          <target state="translated">STM 트랜잭션 외부에서 &lt;code&gt;TVar#&lt;/code&gt; 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5ff6ad28f98052f9fcd898c2d97970160ba11e64" translate="yes" xml:space="preserve">
          <source>Read contents of &lt;code&gt;TVar#&lt;/code&gt;. Result is not yet evaluated.</source>
          <target state="translated">&lt;code&gt;TVar#&lt;/code&gt; 내용을 읽으십시오 . 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3603a43d62483fa4679d6af07c238488c46786c9" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; and convert it to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using the locale encoding. Throws an exception if this is an invalid descriptor, or EOF has been reached.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽고 로케일 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로 변환하십시오 . 디스크립터가 유효하지 않거나 EOF에 도달하면 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="43ab7f0c4f47fef128b100ea328372f14b6a3498" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; into memory. This is exactly equivalent to the POSIX &lt;code&gt;read&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 메모리로 데이터를 읽 습니다. 이것은 POSIX &lt;code&gt;read&lt;/code&gt; 기능 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="944c1e8256532934e3f44d1937f7def6a13dd70a" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; and convert it to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using the locale encoding. Throws an exception if this is an invalid descriptor, or EOF has been reached.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 데이터를 읽고 이를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 로케일 인코딩을 사용하여 문자열. 유효하지 않은 설명자이거나 EOF에 도달 한 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b425fd701193503b88a9a082df1d09c431fc7f8" translate="yes" xml:space="preserve">
          <source>Read data from an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; into memory. This is exactly equivalent to the POSIX &lt;code&gt;read&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에서 데이터 읽기 에서 메모리로 습니다. 이것은 POSIX &lt;code&gt;read&lt;/code&gt; 기능 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f5bf8684c269a4820abae27741f614d296efe4c4" translate="yes" xml:space="preserve">
          <source>Read double; offset in bytes.</source>
          <target state="translated">이중 읽기; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="b0cca27f8a9fdef6889ea37c66301c876cab8ce6" translate="yes" xml:space="preserve">
          <source>Read entire handle contents &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Chunks are read on demand, using the default chunk size.</source>
          <target state="translated">전체 핸들 내용을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 청크는 기본 청크 크기를 사용하여 요청시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="101b8e34a22629aafaa1a8c5025821cec283fe82" translate="yes" xml:space="preserve">
          <source>Read entire handle contents &lt;em&gt;lazily&lt;/em&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Chunks are read on demand, using the default chunk size.</source>
          <target state="translated">전체 핸들 내용을 읽어 &lt;em&gt;유유히&lt;/em&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 청크는 기본 청크 크기를 사용하여 요청시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e54160b8e25354935fce10255c3e4543c690a8d3" translate="yes" xml:space="preserve">
          <source>Read float; offset in bytes.</source>
          <target state="translated">플로트를 읽습니다; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="db90f20fdb5334fdb03e7dc9053d0abf64c43f74" translate="yes" xml:space="preserve">
          <source>Read from specified index of immutable array. Result is packaged into an unboxed singleton; the result itself is not yet evaluated.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 읽습니다. 결과는 박스형 싱글 톤으로 패키지됩니다. 결과 자체는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0200070728a5fb343af81ee6afd180f318933176" translate="yes" xml:space="preserve">
          <source>Read from specified index of mutable array. Result is not yet evaluated.</source>
          <target state="translated">가변 배열의 지정된 인덱스에서 읽습니다. 결과는 아직 평가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d1a39c4b6ea4cc164485bd240d4bd6cf1570e05c" translate="yes" xml:space="preserve">
          <source>Read from the specified index of an immutable array. The result is packaged into an unboxed unary tuple; the result itself is not yet evaluated. Pattern matching on the tuple forces the indexing of the array to happen but does not evaluate the element itself. Evaluating the thunk prevents additional thunks from building up on the heap. Avoiding these thunks, in turn, reduces references to the argument array, allowing it to be garbage collected more promptly.</source>
          <target state="translated">불변 배열의 지정된 인덱스에서 읽습니다. 결과는 박스형 단항 튜플에 패키지됩니다. 결과 자체는 아직 평가되지 않았습니다. 튜플의 패턴 일치는 배열의 색인 생성을 강제하지만 요소 자체는 평가하지 않습니다. 썽크를 평가하면 추가 썽크가 힙에 쌓이지 않습니다. 이러한 썽크를 피하면 인수 배열에 대한 참조가 줄어들어보다 신속하게 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36061d225788479538ce96083566a66df2c49724" translate="yes" xml:space="preserve">
          <source>Read input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;. Use terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), use file-style interaction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 터미널에 연결되어 있고 에코가 활성화 된 경우 터미널 스타일 상호 작용을 사용하십시오 . 그렇지 않으면 (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 파이프 인 경우) 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e2b87177b15201771ca07ee6fd67e9a5fc97ac6f" translate="yes" xml:space="preserve">
          <source>Read int; offset in bytes.</source>
          <target state="translated">int를 읽으십시오; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="509993ef463c0c211358fd0c0596577266fe2fb7" translate="yes" xml:space="preserve">
          <source>Read integer; offset in words.</source>
          <target state="translated">정수 읽기; 단어의 오프셋.</target>
        </trans-unit>
        <trans-unit id="e9087047c795daa1de0e7dba3f7e080b494418f8" translate="yes" xml:space="preserve">
          <source>Read some text. If the read succeeds, return its value and the remaining text, otherwise an error message.</source>
          <target state="translated">텍스트를 읽으십시오. 읽기에 성공하면 해당 값과 나머지 텍스트를 반환하고, 그렇지 않으면 오류 메시지를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="385971a1139a0bdb98d1292763e2b5ce86ca29ce" translate="yes" xml:space="preserve">
          <source>Read stable pointer; offset in bytes.</source>
          <target state="translated">안정적인 포인터를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="3fc7f5e6a842e6c7c7f4d5cd93c243638c0a22c7" translate="yes" xml:space="preserve">
          <source>Read the interface in ⟨file⟩ and dump it as text to &lt;code&gt;stdout&lt;/code&gt;. For example &lt;code&gt;ghc --show-iface M.hi&lt;/code&gt;.</source>
          <target state="translated">⟨file⟩의 인터페이스를 읽고 &lt;code&gt;stdout&lt;/code&gt; 에 텍스트로 덤프하십시오 . 예를 들어 &lt;code&gt;ghc --show-iface M.hi&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35fd8313e4529e013617beaafbd192823c6b704e" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;. Blocks when the channel is empty. Since the read end of a channel is an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, this operation inherits fairness guarantees of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s (e.g. threads blocked in this operation are woken up in FIFO order).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 . 채널이 비어있을 때 차단합니다. 채널의 읽기 끝 이 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이므로이 작업은 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 공정성을 보장합니다 (예 :이 작업에서 차단 된 스레드는 FIFO 순서 로 깨어남 ).</target>
        </trans-unit>
        <trans-unit id="a3f42dd07bf605d27f73449bde07c7d88dd5a27e" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="219b4ebe09d71aecd989470d5600adac017a8f74" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0e07d0d1882240686a99adef17b39a619c1bef0f" translate="yes" xml:space="preserve">
          <source>Read the next value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 에서 다음 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e007f69e1d890c7d542d9833535fb4b6a263ffd6" translate="yes" xml:space="preserve">
          <source>Read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; as a string. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 문자열로 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 내용을 읽은 후 폐쇄, 또는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85f565788b2b9a2c3728b76cecd24c45e236a991" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="e7780aaaf7afd886eedb902ae89adf47399d57fc" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="e675dd344452e999c38ed03687aca33c72e023cd" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="8e716a6f85aeaaaa890a3308400401bdff5d70c0" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="01bf80e08c343263e4bb151f8cf9ca8018bbad19" translate="yes" xml:space="preserve">
          <source>Read the value of an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 가치를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="048e888435023fe10ac7481eb2d18a6767a2ae0e" translate="yes" xml:space="preserve">
          <source>Read up to the specified number of bytes, returning the number of bytes actually read, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the end of the stream has been reached.</source>
          <target state="translated">지정된 바이트 수까지 읽은 다음 실제로 읽은 바이트 수를 반환하거나 스트림 끝에 도달하면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ddb4092dc0454475d79a2caf656b95780da4b95" translate="yes" xml:space="preserve">
          <source>Read up to the specified number of bytes, returning the number of bytes actually read. This function should only block if there is no data available. If there is not enough data available, then the function should just return the available data. A return value of zero indicates that the end of the data stream (e.g. end of file) has been reached.</source>
          <target state="translated">지정된 바이트 수까지 읽고 실제로 읽은 바이트 수를 반환합니다. 이 기능은 사용 가능한 데이터가없는 경우에만 차단해야합니다. 사용 가능한 데이터가 충분하지 않으면 함수는 사용 가능한 데이터 만 반환해야합니다. 리턴 값이 0이면 데이터 스트림의 끝 (예 : 파일의 끝)에 도달했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29b7483916a09f80924395ee0d7b83ba6ab96615" translate="yes" xml:space="preserve">
          <source>Read word; offset in bytes.</source>
          <target state="translated">단어를 읽고; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="e12038f525002402b577d6fb2889e55cff2dfbae" translate="yes" xml:space="preserve">
          <source>Read word; offset in words.</source>
          <target state="translated">단어를 읽고; 단어의 오프셋.</target>
        </trans-unit>
        <trans-unit id="1b9d7709bfb533d78fbe0b84eb0c51db68ac6e05" translate="yes" xml:space="preserve">
          <source>Read1</source>
          <target state="translated">Read1</target>
        </trans-unit>
        <trans-unit id="81d8932de84f99268c4fd5f11aa697682044fa60" translate="yes" xml:space="preserve">
          <source>Read2</source>
          <target state="translated">Read2</target>
        </trans-unit>
        <trans-unit id="f1e077638634abc3662a6f0c89d3f406f31baa23" translate="yes" xml:space="preserve">
          <source>ReadBuffer</source>
          <target state="translated">ReadBuffer</target>
        </trans-unit>
        <trans-unit id="c5020e6d3d649435fd6a8008235ac63730a66a73" translate="yes" xml:space="preserve">
          <source>ReadEnable</source>
          <target state="translated">ReadEnable</target>
        </trans-unit>
        <trans-unit id="6de7f0656dc34507427ddc07a973f98f0bcc41df" translate="yes" xml:space="preserve">
          <source>ReadHandle</source>
          <target state="translated">ReadHandle</target>
        </trans-unit>
        <trans-unit id="54556afe3251c3e593a21d925fcc337a1e508750" translate="yes" xml:space="preserve">
          <source>ReadLock</source>
          <target state="translated">ReadLock</target>
        </trans-unit>
        <trans-unit id="c2f37f72692c3515483dfa8baf2cb80b52368faa" translate="yes" xml:space="preserve">
          <source>ReadMode</source>
          <target state="translated">ReadMode</target>
        </trans-unit>
        <trans-unit id="35b71d2407f50e29058b6e84ccdbdda494394136" translate="yes" xml:space="preserve">
          <source>ReadOnly</source>
          <target state="translated">ReadOnly</target>
        </trans-unit>
        <trans-unit id="46689621a240954e944093b728ea402ca810f9e1" translate="yes" xml:space="preserve">
          <source>ReadP</source>
          <target state="translated">ReadP</target>
        </trans-unit>
        <trans-unit id="4b68042bf88ac33a1e40bfc7d7f822fcd7009e90" translate="yes" xml:space="preserve">
          <source>ReadPrec</source>
          <target state="translated">ReadPrec</target>
        </trans-unit>
        <trans-unit id="9fe9c76a65059b5111bfa003358795f86d10951b" translate="yes" xml:space="preserve">
          <source>ReadS</source>
          <target state="translated">ReadS</target>
        </trans-unit>
        <trans-unit id="934e6375acc87422b86cc2cd6088641368f302ce" translate="yes" xml:space="preserve">
          <source>ReadWrite</source>
          <target state="translated">ReadWrite</target>
        </trans-unit>
        <trans-unit id="9b64792077a2e304ad52b88e180478893f260952" translate="yes" xml:space="preserve">
          <source>ReadWriteHandle</source>
          <target state="translated">ReadWriteHandle</target>
        </trans-unit>
        <trans-unit id="52f3ccd214d97eb22352b89cf6fab70f198121a0" translate="yes" xml:space="preserve">
          <source>ReadWriteMode</source>
          <target state="translated">ReadWriteMode</target>
        </trans-unit>
        <trans-unit id="ac5bbe8292ed1b69e0f95e5bdaa035569a295fd7" translate="yes" xml:space="preserve">
          <source>Reader</source>
          <target state="translated">Reader</target>
        </trans-unit>
        <trans-unit id="c63a28bc751310feb69d6d85675c8d7417374a2f" translate="yes" xml:space="preserve">
          <source>Reader operations</source>
          <target state="translated">리더 조작</target>
        </trans-unit>
        <trans-unit id="c6a6be791f6f7604b9585f870722f3f322f53e43" translate="yes" xml:space="preserve">
          <source>ReaderT</source>
          <target state="translated">ReaderT</target>
        </trans-unit>
        <trans-unit id="cffa2af0a3a67cf2123e3411d020161abc01fc05" translate="yes" xml:space="preserve">
          <source>Reading</source>
          <target state="translated">Reading</target>
        </trans-unit>
        <trans-unit id="c422c2c68b42e2bd58fbc1703fc83cd895932253" translate="yes" xml:space="preserve">
          <source>Reading a &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; value is always a parse error, considering &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; as a data type with no constructors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 값을 읽는 것은 생성자가없는 데이터 유형으로 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 를 고려할 때 항상 구문 분석 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f06f44f189a8a36daa4efe052b72e715b174b17d" translate="yes" xml:space="preserve">
          <source>Reading a &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; value is always a parse error, considering &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; as a data type with no constructors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 값을 읽는 것은 생성자가없는 데이터 유형으로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 를 고려할 때 항상 구문 분석 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="ceb93f69e25dd4f67fafd5c0c9bcf1b6c00353d6" translate="yes" xml:space="preserve">
          <source>Reading and writing</source>
          <target state="translated">읽고 쓰기</target>
        </trans-unit>
        <trans-unit id="4f18826bef9dfdb927570ae8ab6b9bec70524276" translate="yes" xml:space="preserve">
          <source>Reading and writing mutable arrays</source>
          <target state="translated">가변 배열 읽기 및 쓰기</target>
        </trans-unit>
        <trans-unit id="365b9ae589656ef49d750dc632c6d31ceb0c5361" translate="yes" xml:space="preserve">
          <source>Reading directories</source>
          <target state="translated">디렉토리 읽기</target>
        </trans-unit>
        <trans-unit id="96b64527dbce354910bf9627caf09e2a6cfc34cf" translate="yes" xml:space="preserve">
          <source>Reading from ByteStrings</source>
          <target state="translated">바이트 열에서 읽기</target>
        </trans-unit>
        <trans-unit id="e253f6b863facf4d77e612851b75f8717edbc34a" translate="yes" xml:space="preserve">
          <source>Reading user input</source>
          <target state="translated">사용자 입력 읽기</target>
        </trans-unit>
        <trans-unit id="6a32d6ca2eb1805847b13bc731bea17f663fa696" translate="yes" xml:space="preserve">
          <source>Reading/writing data</source>
          <target state="translated">데이터 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="c80f1cd51e818f0a4c3a4b8c5cf43e874d958e5a" translate="yes" xml:space="preserve">
          <source>Reads 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 비트 문자를 읽습니다. 4 바이트 단어로 오프셋합니다.</target>
        </trans-unit>
        <trans-unit id="921dc7c293431a3a64c3ded33915a5aa38ae62af" translate="yes" xml:space="preserve">
          <source>Reads 8-bit character; offset in bytes.</source>
          <target state="translated">8 비트 문자를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="a5b991e4a4379bd9b80c3767927105724a0875a1" translate="yes" xml:space="preserve">
          <source>Reads a &lt;em&gt;signed&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; value, given a reader for an unsigned value.</source>
          <target state="translated">부호없는 값에 대한 독자에게 주어진 &lt;em&gt;부호있는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="1fd583060d47ecdc99e4f5f0f86aaa58223cfd92" translate="yes" xml:space="preserve">
          <source>Reads a non-empty string of decimal digits.</source>
          <target state="translated">비어 있지 않은 10 진수 문자열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cbbbba4aaf9680cf8ac1a308bdb53817ab019a45" translate="yes" xml:space="preserve">
          <source>Reads a number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s from the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; directly into an array.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 여러 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 배열로 직접 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="556bd04c13e60facc8066057186c581b79650a92" translate="yes" xml:space="preserve">
          <source>Reads a number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s from the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; directly into an array.</source>
          <target state="translated">지정된에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 수를 읽습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 배열로 직접.</target>
        </trans-unit>
        <trans-unit id="f07300e7dd09099ac84ef4f53f7fd7ce2c8ce883" translate="yes" xml:space="preserve">
          <source>Reads a package specification from ⟨file⟩ (which may be &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; to indicate standard input), and adds it to the database of installed packages. The syntax of ⟨file⟩ is given in &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: a package specification&lt;/a&gt;.</source>
          <target state="translated">⟨file⟩ ( 표준 입력을 나타 내기 위해 &amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo; 일 수 있음)에서 패키지 사양을 읽고 설치된 패키지의 데이터베이스에 추가합니다. ⟨file⟩의 구문은 &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo : package specification에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e64b7710b0f793ca4a73b1986230bc60e374cb" translate="yes" xml:space="preserve">
          <source>Reads an &lt;em&gt;unsigned&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value in an arbitrary base.</source>
          <target state="translated">임의의 기준으로 &lt;em&gt;부호없는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="df34a2a58d81dcca7a482cd5956785905a568c3f" translate="yes" xml:space="preserve">
          <source>Reads an &lt;em&gt;unsigned&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; value, expressed in decimal scientific notation.</source>
          <target state="translated">십진 과학 표기법으로 표현 된 &lt;em&gt;부호없는 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 값을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ab426f1eb57de3cd53ffe87e3b87e21c773c64b0" translate="yes" xml:space="preserve">
          <source>Reads one character of input. Ignores non-printable characters.</source>
          <target state="translated">하나의 입력 문자를 읽습니다. 인쇄 할 수없는 문자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="8db8c0a51e77d5b8ce47a692479eb60e9ad3c1d1" translate="yes" xml:space="preserve">
          <source>Reads one line of input and fills the insertion space with initial text. When using terminal-style interaction, this function provides a rich line-editing user interface with the added ability to give the user default values.</source>
          <target state="translated">한 줄의 입력을 읽고 초기 텍스트로 삽입 공간을 채 웁니다. 터미널 스타일 상호 작용을 사용할 때이 기능은 풍부한 기본값을 제공하는 기능이 추가 된 풍부한 라인 편집 사용자 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33401a6d6df492bf1a176a021ff28fb4ff727341" translate="yes" xml:space="preserve">
          <source>Reads one line of input, without displaying the input while it is being typed. When using terminal-style interaction, the masking character (if given) will replace each typed character.</source>
          <target state="translated">입력하는 동안 입력을 표시하지 않고 한 줄의 입력을 읽습니다. 터미널 스타일의 상호 작용을 사용하는 경우 마스킹 문자 (제공된 경우)가 각 입력 된 문자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5e14c26e4702c8715ffc36b86faf8dd417b0a61b" translate="yes" xml:space="preserve">
          <source>Reads one line of input. The final newline (if any) is removed. When using terminal-style interaction, this function provides a rich line-editing user interface.</source>
          <target state="translated">한 줄의 입력을 읽습니다. 마지막 개행 (있는 경우)이 제거됩니다. 터미널 스타일 상호 작용을 사용할 때이 기능은 풍부한 라인 편집 사용자 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2fcf3b55305c70b8c82f22537db6b19a7a199aa5" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;FilePath&lt;/code&gt; pointed to by the symbolic link and returns it.</source>
          <target state="translated">심볼릭 링크가 가리키는 &lt;code&gt;FilePath&lt;/code&gt; 를 읽고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b52ed1233e0f5b938bb0cd5a498ea44aaf2572ed" translate="yes" xml:space="preserve">
          <source>Reads the &lt;code&gt;RawFilePath&lt;/code&gt; pointed to by the symbolic link and returns it.</source>
          <target state="translated">심볼릭 링크가 가리키는 &lt;code&gt;RawFilePath&lt;/code&gt; 를 읽고 이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="722dfe2339359bc8455fa059b0c2ff7e3c1b3b76" translate="yes" xml:space="preserve">
          <source>Reads the line input history from the given file. Returns &lt;code&gt;&lt;a href=&quot;system-console-haskeline-history#v:emptyHistory&quot;&gt;emptyHistory&lt;/a&gt;&lt;/code&gt; if the file does not exist or could not be read.</source>
          <target state="translated">주어진 파일에서 라인 입력 히스토리를 읽습니다. 파일이 없거나 읽을 수없는 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-history#v:emptyHistory&quot;&gt;emptyHistory&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ef042421d404f2b4e066a957f7c03bc5b97e85a1" translate="yes" xml:space="preserve">
          <source>Reads vector; offset in bytes.</source>
          <target state="translated">벡터를 읽습니다. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="35688a4a54ddf8e2c084064bb89a3f81c25ec6d0" translate="yes" xml:space="preserve">
          <source>Reads vector; offset in scalar elements.</source>
          <target state="translated">벡터를 읽습니다. 스칼라 요소의 오프셋.</target>
        </trans-unit>
        <trans-unit id="8e16e5b2c446aea3b142d9320755f82932fc2cdf" translate="yes" xml:space="preserve">
          <source>Real</source>
          <target state="translated">Real</target>
        </trans-unit>
        <trans-unit id="fe1df2542911bb9bfc0a0622989aa4692d4d4925" translate="yes" xml:space="preserve">
          <source>RealFloat</source>
          <target state="translated">RealFloat</target>
        </trans-unit>
        <trans-unit id="1d59ea5cfe761d6c3eab8be5af3e930b4e9813c9" translate="yes" xml:space="preserve">
          <source>RealFrac</source>
          <target state="translated">RealFrac</target>
        </trans-unit>
        <trans-unit id="72916ca84578a33d194a32dbc91dd0f2ffc568d0" translate="yes" xml:space="preserve">
          <source>RealWorld</source>
          <target state="translated">RealWorld</target>
        </trans-unit>
        <trans-unit id="5dba1501ceaedf9b453524d857a2faa617cb3fe6" translate="yes" xml:space="preserve">
          <source>Reason: a value of type &lt;code&gt;T&lt;/code&gt; must be represented as a pair of a dictionary for &lt;code&gt;Ord t&lt;/code&gt; and a value of type &lt;code&gt;t&lt;/code&gt;. That contradicts the idea that &lt;code&gt;newtype&lt;/code&gt; should have no concrete representation. You can get just the same efficiency and effect by using &lt;code&gt;data&lt;/code&gt; instead of &lt;code&gt;newtype&lt;/code&gt;. If there is no overloading involved, then there is more of a case for allowing an existentially-quantified &lt;code&gt;newtype&lt;/code&gt;, because the &lt;code&gt;data&lt;/code&gt; version does carry an implementation cost, but single-field existentially quantified constructors aren&amp;rsquo;t much use. So the simple restriction (no existential stuff on &lt;code&gt;newtype&lt;/code&gt;) stands, unless there are convincing reasons to change it.</source>
          <target state="translated">이유 : 타입의 값 &lt;code&gt;T&lt;/code&gt; 를 위한 사전의 쌍으로 표현되어야 &lt;code&gt;Ord t&lt;/code&gt; 및 입력 값 &lt;code&gt;t&lt;/code&gt; . 것을 모순 아이디어 그 &lt;code&gt;newtype&lt;/code&gt; 은이 구체적인 표현이 없습니다. &lt;code&gt;newtype&lt;/code&gt; 대신 &lt;code&gt;data&lt;/code&gt; 를 사용하면 동일한 효율성과 효과를 얻을 수 있습니다 . 과부하가 발생하지 않으면 &lt;code&gt;data&lt;/code&gt; 버전에 구현 비용이 들지만 단일 필드 존재 수량화 생성자가 많이 사용되지 않기 때문에 존재 수량화 된 &lt;code&gt;newtype&lt;/code&gt; 을 허용하는 경우가 더 많습니다. 그래서 간단한 제한 ( &lt;code&gt;newtype&lt;/code&gt; 에는 존재하지 않는 것들))는 설득력있는 이유가없는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9a6256eaed9ea1114a2efcaedbce4cb0208a3d14" translate="yes" xml:space="preserve">
          <source>Reason: exactly which implicit parameter you pick up depends on exactly where you invoke a function. But the &amp;ldquo;invocation&amp;rdquo; of instance declarations is done behind the scenes by the compiler, so it&amp;rsquo;s hard to figure out exactly where it is done. Easiest thing is to outlaw the offending types.</source>
          <target state="translated">이유 : 정확히 어떤 암시 적 매개 변수를 선택하는지는 함수를 호출 한 위치에 따라 다릅니다. 그러나 인스턴스 선언의 &quot;호출&quot;은 컴파일러에 의해 배후에서 수행되므로 정확히 어디에서 수행되는지 파악하기가 어렵습니다. 가장 쉬운 것은 문제 유형을 불법화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="298dc73731bc7a4749394c1ed1eaf9eac550e401" translate="yes" xml:space="preserve">
          <source>RebindableSyntax</source>
          <target state="translated">RebindableSyntax</target>
        </trans-unit>
        <trans-unit id="7b3fd32a019ac1e42cb2925f62672bed86d5adf3" translate="yes" xml:space="preserve">
          <source>Rec0</source>
          <target state="translated">Rec0</target>
        </trans-unit>
        <trans-unit id="1295aa259117100bd41b364e47ee19a8bf31b72d" translate="yes" xml:space="preserve">
          <source>Rec1</source>
          <target state="translated">Rec1</target>
        </trans-unit>
        <trans-unit id="1da832231b93d55790d520c684e009389eb2a703" translate="yes" xml:space="preserve">
          <source>RecConError</source>
          <target state="translated">RecConError</target>
        </trans-unit>
        <trans-unit id="fd95315fe03dd1800894931f422af84de4684d14" translate="yes" xml:space="preserve">
          <source>RecSelError</source>
          <target state="translated">RecSelError</target>
        </trans-unit>
        <trans-unit id="f3a0da81b45abf2b006fec20fa2d39ebbd2d4bbf" translate="yes" xml:space="preserve">
          <source>RecUpdError</source>
          <target state="translated">RecUpdError</target>
        </trans-unit>
        <trans-unit id="a335b25548f3bcd7b0fb7f79636f5e2db53c5a11" translate="yes" xml:space="preserve">
          <source>Recall our running &lt;code&gt;GMapKey&lt;/code&gt; class example:</source>
          <target state="translated">실행중인 &lt;code&gt;GMapKey&lt;/code&gt; 클래스 예제를 상기하십시오.</target>
        </trans-unit>
        <trans-unit id="903432601712147eb2434cb8c476ff0e83952cd7" translate="yes" xml:space="preserve">
          <source>Recipient</source>
          <target state="translated">Recipient</target>
        </trans-unit>
        <trans-unit id="9ef05c4a6741a87ca08b890fc7c21f33e2ad896a" translate="yes" xml:space="preserve">
          <source>RecipientClass</source>
          <target state="translated">RecipientClass</target>
        </trans-unit>
        <trans-unit id="78cbf8eb1d8fbe5db88f5c1a9c458b79c931b4c8" translate="yes" xml:space="preserve">
          <source>Recipients</source>
          <target state="translated">Recipients</target>
        </trans-unit>
        <trans-unit id="963a33a0896f0406c37381574c5bd6de3ca240a0" translate="yes" xml:space="preserve">
          <source>Reciprocal fraction.</source>
          <target state="translated">상호 분수.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="45d008c06807b89d2865fcbc138d7ad3f636b17b" translate="yes" xml:space="preserve">
          <source>Record external files that runIO is using (dependent upon). The compiler can then recognize that it should re-compile the Haskell file when an external file changes.</source>
          <target state="translated">runIO가 사용하는 외부 파일을 기록하십시오 (의존적). 그러면 컴파일러는 외부 파일이 변경 될 때 Haskell 파일을 다시 컴파일해야 함을 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b2f37c69064f4d60557c4a483d9e445adf20b7f" translate="yes" xml:space="preserve">
          <source>Record punning can also be used in an expression, writing, for example,</source>
          <target state="translated">레코드 정리는 표현과 같은 글쓰기에도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6bac77d0dae3258bae661dba81781e4a0a53223" translate="yes" xml:space="preserve">
          <source>Record punning permits the variable name to be elided, so one can simply write</source>
          <target state="translated">레코드 정리는 변수 이름을 생략 할 수 있으므로 간단히 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5738e1bf7489c65afdf5cf1dff634de18b8ff4" translate="yes" xml:space="preserve">
          <source>Record puns are enabled by the language extension &lt;a href=&quot;#extension-NamedFieldPuns&quot;&gt;&lt;code&gt;NamedFieldPuns&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">레코드 제거는 언어 확장 &lt;a href=&quot;#extension-NamedFieldPuns&quot;&gt; &lt;code&gt;NamedFieldPuns&lt;/code&gt; 에&lt;/a&gt; 의해 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="1e65b5bd099154053ee3160874855905008b6109" translate="yes" xml:space="preserve">
          <source>Record update syntax is supported for existentials (and GADTs):</source>
          <target state="translated">레코드 업데이트 구문은 실존 및 GADT에 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="97ef08acc2a72cd32dfb1cf2b2819a6144dc81c7" translate="yes" xml:space="preserve">
          <source>Record updates are allowed with GADT-style declarations, only fields that have the following property: the type of the field mentions no existential type variables.</source>
          <target state="translated">GADT 스타일 선언을 사용하면 레코드 업데이트가 허용되며 다음 속성을 가진 필드 만 가능합니다. 필드 유형에 존재하는 유형 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f66d5685b07c4c5f1ed77f33423e67329db7364a" translate="yes" xml:space="preserve">
          <source>Record wildcard syntax permits a &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; in a record pattern, where each elided field &lt;code&gt;f&lt;/code&gt; is replaced by the pattern &lt;code&gt;f = f&lt;/code&gt;. For example, the above pattern can be written as</source>
          <target state="translated">레코드 와일드 카드 구문 은 레코드 패턴에서 &amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;을 허용합니다 . 여기서 각 생략 된 필드 &lt;code&gt;f&lt;/code&gt; 는 패턴 &lt;code&gt;f = f&lt;/code&gt; 로 대체됩니다 . 예를 들어, 위 패턴은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84df017928cd2888fe54c1800d0964a95c8472d" translate="yes" xml:space="preserve">
          <source>Record wildcards are enabled by the language extension &lt;a href=&quot;#extension-RecordWildCards&quot;&gt;&lt;code&gt;RecordWildCards&lt;/code&gt;&lt;/a&gt;. This exension implies &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">레코드 와일드 카드는 언어 확장 &lt;a href=&quot;#extension-RecordWildCards&quot;&gt; &lt;code&gt;RecordWildCards&lt;/code&gt; 에&lt;/a&gt; 의해 사용 가능합니다 . 이 exension는 의미 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ff47d4cf5dcf2f6329432ce3f29be7e4ab2c66" translate="yes" xml:space="preserve">
          <source>Record wildcards can also be used in an expression, when constructing a record. For example,</source>
          <target state="translated">레코드를 작성할 때 레코드 와일드 카드를 표현식에 사용할 수도 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9336bd8c227cff18636f075435644bdb01f6a34f" translate="yes" xml:space="preserve">
          <source>Record wildcards cannot be used (a) in a record update construct, and (b) for data constructors that are not declared with record fields. For example:</source>
          <target state="translated">레코드 와일드 카드는 (a) 레코드 업데이트 구문에서 사용할 수 없으며 (b) 레코드 필드로 선언되지 않은 데이터 생성자에는 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edd96f87f6d5e76d68e7b04dc0fd9a0c6dbb1f87" translate="yes" xml:space="preserve">
          <source>Record wildcards in patterns can be mixed with other patterns, including puns (&lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;); for example, in a pattern &lt;code&gt;(C {a = 1, b, ..})&lt;/code&gt;. Additionally, record wildcards can be used wherever record patterns occur, including in &lt;code&gt;let&lt;/code&gt; bindings and at the top-level. For example, the top-level binding</source>
          <target state="translated">패턴의 레코드 와일드 카드는 펑 ( &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt; )을 포함하여 다른 패턴과 혼합 될 수 있습니다 . 예를 들어 패턴 &lt;code&gt;(C {a = 1, b, ..})&lt;/code&gt; . 기록 패턴이 발생하는 곳 또한 기록 와일드 카드에 포함하여, 사용할 수있는 &lt;code&gt;let&lt;/code&gt; 바인딩 및 최상위에서. 예를 들어 최상위 바인딩</target>
        </trans-unit>
        <trans-unit id="51710a4a1d384e827a832ae47b51f21552a87d3d" translate="yes" xml:space="preserve">
          <source>RecordPuns</source>
          <target state="translated">RecordPuns</target>
        </trans-unit>
        <trans-unit id="97d6c35fb960d0aa87a71bff4ce123711c88fffa" translate="yes" xml:space="preserve">
          <source>RecordWildCards</source>
          <target state="translated">RecordWildCards</target>
        </trans-unit>
        <trans-unit id="2eeb2a517c2c3eb4abfae9862f77f4fe5dd0c9c7" translate="yes" xml:space="preserve">
          <source>Recover from errors raised by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reportError&quot;&gt;reportError&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reportError&quot;&gt;reportError&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 발생한 오류를 복구하십시오 .</target>
        </trans-unit>
        <trans-unit id="704ab362682b8edb6407654f5c2a1ef4eb552a64" translate="yes" xml:space="preserve">
          <source>Recover from errors raised by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reportError&quot;&gt;reportError&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reportError&quot;&gt;reportError&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 발생한 오류를 복구하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd04839409ff12019afbb419b342d461f21fedc9" translate="yes" xml:space="preserve">
          <source>Recover from the monadic &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">모나드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 에서 복구</target>
        </trans-unit>
        <trans-unit id="0c339e2dbf9dd56253cac56b4a41d7147875527a" translate="yes" xml:space="preserve">
          <source>Rectangular form</source>
          <target state="translated">직사각형</target>
        </trans-unit>
        <trans-unit id="3f83835e919f45852d22ee0e479c39ce851cbd86" translate="yes" xml:space="preserve">
          <source>Recursive &lt;code&gt;do&lt;/code&gt;-statements (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/1262&quot;&gt;#1262&lt;/a&gt;)</source>
          <target state="translated">재귀 &lt;code&gt;do&lt;/code&gt; -statements (참조 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/1262&quot;&gt;1262 #을&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="716fd56982c99c47413170dcc01f043f0ea5c5dd" translate="yes" xml:space="preserve">
          <source>Recursive &lt;code&gt;do&lt;/code&gt;-statements (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/1262&quot;&gt;Issue #1262&lt;/a&gt;)</source>
          <target state="translated">재귀 &lt;code&gt;do&lt;/code&gt; -statements (참조 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/1262&quot;&gt;1262 이슈 번호를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2c0e843943bdbb03678f7b901c80e258f54ba263" translate="yes" xml:space="preserve">
          <source>Recursive calls of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; (or kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, when &lt;code&gt;PolyKinds&lt;/code&gt; is enabled)</source>
          <target state="translated">종류 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 의 재귀 호출 (또는 &lt;code&gt;PolyKinds&lt;/code&gt; 가 활성화 된 경우 종류 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="54fc751a32ae132cec503b25942dbbe06a266bd1" translate="yes" xml:space="preserve">
          <source>RecursiveDo</source>
          <target state="translated">RecursiveDo</target>
        </trans-unit>
        <trans-unit id="275dacbf9d7809835c038a9a00d1c21a893a8aa0" translate="yes" xml:space="preserve">
          <source>Recursively add a closure and its transitive closure to a &lt;code&gt;Compact#&lt;/code&gt;, evaluating any unevaluated components at the same time. Note: &lt;code&gt;compactAdd#&lt;/code&gt; is not thread-safe, so only one thread may call &lt;code&gt;compactAdd#&lt;/code&gt; with a particular &lt;code&gt;Compact#&lt;/code&gt; at any given time. The primop does not enforce any mutual exclusion; the caller is expected to arrange this.</source>
          <target state="translated">클로저 및 전이 클로저를 재귀 적으로 &lt;code&gt;Compact#&lt;/code&gt; 추가하여 평가되지 않은 구성 요소를 동시에 평가합니다. 참고 : &lt;code&gt;compactAdd#&lt;/code&gt; 는 스레드로부터 안전하지 않으므로 특정 &lt;code&gt;Compact#&lt;/code&gt; 사용하여 하나의 스레드 만 &lt;code&gt;compactAdd#&lt;/code&gt; 를 호출 할 수 있습니다 . . Primop은 상호 배제를 강요하지 않습니다. 발신자는이를 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="9db42c28c37a1bd7dcd5d9a57ba47b3781f19c59" translate="yes" xml:space="preserve">
          <source>Recursively loads the specified ⟨module⟩s, and all the modules they depend on. Here, each ⟨module⟩ must be a module name or filename, but may not be the name of a module in a package.</source>
          <target state="translated">지정된 모듈과 모듈에 의존하는 모든 모듈을 재귀 적으로로드합니다. 여기서 각 ⟨module⟩은 모듈 이름 또는 파일 이름이어야하지만 패키지의 모듈 이름이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc9db3a795571c7e71f45670a1da7ff49b5f1557" translate="yes" xml:space="preserve">
          <source>Red</source>
          <target state="translated">Red</target>
        </trans-unit>
        <trans-unit id="f35448b6bee96de50ae1e8ff57c24c8d1e0d25df" translate="yes" xml:space="preserve">
          <source>Redirects all dump files into ⟨dir⟩. Dump files are generated when &lt;code&gt;-ddump-to-file&lt;/code&gt; is used with other &lt;code&gt;-ddump-*&lt;/code&gt; flags.</source>
          <target state="translated">모든 덤프 파일을 ⟨dir⟩로 리디렉션합니다. &lt;code&gt;-ddump-to-file&lt;/code&gt; 을 다른 &lt;code&gt;-ddump-*&lt;/code&gt; 와 함께 사용 하면 덤프 파일이 생성됩니다. 플래그 .</target>
        </trans-unit>
        <trans-unit id="ffcee6acb573e513bf54e2fecdf8ac60da3281ec" translate="yes" xml:space="preserve">
          <source>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are generated when the Haskell source contains a &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;&amp;amp;wrapper&quot;&lt;/code&gt; declaration (see &lt;a href=&quot;ffi-chap#foreign-export-ghc&quot;&gt;Using foreign export and foreign import ccall &quot;wrapper&quot; with GHC&lt;/a&gt;). The &lt;code&gt;-stubdir&lt;/code&gt; option behaves in exactly the same way as &lt;code&gt;-odir&lt;/code&gt; and &lt;code&gt;-hidir&lt;/code&gt; with respect to hierarchical modules.</source>
          <target state="translated">생성 된 모든 FFI 스텁 파일을 ⟨dir⟩로 리디렉션합니다. Haskell 소스에 &lt;code&gt;foreign export&lt;/code&gt; 또는 &lt;code&gt;foreign import &quot;&amp;amp;wrapper&quot;&lt;/code&gt; 선언이 포함 된 경우 스텁 파일이 생성됩니다 ( &lt;a href=&quot;ffi-chap#foreign-export-ghc&quot;&gt;GHC와 함께 외부 내보내기 및 외부 가져 오기 ccall &quot;wrapper&quot;사용&lt;/a&gt; 참조 ). &lt;code&gt;-stubdir&lt;/code&gt; 와 완전히 같은 방법으로 옵션 동작합니다 &lt;code&gt;-odir&lt;/code&gt; 및 &lt;code&gt;-hidir&lt;/code&gt; 계층 모듈에 대해.</target>
        </trans-unit>
        <trans-unit id="a7b3350c72033f92144bca80ed9c6189a91698b5" translate="yes" xml:space="preserve">
          <source>Redirects all generated FFI stub files into ⟨dir⟩. Stub files are generated when the Haskell source contains a &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;&amp;amp;wrapper&quot;&lt;/code&gt; declaration (see &lt;a href=&quot;ffi-chap#foreign-export-ghc&quot;&gt;Using foreign export and foreign import ccall &amp;ldquo;wrapper&amp;rdquo; with GHC&lt;/a&gt;). The &lt;code&gt;-stubdir&lt;/code&gt; option behaves in exactly the same way as &lt;code&gt;-odir&lt;/code&gt; and &lt;code&gt;-hidir&lt;/code&gt; with respect to hierarchical modules.</source>
          <target state="translated">생성 된 모든 FFI 스텁 파일을 ⟨dir⟩로 리디렉션합니다. 스텁 파일은 Haskell 소스에 &lt;code&gt;foreign export&lt;/code&gt; 또는 &lt;code&gt;foreign import &quot;&amp;amp;wrapper&quot;&lt;/code&gt; 선언이 포함 된 경우 생성됩니다 ( &lt;a href=&quot;ffi-chap#foreign-export-ghc&quot;&gt;GHC와 함께 외국 수출 및 외국 수입 ccall &quot;wrapper&quot;사용&lt;/a&gt; 참조 ). &lt;code&gt;-stubdir&lt;/code&gt; 와 완전히 같은 방법으로 옵션 동작합니다 &lt;code&gt;-odir&lt;/code&gt; 및 &lt;code&gt;-hidir&lt;/code&gt; 계층 모듈에 대해.</target>
        </trans-unit>
        <trans-unit id="3486a9a9a04e6a11f983fe636c723b4aeb99470d" translate="yes" xml:space="preserve">
          <source>Redirects all generated extended interface files into ⟨dir⟩, instead of the default.</source>
          <target state="translated">생성 된 모든 확장 인터페이스 파일을 기본값 대신 ⟨dir⟩로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="fafb4cb103b058c31d0ca01a68bbcf1d4a74a011" translate="yes" xml:space="preserve">
          <source>Redirects all generated interface files into ⟨dir⟩, instead of the default.</source>
          <target state="translated">생성 된 모든 인터페이스 파일을 기본값 대신 ⟨dir⟩로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="bafa491122d5e3b44d04eabce2ce9d4d9f3fe18e" translate="yes" xml:space="preserve">
          <source>Redirects object files to directory ⟨dir⟩. For example:</source>
          <target state="translated">객체 파일을 ⟨dir⟩ 디렉토리로 리디렉션합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb62c4540305507d65a57dcc74037f8d6c22e2bf" translate="yes" xml:space="preserve">
          <source>Reduce a non-empty list with &lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 로 비어 있지 않은 목록을 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="f669409b9317be7b6c92d9326e3ee545e967f0d9" translate="yes" xml:space="preserve">
          <source>Reduce a non-empty list with &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 로 비어 있지 않은 목록을 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="3b0a10cb566308fbe77ba8e40a66aaf874f1d51f" translate="yes" xml:space="preserve">
          <source>Reduce to weak head normal form</source>
          <target state="translated">약한 머리 정상 형태로 줄이십시오</target>
        </trans-unit>
        <trans-unit id="cc4741026efb7365015adcf01e2a9a9c11506ab0" translate="yes" xml:space="preserve">
          <source>Reduces a structure of lists to the concatenation of those lists.</source>
          <target state="translated">목록 구조를 해당 목록의 연결로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="68e6f6e8e5e68a420b8551a7827770ccd24a99b7" translate="yes" xml:space="preserve">
          <source>Reducing &lt;code&gt;ByteString&lt;/code&gt;s (folds)</source>
          <target state="translated">감소 &lt;code&gt;ByteString&lt;/code&gt; 의 (주름)</target>
        </trans-unit>
        <trans-unit id="5500c49978ea320adb112aadfa31adc296c7ccd5" translate="yes" xml:space="preserve">
          <source>Reducing lists (folds)</source>
          <target state="translated">리스트 축소하기</target>
        </trans-unit>
        <trans-unit id="2c4aefee968159da773bf3395f055cf516177a64" translate="yes" xml:space="preserve">
          <source>Reexports merge with local declarations; thus, the signature above would successfully merge with:</source>
          <target state="translated">다시 내보내기는 로컬 선언과 병합됩니다. 따라서 위의 서명은 다음과 성공적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="93603a5396d363713d725c65e1f3008ad8c1b7a0" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;glasgow_exts#generic-programming&quot;&gt;generic programming&lt;/a&gt; section for more details.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#generic-programming&quot;&gt;일반 프로그래밍&lt;/a&gt; 참조 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="008c7de1b7be309f3cfe58bf315edd6c93f49696" translate="yes" xml:space="preserve">
          <source>Refer to the docs of &lt;code&gt;&lt;a href=&quot;system-directory#t:XdgDirectory&quot;&gt;XdgDirectory&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:XdgDirectory&quot;&gt;XdgDirectory&lt;/a&gt;&lt;/code&gt; 문서를 참조하십시오 내용 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e74b881339b17289107509d95c7d406494002649" translate="yes" xml:space="preserve">
          <source>Refer to the docs of &lt;code&gt;&lt;a href=&quot;system-directory#t:XdgDirectoryList&quot;&gt;XdgDirectoryList&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:XdgDirectoryList&quot;&gt;XdgDirectoryList&lt;/a&gt;&lt;/code&gt; 의 문서를 참조하십시오 내용 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a9435c3cde07529a15a70848b5052f1d7119dcc" translate="yes" xml:space="preserve">
          <source>References (variables) that can be used within the &lt;code&gt;ST&lt;/code&gt; monad are provided by &lt;a href=&quot;data-stref&quot;&gt;Data.STRef&lt;/a&gt;, and arrays are provided by &lt;a href=&quot;https://hackage.haskell.org/package/array/docs/Data-Array-ST.html&quot;&gt;Data.Array.ST&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; 모나드 내에서 사용할 수있는 참조 (변수)는 &lt;a href=&quot;data-stref&quot;&gt;Data.STRef&lt;/a&gt; 에 의해 제공되며 배열은 &lt;a href=&quot;https://hackage.haskell.org/package/array/docs/Data-Array-ST.html&quot;&gt;Data.Array.ST&lt;/a&gt; 에 의해 제공됩니다 . .</target>
        </trans-unit>
        <trans-unit id="afaad511a2f264ef617c4bd5e27041cac47430f5" translate="yes" xml:space="preserve">
          <source>References from the finalizer to the key are treated in the same way as references from the value to the key: they do not keep the key alive. A finalizer may therefore ressurrect the key, perhaps by storing it in the same data structure.</source>
          <target state="translated">종료 자에서 키로의 참조는 값에서 키로의 참조와 같은 방식으로 처리됩니다. 키를 유지하지 않습니다. 따라서 파이널 라이저는 아마도 동일한 데이터 구조에 키를 저장하여 키를 다시 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ae6b3b0a70dc93123b509716449ade56205cac7" translate="yes" xml:space="preserve">
          <source>References in the &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드 에서의 참조 .</target>
        </trans-unit>
        <trans-unit id="de8ec027bf3ad9a65f5743cae14aaade0d944700" translate="yes" xml:space="preserve">
          <source>References to values are usually implemented with memory addresses, and this is practical when communicating values between the different pieces of a single process.</source>
          <target state="translated">값에 대한 참조는 일반적으로 메모리 주소로 구현되며 이는 단일 프로세스의 다른 부분간에 값을 통신 할 때 실용적입니다.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="18431dfb97e878f723ad36ab7a585ebcaa439ca3" translate="yes" xml:space="preserve">
          <source>References: [1] &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx&quot;&gt;Naming Files, Paths and Namespaces&lt;/a&gt; (Microsoft MSDN)</source>
          <target state="translated">참조 : [1] &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx&quot;&gt;이름 지정 파일, 경로 및 네임 스페이스&lt;/a&gt; (Microsoft MSDN)</target>
        </trans-unit>
        <trans-unit id="bf39b7c2c01888d0a805f728bbe9717c8be184e4" translate="yes" xml:space="preserve">
          <source>Reflexivity</source>
          <target state="translated">Reflexivity</target>
        </trans-unit>
        <trans-unit id="1921671fa378a21fecd5903582dca373a968309c" translate="yes" xml:space="preserve">
          <source>Regard &lt;code&gt;⟨file⟩&lt;/code&gt; as &quot;stable&quot;; i.e., exclude it from having dependencies on it.</source>
          <target state="translated">관련 &lt;code&gt;⟨file⟩&lt;/code&gt; &quot;안정적&quot;으로; 즉, 종속 항목에서 제외합니다.</target>
        </trans-unit>
        <trans-unit id="a7d04efb9a6f71bcdf9b0e41c63b9b9158d592af" translate="yes" xml:space="preserve">
          <source>Regard &lt;code&gt;⟨file⟩&lt;/code&gt; as &amp;ldquo;stable&amp;rdquo;; i.e., exclude it from having dependencies on it.</source>
          <target state="translated">시선 &lt;code&gt;⟨file⟩&lt;/code&gt; &quot;안정적&quot;으로; 즉, 의존성을 갖지 않도록 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="0862e2ed7b6d956e6625b587fceb18c941739a9d" translate="yes" xml:space="preserve">
          <source>Regard modules imported from packages as unstable</source>
          <target state="translated">패키지에서 가져온 모듈을 불안정한 것으로 간주</target>
        </trans-unit>
        <trans-unit id="019202863ab0d69f33936ecc2a2b973d9fe8bc76" translate="yes" xml:space="preserve">
          <source>Regard modules imported from packages as unstable, i.e., generate dependencies on any imported package modules (including &lt;code&gt;Prelude&lt;/code&gt;, and all other standard Haskell libraries). Dependencies are not traced recursively into packages; dependencies are only generated for home-package modules on external-package modules directly imported by the home package module. This option is normally only used by the various system libraries.</source>
          <target state="translated">패키지에서 가져온 모듈을 불안정한 것으로 간주합니다. 즉, 가져온 패키지 모듈 ( &lt;code&gt;Prelude&lt;/code&gt; 포함)에 대한 종속성을 생성합니다 및 기타 모든 표준 Haskell 라이브러리 포함) 합니다. 종속성은 패키지에서 재귀 적으로 추적되지 않습니다. 홈 패키지 모듈에서 직접 가져온 외부 패키지 모듈의 홈 패키지 모듈에 대해서만 종속성이 생성됩니다. 이 옵션은 일반적으로 다양한 시스템 라이브러리에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c8723345072b355716dc59e64fea77c552c234c" translate="yes" xml:space="preserve">
          <source>Regardless of &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, instance declarations must conform to some rules that ensure that instance resolution will terminate. The restrictions can be lifted with &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#undecidable-instances&quot;&gt;Undecidable instances&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 에&lt;/a&gt; 관계없이 인스턴스 선언은 인스턴스 확인이 종료되도록하는 일부 규칙을 준수해야합니다. &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; 로&lt;/a&gt; 제한을 해제 할 수 있습니다 ( &lt;a href=&quot;#undecidable-instances&quot;&gt;결정 불가능한 인스턴스&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7189eefa1e3c6484fdace23f3d98f24bbfcd39e2" translate="yes" xml:space="preserve">
          <source>Register a timeout in the given number of microseconds. The returned &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutKey&quot;&gt;TimeoutKey&lt;/a&gt;&lt;/code&gt; can be used to later unregister or update the timeout. The timeout is automatically unregistered after the given time has passed.</source>
          <target state="translated">지정된 시간 (마이크로 초)에 시간 초과를 등록하십시오. 반환 된 &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutKey&quot;&gt;TimeoutKey&lt;/a&gt;&lt;/code&gt; 를 사용하여 나중에 시간 초과를 등록 취소하거나 업데이트 할 수 있습니다. 지정된 시간이 지나면 시간 초과가 자동으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="ed9c07ccabe87a6a9007fc8cf055b8d53c52c17d" translate="yes" xml:space="preserve">
          <source>Registering interest in I/O events</source>
          <target state="translated">I / O 이벤트에 관심 등록</target>
        </trans-unit>
        <trans-unit id="54bddb98d2f657e2c79f06e4e172971579927de0" translate="yes" xml:space="preserve">
          <source>Registering interest in timeout events</source>
          <target state="translated">타임 아웃 이벤트에 관심 등록</target>
        </trans-unit>
        <trans-unit id="adf918739536fb0b0aeadbe1e82a7486651388cb" translate="yes" xml:space="preserve">
          <source>RegularFile</source>
          <target state="translated">RegularFile</target>
        </trans-unit>
        <trans-unit id="edc7ba7cf8b346f1f896a17a01f9d5133beec7fc" translate="yes" xml:space="preserve">
          <source>Reification always returns a pattern synonym's &lt;em&gt;fully&lt;/em&gt; specified type in abstract syntax.</source>
          <target state="translated">Reification은 항상 추상 구문 으로 패턴 동의어의 &lt;em&gt;완전히&lt;/em&gt; 지정된 유형을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5bf8562f4d732fe1a6c21b59731f146166f9ff53" translate="yes" xml:space="preserve">
          <source>Reify</source>
          <target state="translated">Reify</target>
        </trans-unit>
        <trans-unit id="0f962ad51f159e8557fb498cb39e85f2ac566701" translate="yes" xml:space="preserve">
          <source>Related utilities</source>
          <target state="translated">관련 유틸리티</target>
        </trans-unit>
        <trans-unit id="73f01ad7eb3510ed60e70d9f2520b22efaee1381" translate="yes" xml:space="preserve">
          <source>Relative cursor movements</source>
          <target state="translated">상대 커서 이동</target>
        </trans-unit>
        <trans-unit id="1c57e196778cc938a34ed9979a01ca63f8bc5b5a" translate="yes" xml:space="preserve">
          <source>RelativeSeek</source>
          <target state="translated">RelativeSeek</target>
        </trans-unit>
        <trans-unit id="922f646acf7186971e6f5ad3405009de06151459" translate="yes" xml:space="preserve">
          <source>Relax many of the Haskell 98 rules on type synonym definitions.</source>
          <target state="translated">타입 동의어 정의에 관한 많은 Haskell 98 규칙을 완화하십시오.</target>
        </trans-unit>
        <trans-unit id="c6448e9010ce738714d5f43f5ecfb4be301d62a4" translate="yes" xml:space="preserve">
          <source>Relax restrictions on the decidability of type synonym family instances.</source>
          <target state="translated">동의어 패밀리 인스턴스 유형의 결정 가능성에 대한 제한을 완화하십시오.</target>
        </trans-unit>
        <trans-unit id="e90a12b3f26debfd7118805fe63817f39ff4e8fd" translate="yes" xml:space="preserve">
          <source>RelaxedLayout</source>
          <target state="translated">RelaxedLayout</target>
        </trans-unit>
        <trans-unit id="9844dfcb0240e7df480fd384606acd4ece12f354" translate="yes" xml:space="preserve">
          <source>RelaxedPolyRec</source>
          <target state="translated">RelaxedPolyRec</target>
        </trans-unit>
        <trans-unit id="c5033c11bde2f550a77d7d9e2a73f78a23e0b707" translate="yes" xml:space="preserve">
          <source>Release &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:HValueRef&quot;&gt;HValueRef&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">릴리스 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:HValueRef&quot;&gt;HValueRef&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="0eab4b131f1b19fe164b700fad7f1ab96e1f803d" translate="yes" xml:space="preserve">
          <source>Release a lock taken with &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hTryLock&quot;&gt;hTryLock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hTryLock&quot;&gt;hTryLock&lt;/a&gt;&lt;/code&gt; 을 사용하여 잠금을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ebb203461a0aa4dd07920b5d21f54c9db54c7ae" translate="yes" xml:space="preserve">
          <source>Release an HValueRef that originated in this process</source>
          <target state="translated">이 프로세스에서 시작된 HValueRef를 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d0a27c957a07066e9e8f08e838df96108bbbc5" translate="yes" xml:space="preserve">
          <source>Release the storage associated with the given &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;, which must have been obtained from a wrapper stub. This should be called whenever the return value from a foreign import wrapper function is no longer required; otherwise, the storage it uses will leak.</source>
          <target state="translated">래퍼 스텁에서 확보 한 지정된 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 과 연관된 스토리지를 해제하십시오 . 외부 가져 오기 랩퍼 함수의 리턴 값이 더 이상 필요하지 않을 때마다 호출해야합니다. 그렇지 않으면 사용하는 스토리지가 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="8c43bb248aeb7b0967ec7b99ac7ca9c40c0839b9" translate="yes" xml:space="preserve">
          <source>Remote GHCi message types and serialization.</source>
          <target state="translated">원격 GHCi 메시지 유형 및 직렬화</target>
        </trans-unit>
        <trans-unit id="2d1f5938098d57afebae29c3469844d3f945ff39" translate="yes" xml:space="preserve">
          <source>Remote interface to GHC.Exts.Heap.getClosureData. This is used by the GHCi debugger to inspect values in the heap for :print and type reconstruction.</source>
          <target state="translated">GHC.Exts.Heap.getClosureData에 대한 원격 인터페이스. 이것은 GHCi 디버거에서 힙의 : print 및 type 재구성에 대한 값을 검사하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd648c6ca3fe3114aa1f6f720f459d7276ee033" translate="yes" xml:space="preserve">
          <source>RemotePtr</source>
          <target state="translated">RemotePtr</target>
        </trans-unit>
        <trans-unit id="187a245e1a8b6a27415032217dc5a06a99cd68c0" translate="yes" xml:space="preserve">
          <source>RemoteRef</source>
          <target state="translated">RemoteRef</target>
        </trans-unit>
        <trans-unit id="85785f66358814b69df1c70621bcdd7e763d273b" translate="yes" xml:space="preserve">
          <source>Remove an existing &lt;em&gt;directory&lt;/em&gt; symbolic link.</source>
          <target state="translated">기존 &lt;em&gt;디렉토리&lt;/em&gt; 기호 링크를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="0673999ce87506fb5cef09cfbc8dadd5f55cc367" translate="yes" xml:space="preserve">
          <source>Remove any trailing path separators</source>
          <target state="translated">후행 경로 구분 기호를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="8beb6c3c391ddccec77b63bbbde93caf11d17ff0" translate="yes" xml:space="preserve">
          <source>Remove last extension, and the &quot;.&quot; preceding it.</source>
          <target state="translated">마지막 확장자와 &quot;.&quot;를 제거하십시오. 그 전에.</target>
        </trans-unit>
        <trans-unit id="05c187b401a36b809081bde68b4c2aea820fadae" translate="yes" xml:space="preserve">
          <source>Remove redundant trailing slashes and pick the right kind of slash.</source>
          <target state="translated">중복 후행 슬래시를 제거하고 올바른 종류의 슬래시를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="c9e36bf68473eb7f3968e4856066a37060f5834e" translate="yes" xml:space="preserve">
          <source>Remove the current extension and add another, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 확장을 제거하고 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; 과 동일한 다른 확장을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="eec592bd28fecce5e8f5d2be48f7668f7794a216" translate="yes" xml:space="preserve">
          <source>Remove the current extension and add another, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 확장을 제거하고 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; 과 동일한 다른 확장을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="17578b00b37aed0982773868dca74948f1bfdae5" translate="yes" xml:space="preserve">
          <source>Remove the global package database from the package database stack.</source>
          <target state="translated">패키지 데이터베이스 스택에서 글로벌 패키지 데이터베이스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="7bd9c8003f540a0748e2a3ac9a5b859dc7cdda77" translate="yes" xml:space="preserve">
          <source>Remove the global package db from the stack.</source>
          <target state="translated">스택에서 글로벌 패키지 db를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f10c6fc20b38689163ee373e60892416930fb37e" translate="yes" xml:space="preserve">
          <source>Remove the specified package from the database.</source>
          <target state="translated">데이터베이스에서 지정된 패키지를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="11145f3391ca6d052a2bbe930ffcdde0a5e0e622" translate="yes" xml:space="preserve">
          <source>Remove the user&amp;rsquo;s package db from the stack.</source>
          <target state="translated">스택에서 사용자의 패키지 DB를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="4cfc9b66e86496c9a43261651fd6bc11bc6aba2f" translate="yes" xml:space="preserve">
          <source>Remove the user's package db from the stack.</source>
          <target state="translated">스택에서 사용자의 패키지 db를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="75a1d14db76bff13b9d83408f48419f4032867f1" translate="yes" xml:space="preserve">
          <source>Removes a file or directory at &lt;em&gt;path&lt;/em&gt; together with its contents and subdirectories. Symbolic links are removed without affecting their targets. If the path does not exist, nothing happens.</source>
          <target state="translated">파일이나 디렉토리를 내용 및 하위 디렉토리와 함께 &lt;em&gt;경로&lt;/em&gt; 에서 제거합니다 . 대상에 영향을주지 않고 심볼릭 링크가 제거됩니다. 경로가 존재하지 않으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dddbede7e13f9ce87fd5bc843c1cc2df052efa66" translate="yes" xml:space="preserve">
          <source>Rename a file or directory. If the destination path already exists, it is replaced atomically. The destination path must not point to an existing directory. A conformant implementation need not support renaming files in all situations (e.g. renaming across different physical devices), but the constraints must be documented.</source>
          <target state="translated">파일 또는 디렉토리의 이름을 바꾸십시오. 대상 경로가 이미 존재하면 원자 경로로 바뀝니다. 대상 경로는 기존 디렉토리를 가리켜서는 안됩니다. 적합한 구현은 모든 상황에서 파일 이름 바꾸기 (예 : 다른 물리적 장치에서 이름 바꾸기)를 지원할 필요는 없지만 제약 조건을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7349a34435850bc973a75584dea2319034c0124" translate="yes" xml:space="preserve">
          <source>Renamer stats</source>
          <target state="translated">Renamer 통계</target>
        </trans-unit>
        <trans-unit id="9e1ec92d4c65cbeb56b4afb5c7eb5b28b06150b9" translate="yes" xml:space="preserve">
          <source>Renaming files</source>
          <target state="translated">파일 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="57bb091db8c41259255e747c0ecd1b604c7e516e" translate="yes" xml:space="preserve">
          <source>Render a document with annotations, by interpreting the start and end of the annotations, as well as the text details in the context of a monad.</source>
          <target state="translated">주석의 시작과 끝 및 모나드 컨텍스트의 텍스트 세부 사항을 해석하여 주석이있는 문서를 렌더링하십시오.</target>
        </trans-unit>
        <trans-unit id="a9a4799c8dd61934677f0523fd77b9ce5a5bae56" translate="yes" xml:space="preserve">
          <source>Render a piece of HTML without adding a DOCTYPE declaration or root element. Does not add any extra whitespace.</source>
          <target state="translated">DOCTYPE 선언 또는 루트 요소를 추가하지 않고 HTML을 렌더링하십시오. 여분의 공백을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0396f6604a2cd217fc5188ee1468a23a68c8152" translate="yes" xml:space="preserve">
          <source>Render a piece of indented HTML without adding a DOCTYPE declaration or a root element. The indentation is done inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DOCTYPE 선언이나 루트 요소를 추가하지 않고 들여 쓰기 된 HTML 조각을 렌더링하십시오. 들여 쓰기는 요소 내부에서 수행됩니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a89ea59d1fabd252ac4ff35ea0e42758d3ed5fc6" translate="yes" xml:space="preserve">
          <source>Render a piece of indented HTML without adding a DOCTYPE declaration or a root element. The indentation is done inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DOCTYPE 선언이나 루트 요소를 추가하지 않고 들여 쓰기 된 HTML 조각을 렌더링하십시오. 들여 쓰기는 요소 내부에서 수행됩니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0f0aa368898e42e42051599ad438bce930756e" translate="yes" xml:space="preserve">
          <source>Render a piece of indented HTML without adding a DOCTYPE declaration or a root element. The indentation is done inside elements. This can change the meaning of the HTML document, and is mostly useful for debugging the HTML output. The implementation is inefficient, and you are normally better off using &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DOCTYPE 선언이나 루트 요소를 추가하지 않고 들여 쓰기 된 HTML 조각을 렌더링하십시오. 들여 쓰기는 요소 내부에서 수행됩니다. HTML 문서의 의미를 변경할 수 있으며 HTML 출력을 디버깅하는 데 주로 유용합니다. 구현은 비효율적이며 일반적으로 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:showHtmlFragment&quot;&gt;showHtmlFragment&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#v:renderHtmlFragment&quot;&gt;renderHtmlFragment&lt;/a&gt;&lt;/code&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="71fee5123224c152c3f87461295917f353b82c69" translate="yes" xml:space="preserve">
          <source>Render a piece of indented HTML without adding a DOCTYPE declaration or root element. Only adds whitespace where it does not change the meaning of the document.</source>
          <target state="translated">DOCTYPE 선언 또는 루트 요소를 추가하지 않고 들여 쓰기 된 HTML 조각을 렌더링하십시오. 문서의 의미를 변경하지 않는 공백 만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="989a09007121599919344bf188e1cc94bb96ae11" translate="yes" xml:space="preserve">
          <source>Render a stacktrace as a string</source>
          <target state="translated">스택 추적을 문자열로 렌더링</target>
        </trans-unit>
        <trans-unit id="1c7773afe751d705bbb0bab378fcfc6c481f0947" translate="yes" xml:space="preserve">
          <source>Render an annotated &lt;code&gt;Doc&lt;/code&gt; to a String and list of annotations (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt;) using the default &lt;code&gt;Style&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;Style&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 참조 )을 사용하여 주석 이 달린 &lt;code&gt;Doc&lt;/code&gt; 을 String 및 주석 목록 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 참조 )에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="9f470695f470e172217ac5b861bd07c99096b4a5" translate="yes" xml:space="preserve">
          <source>Render an annotated &lt;code&gt;Doc&lt;/code&gt; to a String and list of annotations (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt;) using the default &lt;code&gt;Style&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;Style&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 참조 )을 사용하여 주석 이 달린 &lt;code&gt;Doc&lt;/code&gt; 을 String 및 주석 목록 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Span&quot;&gt;Span&lt;/a&gt;&lt;/code&gt; 참조 )에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="92ba9e1fab478804fa747870260b0ff064c15ae9" translate="yes" xml:space="preserve">
          <source>Render out a String, interpreting the annotations as part of the resulting document.</source>
          <target state="translated">주석을 결과 문서의 일부로 해석하여 문자열을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="74c43db33234ecef01eb99606404a4b48f7d70ce" translate="yes" xml:space="preserve">
          <source>Render the &lt;code&gt;Doc&lt;/code&gt; to a String using the default &lt;code&gt;Style&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;Style&lt;/code&gt; 사용하여 &lt;code&gt;Doc&lt;/code&gt; 를 문자열로 렌더링합니다 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3f8842d2196fa6bcd3a6003035321861d97ea702" translate="yes" xml:space="preserve">
          <source>Render the &lt;code&gt;Doc&lt;/code&gt; to a String using the default &lt;code&gt;Style&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;Style&lt;/code&gt; 사용하여 &lt;code&gt;Doc&lt;/code&gt; 를 문자열로 렌더링합니다 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="87d0d1bd7f492f89f6856659a698622e65a18512" translate="yes" xml:space="preserve">
          <source>Render the &lt;code&gt;Doc&lt;/code&gt; to a String using the default &lt;code&gt;Style&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;Style&lt;/code&gt; 사용하여 &lt;code&gt;Doc&lt;/code&gt; 를 문자열로 렌더링합니다 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="12f0d532a812bfd8c1a9dcc5e2d9fb2fc2e469b9" translate="yes" xml:space="preserve">
          <source>Render the &lt;code&gt;Doc&lt;/code&gt; to a String using the given &lt;code&gt;Style&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Style&lt;/code&gt; 를 사용해 &lt;code&gt;Doc&lt;/code&gt; 를 String에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="e263a3336086d5999e51a2639cfc00cf3424c6ff" translate="yes" xml:space="preserve">
          <source>Render this exception value in a human-friendly manner.</source>
          <target state="translated">이 예외 값을 인간 친화적 인 방식으로 렌더링하십시오.</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="34a6e257033eabcb340989811be4abac8f495cec" translate="yes" xml:space="preserve">
          <source>Rendering documents</source>
          <target state="translated">문서 렌더링</target>
        </trans-unit>
        <trans-unit id="c4352059e23f7c8b5fdeb527b42173ae6cff8abe" translate="yes" xml:space="preserve">
          <source>Rendering mode.</source>
          <target state="translated">렌더링 모드.</target>
        </trans-unit>
        <trans-unit id="edcebf7a78fe981d04d9e64e593c132261b8c07d" translate="yes" xml:space="preserve">
          <source>Rendering with a particular style</source>
          <target state="translated">특정 스타일로 렌더링</target>
        </trans-unit>
        <trans-unit id="7db65b43576bf07e08468b53aec04cf679691cd8" translate="yes" xml:space="preserve">
          <source>Rep (Generic)</source>
          <target state="translated">담당자 (일반)</target>
        </trans-unit>
        <trans-unit id="25e90fd26c391e05ac5ac88ef33690eb193fa404" translate="yes" xml:space="preserve">
          <source>Rep1 (Generic1)</source>
          <target state="translated">담당자 1 (일반 1)</target>
        </trans-unit>
        <trans-unit id="c55c5386c4748e58caec034acfad7a9a0f8d3a82" translate="yes" xml:space="preserve">
          <source>Repeat a value &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">값을 &lt;code&gt;n&lt;/code&gt; 번 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="13ca240f053ae4ac28b651b1633ebe58645ee9c6" translate="yes" xml:space="preserve">
          <source>Repeat an action indefinitely.</source>
          <target state="translated">작업을 무기한 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="180241f79b869b03862e97b4f7229351a6acf267" translate="yes" xml:space="preserve">
          <source>Repeat the previous command.</source>
          <target state="translated">이전 명령을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="b4c2e50efbac27b5756172990043eab9f749caef" translate="yes" xml:space="preserve">
          <source>Repeated indices in the association list are handled as for &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt;: Haskell 2010 specifies that the resulting array is undefined (i.e. bottom), but GHC's implementation uses the last association for each index.</source>
          <target state="translated">연관 목록에서 반복되는 인덱스는 &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 과 같이 처리됩니다. . Haskell 2010은 결과 배열이 정의되지 않음 (즉, 아래쪽)을 지정하지만 GHC 구현에서는 각 인덱스의 마지막 연관을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="061f8bc61cf8ff462c0933d83acdae1674118907" translate="yes" xml:space="preserve">
          <source>Repeated indices in the association list are handled as for &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt;: Haskell 2010 specifies that the resulting array is undefined (i.e. bottom), but GHC's implementation uses the last association for each index.</source>
          <target state="translated">연관리스트의 반복 된 인덱스는 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 과 같이 처리됩니다 . Haskell 2010은 결과 배열이 정의되지 않음 (즉, 아래쪽)을 지정하지만 GHC 구현에서는 각 인덱스의 마지막 연관을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="711ba373a79d31376784182b72065d953222072d" translate="yes" xml:space="preserve">
          <source>Repetition</source>
          <target state="translated">Repetition</target>
        </trans-unit>
        <trans-unit id="203954ef3852cad427fc7bba8f24e8bfd55318a5" translate="yes" xml:space="preserve">
          <source>Replace all extensions of a file with a new extension. Note that &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; both work for adding multiple extensions, so only required when you need to drop all extensions first.</source>
          <target state="translated">파일의 모든 확장자를 새로운 확장자로 바꾸십시오. 참고 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 먼저 모든 확장을 드롭해야 할 때 너무에만 필요합니다 여러 확장 기능을 추가, 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="72c284911c0f562af8d743e9793ca8e8ff29667d" translate="yes" xml:space="preserve">
          <source>Replace all extensions of a file with a new extension. Note that &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; both work for adding multiple extensions, so only required when you need to drop all extensions first.</source>
          <target state="translated">파일의 모든 확장자를 새로운 확장자로 바꾸십시오. 참고 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:replaceExtension&quot;&gt;replaceExtension&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 먼저 모든 확장을 드롭해야 할 때 너무에만 필요합니다 여러 확장 기능을 추가, 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ae954cfcce8d05d3d28022faa1cefad196caa67" translate="yes" xml:space="preserve">
          <source>Replace all locations in the input with the same value. The default definition is &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, but this may be overridden with a more efficient version.</source>
          <target state="translated">입력의 모든 위치를 동일한 값으로 바꾸십시오. 기본 정의는 &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 이지만 더 효율적인 버전으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc970150dc79b794321f0edff04417f225cb5aef" translate="yes" xml:space="preserve">
          <source>Replace all locations in the input with the same value. The default definition is &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, but this may be overridden with a more efficient version.</source>
          <target state="translated">입력의 모든 위치를 동일한 값으로 바꾸십시오. 기본 정의는 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 이지만 더 효율적인 버전으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81c2807ba345abe34a825bdb92d7f1c4f392afa" translate="yes" xml:space="preserve">
          <source>Replace all locations in the input with the same value. The default definition is &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;ghc-base#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, but this may be overridden with a more efficient version.</source>
          <target state="translated">입력의 모든 위치를 동일한 값으로 바꾸십시오. 기본 정의는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;ghc-base#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 이지만 더 효율적인 버전으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f677b5ab54ec7700f8aa112431fe1d686734e1e1" translate="yes" xml:space="preserve">
          <source>Replace all locations in the input with the same value. The default definition is &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;prelude#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, but this may be overridden with a more efficient version.</source>
          <target state="translated">입력의 모든 위치를 동일한 값으로 바꾸십시오. 기본 정의는 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; . &lt;a href=&quot;prelude#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 이지만 더 효율적인 버전으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01390d4b3f68ac20f556d360b5e40d6cc51b0423" translate="yes" xml:space="preserve">
          <source>Replace all locations in the output with the same value. The default definition is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, but this may be overridden with a more efficient version.</source>
          <target state="translated">출력의 모든 위치를 동일한 값으로 바꾸십시오. 기본 정의는 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; . &lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 이지만 더 효율적인 버전으로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98d97ae2c4e41287d8c7c06782fc94f17ade6313" translate="yes" xml:space="preserve">
          <source>Replace an invalid input byte with the Unicode replacement character U+FFFD.</source>
          <target state="translated">유효하지 않은 입력 바이트를 유니 코드 대체 문자 U + FFFD로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="b279f97032f9ccdb089926b2954f43b47cf0bc96" translate="yes" xml:space="preserve">
          <source>Replace an invalid input with a valid output.</source>
          <target state="translated">유효하지 않은 입력을 유효한 출력으로 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="710069cd7ce970d000411758cf92ef5db06e5b43" translate="yes" xml:space="preserve">
          <source>Replace any binding &lt;code&gt;!p = e&lt;/code&gt; with &lt;code&gt;v = case e of p -&amp;gt; (x1, ..., xn); (x1, ..., xn) = v&lt;/code&gt; and replace &lt;code&gt;body&lt;/code&gt; with &lt;code&gt;v seq body&lt;/code&gt;, where &lt;code&gt;v&lt;/code&gt; is fresh. This translation works fine if &lt;code&gt;p&lt;/code&gt; is already a variable &lt;code&gt;x&lt;/code&gt;, but can obviously be optimised by not introducing a fresh variable &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">모든 바인딩 &lt;code&gt;!p = e&lt;/code&gt; 를 &lt;code&gt;v = case e of p -&amp;gt; (x1, ..., xn); (x1, ..., xn) = v&lt;/code&gt; 이고 &lt;code&gt;body&lt;/code&gt; 를 &lt;code&gt;v seq body&lt;/code&gt; 로 바꿉니다 . 여기서 &lt;code&gt;v&lt;/code&gt; 는 최신입니다. 이 변환은 &lt;code&gt;p&lt;/code&gt; 가 이미 변수 &lt;code&gt;x&lt;/code&gt; 인 경우에는 잘 작동 하지만 새로운 변수 &lt;code&gt;v&lt;/code&gt; 를 도입하지 않으면 최적화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea93161b8e74f17f89a87eea1945732825c68a45" translate="yes" xml:space="preserve">
          <source>Replace any binding &lt;code&gt;p = e&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is not a variable, with &lt;code&gt;v = e; x1 = case v of p -&amp;gt; x1; ...; xn = case v of p -&amp;gt; xn&lt;/code&gt;, where &lt;code&gt;v&lt;/code&gt; is fresh and &lt;code&gt;x1&lt;/code&gt;.. &lt;code&gt;xn&lt;/code&gt; are the bound variables of &lt;code&gt;p&lt;/code&gt;. Again if &lt;code&gt;e&lt;/code&gt; is a variable, this can be optimised by not introducing a fresh variable.</source>
          <target state="translated">바인딩 &lt;code&gt;p = e&lt;/code&gt; 바꿉니다 . 여기서 &lt;code&gt;p&lt;/code&gt; 는 변수가 아닙니다. &lt;code&gt;v = e; x1 = case v of p -&amp;gt; x1; ...; xn = case v of p -&amp;gt; xn&lt;/code&gt; . 여기서 &lt;code&gt;v&lt;/code&gt; 는 신선하고 &lt;code&gt;x1&lt;/code&gt; .. &lt;code&gt;xn&lt;/code&gt; 은 &lt;code&gt;p&lt;/code&gt; 의 바인딩 된 변수입니다 . 다시 &lt;code&gt;e&lt;/code&gt; 가 변수라면, 새로운 변수를 도입하지 않음으로써 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81063ace05e94fc04efdafdeb00bab024fa5cbd6" translate="yes" xml:space="preserve">
          <source>Replace each element of a list with a constant &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">목록의 각 요소를 상수 &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="513681c11e07f73c6a50486d27fc8225cfd91990" translate="yes" xml:space="preserve">
          <source>Replace every element of a list with unit:</source>
          <target state="translated">목록의 모든 요소를 ​​단위로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="2648d76cb08af5485bbcad7562d6a30eed9a95d8" translate="yes" xml:space="preserve">
          <source>Replace the contents of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; with a constant &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 내용을 상수 &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 교체합니다 :</target>
        </trans-unit>
        <trans-unit id="f31cb308fcd0aaf7f1f3072a015acd75e99b34bf" translate="yes" xml:space="preserve">
          <source>Replace the contents of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; with unit:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 내용을 단위로 교체하십시오 .</target>
        </trans-unit>
        <trans-unit id="5977c89e8466a29307fddb6c6e225a0b69928af1" translate="yes" xml:space="preserve">
          <source>Replace the contents of an &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; with a constant &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, resulting in an &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;
&lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">의 내용을 대체 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 상수와 &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 결과, &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b7036b629fc4f069c30e816ee286bff66f0a0fe" translate="yes" xml:space="preserve">
          <source>Replace the contents of an &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; with unit, resulting in an &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; ()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 내용을 단위로 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-int#v:Int&quot;&gt;Int&lt;/a&gt; ()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c404cb7e17bfbc9363bb25af2f270338bbdb908f" translate="yes" xml:space="preserve">
          <source>Replace the second element of a pair with a constant &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">쌍의 두 번째 요소를 상수 &lt;code&gt;&lt;a href=&quot;data-string#v:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="ad5fd43d79beb7227805310f949ed0b8e62c8219" translate="yes" xml:space="preserve">
          <source>Replace the second element of a pair with unit:</source>
          <target state="translated">쌍의 두 번째 요소를 단위로 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="73b7214222897a4da7310495b3173dc47e2ed0ae" translate="yes" xml:space="preserve">
          <source>Replace the state in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 모나드 에서 상태를 교체하십시오 . 상태는 Template Haskell 표현식이 실행되는 Haskell 모듈에 국한됩니다.</target>
        </trans-unit>
        <trans-unit id="e783a2110c1a2dd69be9228b632da888c51e6f89" translate="yes" xml:space="preserve">
          <source>Replace the state inside the monad.</source>
          <target state="translated">모나드 내부의 상태를 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="fabcda4a7ffafa1589944ce7fdd1741e8b4ce15f" translate="yes" xml:space="preserve">
          <source>Replace with the closest visual match upon an illegal sequence</source>
          <target state="translated">잘못된 시퀀스에서 가장 가까운 시각적 일치로 교체</target>
        </trans-unit>
        <trans-unit id="78bc12a2d09cc8e540b1af5c661d077103eab0cf" translate="yes" xml:space="preserve">
          <source>Replicates a &lt;code&gt;withXXX&lt;/code&gt; combinator over a list of objects, yielding a list of marshalled objects</source>
          <target state="translated">&lt;code&gt;withXXX&lt;/code&gt; 콤비 네이터 를 객체 목록에 복제하여 마샬링 된 객체 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6c2bb735a46a8ff307fe2e638d581295b2a49e09" translate="yes" xml:space="preserve">
          <source>Reply</source>
          <target state="translated">Reply</target>
        </trans-unit>
        <trans-unit id="210be950e48b6b09718f614ef624140560013a67" translate="yes" xml:space="preserve">
          <source>Report a warning to the user, and carry on.</source>
          <target state="translated">사용자에게 경고를보고하고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="e35e7e48596095fe28a97fb7c0701b1712a21966" translate="yes" xml:space="preserve">
          <source>Report all record wildcards where none of the variables bound implicitly are used. For instance:</source>
          <target state="translated">암시 적으로 바인딩 된 변수가 사용되지 않는 모든 레코드 와일드 카드를보고합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f1819d25d3da8dde34b0be9d666711b3615eec69" translate="yes" xml:space="preserve">
          <source>Report all record wildcards where the wild card match binds no patterns. For instance:</source>
          <target state="translated">와일드 카드 일치가 패턴을 바인딩하지 않는 모든 레코드 와일드 카드를보고합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b29cc263854e35bdc210f347658ec81f2657154e" translate="yes" xml:space="preserve">
          <source>Report all unused implicitly bound type variables which arise from patterns in type family and data family instances. For instance:</source>
          <target state="translated">유형 패밀리 및 데이터 패밀리 인스턴스의 패턴에서 발생하는 사용되지 않는 암시 적으로 바운드 된 유형 변수를 모두보고하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5ac656d868f74d0d322d7eb08c66336d780f95e3" translate="yes" xml:space="preserve">
          <source>Report all unused type variables which arise from explicit, user-written &lt;code&gt;forall&lt;/code&gt; statements. For instance:</source>
          <target state="translated">명시적이고 사용자 작성 &lt;code&gt;forall&lt;/code&gt; 문 에서 발생하는 사용되지 않은 모든 유형 변수를보고하십시오 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7e5640248d20d9738f29370ad53212fe64c17e0c" translate="yes" xml:space="preserve">
          <source>Report all unused variables which arise from term-level pattern matches, including patterns consisting of a single variable. For instance &lt;code&gt;f x y = []&lt;/code&gt; would report &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unused. The warning is suppressed if the variable name begins with an underscore, thus:</source>
          <target state="translated">단일 변수로 구성된 패턴을 포함하여 용어 수준 패턴 일치에서 발생하는 사용되지 않은 모든 변수를보고합니다. 예를 들어 &lt;code&gt;f x y = []&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 사용되지 않은 것으로보고 합니다. 변수 이름이 밑줄로 시작하면 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2d850b8b5dd31316cfd82cb19c2b631422fed64" translate="yes" xml:space="preserve">
          <source>Report an error (True) or warning (False) ...but carry on; use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; to stop</source>
          <target state="translated">오류 (True) 또는 경고 (False)를보고하지만 계속 수행하십시오. 사용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 정지</target>
        </trans-unit>
        <trans-unit id="a1c620c4068859caa4d346ede74c1d8d10061e19" translate="yes" xml:space="preserve">
          <source>Report an error (True) or warning (False), but carry on; use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; to stop.</source>
          <target state="translated">오류 (참) 또는 경고 (거짓)를보고하지만 계속하십시오. 사용 을 중지 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 마십시오 .</target>
        </trans-unit>
        <trans-unit id="27c2f2834c134bcd0f46f16a100ad0f41229f9a9" translate="yes" xml:space="preserve">
          <source>Report an error to the user, but allow the current splice's computation to carry on. To abort the computation, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자에게 오류를보고하지만 현재 스플 라이스의 계산을 계속 수행하십시오. 계산을 중단하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="62d5b0be5b3ad3e15cbbad98168f15169b9f9a48" translate="yes" xml:space="preserve">
          <source>Report an error.</source>
          <target state="translated">오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="fcce7c0789dcd81563ee3585394cd8a41c2e0685" translate="yes" xml:space="preserve">
          <source>Report any function definitions (and local bindings) which are unused. An alias for</source>
          <target state="translated">사용되지 않은 함수 정의 (및 로컬 바인딩)를보고하십시오. 에 대한 별칭</target>
        </trans-unit>
        <trans-unit id="c73f069d8746fd50c3b70f8192e9fd23df6fc4f6" translate="yes" xml:space="preserve">
          <source>Report any function definitions which are unused.</source>
          <target state="translated">사용되지 않은 함수 정의를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="c68cbca196a7f8a1f32e076e847cdcae60eb1331" translate="yes" xml:space="preserve">
          <source>Report any local definitions which are unused. For example:</source>
          <target state="translated">사용되지 않은 로컬 정의를보고하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56ea34f3aadd7ff1bfabeb1f2e13d83f09f25cc0" translate="yes" xml:space="preserve">
          <source>Report any modules that are explicitly imported but never used. However, the form &lt;code&gt;import M()&lt;/code&gt; is never reported as an unused import, because it is a useful idiom for importing instance declarations, which are anonymous in Haskell.</source>
          <target state="translated">명시 적으로 가져 왔지만 사용되지 않은 모듈은 모두보고하십시오. 그러나 &lt;code&gt;import M()&lt;/code&gt; 형식 은 Haskell에서 익명 인 인스턴스 선언을 가져 오는 데 유용한 관용구이므로 사용되지 않은 가져 오기로보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="186922e407e4cea2c9163d0d00b27598db5e305a" translate="yes" xml:space="preserve">
          <source>Report expressions occurring in &lt;code&gt;do&lt;/code&gt; and &lt;code&gt;mdo&lt;/code&gt; blocks that appear to lack a binding. For instance &lt;code&gt;do { return (popInt 10) ; return 10 }&lt;/code&gt; would report the first statement in the &lt;code&gt;do&lt;/code&gt; block as suspicious, as it has the type &lt;code&gt;StackM (StackM Int)&lt;/code&gt; (which consists of two nested applications of the same monad constructor), but which is not then &amp;ldquo;unpacked&amp;rdquo; by binding the result. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</source>
          <target state="translated">바인딩이없는 것으로 보이는 &lt;code&gt;do&lt;/code&gt; 및 &lt;code&gt;mdo&lt;/code&gt; 블록 에서 발생하는 표현식을보고하십시오 . 예를 들어 &lt;code&gt;do { return (popInt 10) ; return 10 }&lt;/code&gt; 은 &lt;code&gt;do&lt;/code&gt; 블록 의 첫 번째 명령문이 &lt;code&gt;StackM (StackM Int)&lt;/code&gt; 유형 ( 동일한 모나드 생성자의 두 개의 중첩 된 애플리케이션으로 구성됨)을 갖지만 의심되는 것으로보고 합니다. 결과. 프로그램이 무언가를 버리고 있다는 소스 코드를 명시 적으로 언급하면 ​​경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="038c812031da3596ee105d128edaed69c9791794" translate="yes" xml:space="preserve">
          <source>Report expressions occurring in &lt;code&gt;do&lt;/code&gt; and &lt;code&gt;mdo&lt;/code&gt; blocks that appear to silently throw information away. For instance &lt;code&gt;do { mapM popInt xs ; return 10 }&lt;/code&gt; would report the first statement in the &lt;code&gt;do&lt;/code&gt; block as suspicious, as it has the type &lt;code&gt;StackM [Int]&lt;/code&gt; and not &lt;code&gt;StackM ()&lt;/code&gt;, but that &lt;code&gt;[Int]&lt;/code&gt; value is not bound to anything. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</source>
          <target state="translated">정보를 자동으로 버리는 것처럼 보이는 &lt;code&gt;do&lt;/code&gt; 및 &lt;code&gt;mdo&lt;/code&gt; 블록 에서 발생하는 표현식을보고 하십시오. 예를 들어 &lt;code&gt;do { mapM popInt xs ; return 10 }&lt;/code&gt; (가)의 첫 번째 문을보고 할 &lt;code&gt;do&lt;/code&gt; 의심 블록은 유형이 같은 &lt;code&gt;StackM [Int]&lt;/code&gt; 하지 &lt;code&gt;StackM ()&lt;/code&gt; 하지만 &lt;code&gt;[Int]&lt;/code&gt; 값이 아무것도에 바인딩되지 않습니다. 프로그램이 무언가를 버리고 있다는 소스 코드를 명시 적으로 언급하면 ​​경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd30304350d0689ec5bbe6a3f6497f3ec6334207" translate="yes" xml:space="preserve">
          <source>Report the heap size.</source>
          <target state="translated">힙 크기를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="70173459a195f442c355a3fc300b097436d9e070" translate="yes" xml:space="preserve">
          <source>Report the live heap size.</source>
          <target state="translated">라이브 힙 크기를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="d80bdbb7c8a6935b5a45975b33da400dc2c16cc6" translate="yes" xml:space="preserve">
          <source>Report unqualified imports of core libraries which are expected to cause compatibility problems in future releases.</source>
          <target state="translated">향후 릴리스에서 호환성 문제를 일으킬 것으로 예상되는 코어 라이브러리의 정규화되지 않은 가져 오기를보고합니다.</target>
        </trans-unit>
        <trans-unit id="735a11bcb235cff53b8ba5b3f22520d05fd7bdbf" translate="yes" xml:space="preserve">
          <source>Report various information about the heap configuration. Typically produced during RTS initialization..</source>
          <target state="translated">힙 구성에 대한 다양한 정보를보고합니다. 일반적으로 RTS 초기화 중에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b51caa4097d27e97021974ca37a3eb172d1faa25" translate="yes" xml:space="preserve">
          <source>Report warnings when &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferred type errors&lt;/a&gt; are enabled. This option is enabled by default. See &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;지연된 유형 오류&lt;/a&gt; 가 활성화 되면 경고를보고합니다 . 이 옵션은 기본적으로 활성화되어 있습니다. &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb8d962b7ceb76b163fd6f75585fd61427a421ba" translate="yes" xml:space="preserve">
          <source>Report warnings when &lt;a href=&quot;glasgow_exts#typed-holes&quot;&gt;typed hole&lt;/a&gt; errors are &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferred until runtime&lt;/a&gt;. See &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#typed-holes&quot;&gt;유형 홀&lt;/a&gt; 오류가 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임까지 지연 될 때&lt;/a&gt; 경고를보고 합니다 . &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3876a176e0cb586bc4ba95c55f3d4c1969ddb9dc" translate="yes" xml:space="preserve">
          <source>Report warnings when variable out-of-scope errors are &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferred until runtime&lt;/a&gt;. See &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">범위를 벗어난 변수 오류가 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임까지 지연 될 때&lt;/a&gt; 경고를보고 합니다 . &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0148d6cc97deecd36edc0baa1b6a3f9dcb097f11" translate="yes" xml:space="preserve">
          <source>Reports all module-local uses of the thing at the given position in the module, e.g.:</source>
          <target state="translated">모듈의 지정된 위치에서 사물의 모든 모듈 로컬 사용을보고합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ed90fb14d4af2cae21171d0f93343d8c595bf3d1" translate="yes" xml:space="preserve">
          <source>Reports the inferred type at the given span/position in the module, e.g.:</source>
          <target state="translated">모듈에서 주어진 범위 / 위치에서 유추 된 유형을보고합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cb4f47e477ef256ba7b45b511bda017048a23708" translate="yes" xml:space="preserve">
          <source>Repositioning handles</source>
          <target state="translated">재배치 핸들</target>
        </trans-unit>
        <trans-unit id="cfd421be6e964f2d973beeab3a903b4b8dbca988" translate="yes" xml:space="preserve">
          <source>Representable types are collected in the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; class, which defines the associated type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; as well as conversion functions &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to&quot;&gt;to&lt;/a&gt;&lt;/code&gt;. Typically, you will not define &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; instances by hand, but have the compiler derive them for you.</source>
          <target state="translated">표현 가능한 형식은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 클래스 에서 수집되며,이 형식은 연결된 형식 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to&quot;&gt;to&lt;/a&gt;&lt;/code&gt; 로의 변환 함수 를 정의합니다 . 일반적으로 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 인스턴스를 직접 정의 하지는 않지만 컴파일러가이를 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="19682e38b0c71dbda763927c57f8b65c290b0f2f" translate="yes" xml:space="preserve">
          <source>Representable types of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; (or kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, when &lt;code&gt;PolyKinds&lt;/code&gt; is enabled). This class is derivable in GHC with the &lt;code&gt;DeriveGeneric&lt;/code&gt; flag on.</source>
          <target state="translated">종류 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 의 대표 가능한 유형 (또는 &lt;code&gt;PolyKinds&lt;/code&gt; 가 활성화 된 경우 종류 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; ). 이 클래스는 &lt;code&gt;DeriveGeneric&lt;/code&gt; 플래그 가 설정된 GHC에서 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee2698bb964d52fc57600dbd9abaf6d51a0a4e0" translate="yes" xml:space="preserve">
          <source>Representable types of kind &lt;code&gt;*&lt;/code&gt;. This class is derivable in GHC with the &lt;code&gt;DeriveGeneric&lt;/code&gt; flag on.</source>
          <target state="translated">대표 가능한 종류 &lt;code&gt;*&lt;/code&gt; . 이 클래스는 &lt;code&gt;DeriveGeneric&lt;/code&gt; 플래그 가 설정된 GHC에서 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3046120cbf4b7cd62bc24b957ce87fe60e8d7792" translate="yes" xml:space="preserve">
          <source>Representation of &lt;code&gt;* -&amp;gt; *&lt;/code&gt; types</source>
          <target state="translated">의 표현 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 종류</target>
        </trans-unit>
        <trans-unit id="c04043fc4434d1f9286ef0d8dcc9a50d45126bbe" translate="yes" xml:space="preserve">
          <source>Representation of &lt;code&gt;k -&amp;gt; *&lt;/code&gt; types</source>
          <target state="translated">표현 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="3344925672ee12b2453942aee5ea1db1e2ff176d" translate="yes" xml:space="preserve">
          <source>Representation of constructors. Note that equality on constructors with different types may not work -- i.e. the constructors for &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; may compare equal.</source>
          <target state="translated">생성자 표현. 다른 유형의 생성자에서 동등성이 작동하지 않을 수 있습니다. 즉 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 의 생성자가 동일하게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47a0325484885141fbc604287a2df8331178b15" translate="yes" xml:space="preserve">
          <source>Representation of datatypes. A package of constructor representations with names of type and module.</source>
          <target state="translated">데이터 유형 표현. 타입과 모듈의 이름을 가진 생성자 표현 패키지.</target>
        </trans-unit>
        <trans-unit id="6a8a2b8cb82090e3d77dce2dbb2bfcf782570834" translate="yes" xml:space="preserve">
          <source>Representation of types with many constructors or many fields</source>
          <target state="translated">많은 생성자 또는 많은 필드가있는 유형 표현</target>
        </trans-unit>
        <trans-unit id="35397673d9b11600f8956f67c44793a1eedc1924" translate="yes" xml:space="preserve">
          <source>Representation of unlifted types</source>
          <target state="translated">리프팅되지 않은 유형의 표현</target>
        </trans-unit>
        <trans-unit id="264ee02a2c969393a215ad8bfc32e8b2b845f204" translate="yes" xml:space="preserve">
          <source>Representation polymorphism</source>
          <target state="translated">표현 다형성</target>
        </trans-unit>
        <trans-unit id="879c48418a21002d9297fbd9e3ffac9d2017770f" translate="yes" xml:space="preserve">
          <source>Representational equality. If &lt;code&gt;Coercion a b&lt;/code&gt; is inhabited by some terminating value, then the type &lt;code&gt;a&lt;/code&gt; has the same underlying representation as the type &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">대표 평등. 경우 &lt;code&gt;Coercion a b&lt;/code&gt; 일부 종단 값 살고 다음은 입력 &lt;code&gt;a&lt;/code&gt; 유형과 같은 기본 표현을 갖는 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c720f46bcd60ae9520c3086c1ecf644ef6144adc" translate="yes" xml:space="preserve">
          <source>RepresentationalR</source>
          <target state="translated">RepresentationalR</target>
        </trans-unit>
        <trans-unit id="f097ee1b17998d299a2f160cedc967fc9f78cbf6" translate="yes" xml:space="preserve">
          <source>Representations of C types</source>
          <target state="translated">C 유형의 표현</target>
        </trans-unit>
        <trans-unit id="a79298e81ca3b532230a8583d8f8409c75a6d705" translate="yes" xml:space="preserve">
          <source>Representations of some basic types</source>
          <target state="translated">일부 기본 유형의 표현</target>
        </trans-unit>
        <trans-unit id="67da1ed51acd40fcb2fcb744269f2c5d7d3d0098" translate="yes" xml:space="preserve">
          <source>Representing datatypes</source>
          <target state="translated">데이터 타입 표현</target>
        </trans-unit>
        <trans-unit id="34758cefddc40aa1470cfbff99ae668d79c9b020" translate="yes" xml:space="preserve">
          <source>Represents a C-- basic block. Note that this is a slight departure from the intended meaning of this DIE type as it does not necessarily reflect lexical scope in the source program.</source>
          <target state="translated">C-- 기본 블록을 나타냅니다. 이것은 소스 프로그램의 어휘 범위를 반드시 반영하지 않기 때문에이 DIE 유형의 의도 된 의미에서 약간 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="1fa24476be6c73885eb7fbb4bf8517339a1cd7ef" translate="yes" xml:space="preserve">
          <source>Represents a C-- top-level basic block.</source>
          <target state="translated">C-- 최상위 기본 블록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0cf15330bda4d0352a73b8fedf9c47f7a854fb5e" translate="yes" xml:space="preserve">
          <source>Represents a C-\- basic block. Note that this is a slight departure from the intended meaning of this DIE type as it does not necessarily reflect lexical scope in the source program.</source>
          <target state="translated">C-\-기본 블록을 나타냅니다. 소스 프로그램의 어휘 범위를 반드시 반영 할 필요는 없으므로이 DIE 유형의 의도 된 의미에서 약간 벗어난 것입니다.</target>
        </trans-unit>
        <trans-unit id="67e5c7afc820ce932f90778d78e604b5c2630d35" translate="yes" xml:space="preserve">
          <source>Represents a C-\- top-level basic block.</source>
          <target state="translated">C-\-최상위 레벨 기본 블록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6dd9a4bf554abf7b310b93fad15543594f89afcc" translate="yes" xml:space="preserve">
          <source>Represents a compilation unit (e.g. a Haskell module).</source>
          <target state="translated">컴파일 단위 (예 : Haskell 모듈)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71b0bcf91aa6fb4f634cf7991b4493fb262523a4" translate="yes" xml:space="preserve">
          <source>Request a CallStack.</source>
          <target state="translated">CallStack을 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="1a86db96bf5edca3b30436e4953013bfeb293ef4" translate="yes" xml:space="preserve">
          <source>RequireOrder</source>
          <target state="translated">RequireOrder</target>
        </trans-unit>
        <trans-unit id="5e3a8a744e7e46ab41222ebbc049e8887d9bf220" translate="yes" xml:space="preserve">
          <source>Reset the current package database stack. This option removes every previously specified package database (including those read from the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-4&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable) from the package database stack.</source>
          <target state="translated">현재 패키지 데이터베이스 스택을 재설정하십시오. 이 옵션은 패키지 데이터베이스 스택에서 이전에 지정된 모든 패키지 데이터베이스 ( &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-4&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt; 환경 변수 에서 읽은 데이터베이스 포함 )를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9d9437ce1c149db92a35f069931633d0e7667617" translate="yes" xml:space="preserve">
          <source>Reset the current thread's &lt;code&gt;errno&lt;/code&gt; value to &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:eOK&quot;&gt;eOK&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 스레드의 &lt;code&gt;errno&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:eOK&quot;&gt;eOK&lt;/a&gt;&lt;/code&gt; 로 재설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cf5aab60ea4b429ce0f728614ce1a39b30514f8" translate="yes" xml:space="preserve">
          <source>Resets the precedence context to zero.</source>
          <target state="translated">우선 순위 컨텍스트를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="3d530ddb394e59a93f8fd08475db15473c9be43e" translate="yes" xml:space="preserve">
          <source>Resize (unpinned) mutable byte array to new specified size (in bytes). The returned &lt;code&gt;MutableByteArray#&lt;/code&gt; is either the original &lt;code&gt;MutableByteArray#&lt;/code&gt; resized in-place or, if not possible, a newly allocated (unpinned) &lt;code&gt;MutableByteArray#&lt;/code&gt; (with the original content copied over).</source>
          <target state="translated">변경 가능한 고정되지 않은 바이트 배열의 크기를 새로운 지정된 크기 (바이트)로 조정합니다. 반환 된 &lt;code&gt;MutableByteArray#&lt;/code&gt; 는 원래 크기가 조정 된 원래 &lt;code&gt;MutableByteArray#&lt;/code&gt; 이거나 가능하지 않은 경우 새로 할당 된 (고정되지 않은) &lt;code&gt;MutableByteArray#&lt;/code&gt; (원본 내용이 복사 된 상태)입니다.</target>
        </trans-unit>
        <trans-unit id="af23022ae2fbc703adfc587f443d4886c8b9c829" translate="yes" xml:space="preserve">
          <source>Resize a memory area that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; to the given size. The returned pointer may refer to an entirely different memory area, but will be sufficiently aligned for any of the basic foreign types that fits into a memory block of the given size. The contents of the referenced memory area will be the same as of the original pointer up to the minimum of the original size and the given size.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 로 할당 된 메모리 영역의 크기를 주어진 크기로 조정하십시오. 리턴 된 포인터는 완전히 다른 메모리 영역을 참조 할 수 있지만 주어진 크기의 메모리 블록에 맞는 기본 외부 유형에 대해 충분히 정렬됩니다. 참조 된 메모리 영역의 내용은 원래 크기와 지정된 크기의 최소값까지 원래 포인터와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0b2bb3f258d16c01bdf266d3f03d994c61e11ff5" translate="yes" xml:space="preserve">
          <source>Resize a memory area that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; to the size needed to store values of type &lt;code&gt;b&lt;/code&gt;. The returned pointer may refer to an entirely different memory area, but will be suitably aligned to hold values of type &lt;code&gt;b&lt;/code&gt;. The contents of the referenced memory area will be the same as of the original pointer up to the minimum of the original size and the size of values of type &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 로 할당 된 메모리 영역 의 크기를 &lt;code&gt;b&lt;/code&gt; 유형의 값을 저장하는 데 필요한 크기로 조정하십시오 . 리턴 된 포인터는 완전히 다른 메모리 영역을 참조 할 수 있지만 &lt;code&gt;b&lt;/code&gt; 유형의 값을 보유하도록 적절하게 정렬됩니다 . 참조 된 메모리 영역의 내용은 원래 크기의 최소 크기와 &lt;code&gt;b&lt;/code&gt; 유형의 값 크기까지 원래 포인터와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a005485cd10cadec5528720089b01d7c3f83bf1d" translate="yes" xml:space="preserve">
          <source>ResolvedBCO</source>
          <target state="translated">ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="6e1de862f17f2c0d61dcfa8869842063045a9469" translate="yes" xml:space="preserve">
          <source>ResolvedBCOPtr</source>
          <target state="translated">ResolvedBCOPtr</target>
        </trans-unit>
        <trans-unit id="481ed4541019846722b9befe3b9bb925ee185d7b" translate="yes" xml:space="preserve">
          <source>Resolves to the MutableArray# inside the BreakArray</source>
          <target state="translated">BreakArray 내부의 MutableArray #로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="021493f340d35ce0d744f7a3a9e53445394e86a6" translate="yes" xml:space="preserve">
          <source>Resource</source>
          <target state="translated">Resource</target>
        </trans-unit>
        <trans-unit id="ad94287ab4f543bf10c68378e7ba19242a3df67f" translate="yes" xml:space="preserve">
          <source>Resource Limits</source>
          <target state="translated">자원 제한</target>
        </trans-unit>
        <trans-unit id="f26c6059d9651d00e556526c3868d40e27ae8a46" translate="yes" xml:space="preserve">
          <source>ResourceBusy</source>
          <target state="translated">ResourceBusy</target>
        </trans-unit>
        <trans-unit id="b020bc6431b3b7023d76f2e64d60f17277ec97b4" translate="yes" xml:space="preserve">
          <source>ResourceCPUTime</source>
          <target state="translated">ResourceCPUTime</target>
        </trans-unit>
        <trans-unit id="2dc3de2b05e8f70724173719ff240dda68f8caab" translate="yes" xml:space="preserve">
          <source>ResourceCoreFileSize</source>
          <target state="translated">ResourceCoreFileSize</target>
        </trans-unit>
        <trans-unit id="bcf85ca1883d8d70b35323b8ac1608d3228793f6" translate="yes" xml:space="preserve">
          <source>ResourceDataSize</source>
          <target state="translated">ResourceDataSize</target>
        </trans-unit>
        <trans-unit id="ba115e3b77b67bdb8168bff8f2572fe7a2e3bd8d" translate="yes" xml:space="preserve">
          <source>ResourceExhausted</source>
          <target state="translated">ResourceExhausted</target>
        </trans-unit>
        <trans-unit id="35fc7cdea7e77fa9f20ff9cf8167182034131cd7" translate="yes" xml:space="preserve">
          <source>ResourceFileSize</source>
          <target state="translated">ResourceFileSize</target>
        </trans-unit>
        <trans-unit id="d61e08164f1a81223237b903b736ba4407436943" translate="yes" xml:space="preserve">
          <source>ResourceLimit</source>
          <target state="translated">ResourceLimit</target>
        </trans-unit>
        <trans-unit id="32a2741a75201adad483efb7ecfc4c10371a9b6d" translate="yes" xml:space="preserve">
          <source>ResourceLimitInfinity</source>
          <target state="translated">ResourceLimitInfinity</target>
        </trans-unit>
        <trans-unit id="0d6dc59579d48df2cd89dd60631ce90b42cf2846" translate="yes" xml:space="preserve">
          <source>ResourceLimitUnknown</source>
          <target state="translated">ResourceLimitUnknown</target>
        </trans-unit>
        <trans-unit id="f11112cf2840ff9c720b327aaefa09f02d694542" translate="yes" xml:space="preserve">
          <source>ResourceLimits</source>
          <target state="translated">ResourceLimits</target>
        </trans-unit>
        <trans-unit id="d2af36c4a7640045e8251579752c2f729046eb04" translate="yes" xml:space="preserve">
          <source>ResourceOpenFiles</source>
          <target state="translated">ResourceOpenFiles</target>
        </trans-unit>
        <trans-unit id="147a596e2a9d58f70e713e6b3139672c9d488b7c" translate="yes" xml:space="preserve">
          <source>ResourceStackSize</source>
          <target state="translated">ResourceStackSize</target>
        </trans-unit>
        <trans-unit id="aa19422c07be3f3671269e1768d4706d3a3e2b2c" translate="yes" xml:space="preserve">
          <source>ResourceTotalMemory</source>
          <target state="translated">ResourceTotalMemory</target>
        </trans-unit>
        <trans-unit id="9c4dbd9b8ca47dc047650c64ccd632f15455d5c0" translate="yes" xml:space="preserve">
          <source>ResourceVanished</source>
          <target state="translated">ResourceVanished</target>
        </trans-unit>
        <trans-unit id="24f8e3947f79a1fb2d83a89f0b6ab726732d6422" translate="yes" xml:space="preserve">
          <source>Resources associated with the encoding may now be released. The &lt;code&gt;encode&lt;/code&gt; function may not be called again after calling &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">인코딩과 관련된 리소스가 이제 해제 될 수 있습니다. &lt;code&gt;encode&lt;/code&gt; 기능을 호출 한 후 다시 호출 할 수 없습니다 &lt;code&gt;close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eb20dcf60dd0da5f37b1239d272f3287ea9bcc3" translate="yes" xml:space="preserve">
          <source>Rest of the format string.</source>
          <target state="translated">나머지 형식 문자열</target>
        </trans-unit>
        <trans-unit id="879a3471887029471d2168fa737f849188fe74c6" translate="yes" xml:space="preserve">
          <source>RestartOutput</source>
          <target state="translated">RestartOutput</target>
        </trans-unit>
        <trans-unit id="94e38d2852d0374138e6492fc960350b1f4d7792" translate="yes" xml:space="preserve">
          <source>Restores foreground/background colors to their original settings.</source>
          <target state="translated">전경색 / 배경색을 원래 설정으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="38213008afe420fee37f728dc46cf0e5fd546894" translate="yes" xml:space="preserve">
          <source>Restreaming</source>
          <target state="translated">Restreaming</target>
        </trans-unit>
        <trans-unit id="3638fae628fb0f507ffb4a26800173a2467b3120" translate="yes" xml:space="preserve">
          <source>Restreaming state.</source>
          <target state="translated">리 스트리밍 상태.</target>
        </trans-unit>
        <trans-unit id="e2fc156aca734a5b9c9b389bcb970f6b6e0ce3b1" translate="yes" xml:space="preserve">
          <source>Restrict the .hsc directives to those supported by the &lt;code&gt;--cross-compile&lt;/code&gt; mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;). This should be useful if your &lt;code&gt;.hsc&lt;/code&gt; files must be safely cross-compiled and you wish to keep non-cross-compilable constructs from creeping into them.</source>
          <target state="translated">.hsc 지시문을 &lt;code&gt;--cross-compile&lt;/code&gt; 모드 에서 지원하는 지시문으로 제한 하십시오 ( &lt;a href=&quot;#hsc2hs-cross&quot;&gt;교차 컴파일&lt;/a&gt; 참조 ). 이것은 &lt;code&gt;.hsc&lt;/code&gt; 파일을 안전하게 크로스 컴파일해야하고 크로스 컴파일 할 수없는 구문이 들어오지 않도록하려는 경우에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="aedd633c093fe43362bae96de582861ec838410a" translate="yes" xml:space="preserve">
          <source>Restrict the number of elements in a retainer set to ⟨size⟩ (default 8).</source>
          <target state="translated">리테이너의 요소 수를 ⟨size⟩ (기본값 8)로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba09a9a0fa12c5c7ed15a9028a5668c2066777d" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures produced by cost-centre stacks with one of the specified cost centres anywhere in the stack.</source>
          <target state="translated">지정된 코스트 센터 중 하나가 스택의 어느 위치에 있든 코스트 센터 스택에서 생성 된 마감으로 프로파일을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="988f43d05062af42f11912707b2255cf7e924c8d" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures produced by cost-centre stacks with one of the specified cost centres at the top.</source>
          <target state="translated">지정된 코스트 센터 중 하나가 맨 위에있는 코스트 센터 스택에서 생성 된 마감으로 프로파일을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8cc2a3cc5491baa09dd9e6d7305aa27e9729ee67" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures produced by the specified modules.</source>
          <target state="translated">지정된 모듈에서 생성 한 클로저로 프로파일을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="8e5eb29c710134325c75e103e6c39e0d8cf4113d" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures with one of the specified biographies, where ⟨bio⟩ is one of &lt;code&gt;lag&lt;/code&gt;, &lt;code&gt;drag&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">지정된 약력 중 하나를 사용하여 프로파일을 클로저로 제한합니다. 여기서 ⟨bio⟩는 &lt;code&gt;lag&lt;/code&gt; , &lt;code&gt;drag&lt;/code&gt; , &lt;code&gt;void&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="77aa2da641bd4074fc631140f99b3429af2e4c61" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures with retainer sets containing cost-centre stacks with one of the specified cost centres at the top.</source>
          <target state="translated">지정된 코스트 센터 중 하나가 맨 위에있는 코스트 센터 스택이 포함 된 리테이너 세트를 사용하여 프로파일을 클로저로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8a4cf9779af43faa60dea8a6b135485084595f2c" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures with the specified description strings.</source>
          <target state="translated">지정된 설명 문자열을 사용하여 프로파일을 클로저로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="f8ec1f3f879de514bd809577ca2942e389746a15" translate="yes" xml:space="preserve">
          <source>Restrict the profile to closures with the specified types.</source>
          <target state="translated">지정된 유형의 클로저로 프로파일을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="91d9d512b80f1af15f20e59d89aecd2b45b56287" translate="yes" xml:space="preserve">
          <source>Restrictions on unlifted boxed arguments passed to foreign C calls. Cells marked as &amp;ldquo;Unsound&amp;rdquo; represent combinations that lead to undefined runtime behavior. GHC does not reject such unsound programs at compile time.</source>
          <target state="translated">외부 C 호출에 전달되는 해제되지 않은 boxed 인수에 대한 제한. &quot;Unsound&quot;로 표시된 셀은 정의되지 않은 런타임 동작을 유발하는 조합을 나타냅니다. GHC는 컴파일 타임에 이러한 불건전 한 프로그램을 거부하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26d2b2f2e73d96c76f8c4e16a012c52b69296a83" translate="yes" xml:space="preserve">
          <source>Restricts the module to the safe language. All of the module&amp;rsquo;s direct imports must be trusted, but the module itself need not reside in a trusted package, because the compiler vouches for its trustworthiness. The &amp;ldquo;safe&amp;rdquo; keyword is allowed but meaningless in import statements, as regardless, every import is required to be safe.</source>
          <target state="translated">모듈을 안전한 언어로 제한합니다. 모든 모듈의 직접 가져 오기는 신뢰할 수 있어야하지만 컴파일러는 신뢰성을 보증하기 때문에 모듈 자체는 신뢰할 수있는 패키지에 상주 할 필요가 없습니다. &quot;safe&quot;키워드는 import 문에서 허용되지만 모든 가져 오기가 안전해야하므로 import 문에서는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7f93cb4cbd018198d45aad9dd5a95fdaa60b376" translate="yes" xml:space="preserve">
          <source>Result and lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; written as its side-effect</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 작성된 결과 및 게으른 ByteString</target>
        </trans-unit>
        <trans-unit id="f126664f4124c32cc770797ecc3b6cb80fef630c" translate="yes" xml:space="preserve">
          <source>Result is meaningless if two &lt;code&gt;Addr#&lt;/code&gt;s are so far apart that their difference doesn't fit in an &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">두 개의 &lt;code&gt;Addr#&lt;/code&gt; 이 너무 멀어 차이가 &lt;code&gt;Int#&lt;/code&gt; 맞지 않으면 결과는 의미 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4e33029c02405231480642f8c9bc28cfb0dc6afd" translate="yes" xml:space="preserve">
          <source>Result.</source>
          <target state="translated">Result.</target>
        </trans-unit>
        <trans-unit id="1ea7765ea17f75b1dace09820437939bcd61f222" translate="yes" xml:space="preserve">
          <source>Resulting lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">결과 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09514b660f7685e5cf80db6e1ba61aa96e531258" translate="yes" xml:space="preserve">
          <source>Resume evaluation of a statement after a breakpoint</source>
          <target state="translated">중단 점 이후 명령문의 평가 재개</target>
        </trans-unit>
        <trans-unit id="99cd022cdbb965b966c78945de76be3957290c13" translate="yes" xml:space="preserve">
          <source>ResumeContext</source>
          <target state="translated">ResumeContext</target>
        </trans-unit>
        <trans-unit id="d5901174d9264b57ddae050fb20336e360ef9545" translate="yes" xml:space="preserve">
          <source>Retain CAFs unconditionally in linked Haskell code. Note that this prevents any code from being unloaded. It should not be necessary unless you are GHCi or hs-plugins, which needs to be able call any function in the compiled code.</source>
          <target state="translated">연결된 Haskell 코드에서 CAF를 무조건 유지합니다. 이렇게하면 코드가 언로드되지 않습니다. 컴파일 된 코드에서 함수를 호출 할 수 있어야하는 GHCi 또는 hs 플러그인이 아닌 경우 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c22154d58d981f7367609ab1e57cfd763b0192df" translate="yes" xml:space="preserve">
          <source>Retain all intermediate temporary files.</source>
          <target state="translated">모든 중간 임시 파일을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="27d1adc7706f62a9f9a5cda60fb9e7578096f7d7" translate="yes" xml:space="preserve">
          <source>Retain intermediate &lt;code&gt;.hc&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.hc&lt;/code&gt; 파일을 보관 하십시오.</target>
        </trans-unit>
        <trans-unit id="1c913a795a1f09102a325857b15b734b517d6fd9" translate="yes" xml:space="preserve">
          <source>Retain intermediate &lt;code&gt;.hi&lt;/code&gt; files (the default).</source>
          <target state="translated">중간 &lt;code&gt;.hi&lt;/code&gt; 파일을 유지 합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="94f8149a3370382a007aedc88c60d2a9c3a7ac93" translate="yes" xml:space="preserve">
          <source>Retain intermediate &lt;code&gt;.hscpp&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.hscpp&lt;/code&gt; 파일을 보관 하십시오.</target>
        </trans-unit>
        <trans-unit id="a97f4a882fdd81370c7271183798db3e068d96e5" translate="yes" xml:space="preserve">
          <source>Retain intermediate &lt;code&gt;.o&lt;/code&gt; files (the default).</source>
          <target state="translated">중간 &lt;code&gt;.o&lt;/code&gt; 파일을 유지 합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="7677f34472654a783e346ec0365bf5cde487e01d" translate="yes" xml:space="preserve">
          <source>Retain intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.s&lt;/code&gt; 파일을 유지 하십시오.</target>
        </trans-unit>
        <trans-unit id="6abfcf523bf9d66cec96d1a7ee8f7a4938402d9b" translate="yes" xml:space="preserve">
          <source>Retain intermediate LLVM &lt;code&gt;.ll&lt;/code&gt; files. Implies &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">중간 LLVM &lt;code&gt;.ll&lt;/code&gt; 파일을 유지 하십시오. &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; 을&lt;/a&gt; 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="8bf8f391a4a50c2f5f64ab4e79fd10a787a92b03" translate="yes" xml:space="preserve">
          <source>RetainCAFs</source>
          <target state="translated">RetainCAFs</target>
        </trans-unit>
        <trans-unit id="8c7019f656594681f2d84dd41a1127bda39fb82f" translate="yes" xml:space="preserve">
          <source>Retainer profiling is designed to help answer questions like &amp;ldquo;why is this data being retained?&amp;rdquo;. We start by defining what we mean by a retainer:</source>
          <target state="translated">리테이너 프로파일 링은 &quot;이 데이터가 왜 유지됩니까?&quot;와 같은 질문에 대답 할 수 있도록 설계되었습니다. 리테이너가 의미하는 바를 정의하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="33953edf5744f519b329e5f8500334513029c025" translate="yes" xml:space="preserve">
          <source>Retainer profiling requires multiple passes over the live heap in order to discover the full retainer set for each object, which can be quite slow. So we set a limit on the maximum size of a retainer set, where all retainer sets larger than the maximum retainer set size are replaced by the special set &lt;code&gt;MANY&lt;/code&gt;. The maximum set size defaults to 8 and can be altered with the &lt;a href=&quot;#rts-flag--R%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-R ⟨size⟩&lt;/code&gt;&lt;/a&gt; RTS option:</source>
          <target state="translated">리테이너 프로파일 링은 각 오브젝트에 대해 전체 리테이너 세트를 발견하기 위해 라이브 힙을 여러 번 통과해야하므로 상당히 느릴 수 있습니다. 따라서 리테이너 세트의 최대 크기에 제한을 설정했습니다. 여기서 최대 리테이너 세트 크기보다 큰 모든 리테이너 세트는 특수 세트 &lt;code&gt;MANY&lt;/code&gt; 로 대체됩니다 . 최대 설정 크기는 기본적으로 8로 설정되며 &lt;a href=&quot;#rts-flag--R%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-R ⟨size⟩&lt;/code&gt; &lt;/a&gt; RTS 옵션을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67be3168cf0629e4eae05d5b7b9dbd03b3c41ac3" translate="yes" xml:space="preserve">
          <source>Retrieve a function of the current environment.</source>
          <target state="translated">현재 환경의 기능을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6d9571fc9ee3f5278e0c11ef645e5f7b3e1788c9" translate="yes" xml:space="preserve">
          <source>Retrieve the address of any Haskell value. This is essentially an &lt;code&gt;unsafeCoerce#&lt;/code&gt;, but if implemented as such the core lint pass complains and fails to compile. As a primop, it is opaque to core/stg, and only appears in cmm (where the copy propagation pass will get rid of it). Note that &quot;a&quot; must be a value, not a thunk! It's too late for strictness analysis to enforce this, so you're on your own to guarantee this. Also note that &lt;code&gt;Addr#&lt;/code&gt; is not a GC pointer - up to you to guarantee that it does not become a dangling pointer immediately after you get it.</source>
          <target state="translated">하스켈 값의 주소를 검색하십시오. 이것은 본질적으로 &lt;code&gt;unsafeCoerce#&lt;/code&gt; 이지만, 그렇게 구현 된 경우 코어 보풀 패스가 불평하고 컴파일에 실패합니다. Primop은 core / stg에 대해 불투명하며 cmm으로 만 나타납니다 (복사 전파 패스에서 제거). &quot;a&quot;는 썽크가 아닌 값이어야합니다! 엄격 성 분석이이를 시행하기에는 너무 늦었으므로이를 보장하기 위해 스스로해야합니다. 또한 &lt;code&gt;Addr#&lt;/code&gt; 은 GC 포인터가 아니라는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67c922a88a65693be2b1528f839dbe2af671ef5" translate="yes" xml:space="preserve">
          <source>Retrieve the system event manager for the capability on which the calling thread is running.</source>
          <target state="translated">호출 스레드가 실행중인 기능에 대한 시스템 이벤트 관리자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="235badb39d6373c1cb58e6c1848af90cf3bee578" translate="yes" xml:space="preserve">
          <source>Retrieve the target path of either a file or directory symbolic link. The returned path may not be absolute, may not exist, and may not even be a valid path.</source>
          <target state="translated">파일 또는 디렉토리 기호 링크의 대상 경로를 검색하십시오. 반환 된 경로는 절대적이지 않을 수도 있고 존재하지 않을 수도 있으며 유효한 경로가 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b054dbd8a0e74b67f6dbc9d2335a04d6537353" translate="yes" xml:space="preserve">
          <source>Retrieves a function of the current environment.</source>
          <target state="translated">현재 환경의 기능을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d17266b1630a9adf39cc3d99f791ee0584d71942" translate="yes" xml:space="preserve">
          <source>Retrieves the allocation counter for the current thread.</source>
          <target state="translated">현재 스레드의 할당 카운터를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6e91946c8c050e29662b02a9062f6c9667679dfd" translate="yes" xml:space="preserve">
          <source>Retrieves the monad environment.</source>
          <target state="translated">모나드 환경을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2c23c52fc6ba8b0150f98d916f65b08930d46770" translate="yes" xml:space="preserve">
          <source>Retry execution of the current memory transaction because it has seen values in &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s which mean that it should not continue (e.g. the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s represent a shared buffer that is now empty). The implementation may block the thread until one of the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s that it has read from has been updated. (GHC only)</source>
          <target state="translated">현재 메모리 트랜잭션이 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에서 값을 보았 으므로 계속 실행하지 않아야 함을 의미 하므로 현재 메모리 트랜잭션의 실행을 재 시도하십시오 (예 : &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 는 현재 비어있는 공유 버퍼를 나타냄). 구현 은 읽은 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 중 하나 가 업데이트 될 때까지 스레드를 차단할 수 있습니다 . (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="bd96c6cf565c03c2ca0661677b90019b856d671d" translate="yes" xml:space="preserve">
          <source>Retry execution of the current memory transaction because it has seen values in &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s which mean that it should not continue (e.g. the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s represent a shared buffer that is now empty). The implementation may block the thread until one of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s that it has read from has been updated. (GHC only)</source>
          <target state="translated">현재 메모리 트랜잭션이 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에서 값을 보았 으므로 계속 실행하지 않아야 함을 의미 하므로 현재 메모리 트랜잭션의 실행을 재 시도하십시오 (예 : &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 는 현재 비어있는 공유 버퍼를 나타냄). 구현 은 읽은 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 중 하나 가 업데이트 될 때까지 스레드를 차단할 수 있습니다 . (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="a41598457732e6a139ea7baf3e01dacbaa879066" translate="yes" xml:space="preserve">
          <source>Retry execution of the current memory transaction because it has seen values in &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s which mean that it should not continue (e.g. the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s represent a shared buffer that is now empty). The implementation may block the thread until one of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;s that it has read from has been updated. (GHC only)</source>
          <target state="translated">현재 메모리 트랜잭션이 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에서 값을 보았 으므로 계속 실행하지 않아야 함을 의미 하므로 현재 메모리 트랜잭션의 실행을 재 시도하십시오 (예 : &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 는 현재 비어있는 공유 버퍼를 나타냄). 구현 은 읽은 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 중 하나 가 업데이트 될 때까지 스레드를 차단할 수 있습니다 . (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="5f55dc7b78eff20eb547e4e65b19db690d4f2f91" translate="yes" xml:space="preserve">
          <source>Return 1 if &lt;code&gt;MVar#&lt;/code&gt; is empty; 0 otherwise.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; 가 비어 있으면 1을 리턴합니다 . 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="239d43f62a2ac56e1dbb4fb2dddfc95302d9b332" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt; depending on whether argument is negative, zero, or positive, respectively</source>
          <target state="translated">인수가 각각 음수인지, 0인지, 양수인지에 따라 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="75ae59416d00ac6d23a619b93fee5990e88af0ba" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;n&lt;/code&gt;th bit of the argument is 1</source>
          <target state="translated">반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;n&lt;/code&gt; 개의 인수의 비트 일이 1</target>
        </trans-unit>
        <trans-unit id="53cf09a54a19ee477705620e40bcfb76df4f57a8" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument is a signed type. The actual value of the argument is ignored</source>
          <target state="translated">인수가 부호있는 유형이면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 하십시오. 인수의 실제 값은 무시됩니다</target>
        </trans-unit>
        <trans-unit id="eac4dfb2694aef9d0b8f5e10b7ac3081dd00ae76" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the given value is a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;-value, &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 주어진 값은 경우 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; - 값, &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="eca218c17eed305dc2ccdc0de31b5e04d9d790d4" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the given value is a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;-value, &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 주어진 값은 경우 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; - 값, &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="5d9487c74e478b83432c0f9ed756421488cb12f9" translate="yes" xml:space="preserve">
          <source>Return a lazy list representing the contents of the supplied &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;, much like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 와 같이 제공된 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 의 내용을 나타내는 게으른 목록을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="dde79354e4f97fd4330824eb28771fc86a169834" translate="yes" xml:space="preserve">
          <source>Return a list of all the associations of a mutable array, in index order.</source>
          <target state="translated">가변 배열의 모든 연관 목록을 색인 순서로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5294447931aadc184da1bcc2bf0aa028072f7b77" translate="yes" xml:space="preserve">
          <source>Return a list of all the elements of a mutable array</source>
          <target state="translated">변경 가능한 배열의 모든 요소 목록을 반환</target>
        </trans-unit>
        <trans-unit id="50ee4676f7c6d6de5113fecfe4b4e6f32c7787ff" translate="yes" xml:space="preserve">
          <source>Return a printing function, which in terminal-style interactions is thread-safe and may be run concurrently with user input without affecting the prompt.</source>
          <target state="translated">터미널 스타일의 상호 작용에서 스레드 안전하고 프롬프트에 영향을주지 않고 사용자 입력과 동시에 실행될 수있는 인쇄 기능을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57437da4505312d826ea216562dd7d443309e6b7" translate="yes" xml:space="preserve">
          <source>Return a string describing the usage of a command, derived from the header (first argument) and the options described by the second argument.</source>
          <target state="translated">헤더 (첫 번째 인수)와 두 번째 인수로 설명 된 옵션에서 파생 된 명령 사용법을 설명하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="239bc1a1b2f9b5af6133bea92a7a0289c85350c8" translate="yes" xml:space="preserve">
          <source>Return a word where only the highest bit is set.</source>
          <target state="translated">가장 높은 비트 만 설정된 단어를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a34cf9a224b0d2339198c27219aca2835c18c572" translate="yes" xml:space="preserve">
          <source>Return monotonic time in nanoseconds, since some unspecified starting point</source>
          <target state="translated">지정되지 않은 시작점이 있기 때문에 단조 시간을 나노초로 반환</target>
        </trans-unit>
        <trans-unit id="bc8397067589a4106551930ce04ff005c5ca83dc" translate="yes" xml:space="preserve">
          <source>Return monotonic time in seconds, since some unspecified starting point</source>
          <target state="translated">지정되지 않은 시작점이 있기 때문에 단조 시간을 초 단위로 반환</target>
        </trans-unit>
        <trans-unit id="e049737e569caa173356b218731d69e810155a45" translate="yes" xml:space="preserve">
          <source>Return non-zero if there is any possibility that the upper word of a signed integer multiply might contain useful information. Return zero only if you are completely sure that no overflow can occur. On a 32-bit platform, the recommended implementation is to do a 32 x 32 -&amp;gt; 64 signed multiply, and subtract result[63:32] from (result[31] &amp;gt;&amp;gt;signed 31). If this is zero, meaning that the upper word is merely a sign extension of the lower one, no overflow can occur.</source>
          <target state="translated">부호있는 정수의 상위 단어에 유용한 정보가 포함될 가능성이있는 경우 0이 아닌 값을 리턴하십시오. 오버플로가 발생하지 않는 것이 확실한 경우에만 0을 반환하십시오. 32 비트 플랫폼에서 권장되는 구현은 32 x 32-&amp;gt; 64 부호 곱하기를 수행하고 (결과 [31] &amp;gt;&amp;gt; 부호 31)에서 결과 [63:32]를 빼는 것입니다. 이것이 0 인 경우, 상위 단어는 하위 단어의 부호 확장 일 뿐이므로 오버 플로우가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="089af53d4f503e35d265ce67c50d16af5751b41c" translate="yes" xml:space="preserve">
          <source>Return number of limbs contained in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 에 포함 된 사지 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="85ec6ff49102368c01101d47968288128fbabe34" translate="yes" xml:space="preserve">
          <source>Return the Module at the place of splicing. Can be used as an input for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">접속 장소에 모듈을 반환하십시오. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyModule&quot;&gt;reifyModule&lt;/a&gt;&lt;/code&gt; 의 입력으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9feff01416814c7f674de08669bf9a6210d4ba5" translate="yes" xml:space="preserve">
          <source>Return the contents of a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;-value or a default value otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값 의 내용을 반환 하거나 그렇지 않으면 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a4219a1ca698a5ce4bdecbe9f37c4fe76184a7b" translate="yes" xml:space="preserve">
          <source>Return the contents of a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;-value or a default value otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 값 의 내용을 반환 하거나 그렇지 않으면 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50a35e6d38815fc302d4c90367bb6daf75c38f29" translate="yes" xml:space="preserve">
          <source>Return the contents of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. After a &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 돌려 줍니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. 후 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e26b74da17c33b2ba651eaaf96834eedc3261b44" translate="yes" xml:space="preserve">
          <source>Return the contents of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. After a &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 반환합니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. 후 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="12d450260d7a459d097708b37ebc8db3a8f28013" translate="yes" xml:space="preserve">
          <source>Return the contents of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. After a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 돌려 줍니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d328824b3c6db4e18e37fb0076d3c2e8117db196" translate="yes" xml:space="preserve">
          <source>Return the contents of the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is currently empty, the transaction will &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. After a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 의 내용을 돌려 줍니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 현재 비어, 트랜잭션이됩니다 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b4f1d61fdfa4d546a13cfaad9fb2a667775f27" translate="yes" xml:space="preserve">
          <source>Return the contents of the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. After a &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 돌려 줍니다 . 는 IF &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. 후 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea68eb97919fc9b0cfd5d29c51e40ceaef8943ba" translate="yes" xml:space="preserve">
          <source>Return the current &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="319e57db0ec551d795190efab473311e211d6d1f" translate="yes" xml:space="preserve">
          <source>Return the current &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for the specified &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is in binary mode.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 현재 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 을 반환 하거나 , &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 이진 모드 인 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a385606de0a0d97dcf5a301fa91b6acdb8993db6" translate="yes" xml:space="preserve">
          <source>Return the current &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for the specified &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is in binary mode.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 현재 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 을 반환 하거나 , &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 이진 모드 인 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="030b59327240344191337257cba1ced35f7e462b" translate="yes" xml:space="preserve">
          <source>Return the current state of the codec.</source>
          <target state="translated">코덱의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ffdac4826cf5e6776bfa99acff9575e942f4dcf5" translate="yes" xml:space="preserve">
          <source>Return the current value of the allocation counter for the current thread.</source>
          <target state="translated">현재 스레드에 대한 할당 카운터의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="614b003213b2a6029b214aae2c537019dd082e03" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c9ef1cc8cbe1136acc0260f0302bf15831f79133" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;. This is equivalent to</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="1adfeb4463484d8a90b6a055148c1a24fb260b36" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de07a8e373cde6be61c5b2aa67d876192a13923f" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;. This is equivalent to</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="2989d911f3e6d348eb0d3212d71e35f878d57174" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b717a867ccdc10b3d490ff579c22b82c4b548f16" translate="yes" xml:space="preserve">
          <source>Return the current value stored in a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;. This is equivalent to</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 저장된 현재 값을 반환합니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="7c3cf41214c8e4f2638aaeeaf85a590be1d8dfff" translate="yes" xml:space="preserve">
          <source>Return the length of a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 의 길이를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="89e1ee73af0c66d132ceb25eff85b101d3885543" translate="yes" xml:space="preserve">
          <source>Return the number of bits in the type of the argument. The actual value of the argument is ignored. Moreover, &lt;code&gt;&lt;a href=&quot;data-bits#v:finiteBitSize&quot;&gt;finiteBitSize&lt;/a&gt;&lt;/code&gt; is total, in contrast to the deprecated &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSize&quot;&gt;bitSize&lt;/a&gt;&lt;/code&gt; function it replaces.</source>
          <target state="translated">인수 유형의 비트 수를 리턴하십시오. 인수의 실제 값은 무시됩니다. 또한 사용되지 않는 &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSize&quot;&gt;bitSize&lt;/a&gt;&lt;/code&gt; 함수 와 달리 &lt;code&gt;&lt;a href=&quot;data-bits#v:finiteBitSize&quot;&gt;finiteBitSize&lt;/a&gt;&lt;/code&gt; 는 총계 입니다.</target>
        </trans-unit>
        <trans-unit id="c3d31ee919be276fced9ac0c9ab3823d5574040e" translate="yes" xml:space="preserve">
          <source>Return the number of bits in the type of the argument. The actual value of the argument is ignored. Returns Nothing for types that do not have a fixed bitsize, like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 유형의 비트 수를 리턴하십시오. 인수의 실제 값은 무시됩니다. &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 같이 고정 된 비트 크기가없는 유형에 대해서는 Nothing을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ad946e3684fd16c73b3c7e852c835abb79d62032" translate="yes" xml:space="preserve">
          <source>Return the number of bits in the type of the argument. The actual value of the argument is ignored. The function &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSize&quot;&gt;bitSize&lt;/a&gt;&lt;/code&gt; is undefined for types that do not have a fixed bitsize, like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 유형의 비트 수를 리턴하십시오. 인수의 실제 값은 무시됩니다. &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSize&quot;&gt;bitSize&lt;/a&gt;&lt;/code&gt; 함수 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 같이 고정 된 비트 크기가없는 유형에 대해서는 정의되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a62d9a774a1acb8192ffd48d2a06aba53e3f8629" translate="yes" xml:space="preserve">
          <source>Return the number of elements in an array, excluding the terminator</source>
          <target state="translated">터미네이터를 제외하고 배열의 요소 수를 반환</target>
        </trans-unit>
        <trans-unit id="7207025791701e635ca0ea0addb569d6c91a1091" translate="yes" xml:space="preserve">
          <source>Return the number of elements in the array.</source>
          <target state="translated">배열의 요소 수를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
