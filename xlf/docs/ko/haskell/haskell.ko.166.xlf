<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">사용되지 않는 언어 옵션 &lt;code&gt;PolymorphicComponents&lt;/code&gt; 및 &lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; 는&lt;/a&gt; 동의어입니다 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; . 그들은 GHC가 더 이상 만들지 않는 더 미세한 구별을 지정했습니다. (실제로 사용 중단 경고를 표시해야하지만, 저자가 이전 플래그 사양을 변경하기 위해 라이브러리를 작성하지 않아도되는 것은 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">의 이전, 그림자, 버전 &lt;code&gt;T&lt;/code&gt; 가 표시됩니다 &lt;code&gt;main::Interactive.T&lt;/code&gt; 새로운 구별하기위한 시도 GHCi에 의해 &lt;code&gt;T&lt;/code&gt; 단순히으로 표시됩니다, &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">이 규칙의 한 가지 예외는 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를&lt;/a&gt; 통해 인스턴스를 유도하기 때문에 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 간단히 생성자의 사용을 필요로하지 않는 빈 인스턴스 선언을 생성합니다. 자세한 내용은 &lt;a href=&quot;#derive-any-class&quot;&gt;클래스 파생하기&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e0a9633714321260550a5d2fcda2a976b8c7ecf" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">이 규칙의 한 가지 예외는 &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; 를&lt;/a&gt; 통해 인스턴스를 유도하기 때문에 &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 간단히 생성자의 사용을 필요로하지 않는 빈 인스턴스 선언을 생성합니다. 자세한 내용은 &lt;a href=&quot;#derive-any-class&quot;&gt;클래스 파생&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">입출력 동작 허용 유일한 IO 조작에 전달 &lt;code&gt;unsafeLocalState&lt;/code&gt; 있다 (a) 로컬 할당 ( &lt;code&gt;alloca&lt;/code&gt; 를 , &lt;code&gt;allocaBytes&lt;/code&gt; 와 같은 유도 된 동작 &lt;code&gt;withArray&lt;/code&gt; 및 &lt;code&gt;withCString&lt;/code&gt; ) 및 (b) 포인터 동작 ( &lt;code&gt;Foreign.Storable&lt;/code&gt; 및 &lt;code&gt;Foreign.Ptr&lt;/code&gt; 포인터에) (c) 로컬로 할당 된 메모리를 읽고 /거나 쓰는 것이 관찰 가능한 효과를 갖는 외부 기능 이러한 규칙을 따르지 않는 IO 작업을 전달하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">두 그룹의 유일한 차이점은 두 번째 그룹에서 &lt;code&gt;len_acc&lt;/code&gt; 에 유형 서명이 제공 된다는 것 입니다. 전자의 경우, &lt;code&gt;len_acc1&lt;/code&gt; 는 암시 적 매개 변수, 그래서 자신의 오른쪽에 단형이다 &lt;code&gt;?acc&lt;/code&gt; 재귀 호출에 전달되지 않습니다. 때문에, 후자의 경우, &lt;code&gt;len_acc2&lt;/code&gt; 이 타입 서명이 재귀 호출이 이루어집니다 &lt;em&gt;다형성&lt;/em&gt; 얻어 버전 &lt;code&gt;?acc&lt;/code&gt; 암시 파라미터로. 따라서 GHCi에서 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9990b4df29d87745ac325e522dbe79968c7bc35e" translate="yes" xml:space="preserve">
          <source>The only effect which is intentionally not incorporated in the &lt;code&gt;release&lt;/code&gt; action is the effect of throwing an error. In that case, the error must be re-thrown. One subtlety which is easy to miss is that in the case in which &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; both throw an error, the error from &lt;code&gt;release&lt;/code&gt; should take priority. Here is an implementation for &lt;code&gt;ExceptT&lt;/code&gt; which demonstrates how to do this.</source>
          <target state="translated">의도적으로 &lt;code&gt;release&lt;/code&gt; 작업에 포함되지 않은 유일한 효과 는 오류를 던지는 효과입니다. 이 경우 오류가 다시 발생해야합니다. 놓치기 쉬운 한 가지 미묘한 점은 &lt;code&gt;use&lt;/code&gt; 과 &lt;code&gt;release&lt;/code&gt; 모두 오류를 던지는 경우 &lt;code&gt;release&lt;/code&gt; 의 오류 가 우선해야한다는 것입니다. 다음은 이를 수행하는 방법을 보여주는 &lt;code&gt;ExceptT&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">이러한 서명의 허용되는 유일한 구현은 정확히 동일한 엔티티를 다시 내보내는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">공백 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출해야하는 유일한 지점 은 선행 공백을 건너 뛰기 위해 기본 구문 분석기의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">공백 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출해야하는 유일한 지점 은 선행 공백을 건너 뛰기 위해 기본 구문 분석기의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">사전 정의 된 유일한 인스턴스는 아무 것도 수행하지 않는 명백한 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">사전 정의 된 유일한 인스턴스는 문자열을 평소와 같이 작동시키는 명백한 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">유일한 문제는 모듈에 인스턴스 선언이 포함되어 있고 GHC에 모듈을 방문 할 다른 이유가없는 경우에 발생합니다. 예:</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">이제 남은 것은 &quot;프론트 엔드&quot;클래스를 정의하는 것입니다.이 클래스는 사용자에게 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;Unused&lt;/code&gt; 생성자에 대한 유일한 사용 은 유형 변수 &lt;code&gt;cxt&lt;/code&gt; 에 올바른 종류를 강제하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">프로그램이 실행중인 운영 체제</target>
        </trans-unit>
        <trans-unit id="baf98890264db12c13a0ed323b113f943e70d115" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running. Common values include:</source>
          <target state="translated">프로그램이 실행중인 운영 체제입니다. 일반적인 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">작업 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 는 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인수 파일이 존재하고 디렉토리 또는 디렉토리에 대한 심볼릭 링크, 그리고 중 하나 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="8332f5125e87dd009d7bdddc38f1192739ced75f" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 작업 은 인수 파일이 존재하고 디렉토리 또는 디렉토리에 대한 심볼릭 링크이면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4854d75c06e684b051f9e4890dec7d55c0adcabb" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 작업 은 인수 파일이 존재하고 디렉토리 또는 디렉토리에 대한 심볼릭 링크이면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">조작 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 는 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인수 파일이 존재하고 디렉토리 아니며, 경우에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a53f211f831c07b35860c179c1095eecd331bca" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 작업 은 인수 파일이 있고 디렉토리가 아니면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="907aadbc191368f77ac2409d9668430f37f02e38" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 작업 은 인수 파일이 있고 디렉토리가 아니면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; 와 동일한 예외로 조작이 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 와 동일한 예외로 작업이 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; 와 동일한 예외로 작업이 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">다음과 같은 경우 작업이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">문자열에 대한 작업은 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">연산자 섹션은 정의되지 않은 함수의 함수 적용으로 취급되는 반면 람다 양식은 정의되지 않은 함수의 적용을 포함하는 WHNF입니다.</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">최적화는 사전을 바인딩하는 GADT에도 적용됩니다. 필요한 클래스 사전을 정적으로 알고 있으면 런타임에 전달 된 클래스를 간접적으로 사용하지 않고 직접 해결합니다.</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt; 옵션 은 GHC가 등록되지 않은 모드로 구축 된 경우에만 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;codegens#unreg&quot;&gt;미등록 컴파일&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt; 옵션 은 컴파일러의 사전 처리 단계 만 실행하여 결과를 파일로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 옵션 은 런타임시 패턴 일치가 실패 할 수있는 위치에 대해 경고합니다. 비어 있지 않은 목록에 적용하면 아래 함수 &lt;code&gt;g&lt;/code&gt; 가 실패하므로 &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 컴파일러에서 이에 대한 경고를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt; 옵션 은 부족한 생성자를 통해 액세스 할 때 실패 할 수있는 레코드 필드에 대해 경고합니다. 아래의 &lt;code&gt;f&lt;/code&gt; 함수 는 &lt;code&gt;Bar&lt;/code&gt; 에 적용될 때 실패 하므로 컴파일러는 &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 해당 정의에서 경고를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="b08d390b9c785654fe869c3d6ad222e20f07d378" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt;&lt;code&gt;-Wunused-packages&lt;/code&gt;&lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;, but were not loaded during compication. Usually it means that you have an unused dependency.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt; &lt;code&gt;-Wunused-packages&lt;/code&gt; &lt;/a&gt; 옵션 은 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 또는 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 를 통해 명령 줄에 지정 되었지만 압축 중에로드되지 않은 패키지에 대해 경고합니다 . 일반적으로 사용하지 않는 종속성이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61a620c8d9cc429955a946259cb514c924df7f85" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt;&lt;code&gt;-Wunused-packages&lt;/code&gt;&lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;, but were not loaded during compilation. Usually it means that you have an unused dependency.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt; &lt;code&gt;-Wunused-packages&lt;/code&gt; &lt;/a&gt; 옵션 은 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 또는 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 를 통해 명령 줄에 지정 되었지만 컴파일 중에로드되지 않은 패키지에 대해 경고합니다 . 일반적으로 사용하지 않는 종속성이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt; 옵션을 사용 하면 평가가 시작 되 자마자 각 썽크가 블랙홀됩니다. 기본값은 &quot;게으른 블랙홀 링&quot;이며, 스레드는 어떤 이유로 스레드가 일시 정지 된 경우에만 평가 중으로 표시됩니다. 게으른 블랙홀 링은 일반적으로 대부분의 썽크를 블랙홀 할 필요가 없기 때문에 1-2 % 정도 더 효율적입니다. 그러나 열성적인 블랙홀 링은 병렬 프로그램에서 더 많은 반복 계산을 피할 수 있으며, 이는 종종 병렬 처리에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">프롬프트에서 입력 한 표현식에 특수 기본 규칙을 적용하기 위해 &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; 옵션 이 사용됩니다 ( &lt;a href=&quot;#extended-default-rules&quot;&gt;GHCi의 유형 기본값&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">옵션 설명 ( &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">주문 요구 사항 ( &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d8167b403a42cc1edb9a2a682b7a5b48280ccc43" translate="yes" xml:space="preserve">
          <source>The origin of the combinatorial product when &lt;strong&gt;&lt;code&gt;F&lt;/code&gt;&lt;/strong&gt; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; should now be apparent, the &lt;em&gt;non-deterministic&lt;/em&gt; definition of &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; for &lt;code&gt;List&lt;/code&gt; makes multiple independent choices for each element of the structure.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;F&lt;/code&gt; &lt;/strong&gt; 가 &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; 일&lt;/strong&gt; 때 조합 제품의 기원 이 이제 분명 해져야 합니다. &lt;code&gt;List&lt;/code&gt; 에 대한 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 의 &lt;em&gt;비 결정적&lt;/em&gt; 정의 는 구조의 각 요소에 대해 여러 독립적 인 선택을합니다.</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">원래 토론은 여기에 보관되어 있습니다. &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;Data.Text.Text에 대한 Data 인스턴스를 얻을 수 있습니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">원래 프로그램은 잘못되었습니다. 또 다른 종류의 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 원래 데이터 생성자 세트</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 작업 인 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; 를 사용하여 리프팅하기에 적합한 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">다른 콤비 네이터에는 합리적인 기본 정의가 있으며 이는 효율성을 위해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">다른 메소드에는 다음과 같은 기본 정의가 있으며 이는 동등한 특수 구현으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb7ece3e405ff935e86728e725cfcb4a44b98bc" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">역할 주석이 필요할 수있는 다른 위치는 &lt;code&gt;hs-boot&lt;/code&gt; 파일 ( &lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt; )이며, 여기서 정의의 오른쪽 부분을 생략 할 수 있습니다. 평소와 같이 &lt;code&gt;hs-boot&lt;/code&gt; 파일에 선언 된 유형 / 클래스는 역할까지 포함 하여 &lt;code&gt;hs&lt;/code&gt; 파일 의 정의와 일치해야 합니다. 데이터 유형의 기본 역할 은 일반적인 사용 사례에 해당하는 &lt;code&gt;hs-boot&lt;/code&gt; 파일의 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">역할 주석이 필요할 수있는 다른 위치 는 정의의 오른쪽을 생략 할 수있는 &lt;code&gt;hs-boot&lt;/code&gt; 파일 ( &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;상호 재귀 모듈을 컴파일하는 방법&lt;/a&gt; )에 있습니다. 평소와 같이 &lt;code&gt;hs-boot&lt;/code&gt; 파일에 선언 된 유형 / 클래스는 역할까지 포함 하여 &lt;code&gt;hs&lt;/code&gt; 파일 의 정의와 일치해야 합니다. 데이터 유형의 기본 역할 은 일반적인 사용 사례에 해당하는 &lt;code&gt;hs-boot&lt;/code&gt; 파일로 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">아래의 다른 전술은 특별한 경우를 위해 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 의 최적화 또는 단순화입니다 . 가장 중요한 것은,</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">아래의 다른 전술은 특별한 경우 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 의 최적화 또는 단순화입니다 . 가장 중요한 것은,</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">아래의 다른 전술은 특별한 경우를 위해 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 의 최적화 또는 단순화입니다 . 가장 중요한 것은,</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">아래의 다른 전술은 특별한 경우 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 의 최적화 또는 단순화입니다 . 가장 중요한 것은,</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">&lt;code&gt;ghc-pkg recache&lt;/code&gt; 가 유용한 다른 시간 은 패키지를 수동으로 등록하는 것입니다. 패키지 데이터베이스 디렉토리에 적절한 파일을 넣고 &lt;code&gt;ghc-pkg recache&lt;/code&gt; 를 호출 하여 캐시를 업데이트하면 패키지를 등록 할 수 있습니다 . 이 패키지 등록 방법은 자동화 된 패키징 시스템에 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">유형의 외부 유형 생성자</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 로 비활성화하지 않으면 모든 패턴 일치의 가장 바깥 쪽 패턴이 암시 적 뱅을 얻습니다 . 이는 대소 문자 표현, 람다 패턴, 표기법, 목록 이해 등에 적용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">출력 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 은 줄의 왼쪽 절반에서 사용되지 않은 부분이며 반대입니다.</target>
        </trans-unit>
        <trans-unit id="64559f0045cf50a2584ac0f3b554b1497f350498" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">출력 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 은 반전 된 줄의 왼쪽 절반에서 사용되지 않은 부분입니다.</target>
        </trans-unit>
        <trans-unit id="e8d7a4ea6191b58bf6e33cabb3a1257778b2a45b" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">출력 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 은 반전 된 줄의 왼쪽 절반에서 사용되지 않은 부분입니다.</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">출력에는 프로그램에서 발생한 각 예외에 대한 하나의 보고서가 포함됩니다 (프로그램은 실행 중에 여러 가지 예외를 발생시키고 포착 할 수 있음). 각 보고서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c2e5b9a77507c6a8b08d76dc41ae952b97f0397" translate="yes" xml:space="preserve">
          <source>The output is a listing of all matching instances, simplified and instantiated as much as possible.</source>
          <target state="translated">출력은 가능한 한 많이 단순화되고 인스턴스화 된 모든 일치하는 인스턴스의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e1647f08fd0d03cfed6027ec69a028632d0edcfe" translate="yes" xml:space="preserve">
          <source>The output is as follows:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">출력은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 관련 버퍼를 사용하여 버퍼링됩니다 . 이 버퍼가 너무 작아서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 조치 의 한 단계를 수행 할 수 없으면 충분히 큰 버퍼로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="5fe80f6940b0232944b7b1dd6f17ef4e130eec5a" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">출력은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 관련 버퍼를 사용하여 버퍼링됩니다 . 이 버퍼가 너무 작아 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 작업 의 한 단계를 실행할 수 없으면 충분히 큰 버퍼로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="3218872b6fb2290ae09475079bde573ea5753f84" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">출력은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 관련 버퍼를 사용하여 버퍼링됩니다 . 이 버퍼가 너무 작아 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 작업 의 한 단계를 실행할 수 없으면 충분히 큰 버퍼로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">출력은 ⟨file⟩에 배치됩니다. ⟨file⟩이 생략되면 출력이 &lt;code&gt;stderr&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; 의 출력은 세 개의 공백으로 구분 된 필드를 포함하는 헤더 행으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">&lt;code&gt;+RTS -s&lt;/code&gt; 의 출력은 프로그램 실행 중 생성 및 실행 된 &quot;스파크&quot;수 ( &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션&lt;/a&gt; 참조 )를 알려주므로 &lt;code&gt;par&lt;/code&gt; 주석이 얼마나 잘 작동하는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">이 프로그램의 출력 :</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">오버로드 된 불변 배열 인터페이스</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">유형이 선언 된 모듈의 패키지 이름</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">패키지 사양은 아직 설치되지 않은 패키지 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; 가 반환 한 쌍은 &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; 와 같은 쌍이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">종이 &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;정량화 된 클래스 제약&lt;/a&gt; (Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017)은이 기능에 대한 기술적 인 세부 사항을 예제와 함께 설명하므로이 제안서의 기본 참조 소스입니다.</target>
        </trans-unit>
        <trans-unit id="9a39d25846fddc558c23b85ab30760213efefaf3" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this feature.</source>
          <target state="translated">&lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) 백서 에서는이 기능을 예제와 함께 기술적 인 세부 사항에 대해 설명하므로이 기능의 주요 참조 소스입니다.</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">파라미터 화 가능한 예외 모나드.</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">매개 변수화 가능 모나드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 모나드로 임의 모나드를 구성하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b9fb54cd437f1b7ff93722b920d2899ccc3176a" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 모나드로 임의의 모나드를 구성하여 얻은 매개 변수화 가능한 아마도 모나드.</target>
        </trans-unit>
        <trans-unit id="b0d4cf46f2063df438af6121c5250c1c1eb7b7e2" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 모나드로 임의의 모나드를 구성하여 얻은 매개 변수화 가능한 아마도 모나드.</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">파라미터 화 가능한 리더 모나드.</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">파서 &lt;code&gt;anyToken&lt;/code&gt; 은 모든 종류의 토큰을 허용합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 를 구현하는 데 사용됩니다 . 허용 된 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">파서 &lt;code&gt;anyToken&lt;/code&gt; 은 모든 종류의 토큰을 허용합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 를 구현하는 데 사용됩니다 . 허용 된 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">파서 &lt;code&gt;anyToken&lt;/code&gt; 은 모든 종류의 토큰을 허용합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 를 구현하는 데 사용됩니다 . 허용 된 토큰을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">파서 &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; 는 파서 &lt;code&gt;p&lt;/code&gt; 로 동작 하지만 &lt;em&gt;입력을 소비&lt;/em&gt; 하지 &lt;em&gt;않고&lt;/em&gt; 파서 &lt;code&gt;p&lt;/code&gt; 가 실패 할 때마다 예상 오류 메시지를 예상 오류 메시지 &lt;code&gt;msg&lt;/code&gt; 로 바꿉니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">파서 &lt;code&gt;permute perm&lt;/code&gt; 은 &lt;code&gt;perm&lt;/code&gt; 으로 설명 된 파서의 순열을 구문 분석합니다 . 의 선택적 문자열 예를 들어, 우리의 순열 분석한다고 가정 의, 문자 &lt;code&gt;b&lt;/code&gt; 및 선택적 &lt;code&gt;c&lt;/code&gt; . 이것은 다음과 같이 설명 할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">제공된 함수 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하는 모든 문자에 대해 구문 분석기가 &lt;code&gt;satisfy f&lt;/code&gt; . 실제로 구문 분석 된 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3da61c1f215262075e23c68ae9974f2a60c3aee3" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">구문 분석기 는 제공된 함수 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하는 모든 문자에 대해 &lt;code&gt;satisfy f&lt;/code&gt; 합니다 . 실제로 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e182b9ed56cfea719bfb7f4e40d9f6a35233ac2" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">구문 분석기 는 제공된 함수 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 하는 모든 문자에 대해 &lt;code&gt;satisfy f&lt;/code&gt; 합니다 . 실제로 구문 분석 된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">파서 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 를 가진 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . &lt;code&gt;t&lt;/code&gt; 의 소스 위치는 &lt;code&gt;posFromTok t&lt;/code&gt; 에 의해 리턴되어야하며 토큰은 &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8d4044987606d17ffa84d47bfdcb30cc0f2b4ab" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">구문 분석기 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 가 있는 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . &lt;code&gt;t&lt;/code&gt; 의 소스 위치는 &lt;code&gt;posFromTok t&lt;/code&gt; 에 의해 반환되어야하며 토큰은 &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0c3af649fb859adf4b4cd09d1710a5b4d71f62f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">구문 분석기 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 가 있는 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . &lt;code&gt;t&lt;/code&gt; 의 소스 위치는 &lt;code&gt;posFromTok t&lt;/code&gt; 에 의해 반환되어야하며 토큰은 &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">파서 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 를 가진 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 토큰을 표시 할 수 있습니다 . &lt;code&gt;nextPos&lt;/code&gt; 가 현재 소스 위치 &lt;code&gt;pos&lt;/code&gt; , 현재 토큰 &lt;code&gt;t&lt;/code&gt; 및 나머지 토큰 &lt;code&gt;toks&lt;/code&gt; , &lt;code&gt;nextPos pos t toks&lt;/code&gt; tks 와 함께 호출 될 때 &lt;em&gt;다음&lt;/em&gt; 토큰 의 위치 가 리턴되어야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21e2fe8d4e41cdd8a83bf46968df27727c4731ed" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">구문 분석기 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 가 있는 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . 토큰은 &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 표시 할 수 있습니다 . &lt;em&gt;다음&lt;/em&gt; 토큰 의 위치는 &lt;code&gt;nextPos&lt;/code&gt; 가 현재 소스 위치 &lt;code&gt;pos&lt;/code&gt; , 현재 토큰 &lt;code&gt;t&lt;/code&gt; 및 나머지 토큰 &lt;code&gt;toks&lt;/code&gt; , &lt;code&gt;nextPos pos t toks&lt;/code&gt; 로 호출 될 때 반환되어야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27e6679a2040a4cc14d5ec3614b408bb7ee98b37" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">구문 분석기 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 는 &lt;code&gt;testTok t&lt;/code&gt; 함수 가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x를 반환 할 때 결과 &lt;code&gt;x&lt;/code&gt; 가 있는 토큰 &lt;code&gt;t&lt;/code&gt; 를 받습니다 . 토큰은 &lt;code&gt;showTok t&lt;/code&gt; 를 사용하여 표시 할 수 있습니다 . &lt;em&gt;다음&lt;/em&gt; 토큰 의 위치는 &lt;code&gt;nextPos&lt;/code&gt; 가 현재 소스 위치 &lt;code&gt;pos&lt;/code&gt; , 현재 토큰 &lt;code&gt;t&lt;/code&gt; 및 나머지 토큰 &lt;code&gt;toks&lt;/code&gt; , &lt;code&gt;nextPos pos t toks&lt;/code&gt; 와 함께 호출 될 때 반환되어야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">파서 &lt;code&gt;try p&lt;/code&gt; 는 파서 &lt;code&gt;p&lt;/code&gt; 와 같이 동작하지만 오류가 발생했을 때 입력을 소비하지 않은 것으로 가장합니다.</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">파서 &lt;code&gt;unexpected msg&lt;/code&gt; 항상 예기치 않은 오류 메시지와 함께 실패 &lt;code&gt;msg&lt;/code&gt; 모든 입력을 사용하지 않고.</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">파서는 &lt;code&gt;p&lt;/code&gt; 가 입력을 소비하지 않은 경우에만 (즉, 미리보기는 1 임) &lt;code&gt;q&lt;/code&gt; 가 시도 되기 때문에 파서를 &lt;em&gt;예측&lt;/em&gt; 이라고 합니다. 이 역 추적 비헤이비어는 파서 결합기를 효율적으로 구현하고 우수한 오류 메시지를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 오류 메시지를 생성하는 데 사용되는 세 개의 파서가 &lt;code&gt;unexpected&lt;/code&gt; 입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 의 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 오류 메시지를 생성하는 데 사용되는 세 개의 파서가 &lt;code&gt;unexpected&lt;/code&gt; 입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 의 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 오류 메시지를 생성하는 데 사용되는 세 개의 파서가 &lt;code&gt;unexpected&lt;/code&gt; 입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 의 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7ee59d681c70376770b1fac8def196e60a6b828" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd849bb3016a66d8c098cc0703e43bfaab55d628" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3eada09e683e23c6ff49ebfe7467394ea90bede" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5fe22074b95aef0b21f9a5dd43e52a6c7896746" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e8eb477e245f7f3705845f40a88a71eb316dcf" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4f7143d745a0515f027af6396b04eb6900940b4" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하고 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;unexpected&lt;/code&gt; 것은 오류 메시지를 생성하는 데 사용되는 세 가지 파서입니다. 이 중 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 만 일반적으로 사용됩니다. &lt;code&gt;unexpected&lt;/code&gt; 사용의 예 는 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">&quot; &lt;code&gt;=&amp;gt;&lt;/code&gt; &quot; 앞의 부분 은 &lt;em&gt;context&lt;/em&gt; 이고 &quot; &lt;code&gt;=&amp;gt;&lt;/code&gt; &quot; 뒤의 부분 은 인스턴스 선언 의 &lt;em&gt;헤드&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">결과와 함께 부분적으로 채워진 마지막 버퍼.</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">이 그룹의 비밀번호 (gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; 으로 리턴 된 경로 는 동일한 문자열 ( &lt;code&gt;ShellCommand&lt;/code&gt; 가 아닌 &lt;code&gt;RawCommand&lt;/code&gt; )이 전달 될 때 &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 에 의해 실행되는 프로그램에 해당 합니다 ( 해당 &lt;code&gt;name&lt;/code&gt; 이 둘 이상의 세그먼트가있는 상대 경로가 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="b2d3f49ac1a8f81e24f3b676bdd92147b2b52971" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; 의해 반환 된 경로 는 동일한 문자열 ( &lt;code&gt;ShellCommand&lt;/code&gt; 가 아닌 &lt;code&gt;RawCommand&lt;/code&gt; 로)을 전달할 때 &lt;code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 가 실행하는 프로그램에 해당 합니다. 단 , 해당 &lt;code&gt;name&lt;/code&gt; 은 세그먼트가 둘 이상인 상대 경로가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">만들려는 디렉토리의 경로</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">패턴</target>
        </trans-unit>
        <trans-unit id="315acf3488874c225ec06af4616c6846812ce4e8" translate="yes" xml:space="preserve">
          <source>The pattern match checker works by assigning symbolic values to each pattern. We call each such assignment a &amp;lsquo;model&amp;rsquo;. Now, each pattern match clause leads to potentially multiple splits of that model, encoding different ways for the pattern match to fail. For example, when matching &lt;code&gt;x&lt;/code&gt; against &lt;code&gt;Just 4&lt;/code&gt;, we split each incoming matching model into two uncovered sub-models: One where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; and one where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; is not &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">패턴 일치 검사기는 각 패턴에 기호 값을 할당하여 작동합니다. 우리는 그러한 각 할당을 '모델'이라고 부릅니다. 이제 각 패턴 일치 절은 해당 모델의 잠재적으로 여러 분할로 이어져 패턴 일치가 실패하는 여러 방법을 인코딩합니다. 예를 들어, &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;Just 4&lt;/code&gt; 와 일치시킬 때 들어오는 각 일치 모델을 두 개의 발견되지 않은 하위 모델로 분할합니다. 하나는 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Nothing&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Just y&lt;/code&gt; 이지만 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;4&lt;/code&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b8b96580328f0d50dd0ffa37b821ba6ac58cd252" translate="yes" xml:space="preserve">
          <source>The pattern synonym return type (&lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe Bool) -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">패턴 동의어 반환 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe Bool) -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">패턴 구문은 구문이라는 용어를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">패턴 유형 서명은 방정식의 오른쪽에서 유형 변수를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">RTS가 OS에서 할당 한 최대 메모리입니다.</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">이 호출 및 모든 하위 호출에 의해 작성된 프로그램의 총 메모리 할당 (프로파일 링 오버 헤드 제외)의 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">이 호출로 작성된 프로그램의 총 메모리 할당 백분율 (프로파일 링 오버 헤드 제외).</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">이 시점에서 호출 트리에서 소비 한 프로그램의 총 런타임 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">콜 트리에서이 지점 미만으로 소비 한 프로그램의 총 런타임 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">범위 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; 의 복소수의 위상입니다 . 크기가 0이면 위상도 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">프로세스 식별자의 플랫폼 별 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8463d6555430125aabc768a8bec2859b4a17a9f0" translate="yes" xml:space="preserve">
          <source>The plugin is then defined as by providing a value for the &lt;code&gt;holeFitPlugin&lt;/code&gt; field, a function that takes the &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags and returns a &lt;code&gt;HoleFitPluginR&lt;/code&gt;. This function can be used to pass the &lt;code&gt;CommandLineOption&lt;/code&gt; strings along to the candidate and fit plugins respectively.</source>
          <target state="translated">플러그인은 다음의 값으로 제공함으로써 정의된다 &lt;code&gt;holeFitPlugin&lt;/code&gt; 의 필드, 취하는 함수 &lt;code&gt;CommandLineOption&lt;/code&gt; 의 은 USING 컴파일러에 전달되는 문자열 &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; 플래그 및 리턴 &lt;code&gt;HoleFitPluginR&lt;/code&gt; 를 . 이 함수는 &lt;code&gt;CommandLineOption&lt;/code&gt; 문자열을 후보 및 맞춤 플러그인에 각각 전달하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af51c643d01a6af33fb762fecbe75a84665e395b" translate="yes" xml:space="preserve">
          <source>The pointer refers to a byte array. Finalization is not supported. This optimizes &lt;code&gt;MallocPtr&lt;/code&gt; by avoiding the allocation of a &lt;code&gt;MutVar#&lt;/code&gt; when it is known that no one will add finalizers to the &lt;code&gt;ForeignPtr&lt;/code&gt;. Functions that add finalizers to a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; throw exceptions when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is backed by &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt;. The invariants that apply to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:MallocPtr&quot;&gt;MallocPtr&lt;/a&gt;&lt;/code&gt; apply to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; as well.</source>
          <target state="translated">포인터는 바이트 배열을 나타냅니다. 마무리는 지원되지 않습니다. 이것은 아무도 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 종료 자를 추가하지 않을 것으로 알려진 경우 &lt;code&gt;MutVar#&lt;/code&gt; 할당을 피함으로써 &lt;code&gt;MallocPtr&lt;/code&gt; 을 최적화 합니다 . &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 종료 자를 추가하는 함수 는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 에 의해 지원 될 때 예외를 발생 시킵니다 . 에 적용되는 불변 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:MallocPtr&quot;&gt;MallocPtr&lt;/a&gt;&lt;/code&gt; 는 적용 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 아니라.</target>
        </trans-unit>
        <trans-unit id="d0849b46a7478d7ad384336c0deed069c4c2b29c" translate="yes" xml:space="preserve">
          <source>The pointer refers to a byte array. The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; field means that the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; is reachable (by GC) whenever the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is reachable. When the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; becomes unreachable, the runtime's normal GC recovers the memory backing it. Here, the finalizer function intended to be used to &lt;code&gt;free()&lt;/code&gt; any ancilliary *unmanaged* memory pointed to by the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt;. See the &lt;code&gt;zlib&lt;/code&gt; library for an example of this use.</source>
          <target state="translated">포인터는 바이트 배열을 나타냅니다. &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 해당 필드 수단 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 마다 (GC에 의해) 도달 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 도달한다. 때 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 가 도달하게되고, 실행시의 정상적인 GC 그것을 백업 메모리를 복구한다. 여기서 종료 자 함수 는 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 가리키는 모든 보조 * 관리되지 않는 * 메모리 를 &lt;code&gt;free()&lt;/code&gt; 하는 데 사용됩니다 . 이 사용의 예 는 &lt;code&gt;zlib&lt;/code&gt; 라이브러리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a263d8d41bb6edc433ea0e9142fdac0bd9776a58" translate="yes" xml:space="preserve">
          <source>The pointer refers to unmanaged memory that should not be freed when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; becomes unreachable. Functions that add finalizers to a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; throw exceptions when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is backed by &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt;Most commonly, this is used with &lt;code&gt;Addr#&lt;/code&gt; literals. See Note [Why FinalPtr].</source>
          <target state="translated">포인터는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 도달 할 수 없을 때 해제해서는 안되는 관리되지 않는 메모리를 나타냅니다 . &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 종료 자를 추가하는 함수 는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 에 의해 지원 될 때 예외를 발생 시킵니다. 가장 일반적으로 이것은 &lt;code&gt;Addr#&lt;/code&gt; 리터럴 과 함께 사용됩니다 . Note [Why FinalPtr]을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8213f977e2ad8f2bba6a392999e51bc11f3a6125" translate="yes" xml:space="preserve">
          <source>The pointer refers to unmanaged memory that was allocated by a foreign function (typically using &lt;code&gt;malloc&lt;/code&gt;). The finalizer frequently calls the C function &lt;code&gt;free&lt;/code&gt; or some variant of it.</source>
          <target state="translated">포인터는 외부 함수 (일반적으로 &lt;code&gt;malloc&lt;/code&gt; 사용 )에 의해 할당 된 관리되지 않는 메모리를 나타냅니다 . 종료자는 자주 C 함수를 &lt;code&gt;free&lt;/code&gt; 또는 일부 변형을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 로 얻습니다 . 이 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (내부에서 사용 )과 유사합니다 . &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수가 reture 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치를 실행하는 동안에 만 포인터를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc771d773e26b800fb99dc3f19db0ff5b4824d1c" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 의해 획득됩니다 . 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (여기서 내부적으로 사용됨 )과 유사합니다 . 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수에 의해 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 실행 중에 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1e8e44c1e9b1f75abd43ddc712a72d215368641" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에서 가져옵니다 . 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (여기서 내부적으로 사용됨 )과 유사합니다 . 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수에 의해 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업을 실행하는 동안에 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 로 얻습니다 . 이 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (내부에서 사용 )과 유사합니다 . &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수가 reture 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치를 실행하는 동안에 만 포인터를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc94f03827f8d452b7fbe2b08e32fe79424476a7" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 의해 획득됩니다 . 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (여기서 내부적으로 사용됨 )과 유사합니다 . 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수에 의해 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 실행 중에 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4910952a92b169df78d7802200e6c4c8bfc1b643" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">배열 내용에 대한 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에서 가져옵니다 . 아이디어는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (여기서 내부적으로 사용됨 )과 유사합니다 . 포인터는 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 에 인수로 전달 된 함수에 의해 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업을 실행하는 동안에 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">이 유형의 다형성 유형을 사용하면 여러 설정에서 사용할 수 있습니다. 예를 들어, 존재하지 않는 인스턴스에 대해 더 나은 오류 메시지를 제공하기 위해 제약 조건으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">하위 범위에서 아래 첨자의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">이 차이의 실질적인 의미는 &lt;em&gt;부정확 한 예외&lt;/em&gt; 의미 로 인해</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">pragma는 인스턴스 선언 의 &lt;code&gt;where&lt;/code&gt; 부분에서 발생해야합니다 .</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">&lt;code&gt;OVERLAPPING&lt;/code&gt; , &lt;code&gt;OVERLAPPABLE&lt;/code&gt; , &lt;code&gt;OVERLAPS&lt;/code&gt; , &lt;code&gt;INCOHERENT&lt;/code&gt; pragma 는 &lt;a href=&quot;#instance-overlap&quot;&gt;겹치는 인스턴스&lt;/a&gt; 섹션에 설명 된대로 개별 인스턴스의 겹침 동작을 지정하는 데 사용됩니다 . pragma는 다음 과 같이 &lt;code&gt;instance&lt;/code&gt; 키워드 바로 뒤에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fac2032d2c008fd2be3f90420e30882ad7ba2306" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;instances#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">pragma &lt;code&gt;OVERLAPPING&lt;/code&gt; , &lt;code&gt;OVERLAPPABLE&lt;/code&gt; , &lt;code&gt;OVERLAPS&lt;/code&gt; , &lt;code&gt;INCOHERENT&lt;/code&gt; 는 섹션 &lt;a href=&quot;instances#instance-overlap&quot;&gt;중복 인스턴스에&lt;/a&gt; 설명 된대로 개별 인스턴스에 대한 중복 동작을 지정하는 데 사용됩니다 . pragma는 다음 과 같이 &lt;code&gt;instance&lt;/code&gt; 키워드 바로 뒤에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">프리 프로세서는 Haskell 컴파일러가 Haskell 입력을 올바르게 처리하기 직전에 실행되지만, 리터럴 마크 업이 제거되고 C 프리 프로세서가 Haskell 입력을 씻은 후에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">정확한 색 구성표는 환경 변수 &lt;code&gt;GHC_COLORS&lt;/code&gt; (또는 &lt;code&gt;GHC_COLOURS&lt;/code&gt; )에 의해 제어됩니다 . 콜론으로 구분 된 &lt;code&gt;key=value&lt;/code&gt; 쌍 목록으로 설정할 수 있습니다 . 기본 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96eb7064b5867fe92b5d5dd35489d4118c6f5245" translate="yes" xml:space="preserve">
          <source>The precise type of a quotation depends on the types of the nested splices inside it:</source>
          <target state="translated">정확한 견적 유형은 그 안에 중첩 된 스플 라이스 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">Integral 유형의 정밀도는 제로 패딩으로 달성됩니다. Integral 필드에 정밀도와 제로 패드가 모두 제공된 경우 제로 패드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">술어는 동등성을 정의한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b97869b6de983c9edee7999d2e2b2ebaa0a6f660" translate="yes" xml:space="preserve">
          <source>The prefix &lt;code&gt;-&lt;/code&gt; binds tighter than any infix operator. &lt;code&gt;-a % b&lt;/code&gt; is parsed as &lt;code&gt;(-a) % b&lt;/code&gt; regardless of the fixity of &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">접두사 &lt;code&gt;-&lt;/code&gt; 어떤 중위 연산자보다 더 엄격하게 바인딩합니다. &lt;code&gt;-a % b&lt;/code&gt; 로 파싱 &lt;code&gt;(-a) % b&lt;/code&gt; 에 관계없이 정착의 &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">접두사` &lt;code&gt;generic&lt;/code&gt; '은 &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; 함수 의 일반화 된 버전 인 오버로드 된 함수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">전처리 기는 다른 Haskell 확장에 대처할 수 없습니다. 이들은 별도의 모듈로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">공유 라이브러리 관리의 주요 어려움은 프로그램이 런타임에 필요한 라이브러리를 찾을 수 있도록하는 것입니다. 이것이 작동하는 방법에 대한 자세한 내용은 플랫폼, 특히 Unix ELF 플랫폼, Windows 및 Mac OS X의 세 가지 주요 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그러나 비동기 예외의 기본 소스는 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">프리미티브 파서 결합기.</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">primops는 &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed 유형&lt;/a&gt; 과 &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed 튜플&lt;/a&gt; 을 광범위하게 사용하며 여기에서 간단히 요약합니다.</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">여기서의 문제는이 인스턴스가 &lt;code&gt;[a]&lt;/code&gt; 의 하나의 특정 선택이 &lt;code&gt;b&lt;/code&gt; 에 대한 하나 이상의 선택과 연관 될 수있게하므로 &lt;code&gt;D&lt;/code&gt; 의 정의에 지정된 종속성과 모순된다는 것 입니다. 더 일반적으로 이것은 다음과 같은 형식의 경우를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="781f3f1a3ff39d864639b6823399b6750b7c27dc" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking &lt;em&gt;system&lt;/em&gt; calls which works for most system calls on both Unix and Windows.</source>
          <target state="translated">문제는 일반적으로 안전하게 외화를 차단할 수 없다는 것입니다. 그러나 GHC는 Unix와 Windows 모두에서 대부분의 시스템 호출에 대해 작동하는 차단 &lt;em&gt;시스템&lt;/em&gt; 호출 을 중단하는 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">문제는 일반적으로 외래 통화를 안전하게 중단 할 수 없다는 것입니다. 그러나 GHC는 Unix와 Windows 모두에서 대부분의 시스템 호출에 작동하는 시스템 호출 차단을 방해하는 방법을 제공합니다. 때 &lt;code&gt;InterruptibleFFI&lt;/code&gt; 의 확장이 활성화되어, 외국 통화는 주석 할 수 &lt;code&gt;interruptible&lt;/code&gt; 대신 &lt;code&gt;safe&lt;/code&gt; 또는 &lt;code&gt;unsafe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; 을 사용하여 브로드 캐스트 채널을 작성할 때 의 문제점 은 그것이 단지 쓰기 만하고 읽지 않으면 항목이 메모리에 쌓이게 된다는 것입니다. 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; 를 방송 채널을 생성하는 항목은 클라이언트가 그들을 본 후 쓰레기 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">모듈의 신뢰 여부를 확인하는 절차는 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 있는지 여부에 따라 다릅니다 . 검사는 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 두 경우 모두 유사하며 신뢰할 수있는 모듈에 대한 추가 요구 사항을 신뢰할 수있는 것으로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">프로세스가 작업을 수행 할 수있는 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">결합이 다형성 일 때 프로세스는 약간 복잡하다. 예제를 통해 프로세스를 보여줍니다. 일을 단순하게 유지하기 위해 잘 알려진 &lt;code&gt;map&lt;/code&gt; 기능을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">프로세스 신호 마스크</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">프로필 데이터 자체는 다음과 같은 속성을 가진 트리와 같은 객체 (여기서는 &quot;비용 센터 스택&quot;이라고 함)를 포함하는 &lt;code&gt;profile&lt;/code&gt; 필드로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">프로필 트리 자체</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">프로그램 &lt;strong&gt;hp2ps&lt;/strong&gt; 프로그램 변환에게 &lt;code&gt;.hp&lt;/code&gt; 의해 생성 된 파일 &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; 힙 프로파일의 그래프로 포스트 스크립트 실행 옵션. 일반적으로 &lt;strong&gt;hp2ps에서&lt;/strong&gt; 처리 할 파일의 확장자 는 &lt;code&gt;.hp&lt;/code&gt; 입니다. PostScript 출력은 &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; &lt;em&gt;파일에&lt;/em&gt; 기록됩니다 . 경우 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 은 전적으로 필터로서 다음 프로그램 동작합니다을 생략한다.</target>
        </trans-unit>
        <trans-unit id="0e8eeb216422d9b04565bfefa5f60f99f84c18a4" translate="yes" xml:space="preserve">
          <source>The program below, when compiled with optimisation:</source>
          <target state="translated">아래 프로그램은 최적화를 통해 컴파일 된 경우 :</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">프로그램 텍스트 자체, C 스택, 힙이 아닌 데이터 (예 : 외부 라이브러리에 의해 할당 된 데이터 및 RTS에 의해 할당 된 데이터) 및 &lt;code&gt;mmap()&lt;/code&gt; 'd 메모리는 힙 프로파일에서 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="477940d98b5481ae904ea922ab7dabd1f651a748" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;rsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">프로그램 텍스트 자체, C 스택, 힙이 아닌 데이터 (예 : 외부 라이브러리에서 할당 한 데이터, RTS에서 할당 한 데이터) 및 &lt;code&gt;mmap()&lt;/code&gt; 'd 메모리는 힙 프로필에서 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">프로그램의 힙이 한계에 도달했으며 프로그램이 보유한 라이브 데이터의 양을 줄이기 위해 조치를 취해야합니다. 노트:</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">프로그래머는 소스 프로그램의 일부로 pragma에서 다시 쓰기 규칙을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="770523c810bf8b94673e415429173c9454a13f38" translate="yes" xml:space="preserve">
          <source>The projection function for a record with a single linear field should be multiplicity-polymorphic; currently it&amp;rsquo;s unrestricted.</source>
          <target state="translated">단일 선형 필드가있는 레코드의 프로젝션 함수는 다중 다형성이어야합니다. 현재 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">의사 객체 파일 &lt;code&gt;A.o-boot&lt;/code&gt; 는 비어 있지만 (연결하지 마십시오!) Makefile을 사용할 때 &lt;code&gt;A.hi-boot&lt;/code&gt; 가 마지막으로 업데이트 된 시점을 기록하는 데 매우 유용 합니다 ( &lt;a href=&quot;#using-make&quot;&gt;make 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">템플릿 Haskell의 공개 얼굴</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 의 목적은 버퍼 를 통해 데이터를 읽고 쓸 수있는 I / O 장치에 대한 공통 인터페이스를 제공하는 것입니다. &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 를 구현하는 장치 에는 일반 파일, 메모리 매핑 파일 및 바이트 열이 포함됩니다. &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 구현하는 기본 장치 는 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">설치된 패키지 ID의 목적은 패키지에 종속 된 패키지를 다시 컴파일하지 않고 패키지를 다시 설치하여 발생하는 문제를 감지하는 것입니다. 새로 컴파일 된 패키지가 동일한 컴파일러를 사용하여 동일한 소스 코드에서 빌드 된 경우에도 새로 컴파일 된 패키지가 이전 버전과 다른 ABI (Application Binary Interface)를 가질 수 있으므로 종속성을 다시 컴파일해야합니다. 설치된 패키지 ID를 사용하면 재 컴파일 된 패키지는 이전 버전과 다른 설치된 패키지 ID를 가지므로 이전 버전에 종속 된 패키지는 이제 분리됩니다 (종속성 중 하나가 충족되지 않음). 이런 방식으로 깨진 패키지는 &lt;code&gt;ghc-pkg list&lt;/code&gt; 빨간색으로 (가능한 경우) 출력하거나 중괄호로 묶습니다. 다음 예제에서는 &lt;code&gt;filepath&lt;/code&gt; 패키지를 다시 컴파일하고 다시 설치했으며 이로 인해 &lt;code&gt;Cabal&lt;/code&gt; 을 비롯한 다양한 종속성 이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">빌더 프리미티브를 사용하는 목적은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 성능을 향상시키는 것 입니다. 이러한 개선은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 수행하는 가장 일반적인 두 단계를 보다 효율적으로 만드는 데 있습니다. 이 두 단계를 차례로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 형식 시그니처 의 수량화 는 명시 적입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b448f586c824562f03a97bce628eeed77c6e2ff" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 유형 서명 의 수량화 는 명시 적입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">인용 된 ⟨string⟩은 임의적 일 수 있으며 개행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fea1585aed3010cb59ede80216e1092bd438ce4" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</source>
          <target state="translated">인용 된 ⟨string⟩은 두 문자 시퀀스 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 의 첫 번째 발생에서 끝납니다 . 이스케이프는 절대로 수행되지 않습니다. 문자열에 해당 문자 시퀀스를 포함하려면 고유 한 이스케이프 규칙 (예 : 대신 문자열 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 사용)을 만들고 따옴표 함수가 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; &quot; 로 해석하도록해야합니다. ] &quot; . 이를 구현하는 한 가지 방법은 이스케이프 변환을 수행하기 위해 전처리 패스로 견적서를 작성하는 것입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;# 5348&lt;/a&gt; 의 토론을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">인용 된 ⟨string⟩은 두 문자 시퀀스 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 가 처음 나타날 때 끝납니다 . 절대로 이스케이프가 수행되지 않습니다. 문자열에 해당 문자 시퀀스를 포함하려면 고유 한 이스케이프 규칙 (예 : 대신 문자열 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 사용)을 발명하고 인용 기 함수가 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . 이를 구현하는 한 가지 방법은 따옴표를 사전 처리 패스로 작성하여 이스케이프 변환을 수행하는 것입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;문제 # 5348&lt;/a&gt; 의 토론을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">이 보수적 인 전략에 대한 이론적 근거가 주어진다 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;논문&lt;/a&gt; &quot;하자가 일반화되어서는 안된다&quot;와 &quot;지역 가정 모듈 형 타입 추론&quot;및 관련 &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;블로그 게시물&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46c2ed2757c23fae8b2fbe6c5c9ab4a0e016d4ba" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">이 보수적 인 전략에 대한 이론적 근거가 주어진다 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;논문&lt;/a&gt; &quot;하자가 일반화되어서는 안된다&quot;와 &quot;지역 가정 모듈 형 타입 추론&quot;및 관련 &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;블로그 게시물&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">이 비용 중심에 기인 한 원시 시간 &quot;틱&quot; 이것으로부터, 위에서 언급 한 &lt;code&gt;%time&lt;/code&gt; 그림을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">지정된 모나드에 읽기 전용 환경을 추가하는 리더 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="46f9f597df38a353cb188142732c1daaa5e1b6f6" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behavior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 가 역 추적 출력에이 기호 이름을 표시하지 않는 이유 는 디버그 정보의 해석이 부정확하기 때문입니다. 이는 C에서 유지되지만 Haskell 프로그램이 아니라고 가정합니다. 안타깝게도이 동작이 업스트림에서 수정 될 때까지이 문제를 수동으로 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 가 역 추적 출력에이 기호 이름을 표시하지 않는 이유 는 디버그 정보 해석에 부정확성이 있기 때문에 C에서는 변하지 않고 Haskell 프로그램은 보존하지 않는다고 가정합니다. 불행히도이 동작이 업스트림에 고정 될 때까지이 문제를 수동으로 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">후자의 제한 이유는 인스턴스 일치를 확인할 수있는 방법이 없기 때문입니다. 치다</target>
        </trans-unit>
        <trans-unit id="727c709b27773183b391bcb744b381b376f0efb1" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">이 예외의 이유는 &lt;code&gt;k&lt;/code&gt; 를 바인딩하는 다른 방법이 없을 수 있기 때문 입니다. 예를 들어, &lt;code&gt;S&lt;/code&gt; 가 &lt;em&gt;보이지 않는&lt;/em&gt; 매개 변수 &lt;code&gt;k&lt;/code&gt; 를 사용하여 다음과 같은 종류를 갖기를 원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="76babb94bd7796eeda34a4c806d3669a17f9540b" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">이 예외의 이유는 &lt;code&gt;k&lt;/code&gt; 를 바인딩하는 다른 방법이 없을 수 있기 때문 입니다. 예를 들어, &lt;code&gt;S&lt;/code&gt; 가 &lt;em&gt;보이지 않는&lt;/em&gt; 매개 변수 &lt;code&gt;k&lt;/code&gt; 를 사용하여 다음과 같은 종류를 갖기를 원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="10fffb75c7f29def089f47d64a7d059f29394ea6" translate="yes" xml:space="preserve">
          <source>The reason for this is, essentially, that none of these define a new construct. This means that no new type is being defined where specificity could play a role.</source>
          <target state="translated">그 이유는 본질적으로 이들 중 어느 것도 새로운 구조를 정의하지 않기 때문입니다. 이것은 특이성이 역할을 할 수있는 새로운 유형이 정의되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">&lt;code&gt;mergeQs&lt;/code&gt; 에 대한 호출 이 게으른 이유는 큐의 마지막 요소에 대해 맨 아래가되어 완전히 정렬 된 시퀀스를 평가할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">트러스트를 검사하는 두 가지 모드가있는 이유는 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; 에&lt;/a&gt; 의해 활성화 된 추가 요구 사항으로 인해 Safe Haskell의 설계가 침투하기 때문입니다. 플래그가 활성화 될 때 Safe Haskell을 사용하는 패키지는 사용자 컴퓨터의 신뢰할 수있는 패키지 상태에 따라 컴파일되거나 컴파일되지 않을 수 있습니다. Safe Haskell이 제공 한 보증을 사용하지 않더라도 모두 깨지기 쉬우 며 모든 사람이 컴파일 오류를 일으 킵니다. 기본적으로 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 를 비활성화 하고 플래그로 설정하면 Safe Haskell이 항상 켜져있는 기능이 아닌 옵트 인 확장이됩니다.</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">리 바인드 가능한 연산자는 위 표에 제공된 &quot;예상 유형&quot;을 가져야합니다. 이러한 유형은 놀라 울 정도로 일반적입니다. 예를 들어, 다음 유형의 바인드 연산자를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">더 작은 부품에서 ByteString을 조립하는 권장 방법은 Data.ByteString.Builder의 빌더 모노 &lt;a href=&quot;data-bytestring-builder&quot;&gt;아이드&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">작은 부품에서 게으른 ByteString을 조립하는 권장 방법은 &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 의 빌더 모노 아이드 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">권장 청크 크기입니다. 현재 4k로 설정, 메모리 관리 오버 헤드 감소</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">레코드 필드 &lt;code&gt;f&lt;/code&gt; 의 범위는 어떻게 든 (적격 또는 비 적격)입니다.</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 를 재귀 적으로 사용 하면 두 번째 인수가 &lt;code&gt;Type&lt;/code&gt; 을 갖습니다 . 그러나 형식 유추와 마찬가지로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;사용자 제공 종류 서명&lt;/em&gt; (또는 CUSK)을 제공하여 다형성 재귀를 얻을 수 있습니다 . CUSK는 추론 할 필요없이 모든 인수 종류와 결과 종류를 알면 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dedba55228cde4bbd5f3a4194d8b8dabbf8ef98a" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 를 재귀 적으로 사용 하면 두 번째 인수가 &lt;code&gt;Type&lt;/code&gt; 종류를 갖게 됩니다. 그러나 유형 추론과 마찬가지로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;독립형 종류 서명&lt;/em&gt; 을 제공하여 다형성 재귀를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">호출자 프로세스에서 참조를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">관련된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;찾기 우선 설정 조작&lt;/a&gt; 은 다음과 같이 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82e04509f3c4e35fd2f1a07c859be169e0cebec" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;https://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">관련된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set 연산&lt;/a&gt; 은 다음과 같이 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">렌더링 모드.</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 표현 은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 와 약간 다릅니다 . 우리가 살펴 보자 &lt;code&gt;Tree&lt;/code&gt; 다시 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typ의 표현은 추상화되어 구현에서 멋진 표현 (예 : 공유 관리를위한 해시-콘솔)을 사용할 수 있습니다. 뷰 패턴이 없으면이 서명을 사용하는 것이 약간 불편합니다.</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">외부 파일 또는 스트림에서 줄 바꿈 표현.</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 의 종류를 요술하기 위해서 GHC에 의해 생성 된 표현 입니다.</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">이 표현은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 을 재사용합니다 . (이 재사용 가능성은 우리가 kind- &lt;code&gt;*&lt;/code&gt; -types에 대한 더미 유형 인수를 수행하는 이유 이지만, 이들 각각을 복제하지 않고 이미 다른 이름이 충분합니다.)</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">이 모듈에서 사용되는 표현은 고성능 사용 및 대량의 데이터 스트리밍에 적합합니다. 전체 내용이 메모리에 상주하지 않아도 큰 본문을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 유형의 표현과 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 을 구성하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 의 파생 인스턴스에서 사용되는 함수 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ba5b30cdfd9e86a561074290ccced5278a8f534c" translate="yes" xml:space="preserve">
          <source>The required constraints (&lt;code&gt;&amp;lt;...&amp;gt; Read a =&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">필수 제약 조건 ( &lt;code&gt;&amp;lt;...&amp;gt; Read a =&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">일정 변경 타이머는 기본적으로 20ms 단위로 실행되지만 &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS 옵션을 사용하여 변경할 수 있습니다 . &quot;예약&quot;일정을 변경 한 후에는 실행중인 스레드가 최대한 빨리 선점됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;getCurrentTime&lt;/code&gt; , &lt;code&gt;getPOSIXTime&lt;/code&gt; 의 해상도</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 GADT 스타일 데이터 형식 선언에 대한 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 GADT를 지원하는 GHC의 확장 기능에 대해 간략하게 설명합니다. 확장 프로그램은 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 로 활성화됩니다 . &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; 의&lt;/a&gt; 확장도 설정 &lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb9e53f318cf247bf10897cae419b667774eabb1" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;let_generalisation#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 GADT를 지원하는 GHC 확장에 대해 설명합니다. 확장은 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 로 활성화됩니다 . &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; 의&lt;/a&gt; 확장도 설정 &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;let_generalisation#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">기능적 종속성 ( &lt;a href=&quot;#functional-dependencies&quot;&gt;기능적 종속성&lt;/a&gt; ) 에 대한 제한 은 특히 ​​문제가됩니다. 머리에 나타나지 않는 컨텍스트에 유형 변수를 도입하려는 유혹이 있습니다. 이는 일반적인 규칙에서 제외 된 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="756e15be4e4083197aaf2790548e77863f7b570b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;functional_dependencies#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">기능적 종속성 ( &lt;a href=&quot;functional_dependencies#functional-dependencies&quot;&gt;기능적 종속성&lt;/a&gt; ) 에 대한 제한 은 특히 ​​문제가됩니다. 머리에 나타나지 않는 문맥에 타입 변수를 도입하고 싶은 유혹이 있습니다. 이것은 정상적인 규칙에 의해 배제됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이해의 결과 표현은 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; 의 &lt;em&gt;마지막&lt;/em&gt; 이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이해의 결과 표현은 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; 의 &lt;em&gt;마지막&lt;/em&gt; 이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f01982d31d372848e4d6802c210759a3354a8278" translate="yes" xml:space="preserve">
          <source>The result is always &lt;code&gt;&amp;gt;= 1&lt;/code&gt; since even zero is encoded with 1 limb.</source>
          <target state="translated">결과는 항상 &lt;code&gt;&amp;gt;= 1&lt;/code&gt; 입니다. 0도 1 개의 팔다리로 인코딩되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="234012fc40c4bea56f2e4f13bf5a1c3732914d46" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">결과적으로 구멍이나 변수는 &lt;code&gt;undefined&lt;/code&gt; 처럼 동작 하지만 컴파일 시간에 경고를 표시하고 런타임에 평가되면 동일한 메시지를 표시하는 추가 이점이 있습니다. 이 동작은 &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 를 의미 하는 &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 옵션 의 동작을 따릅니다 . &lt;a href=&quot;defer_type_errors#defer-type-errors&quot;&gt;유형 오류를 런타임으로 연기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">결과적으로 구멍이나 변수는 &lt;code&gt;undefined&lt;/code&gt; 처럼 동작 하지만 컴파일 타임에 경고를 표시하고 런타임에 평가되면 동일한 메시지를 표시한다는 추가 이점이 있습니다. 이 동작은 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 옵션 의 동작을 따르며 , 이는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; 를 의미&lt;/a&gt; 합니다. &lt;a href=&quot;#defer-type-errors&quot;&gt;런타임에 유형 오류 연기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">결과 종류 주석은 선택 사항이며 생략하면 기본값 은 인수 종류와 같은 &lt;code&gt;Type&lt;/code&gt; 입니다. 다품종 유형 군은 종류 주석의 매개 변수를 사용하여 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a8283d81339db6232148408a4fcc0523f7e378" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; is all-or-nothing, either containers of exactly the same shape as the input or a failure (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, empty list, etc.). The &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; function does not perform selective filtering as with e.g. &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 의 결과는 입력과 정확히 같은 모양의 컨테이너이거나 실패 ( &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; , 빈 목록 등) 인 전부 또는 없음 입니다. &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 기능 등으로 선택적으로 필터링을 수행하지 않는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2eca7030285d2fa9dfbb2ca4fe65ae3271250e69" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is all-or-nothing, either containers of exactly the same shape as the input or a failure (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, empty list, etc.). The &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; function does not perform selective filtering as with e.g. &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 의 결과는 입력과 정확히 같은 모양의 컨테이너이거나 실패 ( &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; , 빈 목록 등) 인 전부 또는 없음 입니다. &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 함수는 예와 같이 선택적 필터링을 수행하지 않는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">최종 연속으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 사용하여 CPS 계산을 실행 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="6cddc91b7454e61583af3768c2c69961c994bfc1" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">최종 연속으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 사용하여 CPS 계산을 실행 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="f61cf4af4831c00ee95b4b539424083349107c0f" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">최종 연속으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 사용하여 CPS 계산을 실행 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">주어진 최종 연속으로 CPS 계산을 실행 한 결과. ( &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">주어진 최종 연속으로 CPS 계산을 실행 한 결과. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">ID를 최종 연속으로 사용하여 CPS 계산을 실행 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 아르메니아의 작은 합자 &quot;ﬓ&quot;(지금은 U + FB13)은 &quot;մ&quot;(남자, U + 0574) 순서로 접 히고 그 뒤에 &quot;ն&quot;(현재, U + 0576)로 접습니다. &quot;&amp;micro;&quot;(마이크로 부호, U + 00B5)는 케이스 대신 &quot;&amp;mu;&quot;(작은 글자 mu, U + 03BC)로 접힌 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 현재 아르메니아의 소형 합자 남성 (U + FB13)은 현재 빅램 (U + 0574 U + 0576)으로 접 히고 마이크로 부호 (U + 00B5)는 그리스어 소문자 mu로 접혔습니다. 자체 대신 (U + 03BC).</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 현재 아르메니아의 소형 합자 남성 (U + FB13)은 현재 빅램 (U + 0574 U + 0576)으로 접 히고 마이크로 부호 (U + 00B5)는 그리스어 소문자 mu로 접혔습니다. 자체 대신 (U + 03BC).</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, 라틴어 작은 합자 fl (U + FB02)은 라틴어 대문자 F (U + 0046)와 라틴어 소문자 l (U + 006C)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, &quot;İ&quot;(위의 점이있는 라틴 대문자 I, U + 0130)는 &quot;i&quot;(라틴의 소문자 i, U + 0069)와 &quot;̇&quot;(위의 점, U + 0307 결합) 순서로 매핑됩니다. .</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어 독일어 &quot;&amp;szlig;&quot;(eszett, U + 00DF)는 2 문자 시퀀스 &quot;SS&quot;에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어 독일어 eszett (U + 00DF)는 2 문자 시퀀스 SS에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, 위의 점이있는 라틴 대문자 I (U + 0130)는 라틴어 문자 i 시퀀스 (U + 0069)에 매핑 된 다음 위의 점 (U + 0307)을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">결과 유형은 &lt;code&gt;Show&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">결과 유형이 &lt;code&gt;()&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">결과 유형도 분명해야합니다. 일반적으로 이것은 유추 될 수 있지만 그룹의 모든 패턴 동의어가 생성자에서 다형성 인 경우 사용자는 유형 서명을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">각 데이터 생성자의 결과 유형은 정의 된 유형 생성자로 시작해야합니다. 모든 생성자의 결과 유형이 &lt;code&gt;T a1 ... an&lt;/code&gt; 형식 인 경우 &lt;code&gt;a1 ... an&lt;/code&gt; 고유 유형 변수 인 경우 데이터 유형은 &lt;em&gt;일반입니다&lt;/em&gt; . 그렇지 않으면 &lt;em&gt;일반화 된&lt;/em&gt; 데이터 &lt;a href=&quot;#gadt&quot;&gt;유형 (GADT&lt;/a&gt; ( Generalized Algebraic Data Types) )입니다.</target>
        </trans-unit>
        <trans-unit id="4a3b3a8adec46b33328872fb3047f33759478c0b" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">각 데이터 생성자의 결과 유형은 정의되는 유형 생성자로 시작해야합니다. 모든 생성자의 결과 유형이 &lt;code&gt;T a1 ... an&lt;/code&gt; 이고 여기서 &lt;code&gt;a1 ... an&lt;/code&gt; 은 고유 한 유형 변수 인 경우 데이터 유형은 &lt;em&gt;보통입니다&lt;/em&gt; . 그렇지 않으면 &lt;em&gt;일반화 된&lt;/em&gt; 데이터 &lt;a href=&quot;gadt#gadt&quot;&gt;유형 (GADT&lt;/a&gt; ( Generalized Algebraic Data Types) )입니다.</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">결과는 (아마도) 재귀 적 바인딩 세트가되어 왼쪽의 간단한 변수 만 바인딩합니다. (Haskell Report에서와 같이 한 단계 더 나아갈 수 있고 &lt;code&gt;fix&lt;/code&gt; 를 사용하여 재귀 바인딩을 비 재귀로 만들 수 있지만 Core에서는 그렇게하지 않으며 문제를 난독 화하기 때문에 여기서는 그렇게하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">&lt;code&gt;compactFixupPointers#&lt;/code&gt; 가 호출 될 때까지 결과 블록은 GC에 알려지지 않으며 주소가 이탈되지 않거나 메모리가 누출되지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 코드 및 가능한 실패는 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 경우와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 코드 및 가능한 실패는 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 경우와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="29be3c2210c3b04c22ea1f09a769d96cd67a12c6" translate="yes" xml:space="preserve">
          <source>The return type of the data constructor (&lt;code&gt;&amp;lt;...&amp;gt; T a b -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;). By virtue of this being a Haskell98-style declaration, the order of type variables in the return type will always coincide with the order in which they are quantified.</source>
          <target state="translated">데이터 생성자의 반환 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; T a b -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ). 이것이 Haskell98 스타일 선언이기 때문에 반환 유형의 유형 변수 순서는 항상 수량화되는 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">반환 값은 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; ( &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; 이어야 하지만 Haskell의 타입 시스템은 이것을 어렵게합니다).</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 리턴 값은 가비지 콜렉터 실행시기에 따라 달라 지므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 리턴 값은 가비지 콜렉터 실행시기에 따라 달라 지므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">그 반대의 경우도 반드시 그런 것은 아닙니다. 두 개의 안정된 이름이 같지 않으면 이름이 지정된 개체가 여전히 동일 할 수 있습니다. 특히 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 은 객체가 평가 된 후 다른 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">그 반대의 경우도 반드시 그런 것은 아닙니다. 두 개의 안정된 이름이 같지 않으면 이름이 지정된 개체가 여전히 동일 할 수 있습니다. 특히 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 은 객체가 평가 된 후 다른 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">다시 쓰기는 &lt;code&gt;Control.Exception.assert&lt;/code&gt; 의 응용 프로그램을 발견 할 때만 컴파일러에 의해 수행 되므로 원하는 경우 자신의 고유 버전의 &lt;code&gt;assert&lt;/code&gt; 를 정의하고 사용할 수 있습니다 . 그렇지 않은 경우 &lt;code&gt;Control.Exception&lt;/code&gt; 을 가져와 코드에서 &lt;code&gt;assert&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">레코드 업데이트 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">경험의 규칙은 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 사용 하여 게으른 값에서 예외를 강제로 처리하거나 처리하는 것입니다. 반면에 효율성상의 이유로 만 게으른 값을 강요하고 예외에 신경 쓰지 않으면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">경험의 규칙은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 사용 하여 게으른 값에서 예외를 강제로 처리하거나 처리하는 것입니다. 반면에 효율성상의 이유로 만 게으른 값을 강요하고 예외에 신경 쓰지 않으면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">내보내기 목록 규칙 (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;섹션 5.2&lt;/a&gt; )은 유형 패밀리에 대한 조정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="798cfdb395c403ae103a26777b2df7c204f7f552" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;https://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) need adjustment for type families:</source>
          <target state="translated">수출 목록에 대한 규칙 (Haskell 보고서 &lt;a href=&quot;https://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;섹션 5.2&lt;/a&gt; )은 유형 군에 대한 조정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">어휘 범위 유형 변수에 대한 규칙 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 범위 유형 변수&lt;/a&gt; 참조 )은 패턴 동의어 서명에 적용됩니다. 이러한 규칙에서 명시한 바와 같이 , 패턴 동의어의 정의에 대해 명시적이고 구문 적으로 볼 수있는 외부 &lt;code&gt;forall&lt;/code&gt; (범용) 범위 의 유형 변수 만 ; 내면에 묶여있는 실재는 그렇지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aac6743a839a2635c600ff4724f24ebab991dfb5" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">어휘 범위 유형 변수에 대한 규칙 ( &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;어휘 범위 유형 변수&lt;/a&gt; 참조 )은 패턴 동의어 시그니처에 적용됩니다. 이러한 규칙이 지정하는대로 패턴 동의어 정의에 대한 명시적이고 구문 적으로 볼 수있는 외부 &lt;code&gt;forall&lt;/code&gt; (유니버설) 범위 의 유형 변수 만 ; 내면에 묶여있는 실존주의는 그렇지 않습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="b99c4ffb314648f355d9f28d0c2cc30bab28737d" translate="yes" xml:space="preserve">
          <source>The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; 제약 조건 을 해결하기위한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">'Typeable'제약 조건을 해결하기위한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ( 예 : 산술 시퀀스를 다루는 Haskell 보고서 섹션 참조) 와 같은 경계 유형을 통해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스 를 유지하는 규칙은 여기에 정의 된 다양한 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형을 통해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 와 같은 경계 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스 를 유지하는 규칙 (산술 시퀀스를 처리하는 Haskell 보고서 섹션 참조)도 여기에 정의 된 다양한 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 유형 에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="20727f6b2cc15acd07a14915b1949b34a30873b7" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;exts/ffi#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">런타임은 &lt;code&gt;-N&lt;/code&gt; 옵션에 의해 결정되는 수를 &lt;em&gt;능력&lt;/em&gt; 이라고 부르는 가상 프로세서 세트를 관리합니다 . 각 기능은 한 번에 하나의 Haskell 스레드를 실행할 수 있으므로 기능의 수는 물리적으로 병렬로 실행할 수있는 Haskell 스레드의 수와 같습니다. 기능은 하나 이상의 OS 스레드에 의해 애니메이션됩니다. 런타임은 각 기능에 대한 OS 스레드 풀을 관리하므로 Haskell 스레드가 외부 호출 ( &lt;a href=&quot;exts/ffi#ffi-threads&quot;&gt;멀티 스레딩 및 FFI 참조&lt;/a&gt; )을 수행하면 다른 OS 스레드가 해당 기능을 인수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">런타임은 &lt;em&gt;기능&lt;/em&gt; 이라고하는 가상 프로세서 세트를 관리하며 , 그 수는 &lt;code&gt;-N&lt;/code&gt; 옵션에 의해 결정됩니다 . 각 기능은 한 번에 하나의 Haskell 스레드를 실행할 수 있으므로 기능의 수는 물리적으로 병렬로 실행할 수있는 Haskell 스레드의 수와 같습니다. 기능은 하나 이상의 OS 스레드에 의해 애니메이션됩니다. 런타임은 각 기능에 대한 OS 스레드 풀을 관리하므로 Haskell 스레드가 외부 호출을 수행하는 경우 ( &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;멀티 스레딩 및 FFI 참조&lt;/a&gt; ) 다른 OS 스레드가 해당 기능을 대신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">런타임은 사용 가능한 작업자 OS 스레드를 사용하여 Haskell 스레드를 실행합니다. 특정 Haskell 스레드를 실행하는 데 사용되는 특정 OS 스레드를 제어해야하는 경우 OS 스레드 로컬 상태를 사용하는 외부 라이브러리를 호출해야하므로 바운드 스레드가 필요합니다 ( &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">동일한 &lt;code&gt;-v2&lt;/code&gt; 또한 각 컴파일 단계의 전체 명령 줄 (적절한 경우)은 또한 인쇄 된 것을 제외.</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">동일한 &lt;code&gt;-v3&lt;/code&gt; 각 컴파일 단계 후 중간 프로그램 표현은 또한 인쇄 된 것을 제외하고는 (전처리 및 C / 어셈블리 파일 제외).</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 와 동일 하지만 비 IO 계산 용입니다. 비 IO 유형의 Haskell 함수를 내보내는 데 사용되는 경우에는 &lt;code&gt;foreign export&lt;/code&gt; 및 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 를 포장 하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">같은 &lt;code&gt;register&lt;/code&gt; , 같은 이름의 패키지가 이미 설치되어있는 경우,이 새로운 하나에 의해 대체되는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">일반 Haskell 쌍과 동일하지만</target>
        </trans-unit>
        <trans-unit id="72a1fc3ae8641ac86c68b367076d1f341252f25f" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;rdquo;오류 와 동일한 동작 으로 기본적으로 컴파일이 종료됩니다. &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 이러한 오류를 연기 할 수 있습니다 . 이 플래그는 범위를 벗어난 변수에 의해 생성 된 오류를 런타임까지 연기하고 컴파일 타임 경고로 변환합니다. 이러한 경고는 &lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; 에&lt;/a&gt; 의해 완전히 억제 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;Variable out of scope&lt;/code&gt; &quot;오류 와 동일한 동작 이 기본적으로 컴파일을 종료합니다. &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 이러한 오류를 지연시킬 수 있습니다 . 이 플래그는 런타임까지 범위를 벗어난 변수에 의해 생성 된 오류를 지연시키고 컴파일 타임 경고로 변환합니다. 이러한 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 의해 완전히 억제 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">GHC가 여전히 배치 모드에 있기 때문에 소스에서 모듈을 컴파일하더라도 동일한 플래그가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">동일한 functor이지만 요소를 역순으로 처리하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da41682db6dc3bc462b3f80ca76ddaa5753e53c9" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 요소를 역순으로 처리하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d91297b7e2709522fcdafa0ad0f96001825d2c" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 요소를 역순으로 처리하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">동일한 functor이지만 반대 순서로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aaeaba67e253d52c7d36c2433b481fa76e2e2f2" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be87e89bbaedfbad2722adb37e85a35d656f391" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">동일한 정보가 여기에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9836bb2774b4fe28e93611c450bce02c5621a1e" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; 에&lt;/a&gt; 대해 동일한 단계 번호 지정 제어를 사용할 수 있습니다 ( &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="11ccaaa6255f0ab48c624aeaae5190abd7b58ce2" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; 에&lt;/a&gt; 대해 동일한 단계 번호 지정 제어를 사용할 수 있습니다 ( &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 에 대해 동일한 위상 번호 매기기 제어를 사용할 수 있습니다 ( &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">동일한 정제 된 의존성 분석을 통해 상호 재귀 함수의 타입 시그니처는 서로 다른 컨텍스트를 가질 수 있으며, 이는 Haskell 98 (4.5.2 절 마지막 문장)에서 불법입니다. GHC는 &lt;em&gt;정제 된&lt;/em&gt; 그룹의 유형 서명이 동일한 유형 서명을 가지고 있다고 주장한다 . 실제로 이것은 동일한 패턴 바인딩으로 바인딩 된 변수 만 동일한 컨텍스트를 가져야한다는 것을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">&lt;code&gt;deriving&lt;/code&gt; 절에 의해 생성 된 인스턴스에도 동일한 제한이 적용됩니다 . 따라서 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">이 시나리오 는 완전한 &lt;a href=&quot;#using-own-main&quot;&gt;main&lt;/a&gt; 프로그램을 연결하는 것이 아니라 C 라이브러리를 배포하는 것과 같은 방식으로 배포 할 수있는 Haskell 코드에서 라이브러리를 만드는 것을 제외하고는 자신의 main () 사용 과 매우 유사 합니다. 암호.</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">검색 경로에는 기본적으로 단일 디렉토리가 포함됩니다.&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;(즉, 현재 디렉토리). 검색 경로의 내용을 추가하거나 변경하는 데 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">소스 파일을 찾기위한 검색 경로는 다음과 같이 GHCi 명령 행 에서 &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">두 번째 인수는 일반적으로 응용 프로그램의 이름입니다. 경로에 통합되므로 유효한 경로 문자로 구성되어야합니다. 참고 : 두 번째 인수가 절대 경로 인 경우 두 번째 인수 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="465ae4467d1e0d963f25eb41be201215387efce5" translate="yes" xml:space="preserve">
          <source>The second argument of both is an initial accumulator value &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;b&lt;/code&gt;. This is the result of the fold when the structure is empty. When the structure is non-empty, this is the accumulator value merged with the first element in left-associative folds, or with the last element in right-associative folds.</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;b&lt;/code&gt; 유형 의 초기 누산기 값 &lt;code&gt;z&lt;/code&gt; 입니다 . 구조가 비어있을 때 접힌 결과입니다. 구조가 비어 있지 않은 경우 왼쪽 연관 접기의 첫 번째 요소 또는 오른쪽 연관 접기의 마지막 요소와 병합 된 누산기 값입니다.</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">두 번째 조항은 조금 더 흥미 롭습니다. 오른쪽이 겹치는 영역에서 일치하면 두 개의 겹치는 유형 패밀리 인스턴스가 허용됩니다. 몇 가지 예가 여기에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 번째 생성자는 두 개의 필드로 구성됩니다. 각각은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; (Tree a) 로 표시되는 &lt;code&gt;Tree a&lt;/code&gt; 유형의 재귀 필드입니다 . 개별 필드의 표현은 이진 형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 를 사용하여 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 수행하는 두 번째로 가장 일반적인 단계 는 경계 프리미티브를 사용하여 버퍼를 채우는 것입니다. 이는 다음과 같이 작동합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 체크 경계 원시적을 실행하기 위해 왼쪽에 충분한 공간이 있는지. 있는 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 바운딩 된 기본 요소를 실행 하고 업데이트 된 버퍼로 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 호출합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 드라이버에 새 버퍼가 필요하다는 신호를 보냅니다. 이 버퍼는 최소한 프리미티브의 경계보다 커야합니다. 우리는 연속의 버퍼없는 검사 융합 버퍼가없는 검사의 수를 줄이기 위해 제한된 프리미티브를 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에스. 또한 우리는 먼저 충분한 공간이 남아 있는지 확인한 다음 주어진 값을 인코딩하는 방법을 결정함으로써 버퍼가 가득 찼음을 알리는 제어 흐름을 단순화하기 위해 경계 프리미티브를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">유형이 유형 매개 변수와 다르지만 유형 매개 변수를 포함하는 두 번째 경우는 놀랍도록 까다로울 수 있습니다. 예를 들어 다음 예제는 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="099d78988af4538ef3d0e0fda8df1e66f037475f" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;../ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">두 번째 옵션은 &lt;a href=&quot;../ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터를 실행하는 &lt;/a&gt;&lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 플래그를 추가하는 것입니다 ( 별도의 프로세스에서 인터프리터 실행 참조 ). 여기서 프로파일 링 된 코드를 직접로드하고 실행할 수 있습니다. 코드를 두 번 컴파일 할 필요가 없습니다. &lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 만 추가 하면 됩니다. (이 옵션은 GHC 8.0.x에서 실험적이지만 향후 릴리스에서는 기본값이 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">두 번째 옵션은 &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 플래그 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 )를 추가하는 것으로, 별도의 프로세스 에서 인터프리터를 실행하여 프로파일 된 코드를 직접로드하고 실행할 수 있습니다. 코드를 두 번 컴파일 할 필요가 없으며 &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 를&lt;/a&gt; 추가 하면 작동합니다. (이 옵션은 GHC 8.0.x에서 실험 중이지만 이후 릴리스에서는 기본값이 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">파일의 두 번째 부분은 프로그램에서 가장 많은 비용이 드는 기능을 코스트 센터별로 분류 한 것입니다. 이 경우, 프로그램에는 하나의 중요한 기능, 즉 &lt;code&gt;fib&lt;/code&gt; 만 있었고 프로그램 의 시간 및 할당 비용의 100 %를 담당했습니다.</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">이 매뉴얼의 종류 다형성에 대한 섹션에서는 유형 및 클래스 선언 &lt;a href=&quot;#inferring-variable-order&quot;&gt;의 변수&lt;/a&gt; 가 정렬되는 방식에 대해 설명합니다 ( 유형 / 클래스 선언에서 변수의 순서 유추 ).</target>
        </trans-unit>
        <trans-unit id="88af4d73b1b9951184f204460f7dd5ff35f03022" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;poly_kinds#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">이 매뉴얼의 종류 다형성에 대한 섹션에서는 유형 및 클래스 선언 &lt;a href=&quot;poly_kinds#inferring-variable-order&quot;&gt;의 변수&lt;/a&gt; 가 정렬되는 방식을 설명합니다 ( 유형 / 클래스 선언에서 변수의 순서 추론 ).</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">환경에 적용 할 선택기 기능.</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">선택기의 엄격 주석 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">선택기의 압축 해제 주석 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">이 경우 시맨틱은 필수 엔티티 세트가 익스포트에 의해 독점적으로 정의된다는 것입니다. 내보내기 목록에 엔티티가 언급되지 않은 경우 필요하지 않습니다. 이 기능의 동기는 라이브러리 작성자가 누군가가 사용하고자하는 모든 기능의 유형을 포함하는 옴니버스 서명을 제공 할 수 있도록하는 것이며, 클라이언트는 실제로 필요한 기능으로 내보내기를 줄입니다. 예를 들어, 문자열에 대한 서명을 상속했다고 가정하면이 양식의 로컬 서명을 작성하여 필요한 엔티티 만 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692c1727fec760be3045c78464d8f7cd5b5023ee" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;do&lt;/code&gt; notation statements with &lt;code&gt;-XQualifiedDo&lt;/code&gt; is as follows:</source>
          <target state="translated">&lt;code&gt;-XQualifiedDo&lt;/code&gt; 를 사용 하는 &lt;code&gt;do&lt;/code&gt; 표기법 문의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; 의 의미 는 매우 간단합니다. GHC가 &lt;code&gt;rec&lt;/code&gt; 그룹을 찾을 때마다 바운드 변수 세트를 계산하고 &lt;code&gt;MonadFix&lt;/code&gt; 클래스에 속하는 기본 monadic value-recursion 연산자 &lt;code&gt;mfix&lt;/code&gt; 에 대한 적절한 호출을 도입합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell 패턴 일치의 의미 는 Haskell 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2 절에&lt;/a&gt; 설명되어 있습니다. 이 설명에 다음과 같이 추가 항목 10을 하나 더 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e60ab62bfd1aaf8462ce242eca667d79c6a73ddd" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell 패턴 매칭의 의미 는 Haskell Report의 &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;섹션 3.17.2&lt;/a&gt; 에 설명되어 있습니다. 이 설명에 하나의 추가 항목 10을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">패턴의 의미 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">서버 측 템플릿 Haskell 상태입니다. 이것은 StartTH 메시지에 의해 생성됩니다. GHC 타입 점검 모듈마다 새로운 것이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">정적 포인터 테이블에서 정적 포인터를 찾는 데 사용되는 키 세트는 다른 프로그램 바이너리에 대해 안정적으로 유지되는 것은 아닙니다. 즉, 동일한 프로그램 바이너리에서 시작된 프로세스 만 동일한 키 세트를 사용하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">알려진 인코딩 세트는 시스템에 따라 다르지만 최소한 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프롬프트에서 현재 &lt;em&gt;범위&lt;/em&gt; 에있는 모듈 세트 . 이 세트는 &lt;code&gt;import&lt;/code&gt; 및 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 로 수정되며 위에서 설명한대로 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 후에 자동으로 수정됩니다 . 범위 내의 모듈 세트는 &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; 로 표시&lt;/a&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;em&gt;로드 된&lt;/em&gt; 모듈 세트 . 이 세트는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 에&lt;/a&gt; 의해 수정되며 &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt; 과 함께 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">서명은 패턴 바인딩이 아닌 함수 바인딩 또는 베어 변수 바인딩의 유형을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a04023d825a1ad52cd3401b482121c628912e060" translate="yes" xml:space="preserve">
          <source>The simplest (degenerate case) of these is &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;, which determines whether a structure is empty or not. This only needs to look at the first element, and only to the extent of whether it exists or not, and not its value. In this case termination is guaranteed, and infinite input structures are fine. Its default definition is of course in terms of the lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이들 중 가장 단순한 (퇴화되는 경우) 는 구조가 비어 있는지 여부를 결정하는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 입니다. 이것은 첫 번째 요소 만 볼 필요가 있으며 그 값이 아닌 존재 여부의 범위까지만 볼 필요가 있습니다. 이 경우 종료가 보장되고 무한 입력 구조가 좋습니다. 물론 기본 정의는 lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 측면에서입니다 .</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 디코더 를 실행하는 가장 간단한 인터페이스 입니다. 디코더가 오류가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하거나 호출이 실패 하거나 입력이 부족하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="0e8c225c01f9faa3800585856cd9e7639c83f852" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 디코더 를 실행하는 가장 간단한 인터페이스 입니다. 디코더에 오류가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하거나 호출이 실패 하거나 입력이 부족하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="55de2210f5c6297aafeb6304d32b194dcb4402c4" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 디코더 를 실행하는 가장 간단한 인터페이스 입니다. 디코더에 오류가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하거나 호출이 실패 하거나 입력이 부족하면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15de436f5ad58966f3fd02d798c87b26a0a4d2de" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4392c709b8ab747754f57b03eb8f62ce294291b7" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 시퀀스의 동작이 정의되지 않습니다. 대부분의 응용 프로그램에서는 이러한 상황이 발생하지는 않지만 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 때 특히 반복적으로, 특히 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 과 함께 사용하면 약간의주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9c06af16b62ace31432f475d864e0e1ea766afc" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 시퀀스 동작이 정의되지 않습니다. 이는 대부분의 응용 프로그램에서 발생하지 않을 수 있지만 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , 특히 반복적으로 특히 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 과 함께 사용하는 경우에는주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8952fffc2c0bb8a184fb20f942742b2fb8968330" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 시퀀스의 동작이 정의되지 않습니다. 이는 대부분의 응용 프로그램에서 발생하지 않을 수 있지만 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , 특히 반복적으로 특히 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 과 함께 사용할 때는주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과의 크기가 더 작아 질 수 있습니다 . 이 경우 관련 값은 &lt;code&gt;c&lt;/code&gt; 를 사용하여 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과의 크기가 더 작아 질 수 있습니다 . 이 경우 관련 값은 &lt;code&gt;c&lt;/code&gt; 를 사용하여 결합됩니다 . 두 개의 원래 키보다 큰 값이 &lt;code&gt;c&lt;/code&gt; 의 첫 번째 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과 크기가 더 작아 질 수 있습니다 . 이 경우 원래 키 중 가장 큰 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 바이트 순서의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">세트의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">경계 쌍으로 정의 된 하위 범위의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정립 중요한 데이터 유형, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">당신이 가지고 갈 수있는 망치는 &lt;code&gt;INLINE&lt;/code&gt; 프라 그마입니다.</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">해결책은 인스턴스 별 함수를 직접 정의하여 pragma를 사용하여 너무 빨리 인라인되는 것을 방지하고 규칙을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">프로그램의 소스 파일이 모두 같은 디렉토리에있을 필요는 없습니다. &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션은 검색 경로 (참조에 디렉토리를 추가하는 데 사용할 수있는 &lt;a href=&quot;separate_compilation#search-path&quot;&gt;검색 경로를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">소스 위치</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">특수 &lt;code&gt;family&lt;/code&gt; 은 표준 데이터 선언과 제품군을 구분합니다. 결과 종류 주석은 선택 사항이며 일반적으로 생략하면 기본값은 &lt;code&gt;Type&lt;/code&gt; 입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">특수 &lt;code&gt;family&lt;/code&gt; 는 패밀리를 표준 유형 선언과 구별합니다. 결과 종류 주석은 선택 사항이며 일반적으로 생략하면 기본값은 &lt;code&gt;Type&lt;/code&gt; 입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">특별 패키지 이름 &lt;code&gt;this&lt;/code&gt; 현재 패키지를 참조하는 데 사용할 수있는 내장된다.</target>
        </trans-unit>
        <trans-unit id="2e75e752908ac1f2d1d245f44b5bc23796ac7067" translate="yes" xml:space="preserve">
          <source>The specialisation of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; to the case when &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; is a monad is called &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt;. The two are otherwise generally identical:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt; 가 모나드 인 경우에 대한 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 의 특수화를 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 이라고 합니다. 그렇지 않으면 두 가지가 일반적으로 동일합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">사양은 형식 문자로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">지정된 파일은 C 프로그램, 컴파일 된 Haskell 파일 및 C 헤더에 포함됩니다. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; 가 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">대한 지정자 &lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; 및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 는 다른 유형의 의미 별개입니다. 음의 시간 차이에 대한 지정자는 일반적으로 음수입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 보다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 을 생각하십시오 ).</target>
        </trans-unit>
        <trans-unit id="509d7b73e79bd7157914844fa1c9246fd5e8d212" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; 및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 의 지정 자는 다른 유형과 의미 상 구분됩니다. 음의 시간차에 대한 지정자는 일반적으로 음수입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 보다는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 을 생각하십시오 ).</target>
        </trans-unit>
        <trans-unit id="632d00023758f8684f4fce4f4f22a0178b84409a" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; 및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 에 대한 지정 자는 다른 유형과 의미 상 구분됩니다. 음의 시간 차이에 대한 지정자는 일반적으로 음수입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 보다는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 을 생각하십시오 ).</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(blah1)&lt;/code&gt; 함수를 참조 할 수 &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; 나중에 선언 그룹의 일부, 따라서 보이지 마찬가지로 인 &lt;code&gt;$(blah1)&lt;/code&gt; 의 정의를 참조 할 수없는 &lt;code&gt;h&lt;/code&gt; 그와 같은 선언 그룹의 일부이기 때문에 ( &lt;code&gt;$(blah1)&lt;/code&gt; . 그러나, 스플 라이스 &lt;code&gt;$(blah1)&lt;/code&gt; 정의 볼 수 &lt;code&gt;f&lt;/code&gt; (그 직전의 선언 기이기 때문에).</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(blah2)&lt;/code&gt; 는 스플 라이스 &lt;code&gt;$(th2 ...)&lt;/code&gt; 와 동일한 정의를 볼 수 있습니다 (그러나 바인딩은 생성 &lt;em&gt;하지 않습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">splice &lt;code&gt;$(th1 ...)&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 정의를 볼 수 있습니다. splice는 최상위 수준이므로 이전 선언 그룹의 모든 정의가 표시됩니다 (즉, 모듈의 모든 정의는 포함하지만 다음을 포함하지는 않음). 스플 라이스 자체).</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;D&lt;/code&gt; 를 참조 &lt;em&gt;할 수 없습니다&lt;/em&gt; -동일한 선언 그룹에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">splice &lt;code&gt;$(th2 ...)&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 정의 , &lt;code&gt;$(th1 ...)&lt;/code&gt; 에 의해 생성 된 모든 바인딩 , &lt;code&gt;h&lt;/code&gt; 의 정의 및 &lt;code&gt;[qq|blah|]&lt;/code&gt; 의해 생성 된 모든 바인딩 ( 이것은 모두 이전에 있습니다) 선언 그룹).</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">실행할 스플 라이스</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">스택은 기본적으로 힙 프로필에서 계산되지 않습니다. RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">스택 추적은 종종 &lt;code&gt;GHC.List.CAF&lt;/code&gt; 와 같은 정보가없는 것으로 시작될 수 있습니다 . 이것은 GHC 옵티마이 저의 인공물로, 프로파일 링 시스템이 비용 센터 &quot;CAF&quot;에 할당하는 최상위 수준으로 예외를 발생시킵니다. 그러나 &lt;code&gt;+RTS -xc&lt;/code&gt; 는 현재 스택 만 인쇄하는 것이 아니라 CAF가 평가 될 때 스택을 더 깊게보고보고하며 CAF가 아닌 스택이 발견 될 때까지 추가 스택을보고 할 수 있습니다. 위의 예에서 다음 스택 ( &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 후 )에는 프로그램이 &lt;code&gt;head []&lt;/code&gt; 를 평가할 때 수행 한 작업에 대한 많은 정보가 들어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">스택 오버플로 메시지</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">독립형 구문은 일반 &lt;code&gt;deriving&lt;/code&gt; 절이 일반화 되는 것과 정확히 동일한 방식으로 새 유형에 대해 일반화됩니다 (newtypes에 대한 &lt;a href=&quot;#newtype-deriving&quot;&gt;일반화 된 파생 인스턴스&lt;/a&gt; ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d40910594259296d4a228872f612655d7bafcd0a" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">독립형 구문은 일반 &lt;code&gt;deriving&lt;/code&gt; 절이 일반화 되는 것과 똑같은 방식으로 newtypes에 대해 일반화됩니다 (newtypes에 대한 &lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;일반화 된 파생 인스턴스&lt;/a&gt; ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6e89f770c17d80516fb68856c8f92154e2b891fa" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;../separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">독립형 파생 선언은 데이터 유형 선언과 동일한 모듈에있을 필요가 없습니다. (그러나 고아 인스턴스 ( &lt;a href=&quot;../separate_compilation#orphan-modules&quot;&gt;고아 모듈 및 인스턴스 선언&lt;/a&gt; ) 의 위험성에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">독립형 파생 선언은 데이터 유형 선언과 동일한 모듈에있을 필요는 없습니다. (그러나 고아 인스턴스 ( &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan 모듈 및 인스턴스 선언&lt;/a&gt; ) 의 위험에주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="704c3d94002789a8f5e8c50c778edbf18c8986c7" translate="yes" xml:space="preserve">
          <source>The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">독립형 종류 서명은 &lt;code&gt;T&lt;/code&gt; 에 대한 다형성 종류를 지정하며이 서명은 재귀 적 종류를 포함하여 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 호출에 사용 됩니다. 특히,의 재귀 사용 &lt;code&gt;T&lt;/code&gt; 는 종류에있다 &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db11743c6607fc01898eb1dded2916b4eb86f339" translate="yes" xml:space="preserve">
          <source>The standard C wndproc for every window class registered by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:registerClass&quot;&gt;registerClass&lt;/a&gt;&lt;/code&gt; is a C function pointer provided with this library. It in turn delegates to a Haskell function pointer stored in &lt;code&gt;gWLP_USERDATA&lt;/code&gt;. This action creates that function pointer. All Haskell function pointers must be freed in order to allow the objects they close over to be garbage collected. Consequently, if you are replacing a window closure previously set via this method or indirectly with &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindow&quot;&gt;createWindow&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; you must free it. This action returns a function pointer to the old window closure for you to free. The current window closure is freed automatically by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; when it receives &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">registerClass에 의해 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:registerClass&quot;&gt;registerClass&lt;/a&gt;&lt;/code&gt; 된 모든 윈도우 클래스에 대한 표준 C wndproc 는이 라이브러리와 함께 제공되는 C 함수 포인터입니다. 차례로 &lt;code&gt;gWLP_USERDATA&lt;/code&gt; 에 저장된 Haskell 함수 포인터에 위임합니다 . 이 작업은 해당 함수 포인터를 만듭니다. 모든 Haskell 함수 포인터는 그들이 닫은 객체가 가비지 수집되도록 허용하기 위해 해제되어야합니다. &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindow&quot;&gt;createWindow&lt;/a&gt;&lt;/code&gt; 메소드를 통해 이전에 설정 한 창 닫기를 대체하거나 간접적으로 createWindow 또는 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; 로 대체하는 경우 이를 해제해야합니다. 이 작업은 해제 할 수 있도록 이전 창 닫기에 대한 함수 포인터를 반환합니다. 현재 창 닫기는 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; 수신시 &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; 의해 자동으로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">표준 C99 &lt;code&gt;fenv.h&lt;/code&gt; 헤더는 부동 소수점 장치의 상태를 검사하고 수정하는 작업을 제공합니다. 특히 부동 소수점 연산에 사용되는 반올림 모드를 변경하고 예외 플래그를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">표준 CPUTime 라이브러리.</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">표준 IO 라이브러리</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS X에 대한 표준 가정은 동적 라이브러리가 빌드시 라이브러리 파일의 전체 설치 경로 인&amp;ldquo;설치 이름&amp;rdquo;으로 스탬핑된다는 것입니다. 이후에 링크 된 라이브러리 또는 실행 파일 (아직 설치되지 않은 경우에도)은 해당 경로를 런타임 검색 위치로 선택합니다. ghc로 직접 컴파일 할 때 설치 이름은 기본적으로 빌드 위치로 설정됩니다. &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; 옵션 ( &lt;code&gt;-install_name&lt;/code&gt; 을 Apple 링커로 전달)으로이를 대체 할 수 있습니다 . Cabal이 당신을 위해 이것을합니다. 동적 라이브러리의 설치 이름을 최종 설치 위치의 절대 경로로 자동 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">표준 기본 규칙은 다음과 같이 확장됩니다. 해결되지 않은 모든 제약 조건에 표준 클래스 &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 이 포함 된 경우 기본값이 적용됩니다 . 적어도 하나는 숫자 클래스 &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">표준 함수 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; 은 안정 포인터 테이블을 잠그고 주어진 안정 포인터를 해제 한 다음 안정 포인터 테이블을 다시 잠금 해제합니다. 많은 안정적인 포인터를 한 번에 해제 할 때 일반적으로 테이블을 한 번만 잠 그거나 잠금 해제하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">텍스트 인코딩 및 디코딩을위한 표준 기능은 엄격합니다. 즉, 유효하지 않은 입력에서 예외를 발생시킵니다. 이것은 실제 입력에서 도움이되지 않기 때문에 유효하지 않은 입력을 처리하기 위해 사용자 정의 핸들러를 허용하는 대체 함수가 존재합니다. 이 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; 핸들러는 일반적인 Haskell 함수입니다. 이 모듈에서 사전 제공 함수 중 하나를 사용하거나 사용자 정의 핸들러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; 와 함께 사용되는 표준 관용구 는 연속을 명명하는 람다 표현을 제공하는 것입니다. 그런 다음 중첩 된 계산 내에 많은 계층이 있어도 해당 범위 내에서 명명 된 연속을 호출하면 계산에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">표준 라이브러리는이 장치 유형을 직접 지원하지 않지만 사용자 구현 에서는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 를 제외하고 &lt;code&gt;'\0'&lt;/code&gt; 문자로 구분 된 순서로 디렉토리에 파일 이름 목록을 제공해야합니다 . 및 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 이름. &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 . 검색 작업은 디렉토리에서 지원되지 않습니다 (0 위치 이외).</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수를 설정하여 일부 시스템에서 재정의 할 수있는 시스템 로더의 표준 라이브러리 검색 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">실행 스택의 상태</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">명령문 &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; 는 &quot; &lt;code&gt;IO&lt;/code&gt; 모나드 에서 실행 &lt;code&gt;return 42&lt;/code&gt; 를 실행 하고 결과를 &lt;code&gt;x&lt;/code&gt; 에 바인딩합니다 &quot;를 의미합니다. 그런 다음 &lt;code&gt;x&lt;/code&gt; 를 사용 하여 예를 들어 위에서와 같이 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">명령문이 바인딩이 아니거나 정확히 하나의 변수를 바인딩 하는 모나드 바인딩 ( &lt;code&gt;p &amp;lt;- e&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">저장된 값은 느리게 계산 될 큰 가상 데이터 구조를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">예외가 발생한 지점에서 처리 된 지점으로 바인딩 된 함수를 무시하여 예외를 throw 할 수있는 계산을 결합하는 전략입니다.</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 모나드 변환기는 주어진 모나드에 출력 (카운트 또는 문자열 출력과 같은) 컬렉션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 모나드 변환기는 주어진 모나드에 출력 (카운트 또는 문자열 출력과 같은) 컬렉션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9cc9078a7f0ba79c4a62093f3f0a698571e804e5" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;` is the least likely to be useful, structures that support efficient sequencing &lt;em&gt;only&lt;/em&gt; right-to-left are not at all common.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; `는 유용하지 않을 가능성이 가장 낮으며 오른쪽에서 왼쪽으로 &lt;em&gt;만&lt;/em&gt; 효율적인 순서를 지원하는 구조 는 전혀 일반적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형을 사용하려면 전체 문자열이 한 번에 메모리에 맞아야합니다. 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 작은 메모리 공간을 사용하여 메모리보다 큰 문자열을 스트리밍 할 수 있습니다. 대부분의 경우 청크 스트리밍의 오버 헤드로 인해 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형이 엄격한 대응 유형보다 느리지 만 항상 그런 것은 아닙니다. 때로는 하나의 모듈에서 함수의 시간 복잡도는 내부 구조가 다르기 때문에 다른 모듈과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">엄격 성 분석기는 함수의 인수와 변수를 '엄격하게'처리 할 수있는 시점을 파악합니다 (즉, 함수에서 항상 특정 시점에서 평가됨). 이를 통해 GHC는 지연 인수에 적용될 때 프로그램의 의미를 변경함에 따라 적용되지 않는 언 박싱과 같은 특정 최적화를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">사용자가 필드를 소스 코드로 작성했을 때의 엄격함. 예를 들어 다음 데이터 형식에서</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">GHC가 컴파일하는 동안 필드를 유추하는 엄격 성. &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 의 9 가지 조합이 있지만 GHC가 결정하는 엄격 성은 궁극적으로 게 으르거나 엄격하거나 압축되지 않은 것 중 하나입니다. GHC가 결정하는 것은 사용자가 소스 코드에 작성하는 내용과 GHC 플래그의 영향을받습니다. 예를 들어,이 데이터 유형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">컴파일러가 선택기에 대해 유추 한 엄격 성</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">이 모듈의 문자열 기능은 화살표 키 및 기능 키와 같은 사용자 입력에 해당하는 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">패키지 이름 뒤의 괄호 안에있는 문자열은 설치된 패키지 ID입니다. 일반적으로 패키지 이름과 버전으로 시작하고 컴파일 된 패키지에서 파생 된 해시 문자열로 끝납니다. 패키지 간의 종속성은 패키지 및 버전이 아니라 설치된 패키지 ID로 표시됩니다. 예를 들어, &lt;code&gt;haskell98&lt;/code&gt; 패키지 의 종속성을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">유 방향 그래프의 강하게 연결된 구성 요소는 위상 적으로 역순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">유 방향 그래프의 강하게 연결된 구성 요소는 위상 적으로 역순으로 정렬됩니다. 이 함수는 각 노드에 대한 모든 정보가 유지된다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 이 인터페이스는 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 결과에 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 를 적용 할 때 사용 되므로 종속성 정보를 잃고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">역 토폴로지 순서로 그래프의 강력하게 연결된 구성 요소.</target>
        </trans-unit>
        <trans-unit id="83452083a9ce72a229493bf8b77c24809f89e2bb" translate="yes" xml:space="preserve">
          <source>The structure definition actually admits trees that are unbounded on either or both sides. The only fold that can plausibly terminate for a tree unbounded on both left and right is &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;, when defined as shown below. The default definition in terms of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; diverges if the tree is unbounded on the left. Here we define a variant that avoids travelling down the tree to find the left-most element and just examines the root node.</source>
          <target state="translated">구조 정의는 실제로 한쪽 또는 양쪽에서 제한되지 않은 트리를 허용합니다. 왼쪽과 오른쪽 모두에서 제한되지 않은 트리에 대해 그럴듯하게 종료 할 수있는 유일한 폴드는 아래와 같이 정의 될 때 &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 측면의 기본 정의 는 트리가 왼쪽에서 제한되지 않은 경우 달라 집니다. 여기서 우리는 가장 왼쪽의 요소를 찾기 위해 트리 아래로 이동하는 것을 피하고 루트 노드를 검사하는 변형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3e101feb4c7c413d89ff2a9de0dbd05a34c46cb1" translate="yes" xml:space="preserve">
          <source>The subset of type variables quantified by the GADT constructor that are mentioned in the return type. Note that the order of these variables follows the same principles as in &lt;a href=&quot;type_applications#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;. If the constructor explicitly quantifies its type variables at the beginning of the type, then the field selector type will quantify them in the same order (modulo any variables that are dropped due to not being mentioned in the return type). If the constructor implicitly quantifies its type variables, then the field selector type will quantify them in the left-to-right order that they appear in the field itself.</source>
          <target state="translated">반환 유형에 언급 된 GADT 생성자에 의해 수량화 된 유형 변수의 하위 집합입니다. 이러한 변수의 &lt;a href=&quot;type_applications#scopedsort&quot;&gt;순서는 지정된 변수의 순서 지정&lt;/a&gt; 과 동일한 원칙을 따릅니다 . 생성자가 유형의 시작 부분에서 해당 유형 변수를 명시 적으로 수량화하면 필드 선택기 유형은 동일한 순서로 변수를 수량화합니다 (반환 유형에 언급되지 않아 삭제 된 모든 변수를 모듈로). 생성자가 해당 유형 변수를 암시 적으로 수량화하는 경우 필드 선택기 유형은 필드 자체에 나타나는 왼쪽에서 오른쪽 순서로 수량화합니다.</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">&lt;code&gt;n+k&lt;/code&gt; 패턴 에서 빼기 연산과 같거나 큰 검정 은 범위에있는 &lt;code&gt;(-)&lt;/code&gt; 및 &lt;code&gt;(&amp;gt;=)&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">입력이 충분하지 않아서 디코딩 할 수없는 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 접미 부입니다 .</target>
        </trans-unit>
        <trans-unit id="8b56d651e782e4c6fee2c1292b2f284d6d8eec70" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">입력이 부족하여 디코딩 할 수없는 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 접미사입니다 .</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 액션 모음의 합계 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; 을.</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 액션 모음의 합계 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을.</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을 일반화하는 조치 콜렉션의 합계입니다 . 기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을 일반화하는 조치 콜렉션의 합계입니다 . 기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">수퍼 클래스 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">GHC에서 정의한 기호는 다음과 같습니다. 로컬 GHC 설치에 의해 정의 된 기호를 확인하려면 다음 트릭이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 허용되는 구문은 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 대한 구문과 동일합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 허용되는 구문은 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 대한 구문과 동일합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">패턴 동의어의 구문과 의미는 다음 하위 섹션에서 자세히 설명합니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;논문에&lt;/a&gt; 더 많은 세부 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">최소한의 완전한 정의를위한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">prompt &lt;code&gt;*module&lt;/code&gt; 의 구문은 프롬프트 에서 입력 한 표현식의 범위에 기여하는 ⟨module⟩의 전체 최상위 범위임을 나타냅니다. &lt;code&gt;*&lt;/code&gt; 없이 모듈 내보내기 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">문법은</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">구문은 (a) 키워드 &lt;code&gt;deriving&lt;/code&gt; 및 (b) 위치가 없다는 점을 제외하고 일반적인 인스턴스 선언과 동일 합니다 &lt;code&gt;where&lt;/code&gt; 부분 .</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">대안의 본문이 표현식이 아닌 명령이라는 점을 제외하면 구문은 &lt;code&gt;case&lt;/code&gt; 표현식과 동일합니다. 번역은 &lt;code&gt;if&lt;/code&gt; 의 번역과 유사 합니다 명령 합니다.</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">표현식에 대한 코스트 센터 주석의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCi 프롬프트에서 승인 된 명령문의 구문은 Haskell &lt;code&gt;do&lt;/code&gt; 표현식 의 명령문 구문과 정확히 동일 합니다. 그러나 여기에 모나드 과부하가 없습니다. 프롬프트에서 입력 한 명령문은 &lt;code&gt;IO&lt;/code&gt; 에 있어야합니다. 모나드 .</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">값의 구문은 필드에 따라 다릅니다. 다양한 필드 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">아래 표는 각 유형의 패턴 동의어를 사용할 수있는 위치를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해 설명 된 전술합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">템플릿 파일 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">하위 계산이 종료되면 (보통 또는 예외를 통해) 임시 저장소가 해제되므로이 함수가 반환 된 후에 임시 저장소에 대한 포인터를 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">&amp;ldquo;미등록&amp;rdquo;이라는 용어는 실제로&amp;ldquo;바닐라 C를 통한 컴파일&amp;rdquo;을 의미하며, GHC가 일반적으로 프로그램 속도를 높이기 위해 사용하는 플랫폼 별 트릭을 비활성화합니다. 등록되지 않은 컴파일시 GHC는 gcc를 통해 컴파일 된 C 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">용어 레벨 구문은 비슷합니다. 선행 및 선행 막대 ( &lt;code&gt;|&lt;/code&gt; )는 대체 방법을 나타냅니다. 위에 표시된 유형의 두 가지 용어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c93728cc66c8f173dab941c09797eacc6f5110f5" translate="yes" xml:space="preserve">
          <source>The third and final argument is a &lt;code&gt;Foldable&lt;/code&gt; structure containing elements &lt;code&gt;(a, b, c, &amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">세 번째이자 마지막 인수는 요소 &lt;code&gt;(a, b, c, &amp;hellip;)&lt;/code&gt; 포함 하는 &lt;code&gt;Foldable&lt;/code&gt; 구조 입니다.</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">파일의 세 번째이자 마지막 섹션은 비용 중심 스택별로 프로파일 분류를 제공합니다. 이것은 대략 프로그램의 콜 트리 프로파일입니다. 위의 예에서 비용이 많이 드는 &lt;code&gt;fib&lt;/code&gt; 호출 은 &lt;code&gt;main&lt;/code&gt; 에서 온 것이 분명합니다. .</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">세 번째 사례 선언은 적용 조건을 준수하지 않습니다. 실제로 (정말 이상한) 정의 :</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">세 번째 종류의 인스턴스는 모든 &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; 마다 존재 하며 두 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">와일드 카드의 세 번째 종류는 &lt;em&gt;추가 제약 와일드 카드입니다.&lt;/em&gt; 입니다. 추가 제약 조건 와일드 카드가 있으면 형식 검사 중에 임의의 수의 추가 제약 조건이 유추 될 수 있으며 형식 서명에 추가됩니다. 아래 예에서 추가 제약 조건 와일드 카드는 세 가지 추가 제약 조건을 유추하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">스레드가 차단되어 &lt;code&gt;MVar&lt;/code&gt; 만에 다른 참조가없는 &lt;code&gt;MVar&lt;/code&gt; 그 어느 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">스레드가 STM 트랜잭션 재 시도를 기다리고 있지만 관련된 &lt;code&gt;TVar&lt;/code&gt; 에 대한 다른 참조가 없으므로 계속 진행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">외래 호출을하는 스레드는 &lt;code&gt;pthread_kill()&lt;/code&gt; 사용하여 &lt;code&gt;SIGPIPE&lt;/code&gt; 신호를 보냅니다 . 이는 일반적으로 블로킹 시스템 호출이 &lt;code&gt;EINTR&lt;/code&gt; 과 함께 리턴되도록하기에 충분합니다 (기본적으로 GHC는 &lt;code&gt;SIGPIPE&lt;/code&gt; 에 대해 빈 신호 핸들러를 설치 하여 프로세스를 즉시 종료하는 기본 동작을 대체합니다).</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">스레드 런타임 시스템은 다음과 같은 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">프로그램의 특정 부분에 의해 발생 된 시간과 할당은 두 가지 방식으로 표시됩니다 :&amp;ldquo;이 개별&amp;rdquo;,이 코스트 센터 스택만으로 커버되는 코드에 의해 발생 된 비용,&amp;ldquo;상속 된&amp;rdquo;, 모두에 의해 발생 된 비용 포함 이 노드의 아이</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">GC 자체에서 경과 된 시간</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">GC 이전의 동기화 중 경과 된 시간</target>
        </trans-unit>
        <trans-unit id="4b330c6f47b52569d23f62fae825fc0e09a81ec0" translate="yes" xml:space="preserve">
          <source>The time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">이동하지 않는 동시 GC의 포스트 마크 일시 중지 단계 동안 경과 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">시간 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="1637c3729549ceeb82c37601b6dec6b827e71006" translate="yes" xml:space="preserve">
          <source>The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</source>
          <target state="translated">&lt;a href=&quot;profiling#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 로 활성화 된 시간 프로파일 링 모드 도 이벤트 로그에 샘플 이벤트를 내 보냅니다. 프로파일 링이 시작될 때 틱 간격이 이벤트 로그로 내 보내진 다음 각 틱에서 현재 비용 센터 스택이 내보내집니다. 이를 통해 사용자는 프로그램 실행에 대한 대략적인 추적을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">주어진 값을 사용하여 입력을 구문 분석 할 수없는 경우 시간 값 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="806aa42ce85483bc45bf5f50020217f50c8cf737" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">시간 값 또는 주어진 형식을 사용하여 입력을 구문 분석 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eab7f7de4b2ca2df8fd007dac9308197876dafad" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">시간 값 또는 주어진 형식을 사용하여 입력을 구문 분석 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">시간 값.</target>
        </trans-unit>
        <trans-unit id="431cd0d00a93588e67b435b97058b6600e1ca6b4" translate="yes" xml:space="preserve">
          <source>The top of an instance declaration only permits very specific forms of types. To make more precise what forms of types are or are not permitted, we provide a BNF-style grammar for the tops of instance declarations below:</source>
          <target state="translated">인스턴스 선언의 맨 위는 매우 특정한 형식의 형식 만 허용합니다. 허용되거나 허용되지 않는 유형의 형식을보다 정확하게 설명하기 위해 아래의 인스턴스 선언 맨 위에 BNF 스타일의 문법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">전체 실행에서 프로그램이 할당 한 총 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">수행 된 총 가비지 수집 수입니다.</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">프로그램 실행의 총 벽 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO가 실행될 때 트랜잭션에 일관성없는 메모리보기가있을 수 있습니다. 트랜잭션이 구현되는 방식으로 인해 프로그램 전체에서 사실로 예상되는 변형은 트랜잭션 내에서 사실이 아닐 수 있습니다. 일반적으로 이것은 프로그래머에게는 보이지 않지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 를 사용 하면 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO가 실행될 때 트랜잭션에 일관성없는 메모리보기가있을 수 있습니다. 트랜잭션이 구현되는 방식으로 인해 프로그램 전체에서 사실로 예상되는 변형은 트랜잭션 내에서 사실이 아닐 수 있습니다. 일반적으로 이것은 프로그래머에게는 보이지 않지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 를 사용 하면 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">번역은 간단한 비 재귀 바인딩뿐만 아니라 재귀 및 다형성 바인딩에 의미있는 뱅 패턴을 만들기 위해 신중하게 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">이러한 형식의 변환에는 &lt;code&gt;loop&lt;/code&gt; &lt;code&gt;ArrowLoop&lt;/code&gt; 사용 되므로 관련 화살표는 ArrowLoop 클래스에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">모나드를 동등한 모나드에 매핑하는 사소한 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">고아의 문제점은 모듈의 인터페이스가 다른 용도로 사용되는지 여부에 관계없이 GHC가 인스턴스 또는 규칙이 역할을 수행하는 경우를 대비하여 모든 고아 모듈의 인터페이스 파일을 사전에 읽어야한다는 것입니다. 자세한 내용은 &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;고아 모듈 및 인스턴스 선언&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">후자는 유형 변수를 범위로 가져올 수 있다는 점을 제외하고는 두 가지를 동일하게 취급합니다 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 범위 변수 유형&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1156ff53b3f2cd0af552bcc10ee29d6be241cefb" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">후자가 유형 변수를 범위로 가져올 수 있다는 점을 제외하면 두 가지가 동일하게 처리됩니다 ( &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically 범위 유형 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">두 생성자에는 다음과 같은 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">두 함수 &lt;code&gt;comp1&lt;/code&gt; 및 &lt;code&gt;comp2&lt;/code&gt; 동일한 의미를 가지고 있지만, &lt;code&gt;comp1&lt;/code&gt; 적용될 때 인라인한다 &lt;em&gt;두&lt;/em&gt; 인수하면서 &lt;code&gt;comp2&lt;/code&gt; 필요 &lt;em&gt;세&lt;/em&gt; . 당신이 말하면 이것은 큰 차이를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">두 옵션 세트는 다음과 같이 초기화됩니다. 먼저 &lt;a href=&quot;#ghci-dot-files&quot;&gt;.ghci 및 .haskeline 파일에&lt;/a&gt; 설명 된대로 두 옵션 세트가 모두 초기화됩니다 . 그런 다음 대화식 옵션이 다음과 같이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">인수없이 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 두 옵션 세트를 검사 할 수 있습니다 . 예를 들어, 깨끗한 GHCi 세션에서 다음과 같은 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가 될 수있는 값의 종류이다 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수있는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 의, 그리고 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 중 어느 하나가 될 수있는 값의 종류이다 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수있는 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 의, 그리고 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 유형 에는 역할 표현에 매개 변수가 있으며 일반적으로 가장 일반적입니다. &lt;code&gt;Simple Age&lt;/code&gt; 는 &lt;code&gt;Simple Int&lt;/code&gt; 와 동일한 표현을 갖습니다 . 반면 &lt;code&gt;Complex&lt;/code&gt; 유형 은 &lt;code&gt;Complex Age&lt;/code&gt; 및 &lt;code&gt;Complex Int&lt;/code&gt; 가 동일 &lt;em&gt;하지&lt;/em&gt; 있습니다. 마지막으로, &lt;code&gt;Age&lt;/code&gt; 와 &lt;code&gt;Bool&lt;/code&gt; 은 관련이 없지만 &lt;code&gt;Phant Age&lt;/code&gt; 와 &lt;code&gt;Phant Bool&lt;/code&gt; 은 동일한 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">유형 &lt;code&gt;StreamPermParser s st a&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 함수에 의해 변환 될 때 &lt;code&gt;s&lt;/code&gt; 스트림을 사용자 상태 &lt;code&gt;st&lt;/code&gt; 로 구문 분석 하고 성공시 유형 &lt;code&gt;a&lt;/code&gt; 의 값을 리턴하는 순열 구문 분석기를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 종종 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . 그러나 이것이 필수적인 것은 아니며 포인터에 액세스하기위한 고유 한 작업을 제공 할 수 있습니다. 예를 들어 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정하기 위해 작은 외부 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6120b118bdba0e4c010f34fbf9eb9b4980f33ce0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 인 경우가 많습니다 . 그러나 이것은 필수적인 것은 아니며 포인터에 액세스하기위한 자체 작업을 제공 할 수 있습니다. 예를 들어 작은 외부 함수를 작성하여 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccdd21e1ff03d8afd75bec7ff6200ae1990727b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 인 경우가 많습니다 . 그러나 이것은 필수적인 것은 아니며 포인터에 액세스하기위한 자체 작업을 제공 할 수 있습니다. 예를 들어 작은 외부 함수를 작성하여 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 종종 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . 그러나 이것이 필수적인 것은 아니며 포인터에 액세스하기위한 고유 한 작업을 제공 할 수 있습니다. 예를 들어 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정하기 위해 작은 외부 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">타입 &lt;code&gt;t&lt;/code&gt; 는 임의 타입이다.</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">유형 체커는 때때로 오류 메시지에 유형 환경의 단편을 표시하지만이 플래그에 의해 설정된 최대 수까지만 표시됩니다. &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 로 끄면 무제한으로 사용할 수 있습니다. 구문 적으로 최상위 레벨 바인딩도 일반적으로 제외되지만 (여러 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 수 있으므로) -fno-max-relevant-bindings도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b4f3436c445b81b9b8c7c9be8963efa0b16fdd8a" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</source>
          <target state="translated">유형 검사기는 때때로 오류 메시지에 유형 환경의 일부를 표시하지만이 플래그로 설정된 최대 수까지만 표시합니다. &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 로 끄면 무제한이 제공됩니다. 구문 적으로 최상위 바인딩도 일반적으로 제외되지만 (수많은 수 있기 때문에) &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; 는 해제 된 형식을 안전하지 않게 강제 변환 할 수있는 형식입니다. 보다 구체적으로, 리프트 타입 &lt;code&gt;t&lt;/code&gt; 및 값 &lt;code&gt;x :: t&lt;/code&gt; 경우 &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">타입 생성자 &lt;code&gt;Proxy#&lt;/code&gt; 는 어떤 타입 변수를 감시하는데 사용됩니다. 모델링 유형 응용 프로그램과 같은 작업을 수행하기 위해 프록시 값을 전달하려고 할 때 사용됩니다. &lt;code&gt;Proxy#&lt;/code&gt; 그것은 또한 다형성 종류를 가지고뿐만 아니라 언 박싱, 전부 무료되고, 더 런타임 표현이 없습니다.</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">타입 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 은 모두 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">타입 기능 &lt;code&gt;Item&lt;/code&gt; 은 구조체 &lt;code&gt;l&lt;/code&gt; 의 항목 유형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">의 유형 &lt;code&gt;SPECIALIZE&lt;/code&gt; 프라그 원본 함수의 형태 이하 다형성 임의의 타입 일 수있다. 구체적으로, 원래 함수가 &lt;code&gt;f&lt;/code&gt; 이면 pragma</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">유형에는 물론 클래스 컨텍스트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0da5e4c5461995d9d1a9807b0c5f1ea4b4a2d0bb" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; can also be modified, as seen here for a graded monad:</source>
          <target state="translated">그레이딩 된 모나드에 대해 다음과 같이 &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; 유형을 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 의 유형 골치 거리이지만 운영상리스트 폴드의 간단한 일반화입니다.</target>
        </trans-unit>
        <trans-unit id="2884ac6a531d323777978ba398fbe58aa7e3a183" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; 유형은 Haskell 98에서 불법입니다 . 클래스 유형 변수 (이 경우 &lt;code&gt;a&lt;/code&gt; ) 만 제한하는 제약 조건 &lt;code&gt;Eq a&lt;/code&gt; 가 포함되어 있기 때문 입니다. 보다 정확하게는 다음과 같은 경우 클래스 메서드 시그니처의 제약 조건이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">클래스 유형 변수 (이 경우 &lt;code&gt;a&lt;/code&gt; ) 만 제한하는 제약 조건 &lt;code&gt;Eq a&lt;/code&gt; 가 포함되어 있기 때문에 Haskell 98에서는 &lt;code&gt;elem&lt;/code&gt; 유형이 유효하지 않습니다. 이 경우 &lt;code&gt;a&lt;/code&gt; ). 보다 정확하게는 클래스 메소드 시그니처의 제한 조건이 거부되면</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">에 언급 된 자유 변수의 유형 &lt;code&gt;case&lt;/code&gt; 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에 인덱스가 있고 &lt;code&gt;e&lt;/code&gt; 에 요소가있는 불변의 비 엄격 (박스형) 배열 유형 .</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">비어 있지 않은 스트림의 유형</target>
        </trans-unit>
        <trans-unit id="e4eb98f38164f85b0e9e25152a191c387afddc54" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can change the type of the default method by requiring a different context using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt;, you can specify a default method that uses that generic implementation. But your default implementation can only be used if the constraints are satisfied, therefore you need to change the type of the default method</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 메소드 의 유형 은 &lt;code&gt;[a]&lt;/code&gt; 이며 이것은 기본 메소드의 유형이기도합니다. &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 다른 컨텍스트를 요구하여 기본 메소드의 유형을 변경할 수 있습니다 . 당신이 클래스에 열거의 일반적인 구현을 작성한 경우 예를 들어, &lt;code&gt;GEnum&lt;/code&gt; 방법으로 &lt;code&gt;genum&lt;/code&gt; , 당신은 용도가 일반적인 구현하는 기본 방법을 지정할 수 있습니다. 그러나 기본 구현은 제약 조건이 충족되는 경우에만 사용할 수 있으므로 기본 메서드의 유형을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 메소드 의 유형 은 &lt;code&gt;[a]&lt;/code&gt; 이며 이는 기본 메소드의 유형이기도합니다. &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 확장을 사용하여이 제한을 해제하고 다른 유형을 기본 메소드에 제공 할 수 있습니다 . 당신이 클래스에 열거의 일반적인 구현을 작성한 경우 예를 들어, &lt;code&gt;GEnum&lt;/code&gt; 방법으로 &lt;code&gt;genum&lt;/code&gt; 의 측면에서 &lt;code&gt;GHC.Generics&lt;/code&gt; , 당신은 기본 방법을 지정할 수 있습니다 일반적인 구현하는 용도 :</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">일반적으로 인수 유형은 &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; 에 표시된 것처럼 필요한 유형보다 일반적 일 수 있습니다 . ( &lt;code&gt;reverse&lt;/code&gt; 필요하지 않습니다 &lt;code&gt;Ord&lt;/code&gt; 제약 조건을.)</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">전체 &lt;code&gt;case&lt;/code&gt; 표현식 의 유형은 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">업데이트되는 식의 유형은 유추되지 않으며 제약 조건 해결이 수행되지 않으므로 다음은 모호한 것으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8edd129d0ca324d51366c3bf0ae7aef1ee10d380" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt;).</source>
          <target state="translated">필드 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="905d4fae66a0da2db8e9ac3bf1ac52a2cf5ff066" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, x)&lt;/code&gt;).</source>
          <target state="translated">필드의 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, x)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8af0edfcb4865af68ec3f581c18da4cc40a7334" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; forall e. Either e a&lt;/code&gt;).</source>
          <target state="translated">필드 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; forall e. Either e a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">객체의 유형은 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 의 인스턴스 여야하며 , 이는 단일 유형의 객체 만 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 으로 변환 될 수 있습니다 . 다형성 객체를 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 으로 변환하려면 단형 유형 서명을 지정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">모나드 &lt;code&gt;m&lt;/code&gt; 에 대해 상태 &lt;code&gt;u&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 스트림에서 작동하는 어휘 파서를 보유하는 레코드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">scrutinee의 유형은 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">유형 매개 변수 &lt;code&gt;c_m&lt;/code&gt; 은 &lt;code&gt;T1&lt;/code&gt; ~ &lt;code&gt;Tk&lt;/code&gt; 의 각 유형 변수에서 한 번 발생합니다 . 이 조건이 충족되지 않은 수업을 상상해보십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">type 매개 변수는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 의 인스턴스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">유형 매개 변수는 모두 유형 변수 여야하며 그 중 일부 (모두는 아님)가 클래스 매개 변수 일 수 있습니다. 각 클래스 매개 변수는 연관된 유형 당 최대 한 번만 사용할 수 있지만 일부 클래스는 생략 될 수 있으며 클래스 헤드 이외의 순서 일 수 있습니다. 따라서 다음과 같이 고안된 예가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">이 쌍의 유형 패턴은 &lt;code&gt;x&lt;/code&gt; 가 목록의 무한 중첩으로 대체되는 경우와 같습니다 . 이러한 유형의 사운드에는 이러한 인스턴스를 거부해야합니다.</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 유형 서명 은 명시 적 &lt;code&gt;forall&lt;/code&gt; ( &lt;a href=&quot;#decl-type-sigs&quot;&gt;선언 유형 서명&lt;/a&gt; ) 때문에 유형 변수 &lt;code&gt;a&lt;/code&gt; 를 범위로 가져옵니다 . a로 결합 된 형태 변수 &lt;code&gt;forall&lt;/code&gt; 첨부 선언 값의 전체 범위에 걸쳐 정의. 이 예에서, 유형 변수 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;ys&lt;/code&gt; 에 대한 유형 서명을 포함하여 &lt;code&gt;f&lt;/code&gt; 의 전체 정의에 걸쳐 있습니다. Haskell 98에서는 &lt;code&gt;ys&lt;/code&gt; 에 대한 유형을 선언 할 수 없습니다 . 범위가 지정된 유형 변수의 주요 이점은 그렇게 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">형식 클래스의 기본 메서드에 대한 형식 서명은 해당 기본 메서드의 형식 서명과 동일한 형식을 가져야합니다. 그렇지 않으면 타입 체커는 해당 클래스의 정의를 거부합니다. &quot;같은 양식을 취한다&quot;는 것은 기본 유형 서명이 문맥상에서 만 기본 유형 서명과 달라야 함을 의미합니다. 따라서 메소드 &lt;code&gt;bar&lt;/code&gt; 이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">인스턴스 선언의 타입 시그니처는 클래스 선언의 인스턴스 시그니처보다 인스턴스 이름보다 다형성이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">형식 서명에 결과 형식에 표시되지 않는 수량화 된 형식 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; 의 형식 서명은 정확성이 입증되지 않은 추측에 달려 있음을 사용자에게 알려줍니다. 이 기능을 사용하는 경우 사용자는 다음과 같은 의존성을 인정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">각 생성자의 형식 서명은 독립적이며 평상시처럼 암시 적으로 보편적으로 정량화됩니다. 특히, &quot; &lt;code&gt;data T a where&lt;/code&gt; &quot;헤더 의 타입 변수 는 범위가 없으며, 다른 생성자들은 보편적으로 정량화 된 타입 변수가 다를 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="600179f267be505bf0dea2d828c9b5066c60f915" translate="yes" xml:space="preserve">
          <source>The type signatures for &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; all begin with an outermost &lt;code&gt;forall&lt;/code&gt;, so every type variable in these signatures must be explicitly bound by a &lt;code&gt;forall&lt;/code&gt;. Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, since they explicitly quantify &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. On the other hand, &lt;code&gt;h&lt;/code&gt; does not explicitly quantify &lt;code&gt;b&lt;/code&gt;, so GHC will reject its type signature for being improperly scoped.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;h&lt;/code&gt; 에 대한 유형 서명은 모두 가장 바깥 쪽 &lt;code&gt;forall&lt;/code&gt; 로 시작 하므로 이러한 서명의 모든 유형 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 명시 적으로 바인딩되어야합니다 . &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 모두 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 명시 적으로 정량화하므로 &lt;code&gt;forall&lt;/code&gt; -or-nothing 규칙을 따릅니다 . 반면에 &lt;code&gt;h&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 를 명시 적으로 정량화하지 않으므로 GHC는 범위가 부적절하다는 이유로 해당 유형 서명을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">크기와 크기에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">유형 변수 &lt;code&gt;a&lt;/code&gt; 는 다른 제약 조건에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">여기에 사용 된 유형 변수 &lt;code&gt;e&lt;/code&gt; 는 요소 유형을 나타내고 &lt;code&gt;ce&lt;/code&gt; 는 컨테이너 자체의 유형입니다. 이 프레임 워크 내에서,리스트 또는 특성 함수 (둘 다 동등 유형의 콜렉션을 나타내는 데 사용될 수 있음), 비트 세트 (문자 콜렉션을 나타내는 데 사용할 수있는) 또는 해시에 대해이 클래스의 인스턴스를 정의 할 수 있습니다. 테이블 (해시 함수가있는 요소의 컬렉션을 나타내는 데 사용할 수 있음) 표준 구현 세부 사항을 생략하면 다음과 같은 선언으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">Type 변수는 단일 구문 보이는 최 의해 정량화 &lt;code&gt;forall&lt;/code&gt; 타입의 서명. 예를 들어 GHC는 다음 예를 모두 거부합니다.</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">유형 변수 (제공된 경우)는 명시 적으로 분류 될 수 있으므로 다음 과 같이 &lt;code&gt;Foo&lt;/code&gt; 의 헤더를 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">타입 변수 &lt;code&gt;vk+1...vn&lt;/code&gt; 은 타입 &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;s1..sk&lt;/code&gt; 또는 &lt;code&gt;t1..tj&lt;/code&gt; 에서 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;instance&lt;/code&gt; 선언 의 헤드에있는 유형 변수 는 &lt;code&gt;where&lt;/code&gt; 부분에 정의 된 메소드에 대한 범위 입니다. &lt;code&gt;instance&lt;/code&gt; 선언 에서 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 허용되지만 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 필요하지는 않습니다 . &lt;a href=&quot;#explicit-foralls&quot;&gt;명시 적 범용 정량화 (forall)를&lt;/a&gt; 참조하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4527110e436f59f5f03d4993fa8ef3b4a17f7938" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">다음 예제와 같이 &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 외부 선언 형식의 형식 변수를 명시 적 &lt;code&gt;forall&lt;/code&gt; 로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f03bbab3fd03c0f04b9e0c0fedb642fb00b2844" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">외부 선언 형식의 형식 변수 는 다음 예제와 같이 &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 명시 적 &lt;code&gt;forall&lt;/code&gt; 로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">유형 패밀리 방정식의 오른쪽에있는 유형 변수는 평소와 같이 왼쪽에 명시 적으로 바인딩되어야합니다. 그러나 오른쪽에는 암시 적으로 바인딩 된 종류 변수를 언급 할 수 있으므로 &lt;em&gt;종류&lt;/em&gt; 변수에는 이 제한이 완화됩니다 . 예를 들어 다음은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="cf551ca6fe716e0e3656d418ee13c9c2e0107f55" translate="yes" xml:space="preserve">
          <source>The type variables quantified by the data type head (&lt;code&gt;forall a b. &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">데이터 유형 헤드 ( &lt;code&gt;forall a b. &amp;lt;...&amp;gt;&lt;/code&gt; )로 수량화 된 유형 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">유형 변수 : &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 유형 수준에 해당 합니다 .</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">안전한 유형의 캐스트 작업</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 유형 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 클래스 및 Word32 및 Float와 Word64 및 Double 사이의 캐스트.</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; 는 다시 한 번 입력 레벨된다 프록시를, 단지의 여러 변종 만드는 데 사용 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형의 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 및 클래스 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">유형만으로는 이러한 법률이 적용되지 않으므로 직접 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">구체화 구멍 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; 의 추가 구멍 유형은 출력에 표시됩니다. 예를 들어 foldl1 (_ :: a-&amp;gt; a-&amp;gt; a) 는 구멍 &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; 대한 구체화입니다 . 이 플래그가 꺼져 있으면 출력에 &lt;code&gt;foldl1 _&lt;/code&gt; 만 표시되며 -XScopedTypeVariables 가 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; 구멍을 직접 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d81a104972bf197c2bbed8aa492a5ea327869a2" translate="yes" xml:space="preserve">
          <source>The types of the operations picked for desugaring must produce an expression which is accepted by the typechecker. But other than that, there are no specific requirements on the types.</source>
          <target state="translated">desugaring을 위해 선택한 작업 유형은 typechecker에서 허용하는 표현식을 생성해야합니다. 그러나 그 외에는 유형에 대한 특정 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">박스형 튜플의 일반적인 사용은 단순히 여러 값을 반환하여 여러 결과를 &lt;code&gt;case&lt;/code&gt; 표현식 과 바인딩하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">결합 조작을 사용하여 맵 목록을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산을 사용하여 맵 목록의 결합 (( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="d32217b38bffdaa9ca587e9d6a40f750e6e5bfb9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산이있는 맵 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79dd47dfab111b7b4fefeb6ad5d0a0d8f7cfd08d" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산으로지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산을 사용하여 맵 목록의 결합 (( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="b99c2dfae5341557cba637c4f3ef989142689dd9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산이있는 맵 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="907c04acd0a9bc47be90c69632d4ff6df0869303" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산으로지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">지도 목록의 합집합</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="06da55697aaeea01f68121fc5dda49aec58e2fa9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="61303d04994d9cc4ddac01a7c1400e746e7c55a8" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5359b26f8252c95c2fa3287a62d5ed9a07ab46e7" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ab744c66494b3202c4bf443d168cb8c1c43690a" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">세트리스트의 결합.</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Foldable 구조에서 집합의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">이 그룹의 고유 한 숫자 ID (gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">단위 유형 &lt;code&gt;()&lt;/code&gt; 및 목록 유형 &lt;code&gt;[]&lt;/code&gt; 은 유형 기본값을 지정할 때 시도되는 표준 유형 목록의 시작 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2f4c60db39330dbc4e1160f8c12c21318aa37a" translate="yes" xml:space="preserve">
          <source>The universal type variables (&lt;code&gt;forall a. &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">범용 유형 변수 ( &lt;code&gt;forall a. &amp;lt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">사용자가 소스 코드에서 필드를 작성했을 때의 압축 풀기 예를 들어 다음 데이터 형식에서</target>
        </trans-unit>
        <trans-unit id="f73f2fa8215550228fa8f2f4b091ed3e8ae1ac99" translate="yes" xml:space="preserve">
          <source>The unqualified &lt;code&gt;do&lt;/code&gt; syntax is convenient for writing monadic code, but it only works for data types that provide an instance of the &lt;code&gt;Monad&lt;/code&gt; type class. There are other types which are &amp;ldquo;monad-like&amp;rdquo; but can&amp;rsquo;t provide an instance of &lt;code&gt;Monad&lt;/code&gt; (e.g. indexed monads, graded monads or relative monads), yet they could still use the &lt;code&gt;do&lt;/code&gt; syntax if it weren&amp;rsquo;t hardwired to the methods of the &lt;code&gt;Monad&lt;/code&gt; type class. &lt;code&gt;-XQualifiedDo&lt;/code&gt; comes to make the do syntax customizable in this respect. It allows you to mix and match &lt;code&gt;do&lt;/code&gt; blocks of different types with suitable operations to use on each case:</source>
          <target state="translated">정규화되지 않은 &lt;code&gt;do&lt;/code&gt; 구문은 모나 딕 코드를 작성하는 데 편리하지만 &lt;code&gt;Monad&lt;/code&gt; 유형 클래스 의 인스턴스를 제공하는 데이터 유형에 대해서만 작동합니다 . &quot;모나드 같은&quot;하지만의 인스턴스를 제공 할 수있는 다른 종류가 있습니다 &lt;code&gt;Monad&lt;/code&gt; (예를 들어 인덱스 모나드, 등급 모나드 또는 상대 모나드는) 아직 그들은 여전히 사용할 수있는 &lt;code&gt;do&lt;/code&gt; 이의 방법으로 고정 배선되지 않은 경우 구문을 &lt;code&gt;Monad&lt;/code&gt; 타입 클래스입니다. &lt;code&gt;-XQualifiedDo&lt;/code&gt; 는 이러한 점에서 do 구문을 사용자 정의 할 수 있도록합니다. 다양한 유형의 &lt;code&gt;do&lt;/code&gt; 블록을 각 경우에 사용할 적절한 작업과 혼합하고 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">이것의 결과는 외래 호출에서 차단 된 Haskell 스레드가있는 경우 호출이 리턴 될 때까지 &lt;code&gt;hs_exit()&lt;/code&gt; 가 정지 (또는 통화 중 대기) 될 수 있다는 것입니다. 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; 호출 할 때 시스템에 그러한 스레드가 없는지 확인하는 것이 좋습니다 . 여기에는 I / O를 수행하는 스레드가 포함됩니다. I / O는 I / O 및 플랫폼 유형에 따라 외부 호출 차단을 사용하여 구현 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">의 사용 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 컴파일 할 &lt;code&gt;Danger&lt;/code&gt; A를 사용할 수 있습니다 하스켈의 기능을 제한하는 &lt;a href=&quot;#safe-language&quot;&gt;안전 부분 집합을&lt;/a&gt; . 여기에는 &lt;code&gt;unsafePerformIO&lt;/code&gt; , Template Haskell, 순수 FFI 기능, 규칙 및 겹치는 인스턴스의 작동 제한 이 포함되지 않습니다 . &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그는 또한 모듈에서 가져올 수 제한 &lt;code&gt;Danger&lt;/code&gt; 신뢰할 수있는 것으로 간주되는 만에. 신뢰할 수있는 모듈은 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈입니다 . 여기서 GHC는 코드가 안전하다는 기계적 보증을 제공합니다. 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 가 모듈이 안전하다고 주장하는 Trustworthy로 컴파일 된 모듈.</target>
        </trans-unit>
        <trans-unit id="7f1408b97746788b10921b1206ca1a3f3ea7a9dc" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">의 사용 &lt;code&gt;*&lt;/code&gt; 거주 유형의 종류를 나타 내기 위해이에 의존 &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 의&lt;/a&gt; 미래의 릴리스에서 기본적으로 해제 한 후 가능성이 제거됩니다 확장. 그 이유와 지원 중단 일정은 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC 제안 # 30에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">의 사용 &lt;code&gt;*&lt;/code&gt; 거주 유형의 종류를 나타 내기 위해이에 의존 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 의&lt;/a&gt; 미래의 릴리스에서 기본적으로 해제 한 후 가능성이 제거됩니다 확장. 이에 대한 이유와 지원 중단 일정은 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC 제안서 # 30에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">사용 &lt;code&gt;?x&lt;/code&gt; 바인딩에서 &lt;code&gt;?y&lt;/code&gt; 바인딩 &quot;참조&quot;않는 &lt;code&gt;?x&lt;/code&gt; 의 종류 있도록 &lt;code&gt;f&lt;/code&gt; 이고</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 사용은 매우 양식화되어 있습니다. 적절한 언어 정의를 가져오고 결과 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 에서 필요한 어휘 파서를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 사용은 매우 양식화되어 있습니다. 적절한 언어 정의를 가져오고 결과 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 에서 필요한 어휘 파서를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">비용 중심 스택의 유용성은 예제를 약간 수정하여 더 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">컴파일러 &lt;a href=&quot;#default-deriving-strategy&quot;&gt;는 기본적으로&lt;/a&gt; 컴파일러가 잘못된 &lt;a href=&quot;#deriving-stragies&quot;&gt;전략을&lt;/a&gt; 선택하는 경우 원하는 파생 전략을 선택적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98af7b33a0bad99da65cf462d2b46e6910ecbeb3" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;deriving_strategies#deriving-strategies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;deriving_strategies#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">특히 컴파일러가 &lt;a href=&quot;deriving_strategies#default-deriving-strategy&quot;&gt;기본적으로&lt;/a&gt; 잘못된 &lt;a href=&quot;deriving_strategies#deriving-strategies&quot;&gt;전략을&lt;/a&gt; 선택한 경우 사용자는 원하는 파생 전략을 선택적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">사용자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">일반적인 출력 스트림은 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 입니다. stderr이없는 Windows GUI 응용 프로그램의 경우 출력은 Windows 디버그 콘솔로 보내집니다. 이러한 함수의 일부 구현은 출력중인 문자열을 장식하여 추적 중임을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">배열에서 지정된 인덱스의 값입니다.</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">주 릴리스 &lt;code&gt;x.y.z&lt;/code&gt; 대한 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값 ( &lt;a href=&quot;phases#c-pre-processor&quot;&gt;C 전처리 &lt;/a&gt;기에 영향을주는 옵션 참조 ) 은 정수 ⟨xyy⟩ (⟨y⟩가 한 자리 인 경우 선행 0이 추가되므로 버전 6.8.2)입니다. GHC의 경우 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">스냅 샷 릴리스 의 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값은 정수 ⟨xyy⟩입니다. 그러나이 값을 테스트하는 조건부 코드를 작성해서는 안됩니다. 인터페이스가 매일 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값이 세분화되지 않기 때문에 테스트하는 조건 자를 사용하여 조건부로 컴파일해야합니다. &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 이 지정된 주요 릴리스와 같거나 늦 거나 같은지 여부</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">값 &lt;code&gt;seq a b&lt;/code&gt; 경우 하단 인 &lt;code&gt;a&lt;/code&gt; 아래쪽으로하고, 그렇지 않으면 동일한 &lt;code&gt;b&lt;/code&gt; . 다시 말해, 첫 번째 인수 &lt;code&gt;a&lt;/code&gt; 를 약한 머리 정규형 (WHNF)으로 평가합니다. &lt;code&gt;seq&lt;/code&gt; 는 일반적으로 불필요한 게으름을 피함으로써 성능을 향상시키기 위해 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">컴파일 / 링크시 GHC 플래그 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">변수의 유형은 다형성이 아니며 &lt;code&gt;()&lt;/code&gt; 이 아니며 &lt;code&gt;Show&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">정의의 왼쪽에있는 변수는 오른쪽의 패턴에 의해 구속됩니다. 양방향 패턴 동의어의 경우 오른쪽의 모든 변수도 왼쪽에서 발생해야합니다. 또한 와일드 카드 패턴 및보기 패턴은 허용되지 않습니다. 단방향 및 명시 적 양방향 패턴 동의어의 경우 오른쪽 패턴에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">런타임의 변형 (&amp;ldquo;way&amp;rdquo;). 가장 일반적인 값은 &lt;code&gt;rts_v&lt;/code&gt; (바닐라), &lt;code&gt;rts_thr&lt;/code&gt; (스레드 실행, 즉이 사용하여 링크 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션을) 및 &lt;code&gt;rts_p&lt;/code&gt; (프로파일 런타임, 즉이 사용하여 링크 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션). 다른 변형에는 &lt;code&gt;debug&lt;/code&gt; ( &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; 를&lt;/a&gt; 사용하여 연결됨 ) 및 &lt;code&gt;dyn&lt;/code&gt; 이 포함됩니다 (RTS는 동적으로 연결됩니다 (예 : 실행 파일 자체에 정적으로 연결되는 것이 아니라 공유 라이브러리)). 예를 들어 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">다양한 통신 프로세스는 정적 포인터 테이블의 값을 참조하는 데 사용 된 키를 동의해야합니다. 그렇지 않으면 조회가 실패합니다. 동일한 프로그램 바이너리에서 시작된 프로세스 만 동일한 키 세트를 사용하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">GHC 사본의 버전 번호 는 &lt;code&gt;--version&lt;/code&gt; 플래그 와 함께 &lt;code&gt;ghc&lt;/code&gt; 를 호출하여 찾을 수 있습니다 ( &lt;a href=&quot;using#options-help&quot;&gt;자세한 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">프로그램이 컴파일되었거나 해석중인 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">이 프로그램을 컴파일하는 데 사용 된 GHC 버전.</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">강력하게 연결된 구성 요소 목록의 정점</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">강력하게 연결된 구성 요소의 꼭짓점</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">연관된 패밀리 인스턴스의 오른쪽에있는 클래스 매개 변수의 가시성은 패밀리 의 매개 변수 &lt;em&gt;에만&lt;/em&gt; 의존 합니다. 예를 들어 간단한 클래스 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b254ff12dcb3719a93c7a27f7a665b84f55b2e3b" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;../using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;../using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">기본적으로 꺼져 있지만 &lt;a href=&quot;../using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 포함 된 경고 &lt;a href=&quot;../using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt; 는 가져온 모듈이 내 보내지 않는 항목을 숨기면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt; 경고 는 기본적으로 꺼져 있지만 &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 포함되어 있으며 가져온 모듈이 내 보내지 않은 것을 숨기면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5369ef220638dc82aaace3093ac85be8f6ea055a" translate="yes" xml:space="preserve">
          <source>The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</source>
          <target state="translated">경고 &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (기본적으로 해제 됨)는 전제 구문을 사용하여 &lt;code&gt;qualified&lt;/code&gt; 어노테이션이있는 가져 오기 발생에 대해보고 합니다.</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">밑줄로 시작하는 이름에는 경고가 표시되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">필드 이름이 밑줄로 시작하면 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">경고는 복제 된 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">경고는 중복 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건 을 표시합니다 . : &lt;code&gt;f&lt;/code&gt; 의 정의에 의해 사용되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">경고는 중복 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건 을 표시합니다 . &lt;code&gt;Ord a&lt;/code&gt; 제약 조건 이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b81d66b467d23d7422d611d2f4898b0e6c539b7" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">예측 가능한 행동을 얻을 수있는 방법은 사용하는 것입니다 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; 의&lt;/a&gt; 프라그 또는 &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; 에 프라그를 &lt;code&gt;f&lt;/code&gt; 그 때까지 인라인되지 않도록, &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 불 수있는 기회가 있었다. 경고 플래그 &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;경고 및 온 전성 검사 참조&lt;/a&gt; )은이 상황에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">예측 가능한 동작을 얻는 방법은 &lt;code&gt;f&lt;/code&gt; 에서 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; pragma 또는 INLINE [⟨phase⟩] pragma 를 사용하여 규칙이 발사 될 때까지 인라인되지 않도록하는 것입니다. 경고 플래그 &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;경고 및 위생 검사 참조&lt;/a&gt; )은이 상황에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="14561f92a4c46bb2dbd93c4a1a57a24a8562eada" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;pragmas#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;../using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;../using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">예측 가능한 행동을 얻을 수있는 방법은 사용하는 것입니다 &lt;a href=&quot;pragmas#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; 의&lt;/a&gt; 프라그 또는 &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; 에 프라그를 &lt;code&gt;f&lt;/code&gt; 그 때까지 인라인되지 않도록, &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 불 수있는 기회가 있었다. 경고 플래그 &lt;a href=&quot;../using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../using-warnings#options-sanity&quot;&gt;경고 및 온 전성 검사 참조&lt;/a&gt; )은이 상황에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">이러한 상황을 식별하는 방법 은 데이터 유형, 클래스 및 유형 동의어의 유형 변수에 &lt;em&gt;역할을&lt;/em&gt; 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">이 라이브러리의 약한 포인터는 &lt;em&gt;finalization&lt;/em&gt; 이라는 다른 접근 방식을 지원 &lt;em&gt;합니다&lt;/em&gt; . 약한 포인터가 참조하는 키가 죽으면 스토리지 관리자는 프로그래머가 지정한 종료자를 실행합니다. 예를 들어 메모 테이블의 경우 종료자는 메모 테이블에서 키 / 값 쌍을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">해결 방법은 패키지를 구성하는 .o 파일을 &lt;code&gt;base&lt;/code&gt; 패키지가 수행 하는 방식에 따라 둘 이상의 .o로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">일하는 법</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">랩퍼 및 일반 기본값</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">지퍼 : &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">인용 부호는 템플릿 Haskell 인용 부호와 겹치므로 &quot; &lt;code&gt;e&lt;/code&gt; &quot;, &quot; &lt;code&gt;t&lt;/code&gt; &quot;, &quot; &lt;code&gt;d&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;p&lt;/code&gt; &quot;는 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">따옴표는 수입 된 견적 자의 이름이어야합니다. 임의의 표현이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">그러면 &lt;code&gt;Foo_stub.h&lt;/code&gt; 는 다음과 같은 내용 을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">그런 다음 &lt;code&gt;Parser&lt;/code&gt; 는 &lt;code&gt;MonadPlus&lt;/code&gt; 의 인스턴스입니다 . 모나 딕 시퀀싱은 파서의 연결을 구현하고 &lt;code&gt;mplus&lt;/code&gt; 는 선택을 제공합니다. 구문 분석기를 사용하려면 입력 문자열에서 구성된 구문 분석기를 실행하기위한 기본 요소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d51c7bd79ff661be693430fb4fca8b3531c214f1" translate="yes" xml:space="preserve">
          <source>Then GHC will interpret the return type of &lt;code&gt;MkB&lt;/code&gt; to be &lt;code&gt;C&lt;/code&gt;, and since GHC requires that the return type must be headed by &lt;code&gt;B&lt;/code&gt;, this will be rejected. On the other hand, it is acceptable to use type synonyms within the argument and result types themselves, so the following is permitted:</source>
          <target state="translated">그런 다음 GHC는의 리턴 타입 해석합니다 &lt;code&gt;MkB&lt;/code&gt; 될 &lt;code&gt;C&lt;/code&gt; 를 , 그리고 GHC는 반환 형식이 이끄는되어야 함을 필요로하기 때문에 &lt;code&gt;B&lt;/code&gt; 이 거부됩니다. 반면에 인수 및 결과 유형 자체 내에서 유형 동의어를 사용할 수 있으므로 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">그런 다음 &lt;code&gt;bar&lt;/code&gt; 의 기본 메소드는 다음 양식을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;stdout2&lt;/code&gt; 를 사용 하여 표준 출력에 쓸 수 있지만 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; 는 그렇지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">그런 다음 적용 가능한 설탕 제거로</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">그런 다음 사용자가 작성한 변수를 내재적으로 유형 변수의 종류로 범위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e8b3132a6bec98840d3e0c94bc381c1588c40340" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 다시 컴파일 하고 추가로 &lt;code&gt;-osuf p_o&lt;/code&gt; 를 사용 하여 개체 파일의 이름을 다르게 지정합니다 (여기서 일반 개체 접미사가 아닌 접미사를 선택할 수 있음). GHC는 스플 라이스 표현식을 실행할 때 첫 번째 단계에서 빌드 한 오브젝트 파일을 자동으로로드합니다. &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 빌드 하고 Template Haskell을 사용할 때 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 플래그 를 생략하면 GHC에서 오류 메시지를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 다시 컴파일 하고 추가로 &lt;code&gt;-osuf p_o&lt;/code&gt; 를 사용 하여 오브젝트 파일 이름을 다르게 지정하십시오 (여기서 일반 오브젝트 접미 부가 아닌 접미 부를 선택할 수 있습니다). GHC는 스플 라이스 표현식을 실행할 때 첫 번째 단계에서 빌드 된 객체 파일을 자동으로로드합니다. &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 빌드 하고 템플리트 Haskell을 사용할 때 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 플래그 를 생략하면 GHC에서 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">그리고 일부 수입 모듈에 &lt;code&gt;M&lt;/code&gt; , 제약 &lt;code&gt;(E a Int)&lt;/code&gt; 로 설정하여 &quot;개선&quot;해야한다 &lt;code&gt;a = T&lt;/code&gt; , &lt;em&gt;명시 적 언급이 없어도&lt;/em&gt; 의 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;M&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">그러면 &lt;code&gt;HigherEq Option&lt;/code&gt; 인스턴스 를 파생시킬 수 있습니다 . 유일한 차이점은 이제 &lt;code&gt;(==#)&lt;/code&gt; 에 대한 기본이 아닌 유형 서명 이 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건을 가져온다는 것 입니다. 기본이 아닌 유형 시그니처의 제약 조건은 파생 인스턴스 컨텍스트 자체에는 나타나지 않지만 기본 유형 시그니처에서 요구하는 의무를 이행하는 데 사용될 수 있습니다. 위의 예에서 기본 유형 서명은 &lt;code&gt;Eq a&lt;/code&gt; 인스턴스를 요구했으며 기본 이 아닌 서명은 해당 요청을 충족 할 수 있었으므로 파생 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">그러면 다음과 같은 결과로 오류가 발생하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="30b5d092dccca3ffe5f1a437962d4345013785c1" translate="yes" xml:space="preserve">
          <source>Then the application &lt;code&gt;f3 g3a&lt;/code&gt; is well-typed, because &lt;code&gt;g3a&lt;/code&gt; has a type that matches the type expected by &lt;code&gt;f3&lt;/code&gt;. But &lt;code&gt;f3 g3b&lt;/code&gt; is not well typed, because the foralls are in different places. Nor is &lt;code&gt;f3 g3c&lt;/code&gt;, where the foralls are in the same place but the variables are in a different order. Similarly &lt;code&gt;f4 g4&lt;/code&gt; is not well typed, because the constraints appear in a different order.</source>
          <target state="translated">그러면 응용 프로그램 &lt;code&gt;f3 g3a&lt;/code&gt; 는 잘 입력됩니다. &lt;code&gt;g3a&lt;/code&gt; 가 &lt;code&gt;f3&lt;/code&gt; 가 예상하는 유형과 일치하는 유형을 갖기 때문 입니다. 그러나 &lt;code&gt;f3 g3b&lt;/code&gt; 는 forall이 다른 위치에 있기 때문에 잘 입력되지 않았습니다. forall이 같은 위치에 있지만 변수의 순서가 다른 &lt;code&gt;f3 g3c&lt;/code&gt; 도 아닙니다 . 마찬가지로 &lt;code&gt;f4 g4&lt;/code&gt; 는 제약 조건이 다른 순서로 나타나기 때문에 제대로 입력되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">그러면 파생 &lt;code&gt;Foo&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">그런 다음 파생 인스턴스 선언은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">그러면 파서는 얼마나 많은 &lt;code&gt;tick&lt;/code&gt; 이 실행 되는지 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">그런 다음 나머지 프로그램은 구성된 플래그 목록을 사용하여 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">그런 다음 &lt;code&gt;args.txt&lt;/code&gt; 로 &lt;code&gt;foo&lt;/code&gt; 를 호출 한 결과는 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">그런 다음 다음과 같이 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 프리미티브 위에 고유 버전의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">있습니다 &lt;em&gt;많은&lt;/em&gt; GHC에 의해 생성 된 코드의 품질에 영향을주는 옵션. 대부분의 사람들은&amp;ldquo;빠르게 컴파일&amp;rdquo;또는&amp;ldquo;프로그램을 기름칠 번개처럼 실행하게&amp;rdquo;과 같은 일반적인 목표 만 가지고 있습니다. 다음과 같은 최적화 (또는 부족) 패키지로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 현재 Windows에서는 구현되어 있지 않으며 외부 인터프리터는 GHCi 디버거를 지원하지 않으므로 중단 점 및 단일 스테핑이 필요하지 않습니다. &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 와 함께 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">유형이 지정된 구멍에 대해 표시되는 컨텍스트 정보의 양을 제어하기위한 몇 가지 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">다른 프로파일 링 관련 컴파일 옵션이 있습니다. &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 와 함께&lt;/em&gt; 사용하십시오 . 프로그램의 모든 모듈에 대해 일관되게 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">여기에 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ace737ea1ad0292af239ecd28b2b2f2f35d3aad" translate="yes" xml:space="preserve">
          <source>There are a number of restrictions around these &lt;em&gt;return kinds&lt;/em&gt;. The text below considers &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; and data families (enabled by &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;). The discussion also assumes familiarity with &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;levity polymorphism&lt;/a&gt;.</source>
          <target state="translated">이러한 &lt;em&gt;반환 종류&lt;/em&gt; 에는 여러 가지 제한 사항이 &lt;em&gt;있습니다&lt;/em&gt; . 아래 텍스트는 &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 및 데이터 계열 ( &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; 에서&lt;/a&gt; 활성화 됨 )을 고려합니다. 토론은 또한 &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;levity 다형성에&lt;/a&gt; 익숙하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">다음 과 같은 &lt;code&gt;case&lt;/code&gt; 명령 도 있습니다</target>
        </trans-unit>
        <trans-unit id="dd8eb62640463e13034ae0606f48f2c5c055b371" translate="yes" xml:space="preserve">
          <source>There are also hybrid cases, where the method and/or operator are not well suited to the task at hand, resulting in a fold that fails to yield incremental results until the entire input is processed, or fails to strictly evaluate results as it goes, deferring all the work to the evaluation of a large final thunk. Such cases should be avoided, either by selecting a more appropriate &lt;code&gt;Foldable&lt;/code&gt; method, or by tailoring the operator to the chosen method.</source>
          <target state="translated">방법 및 / 또는 연산자가 당면한 작업에 적합하지 않아 전체 입력이 처리 될 때까지 증분 결과를 산출하지 못하거나 결과를 엄격하게 평가하지 못하는 혼합 사례도 있습니다. 모든 작업을 대규모 최종 썽크의 평가로 연기합니다. 이러한 경우는보다 적절한 &lt;code&gt;Foldable&lt;/code&gt; 방법 을 선택 하거나 작업자를 선택한 방법에 맞게 조정하여 피해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1279203c2e0d157a8d9dad524a1fc81607cfc8e4" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt;&lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">현재 유효한 구멍 맞춤을 정렬하는 방법에는 두 가지가 있습니다. &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt; &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 로&lt;/a&gt; 정렬을 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">유효한 구멍 맞춤을 정렬하는 방법에는 현재 두 가지가 있습니다. 정렬은 &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 로 전환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">객체 코드로 컴파일하는 데는 단점이 있습니다. 예를 들어 객체 코드 모듈에서 중단 점을 설정할 수 없습니다. 해석 된 모듈에서와 같이 모든 최상위 레벨 바인딩이 아니라 오브젝트 코드 모듈의 내보내기 만 GHCi에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">제 (기존의) 키워드로 도입 이해 규정의 다섯 개 가지 새로운 형태의 모든 있습니다 &lt;code&gt;then&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">RTS 옵션을 설정하는 네 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">매개 변수 인 위치 나 재귀 호출 인 위치를 구별하지 않는 많은 데이터 유형 일반 함수가 있습니다. 데이터 유형과 생성자의 이름을 전혀 신경 쓰지 않는 많은 데이터 유형 일반 함수도 있습니다. 이러한 상황에서 일반 함수에서 고려해야 할 사례 수를 최소로 유지하기 위해 위에서 소개 한 많은 유형 생성자가 실제로는 동의어이며 더 작은 생성자 집합의 변형으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">다른 RTS 옵션으로 선택하여 생성 할 수있는 다양한 종류의 프로파일이 있습니다. 이 장의 나머지 부분에서 다양한 종류의 프로필을 설명 할 것입니다. 일부 프로파일은 프로그램을 실행 한 후 추가 도구를 사용하여 추가 처리를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="780abf829b6da95d281c25275aa198c1ad98ac87" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 사전 정의 된 인스턴스가 없습니다. 기본적으로 범위에 포함되지 않지만 &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt; 를 가져 와서 범위로 가져올 수 있습니다 . &lt;code&gt;IsString&lt;/code&gt; 과 달리 &lt;code&gt;IsLabel&lt;/code&gt; 에 대한 특별한 기본값 규칙은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 사전 정의 된 인스턴스가 없습니다. 기본적으로 범위가 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;아니지만 GHC.OverloadedLabels&lt;/a&gt; 를 가져와 범위로 가져올 수 있습니다 . &lt;code&gt;IsString&lt;/code&gt; 과 달리 &lt;code&gt;IsLabel&lt;/code&gt; 에는 특별한 기본 규칙이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="70d1d2c96409db371b4aa9bd1644711aa1fc1d7d" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 사전 정의 된 인스턴스가 없습니다. 기본적으로 범위 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;내에 있지는 않지만 GHC.OverloadedLabels&lt;/a&gt; 를 가져와 범위로 가져올 수 있습니다 . &lt;code&gt;IsString&lt;/code&gt; 과 달리 &lt;code&gt;IsLabel&lt;/code&gt; 에 대한 특별한 기본값 규칙은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">실행 가능한 스레드가 없으므로 프로그램이 교착 상태입니다. &lt;code&gt;Deadlock&lt;/code&gt; 예외은 주 스레드에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 와의 구문 변경은 없습니다 . 소스 레벨에서 나타나는 유일한 방법 은 &lt;code&gt;Monad&lt;/code&gt; 제약 조건이 필요없는 &lt;code&gt;do&lt;/code&gt; 표현식을 가질 수 있다는 것 입니다. 예를 들어 GHCi에서 :</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">전달할 &lt;code&gt;V1 p&lt;/code&gt; 유형의 값이 없으므로 (정의되지 않음 제외) 실제로는 불가능합니다. 이 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스를 정의하는 것이 왜 유용한 지 묻습니다 . 빈 유형을 비어 있지 않은 유형의 인수로 사용할 수 있으며 결과 유형을 계속 인코딩 할 수 있습니다. 다소 고안된 예로, 빈 유형은 아니지만 빈 목록 만 포함하는 &lt;code&gt;[Empty]&lt;/code&gt; 를 고려 하십시오. &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 보장하지만 우리는 같은 유형의 일반 함수를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">실제로 모든 종류의 예외를 잡아야하는 경우가 있습니다. 그러나 대부분의 경우 이는 일부만 정리하면됩니다. 실제로 예외 자체에는 관심이 없습니다. 예를 들어, 파일을 열면 파일 처리가 정상적으로 실행되는지 아니면 예외가 발생하는지에 관계없이 파일을 다시 닫으려고합니다. 그러나 이러한 경우에는 실제로 예외를 전달하지는 않지만 적절한 시점에서 정리 함수를 호출하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 과 같은 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68320e8b907613c7782553698755865907bc858f" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags.</source>
          <target state="translated">표현에 액세스하는 플러그인을 정의하는 데 사용할 수있는 여러 가지 액세스 포인트가 있습니다. 이러한 모든 필드 는 &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 컴파일러에 전달 된 &lt;code&gt;CommandLineOption&lt;/code&gt; 문자열 목록을받습니다 .</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">표현에 액세스하는 플러그인을 정의하는 데 사용할 수있는 여러 가지 액세스 포인트가 있습니다. 이러한 모든 필드 는 &lt;code&gt;-fplugin-opt&lt;/code&gt; 플래그를 사용하여 컴파일러에 전달되는 &lt;code&gt;CommandLineOption&lt;/code&gt; 문자열 목록을받습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">생성 될 수있는 여러 가지 종류의 힙 프로파일이 있습니다. 모든 다른 프로파일 유형은 시간에 대한 라이브 힙 그래프를 생성하지만 라이브 힙이 밴드로 분류되는 방식이 다릅니다. 다음 RTS 옵션은 사용할 분류를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">예외를 포착하고 검사하기위한 몇 가지 기능이 있습니다. 모두 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e8b486f6025f68e63b8a2e69c38027f05b9be43" translate="yes" xml:space="preserve">
          <source>There are several legitimate ways to use &lt;code&gt;&lt;a href=&quot;unsafe-coerce#v:unsafeCoerce&quot;&gt;unsafeCoerce&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;unsafe-coerce#v:unsafeCoerce&quot;&gt;unsafeCoerce&lt;/a&gt;&lt;/code&gt; 를 사용하는 몇 가지 합법적 인 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">가비지 수집을 정확하게 제어 할 수있는 몇 가지 옵션이 있습니다. 다행히 정상적인 작동에서는 이러한 기능이 필요하지 않지만 최대 성능을 위해 조정할 수있는 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 에서 제공하는 다른 Haskell 및 GHC 관련 메일 링리스트가 몇 가지 있습니다 . 전체 목록을 보려면 &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; 로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a880f0505216caaeec447cd58fe796163581619e" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;https://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 에서 제공하는 여러 다른 Haskell 및 GHC 관련 메일 링리스트가 있습니다. 전체 목록을 보려면 &lt;a href=&quot;https://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; 로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">여기에주의해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">기존에 수량화 된 생성자를 사용할 수있는 방법에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f0614d42022b318b6c7e89cd2bff7336dde820" translate="yes" xml:space="preserve">
          <source>There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt;, &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</source>
          <target state="translated">이것을 사용할 때 몇 가지 제한이 있습니다. 파일 및 프로세스 IO가 대상에서 실행됩니다. &lt;code&gt;git-embed&lt;/code&gt; 와 같은 패키지 , &lt;code&gt;file-embed&lt;/code&gt; 및 기타 패키지 는 대상과 호스트가 동일한 파일 시스템을 공유하지 않으면 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 파생시킬 수있는 데이터 유형과 관련하여 몇 가지 다른 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 컴파일되지 않는 다른 시나리오가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">기본 유형의 사용에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">박스형 튜플 사용에는 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">힙 프로파일 링과 관련된 세 가지 옵션이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">세 개의 새로운 키워드가 있습니다 : &lt;code&gt;group&lt;/code&gt; , &lt;code&gt;by&lt;/code&gt; 및 &lt;code&gt;using&lt;/code&gt; . &lt;code&gt;sortWith&lt;/code&gt; 및 &lt;code&gt;groupWith&lt;/code&gt; 함수 는 키워드가 아니며 &lt;code&gt;GHC.Exts&lt;/code&gt; 에서 내 보낸 일반 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">현재 통화 스택에 액세스하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18668df28a2960d99f735bbd24797ff6843bd893" translate="yes" xml:space="preserve">
          <source>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</source>
          <target state="translated">구멍 맞춤 플러그인을 정의하기 위해 두 개의 액세스 포인트가 함께 번들로 제공됩니다. 즉, 후보 플러그인과 맞춤 플러그인이 각각 확인되고 적합 할 후보를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0e7482a52c288e2a6aa7c273bf0bcf1dbfeabe7e" translate="yes" xml:space="preserve">
          <source>There are two classes of event types:</source>
          <target state="translated">이벤트 유형에는 두 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">특수 구문에는 두 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLL을 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">이 디코더를 실행하는 방법에는 지연 입력 방법과 증분 입력 방법의 두 가지 방법이 있습니다. 여기에서는 게으른 입력 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">시퀀스와 목록 사이에는 두 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">이 카운터로 수행 할 수있는 두 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">browse 명령에는 두 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">이 pragma를 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">여러 프로세서에서 프로그램을 실행하는 방법은 두 가지가 있습니다. 프로그램에서 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; 를 호출 하거나 RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="54084616a21d75658db0216e6ad990b71f0f3457" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">여러 프로세서에서 프로그램을 실행하는 방법에는 두 가지가 있습니다. 프로그램에서 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; 를 호출 하거나 RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="092fc3bbaa6aff2c322b0758396d9aa0b8912b0f" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">여러 프로세서에서 프로그램을 실행하는 방법에는 프로그램에서 &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; 를 호출 하거나 RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">원하는만큼 파일 헤더 프라그 마가있을 수 있으며 앞에 주석이 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">연관된 유형 동의어에 대해 최대 하나의 기본 선언이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322113e89338d2edb0df8de43c1eb5e1cfd90dc4" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;../bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 여러 호출이있을 수 있지만 각 호출은 &lt;code&gt;hs_exit()&lt;/code&gt; 하나의 호출과 일치해야합니다 . 가장 바깥쪽에있는 &lt;code&gt;hs_exit()&lt;/code&gt; 는 실제로 시스템 초기화를 해제합니다. 현재 GHC의 런타임은 이런 일이 발생한 후에 안정적으로 다시 초기화 할 수 없습니다. &lt;a href=&quot;../bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 여러 호출이있을 수 있지만 각각은 &lt;code&gt;hs_exit()&lt;/code&gt; 한 번의 호출과 일치해야합니다 . 가장 바깥 쪽 &lt;code&gt;hs_exit()&lt;/code&gt; 는 실제로 시스템을 초기화 해제합니다. 현재 GHC의 런타임은이 문제가 발생한 후 안정적으로 다시 초기화 할 수 없습니다. &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;외부 기능 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">&quot; &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; &quot;옵션은 하나만있을 수 있지만 (예 : 위의 예에서 -hr ) 적용 할 수있는 추가 제한 수에는 제한이 없습니다. 모든 옵션은 한 가지 예외가 결합 될 수있다 : GHC는 현재 혼합 지원하지 않습니다 &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt; 옵션을.</target>
        </trans-unit>
        <trans-unit id="94e3121ab462249427193d1d9fad3fc4ffc53a3c" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types&quot;&gt;wiki page dedicated to the linear types extension&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types&quot;&gt;선형 유형 확장 전용 위키 페이지&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">&lt;code&gt;RtsConfig&lt;/code&gt; 유형의 변수를 초기화하는 데 사용해야 하는 기본값 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 가 있습니다 . 앞으로 더 많은 필드가 &lt;code&gt;RtsConfig&lt;/code&gt; 에 추가 될 것이므로 앞으로 코드를 호환 가능하게하려면 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 로 초기화 한 다음 위의 코드 샘플에서와 같이 필수 필드를 수정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">컴파일 안전성 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt; 의 몇 가지 잠재적 인 솔루션과 관련된 문제에 대한 자세한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ef9b54093e73b5247e6192453bb1d4451bfc02a" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt; 에는 컴파일 안전과 관련된 몇 가지 잠재적 솔루션에 대한 자세한 논의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 사이에는 미묘한 차이가 있습니다 ! x 는 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이와 유사합니다 . 게으른 값 &lt;code&gt;x&lt;/code&gt; 에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;반환하십시오 &lt;/a&gt; . x 는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-exception#v:evaluate&quot;&gt;평가&lt;/a&gt; 하면 항상 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 생성됩니다 . 조치는시 예외가 발생합니다 것을 &lt;em&gt;실행&lt;/em&gt; IFF에 &lt;code&gt;x&lt;/code&gt; 는 시 예외가 발생 &lt;em&gt;평가&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="566104a98981fe95741524bb050f2354c55f9f53" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">사이에 미묘한 차이가 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이점과 유사합니다 . 게으른 값의 경우 &lt;code&gt;x&lt;/code&gt; 예외, 발생 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;평가&lt;/a&gt; 는 항상 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업을 생성합니다 . 그 액션은 &lt;em&gt;실행&lt;/em&gt; 시 예외를 던질 것입니다. 만약 &lt;code&gt;x&lt;/code&gt; 가 &lt;em&gt;평가&lt;/em&gt; 시 예외를 던지면 .</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 사이에는 미묘한 차이가 있습니다 ! x 는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이와 유사합니다 . 게으른 값 &lt;code&gt;x&lt;/code&gt; 에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;반환하십시오 &lt;/a&gt; . x 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;평가&lt;/a&gt; 하면 항상 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 생성됩니다 . 조치는시 예외가 발생합니다 것을 &lt;em&gt;실행&lt;/em&gt; IFF에 &lt;code&gt;x&lt;/code&gt; 는 시 예외가 발생 &lt;em&gt;평가&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3600233714778db16c8732014dac5c73f6412ae4" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">사이에 미묘한 차이가 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이점과 유사합니다 . 게으른 값의 경우 &lt;code&gt;x&lt;/code&gt; 예외, 발생 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;평가&lt;/a&gt; 는 항상 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업을 생성합니다 . 그 액션은 &lt;em&gt;실행&lt;/em&gt; 시 예외를 던질 것입니다. 만약 &lt;code&gt;x&lt;/code&gt; 가 &lt;em&gt;평가&lt;/em&gt; 시 예외를 던지면 .</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">교착 상태 감지와 종료 자 ( &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; 의 함수에 의해 생성됨) 간에 미묘한 상호 작용이 있습니다 . 스레드가 종료자가 실행되기를 기다리는 동안 차단되면 스레드가 교착 상태로 간주되어 예외가 전송됩니다. 따라서이 작업을 수행하지 않는 것이 좋지만 대안이없는 경우 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 이이를 가리 키도록 하여 스레드가 교착 상태로 간주되는 것을 방지 할 수 있습니다. 나중에 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 을 해제하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">불법 문자 처리 방법을 지정하는 추가 표기법 (GNU iconv에서 차용)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;스마트 생성자에&lt;/a&gt; 대한 광범위한 Haskell 민속 예술이 있습니다 . 본질적으로 생성자를 둘러싼 유효성 검사를 감싸고 해당 표현을 노출시키지 않는 함수입니다. 단점은 기본 생성자를 매 처로 사용할 수 없다는 것입니다. 패턴 동의어는 유효성 검사 및 일치를 위해 진정한 스마트 생성자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">프로파일 링에 의해 거주자 수치에서 차감되는 프로파일 링 자체의 오버 헤드가 있습니다. 물론 프로파일 링 지원없이 컴파일 할 때이 오버 헤드가 사라집니다. 공간 오버 헤드는 현재 힙 개체 당 2 개의 추가 단어이므로 약 30 %의 오버 헤드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bfeebc74cf73d84eb55c954269428d758e871dbb" translate="yes" xml:space="preserve">
          <source>There is currently no support for multiplicity annotations such as &lt;code&gt;x :: a %p&lt;/code&gt;, &lt;code&gt;\(x :: a %p) -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;x :: a %p&lt;/code&gt; , &lt;code&gt;\(x :: a %p) -&amp;gt; ...&lt;/code&gt; 와 같은 다중 주석은 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">현재 &quot;스택 추적&quot;을 얻을 수있는 지원은 없지만 추적 및 기록 기능은 유용한 두 번째 최고를 제공하며, 이는 종종 오류 컨텍스트를 설정하기에 충분합니다. 예를 들어, 컴파일 된 코드에서 예외가 발생하더라도 예외가 발생하면 자동으로 중단 될 수 있습니다 ( &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;예외 디버깅&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; 유형에는 정확히 하나의 값이 있으므로 인코딩 할 때 지식이 필요 없으며 0 비트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 가 없습니다 . 현지 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 절대 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="19ed2f198aae585d94d8de2a49be348554775e93" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 는 없습니다 . 현지 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 절대 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f32d02061bc32b68cf56c079b75b5a16fbbf4b0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 는 없습니다 . 현지 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 을 사용 하세요 . 절대 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">&lt;code&gt;deRefStableName&lt;/code&gt; 작업 이 없습니다 . 안정된 이름에서 원래 Haskell 객체로 돌아올 수 없습니다. 그 이유는 객체의 안정적인 이름이 있다고해서 객체 자체의 존재를 보장하지 않기 때문입니다. 여전히 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">&lt;code&gt;freeStableName&lt;/code&gt; 과 달리 &lt;a href=&quot;foreign-stableptr&quot;&gt;freeStableName&lt;/a&gt; 작업 이 없습니다 . 더 이상 필요하지 않은 경우 런타임 시스템이 안정적인 이름을 회수합니다.</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">더 없다 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; 또는 &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 가 태그되도록 소스의 주석, &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 읽기 전에 항상 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; 를 호출하기 때문에 읽기 버퍼에 해당하는 조작이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">기존 유형의 이름 만 바꾸는 newtypes에는 영향을 미치지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">평가 순서는 보장되지 않습니다. 구현은 구조물의 구성 요소를 임의의 순서로 또는 병렬로 평가할 수있다. 평가시 실제 주문을 하려면 &lt;code&gt;parallel&lt;/code&gt; 패키지의 &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; 에서 &lt;code&gt;pseq&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">지연 시간이 만료되면 스레드가 즉시 다시 예약 될 것이라는 보장은 없지만 스레드가 지정된 것보다 &lt;em&gt;빨리&lt;/em&gt; 실행되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">모든 소스 파일을 &lt;code&gt;ghc -M&lt;/code&gt; 명령 에 대한 인수로 나열 할 필요는 없습니다 . &lt;code&gt;ghc&lt;/code&gt; 는 &lt;code&gt;ghc --make&lt;/code&gt; (GHC 6.4의 새로운 기능) 와 같이 종속성을 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">소스 에는 엄격함 ( &lt;code&gt;!&lt;/code&gt; ) 또는 게으름 ( &lt;code&gt;~&lt;/code&gt; ) 주석이 없으므로 &lt;code&gt;'NoSourceStrictness&lt;/code&gt; 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b022fa6b4de80677bbfc2a36b1ae5a9a3723a85" translate="yes" xml:space="preserve">
          <source>There is no support for linear pattern synonyms.</source>
          <target state="translated">선형 패턴 동의어에 대한 지원이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">&lt;code&gt;Danger&lt;/code&gt; 가 가져올 수 있는 모듈에 제한을 두는 방법은 없습니다 . 이를 통해 &lt;code&gt;Danger&lt;/code&gt; 의 작성자 는 시스템에 현재 설치된 모든 패키지에 대해 매우 큰 공격 영역을 제공합니다. 이러한 패키지 중 하나에 취약점이 있으면 &lt;code&gt;Danger&lt;/code&gt; 모듈이이를 악용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">초기 데이터 이외의 다른 입력을 제공 할 방법이 없습니다. 점진적으로 더 많은 데이터를 제공하려면 증분 입력 인터페이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">이제 가져 오기 및 내보내기 목록에 약간의 모호성이 있습니다. 예를 들어 &lt;code&gt;import M( (+) )&lt;/code&gt; 을 작성 하면 &lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 또는 &lt;em&gt;형식 생성자 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 를 의미 합니까? 기본값은 전자이지만 &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됨 )를 사용하면 GHC를 사용하여 후자를 키워드 &lt;code&gt;type&lt;/code&gt; 으로 시작 하여 후자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="447a4ae19a6034b9c2aff03899064c3f4858ff91" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;explicit_namespaces#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">이제 가져 오기 및 내보내기 목록에 잠재적 인 모호성이 있습니다. 예를 들어 &lt;code&gt;import M( (+) )&lt;/code&gt; 을 작성 하면 &lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 또는 &lt;em&gt;유형 생성자 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 를 의미 합니까? 기본값은 전자이지만 &lt;a href=&quot;explicit_namespaces#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됨 )를 사용하면 GHC를 사용하면 키워드 &lt;code&gt;type&lt;/code&gt; 을 앞에 추가하여 후자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">하나의 가장자리 경우가 있습니다 : &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 현재 항상 빈리스트 (상관없이 생산 &lt;code&gt;tys&lt;/code&gt; 제공됩니다).</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">이 일반적인 규칙에는 한 가지 예외가 있습니다. : load로 프로그램을 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 하거나 &lt;code&gt;ghci&lt;/code&gt; 를 호출 할 때 프로그램을 지정 하면 모듈 이름 대신 파일 이름을 지정할 수 있습니다. 이 파일 이름은 존재하는 경우로드되며 원하는 모듈을 포함 할 수 있습니다. 동일한 디렉토리에 여러 개의 &lt;code&gt;Main&lt;/code&gt; 모듈이 있고 &lt;code&gt;Main.hs&lt;/code&gt; 를 모두 호출 할 수없는 경우에 특히 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">설명해야 할 까다로운 사례가 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">구문상의 모호성에는 한 가지 문제가 있습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25f515351416a88c7165a7d23467301f2a1ae98e" translate="yes" xml:space="preserve">
          <source>There is room for extra information in the event type specification, which can be ignored by older tools.</source>
          <target state="translated">이전 도구에서는 무시할 수있는 이벤트 유형 사양에 추가 정보를위한 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCi가 prelude 및 표준 라이브러리를로드하는 동안 잠시 일시 중지 될 수 있으며 그 후에 프롬프트가 표시됩니다. 배너에서 알 수 있듯이 &lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;사용 가능한 명령 목록과 각 명령에 대한 반줄 설명을 봅니다. 우리는이 명령들 대부분을 설명 할 &lt;a href=&quot;#ghci-commands&quot;&gt;것이며 GHCi 명령의&lt;/a&gt; 모든 명령들에 대한 완전한 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">같은 키를 가진 약한 포인터가 여러 개있을 수 있습니다. 이 경우 이러한 약한 포인터 각각에 대한 종료자는 모두 임의의 순서로 또는 키가 죽을 때 동시에 실행됩니다. 프로그래머가 오브젝트에 대한 유일한 참조 (예 : 닫고 싶은 파일)를 가지고 있다고 가정하는 종료자를 지정하면, 프로그래머는 그러한 종료자가 하나만 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma에는 세미콜론으로 구분 된 규칙이 0 개 이상있을 수 있습니다 (레이아웃 규칙에 의해 생성 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">토큰에 공백이 없어야합니다. &lt;code&gt;[quoter|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">값 선언은 없어야하지만 값에 대한 형식 서명이있을 수 있습니다. 예를 들어 서명을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">값 선언은 없어야하지만 값에 대한 형식 서명이있을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">모호한 다시 쓰기 시스템을 정의하지 않도록 유형 패밀리의 방정식에 약간의 제한이 있어야합니다. 따라서 개방형 패밀리의 방정식은 호환 가능하도록 제한됩니다. 두 가지 유형의 패턴이 호환되는 경우</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 또 다른 변형 (즉 &lt;code&gt;Par0&lt;/code&gt; )이 있었지만 이후에는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;동시성&lt;/em&gt; 과 &lt;em&gt;병렬&lt;/em&gt; 처리는 잘 구분되어 있습니다 . 병렬 처리는 여러 프로세서를 동시에 사용 하여 프로그램을 &lt;em&gt;더 빠르게&lt;/em&gt; 실행하는 &lt;em&gt;것&lt;/em&gt; 입니다. 반면에 동시성은 추상화의 수단입니다. 여러 비동기 이벤트에 응답해야하는 프로그램을 구성하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">거기 만들 수있는 특수 기능의 &lt;code&gt;StablePtr&lt;/code&gt; : &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; 는 RTS가 필요하기 때문에, &lt;code&gt;StablePtr&lt;/code&gt; 을 원시에 &lt;code&gt;MVar#&lt;/code&gt; 객체, 우리는 바로 그것을 만들 수 없습니다. 마십시오 &lt;em&gt;하지&lt;/em&gt; 만 사용 &lt;code&gt;newStablePtr&lt;/code&gt; 온 &lt;code&gt;MVar&lt;/code&gt; : 프로그램이 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">&lt;code&gt;CYGWIN&lt;/code&gt; 환경 변수에 &lt;code&gt;tty&lt;/code&gt; 가 포함되어 있지 &lt;em&gt;않으면&lt;/em&gt; Cygwin 쉘을 사용할 수 있습니다 . 이 모드에서 Cygwin 쉘은 Windows 콘솔 쉘처럼 작동하며 콘솔 이벤트는 하위 프로세스로 전파됩니다. 있습니다 &lt;code&gt;CYGWIN&lt;/code&gt; 환경 변수를 설정해야합니다 &lt;em&gt;전에&lt;/em&gt; Cygwin에서 쉘을 시작; 나중에 변경해도 쉘에는 영향을 미치지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">외부 라이브러리를 사용하는 경우 다른 한 잡았다 염두에 곰에있다 : 라이브러리가 포함되어있는 경우 &lt;code&gt;main()&lt;/code&gt; 함수를 다음이 GHC 자신과 링크 충돌이 될 것입니다 &lt;code&gt;main()&lt;/code&gt; (기능 예. &lt;code&gt;libf2c&lt;/code&gt; 및 &lt;code&gt;libl&lt;/code&gt; 자신이 &lt;code&gt;main()&lt;/code&gt; 들 ).</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 함수 패밀리 중 하나를 호출 할 때 모든 예외 핸들러 주위에 묵시적인 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 가 있습니다. 이는 대부분의 시간이 필요하기 때문입니다. 예외 처리기가 시작될 때 스택에 다른 예외를 처리 할 예외 처리기가 없을 수 있기 때문에 예외 처리기를 시작할 때 일반적인 경쟁 조건이 제거됩니다. 그러나 핸들러를 입력 할 때 비동기 예외가 마스킹되면 중단되기 전에 새 예외 핸들러를 설치할 시간이 있습니다. 이것이 기본값이 아닌 경우 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e29544df8c9d4e04c3badac10c4c4870ef74b9a" translate="yes" xml:space="preserve">
          <source>There's even a generic way to handle empty values (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, etc.):</source>
          <target state="translated">빈 값을 처리하는 일반적인 방법 ( &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 등)도 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a5307d79c12db0a4b7ba47ec7441e99dc9f60b" translate="yes" xml:space="preserve">
          <source>Therefore the type of an untyped quotation in GHC is `Quote m =&amp;gt; m Exp`</source>
          <target state="translated">따라서 GHC에서 유형이 지정되지 않은 견적 유형은`Quote m =&amp;gt; m Exp`입니다.</target>
        </trans-unit>
        <trans-unit id="6b1f8f78c4b21b4ebde0207b0aeba4e07d56d547" translate="yes" xml:space="preserve">
          <source>Therefore, if we run GHC against the following code using the plugin from above:</source>
          <target state="translated">따라서 위의 플러그인을 사용하여 다음 코드에 대해 GHC를 실행하면 :</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">이러한 &lt;code&gt;Names&lt;/code&gt; 은 템플릿 하스켈 표현식, 패턴, 선언 등을 구성하는 데 사용될 수 있습니다. 또한 &lt;code&gt;reify&lt;/code&gt; 함수에 대한 인수로 제공 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">이러한 RTS 옵션은 (a) GHC 버그를 피하기 위해, (b)&amp;ldquo;실제로 발생하는 상황&amp;rdquo;을 확인하기 위해 또는 (c) 기분이 좋아서 사용할 수 있습니다. 매일 사용하지 않는 것이 좋습니다!</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">Hongwei Xi와 Tim Sheard의 논문에 이러한 사례와 기타 여러 사례가 나와 있습니다. &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;위키에&lt;/a&gt; 대한 더 긴 소개 가 &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;있으며 팬텀 유형&lt;/a&gt; 의 Ralf Hinze의 Fun 에는 많은 예제가 있습니다. 논문은 GHC에서 구현 된 것과 다른 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d9b83f5fd62464360061e6d169acf40021dc88" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;https://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">이러한 예와 다른 많은 예는 Hongwei Xi와 Tim Sheard의 논문에 나와 있습니다. &lt;a href=&quot;https://www.haskell.org/haskellwiki/GADT&quot;&gt;wiki에&lt;/a&gt; 대한 더 긴 소개 가 있으며 Ralf Hinze의 &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom 유형&lt;/a&gt; 에도 많은 예제가 있습니다. 논문은 GHC에서 구현 된 것과 다른 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">이들은 각각 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; 로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">이것들은 &lt;em&gt;신뢰할 수있는&lt;/em&gt; 모듈 데이터에서 &lt;a href=&quot;data-coerce&quot;&gt;얻을&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">다음은 데이터 생성자가 다형성 인수 유형을 갖는 &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;newtype&lt;/code&gt; 선언의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">이들은 프로그램이 실행되도록 컴파일 된 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">이들은 GHC 자체가 컴파일 된 플랫폼입니다. 다시 말하지만, 이는 일반적으로 빌드 및 대상 플랫폼과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">이들은 프로그램이 구축 된 플랫폼입니다. (즉, GHC 자체의 대상 플랫폼입니다.) 일반적으로 이것은 대상 플랫폼과 동일합니다. 크로스 컴파일하면 잠재적으로 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">이러한 속성은 모든 속성이 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">버그 나 성능 문제를 조사하는 데 유용 할 수 있습니다. 프로덕션 코드에서는 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">이러한 기능은 직접 대응 &lt;code&gt;cub&lt;/code&gt; , &lt;code&gt;cud&lt;/code&gt; , &lt;code&gt;cub1&lt;/code&gt; , &lt;code&gt;cud1&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">이러한 문자는 공백, 작은 따옴표, 큰 따옴표 및 백 슬래시 문자입니다. 백 슬래시 문자는 항상 뒤에 오는 문자를 이스케이프합니다 (즉, 추가 고려없이 통과 함). 따옴표를 사용하여 블록에서 문자를 이스케이프 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;편지&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;마크&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;숫자&quot;가 아닌 것이 무엇인지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서에서 &quot;문장&quot;이 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;분리기&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;기호&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19c62646b51deb3633a6d39d0c6ae999d0c5d784" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;편지&quot;가 무엇이고 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7e8ba0bfda8d8d856d1195f3b3b7ce5c153b9ba0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;마크&quot;가 무엇인지 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d54be1da1d383c2b311f8f56c474dac56684b053" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;숫자&quot;가 무엇인지 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="438496159c2e65a90e159a06d8c49e17c47a3199" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;구두점&quot;이 무엇이고 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2d4f46e5583cd4b0d09be2a2692dbfa6cb8a95d5" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;분리기&quot;가 무엇이고 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0044eb8f352d307e6606ff059288ad3a4e298068" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서에서 &quot;기호&quot;가 무엇인지, 아닌지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">이 클래스는 휴대용 Haskell에서 변압기 인수에 대한 제약 조건을 표현하는 데 필요합니다. 따라서 새로운 변환기 &lt;code&gt;T&lt;/code&gt; 의 경우 다음과 같은 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">이러한 고려 사항은 다음과 같은 고아 모듈 정의로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">이들은 파라 메트릭으로 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">이러한 이벤트는 &lt;em&gt;항상&lt;/em&gt; GHC 시스템의 버그이므로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="588a8548c6363993d22d2b7e86c47e328069a514" translate="yes" xml:space="preserve">
          <source>These events are typically produced during program startup and describe the environment which the program is being run in.</source>
          <target state="translated">이러한 이벤트는 일반적으로 프로그램 시작 중에 생성되며 프로그램이 실행되는 환경을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7e9e62a89c4ce54bd1d84649823a3e3080b1425a" translate="yes" xml:space="preserve">
          <source>These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;non-moving collection&lt;/code&gt;&lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</source>
          <target state="translated">이러한 이벤트는 &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;non-moving collection&lt;/code&gt; &lt;/a&gt; 수명주기 의 다양한 단계를 표시 합니다. &lt;code&gt;+RTS -lg&lt;/code&gt; 이벤트 세트 로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bf8fa1560225f49387556fff72128a8cf04cff5" translate="yes" xml:space="preserve">
          <source>These examples can be made to typecheck by eta-expansion. For example &lt;code&gt;f3 (\x -&amp;gt; g3b x)&lt;/code&gt; is well typed, and similarly &lt;code&gt;f3 (\x -&amp;gt; g3c x)&lt;/code&gt; and &lt;code&gt;f4 (\x -&amp;gt; g4 x)&lt;/code&gt;.</source>
          <target state="translated">이 예제는 eta-expansion으로 typecheck를 만들 수 있습니다. 예를 들어 &lt;code&gt;f3 (\x -&amp;gt; g3b x)&lt;/code&gt; 는 잘 입력되고 비슷하게 &lt;code&gt;f3 (\x -&amp;gt; g3c x)&lt;/code&gt; 및 &lt;code&gt;f4 (\x -&amp;gt; g4 x)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">이 플래그는 모듈에 &quot;고아&quot;인스턴스 선언 또는 다시 쓰기 규칙이 포함될 때마다 경고가 발생합니다. 인스턴스 선언은 클래스와 인스턴스 유형이 같은 모듈에서 선언되지 않은 모듈에 나타나는 경우 고아입니다. 규칙이 다른 모듈에서 선언 된 함수에 대한 규칙 인 경우 고아입니다. 고아를 포함하는 모듈을 고아 모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">이 플래그는 다른 백엔드에서 다양한 정보 비트를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">이 플래그는 GHC의 프론트 엔드에서 다양한 정보를 덤프합니다. 여기에는 파서 및 인터페이스 파일 판독기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">이 플래그는 GHC의 타입 체커 및 리 네이터로부터 다양한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="2dc9a8e0f094a600546405a33b0a5ef835899c04" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</source>
          <target state="translated">이 플래그는 GHC의 C-- 파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">이 플래그는 GHC C-\-파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">이 플래그는 GHC의 코어-코어 파이프 라인의 다양한 단계를 덤프합니다. 이것은 디 슈거 러로 시작되며 단순화 기, 작업자 래퍼 변환, 규칙 엔진, 전문가, 엄격 성 / 발생 성 분석기 및 공통 하위 식 제거 패스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">이 플래그는 GHC STG 파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="50fcdcd1fe44bc0c3ab929a2c58bbb80cb13f620" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</source>
          <target state="translated">이러한 플래그 는 C로 시작 하는 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기&lt;/a&gt; 파이프 라인 의 다양한 단계를 덤프 하고 네이티브 어셈블러를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">이 플래그 는 C-\-로 시작하고 기본 어셈블러를 생성 하는 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;기본 코드 생성기&lt;/a&gt; 파이프 라인 의 다양한 단계를 덤프 합니다.</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 개별 최적화를 켜고 끕니다. 기본적으로 on으로 표시된 플래그는 &lt;code&gt;-O&lt;/code&gt; 에 의해 활성화 되므로 명시 적으로 설정할 필요가 없습니다. &lt;code&gt;-fwombat&lt;/code&gt; 플래그 는 다음과 같이 말함으로써 무효화 될 수 있습니다. &lt;code&gt;-fno-wombat&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">표준 유형에 대한 이러한 포맷터는 새로운 유형별 포맷터를 작성하는 데 편의를 위해 제공됩니다. 일반적인 패턴은 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; 로 던지는 것입니다 새 유형에 대한 대부분의 포맷 처리를 수행 로 입니다.</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">이 네 가지 속성은 안전한 언어로 형식을 신뢰할 수 있고 모듈 내보내기 목록이 존중된다는 것을 신뢰할 수 있으며 성공적으로 컴파일 된 코드는 평상시와 동일한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 &lt;a href=&quot;prelude&quot;&gt;Prelude에서&lt;/a&gt; 내보내기도합니다. .</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">이러한 함수는 항상 ASCII를 가정하지 않고 현재 로케일에 의해 결정된 인코딩을 사용한다는 점에서 &lt;code&gt;CAString&lt;/code&gt; 대응 기능과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">이러한 함수는 인스턴스화되는 유형에 따라 다른 결과를 반환해야하기 때문에 오버로드됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">이 함수는 시프트되는 양이 기계 Int #의 비트 크기보다 클 때 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">이러한 함수는 내부적으로 다양한 오류를 발생시키기 위해 사용되며 새로운 유형별 포맷터에서 사용하기 위해 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">이 함수를 사용하여 새로운 대수 유형에 대한 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스 를 어셈블 할 수 있습니다 . 예를 들어, 정의가 주어지면</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">이 함수는 levity-polymorphic 변수를 바인딩하지 않으므로 허용됩니다. 이들의 다형성을 통해 사용자는 박스를 사용하지 않는 유형을 반환하는 함수를 편리하게 스텁 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044a64ee1e082d15f5fc359f3ff870486d8b309f" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="translated">이러한 함수 는 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; 유형 클래스의 메서드를 기반으로한다는 점을 제외하고 &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception의&lt;/a&gt; 함수를 따릅니다 . API 사용에 대해서는 &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e87eeae99023d3ede05957d0fd11586bb75cb64" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="translated">이러한 함수 는 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; 유형 클래스의 메서드를 기반으로한다는 점을 제외하고 &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception의&lt;/a&gt; 함수를 따릅니다 . API 사용에 대해서는 &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">이 함수는 임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작을 종료 자로 허용 하여 이식 가능한 &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; 모듈 에서 이름을 일반화합니다 . 이러한 종료자는 반드시 별도의 스레드에서 실행됩니다 (cf. 2003 년 &lt;em&gt;POPS&lt;/em&gt; Hans Boehm의 &lt;em&gt;소멸자, 종료 자 및 동기화&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">이 함수는 시퀀스의 왼쪽 또는 오른쪽 끝에서 순차적으로 검색하여 일치하는 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">이러한 함수 는 훨씬 유연한 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 보다 이전 버전 입니다.</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">이 함수는리스트 &lt;code&gt;xs&lt;/code&gt; 를 인덱스 콜렉션으로 취급하며 인덱스 범위는 0에서 &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">이 함수는리스트 &lt;code&gt;xs&lt;/code&gt; 를 인덱스 콜렉션으로 취급하며 인덱스 범위는 0- &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">이러한 인스턴스는 암시 적 종류 매개 변수가 다르기 때문에 호환됩니다. 첫 번째는 &lt;code&gt;Type&lt;/code&gt; 을 사용 하고 두 번째는 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">이 매크로는 GHC 7.10.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">이 매크로는 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 이 제공하는 것보다 세밀한 정보를 제공하기 위해 제공됩니다 . 일반적으로 패치 수준 릴리스간에 대부분의 API가 안정적으로 유지 될 것으로 예상되기 때문에 필요하지 않지만 때때로 버그를 수정하기 위해 내부 API 변경이 필요합니다. 패치 레벨에서 조건부 컴파일은 이전 릴리스의 버그를 해결하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">이러한 매크로는 Haskell 모듈에서 생성 된 C 소스 (예 : &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; 및 &lt;code&gt;.hc&lt;/code&gt; )를 포함하여 Haskell 소스 및 C 소스를 사전 처리 할 때 설정됩니다. 파일)를 .</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">이 모듈은 Prelude 기능과의 이름 충돌을 피하기 위해 수입 규정을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b4ffdd3087b092dcee0cb235ee95a5ddd25f36" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">이러한 작업은 각각 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;0#&lt;/code&gt; 및 &lt;code&gt;1#&lt;/code&gt; 반환 합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool 위키 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">이러한 연산은 각각 &lt;code&gt;False&lt;/code&gt; 와 &lt;code&gt;True&lt;/code&gt; 대신 &lt;code&gt;0#&lt;/code&gt; 과 &lt;code&gt;1#&lt;/code&gt; 반환 합니다. 자세한 내용은 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool 위키 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7ccd9c5b4911eda91ad51529b53aa771bb31514" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">이러한 작업은 각각 &lt;code&gt;False&lt;/code&gt; 및 &lt;code&gt;True&lt;/code&gt; 대신 &lt;code&gt;0#&lt;/code&gt; 및 &lt;code&gt;1#&lt;/code&gt; 반환 합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool 위키 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : platform-dependent flags에&lt;/a&gt; 자세히 설명되어 있습니다 . 플래그가 &lt;code&gt;-O&lt;/code&gt; 에 의해 내포되면 플래그 설명에 명시 적으로 다르게 명시되지 않는 한 &lt;code&gt;-O2&lt;/code&gt; 에도 내포됩니다 . 플래그에 &lt;code&gt;-O0&lt;/code&gt; 만 내포 된 경우 플래그는 &lt;code&gt;-O&lt;/code&gt; 및 &lt;code&gt;-O2&lt;/code&gt; 로 내포되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;최적화 (코드 개선)에&lt;/a&gt; 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">이 옵션은 치명적인 것으로 간주되는 경고를 제어하고 컴파일을 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">이 옵션은 프로그램 실행 및 가비지 수집기의 시간, 할당 된 메모리의 양, 힙의 최대 크기 등과 같은 런타임 시스템 통계를 생성합니다. 세 가지 변형은 서로 다른 세부 수준을 제공합니다. &lt;code&gt;-T&lt;/code&gt; 는 데이터를 수집하지만 출력을 생성하지 않습니다. &lt;code&gt;-t&lt;/code&gt; GHC의 &lt;code&gt;-Rghc-timing&lt;/code&gt; 옵션 과 동일한 형식으로 단일 출력 라인을 생성합니다. &lt;code&gt;-s&lt;/code&gt; 는 프로그램과 &lt;code&gt;-S&lt;/code&gt; 는 추가로 각각의 모든 가비지 콜렉션에 대한 정보를 생성합니다. &lt;code&gt;--internal-counters&lt;/code&gt; 전달스레드 된 런타임에 대한 자세한 요약은 실행 중에 누적 된 다양한 내부 수를 포함합니다. 이들은 지정되지 않았으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c0ab9812442b7cb897140c469f1cac49b38dcf7" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">이러한 오버 헤드는 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 다른 생성자로 압축 해제 될 때 모두 1 워드 (4 또는 8 바이트)로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;ByteString&lt;/code&gt; 을 다른 생성자로 압축 해제하면 이러한 오버 헤드를 모두 1 워드 (4 또는 8 바이트) 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">이 문서와 화살표에 대한 자세한 내용은 &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="980eb694aecbc7d843eb7aedc5a7c4e4407cf823" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">이러한 문서와 화살표에 대한 자세한 정보는 &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 패턴은 GHC 버전 8.0 이상에서만 사용 가능하며 버전 8.2는 더 잘 작동합니다. 이러한 최신 버전의 GHC를 작성할 때 &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있는 대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; 패턴을 사용할 수 있습니다 . &amp;lt;| , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">이들은 잠재적으로 중복되지만 GHC는 플래그 설정에 관계없이 인스턴스 선언 자체에 대해 불평하지 않습니다. 나중에 제약 조건 &lt;code&gt;(C Int Char)&lt;/code&gt; 을 해결하려고 하면 첫 번째 인스턴스 만 일치하고 모두 잘됩니다. &lt;code&gt;(C Bool Bool)&lt;/code&gt; 과 유사합니다 . 그러나 &lt;code&gt;(C Int Bool)&lt;/code&gt; 을 해결하려고하면 두 인스턴스가 모두 일치하고 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">이 pragma는 함수 정의의 인라인을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">이러한 제한 사항은 쉽게 확인되고 형식 유추가 종료되도록합니다. 그러나 유형 변수의 재귀 발생이 패밀리 응용 프로그램 아래에있는 &lt;code&gt;a ~ [F a]&lt;/code&gt; 와 같은 소위 &quot;루피 평등&quot;이있는 경우 유형 유추의 완전성을 보장하기에 충분하지 않습니다 . 데이터 생성자 응용 프로그램-자세한 내용은 위에서 언급 한 논문을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f701b27c6f77c55b38a0a5e6d91357571f66567" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">이러한 제한은 쉽게 확인되며 유형 추론의 종료를 보장합니다. 그러나,이 같은 정도로 '깨어나 등식'호출의 존재에 입력 추론 보증 완전성에 충분하지 &lt;code&gt;a ~ [F a]&lt;/code&gt; , 여기서, 타입 변수 재귀 발생 가족 애플리케이션 아래이고 데이터 생성자 응용 프로그램-자세한 내용은 위에서 언급 한 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항으로 인해 인스턴스 확인이 종료됩니다. 각 축소 단계는 하나 이상의 생성자에 의해 문제가 더 작아집니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;제약 조건 처리 규칙을 통한 기능적 종속성 이해&lt;/a&gt; 문서에서 이러한 제한 이유에 대한 많은 배경 자료를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">이 규칙은 레코드 와일드 카드를 사용자가 확장 버전을 작성할 수있는 상황으로 제한합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3572299793ccce6d8d28737f8cbd5463ebd7fbd6" translate="yes" xml:space="preserve">
          <source>These two types of folds are typified by the left-associative strict &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` and the right-associative lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 두 가지 유형의 폴드는 왼쪽 연관 strict &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 및 오른쪽 연관 lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 로 대표 됩니다.</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">이러한 유형은 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 에 가변 개수의 인수 처리를 구현하는 데 필요합니다 . 그들의 구현은 의도적으로이 모듈에서 보이지 않습니다. 적절한 클래스의 인스턴스가 아닌 유형의 인수를 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 에 전달하려고 시도 하면 컴파일러는이를 누락 된 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 인스턴스로보고합니다 . (모두 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">이러한 유형은 Haskell의 C 라이브러리 인터페이스에 액세스하기 위해 C 함수 프로토 타입을 정확하게 나타 내기 위해 필요합니다. Haskell 시스템은 C와 같은 유형을 정확하게 표현할 필요는 없지만 Haskell 유형과 관련하여 다음과 같은 보증이 제공됩니다. &lt;code&gt;CT&lt;/code&gt; C 유형 &lt;code&gt;t&lt;/code&gt; 를 나타내는 CT .</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 은 S의 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스 및있는 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 을 . 이는 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; (각각 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; )의 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 인스턴스를 의미합니다 . &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; (각각 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ) 만큼 나쁘게 행동 합니다.</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 이란 기본 외국인 종류의, 그리고 인스턴스 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 은 의에서 유형의 &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; 및 &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 의 인스턴스 및있는 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">위 함수의 이러한 변형은 유니 코드를 모르는 C 라이브러리와 함께 사용하기위한 것입니다. 정보 손실이 발생할 수 있으므로 이러한 기능은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">위 함수의 이러한 변형은 시스템에 따라 C &lt;code&gt;wchar_t&lt;/code&gt; 유형을 사용하여 유니 코드를 인코딩하는 C 라이브러리와 함께 사용됩니다 . 지원되는 유일한 인코딩은</target>
        </trans-unit>
        <trans-unit id="d4df89c18ae8de17d49ca0683c16ba6bdd50a129" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="translated">입력이 끝나면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="50f263b93d3c7ccbcb56063a272d2935f84a444b" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="translated">입력이 끝나면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">그들은 말할 &lt;code&gt;make&lt;/code&gt; 의 경우 것으로 &lt;code&gt;Foo.o&lt;/code&gt; , &lt;code&gt;Foo.hc&lt;/code&gt; 또는 &lt;code&gt;Foo.s&lt;/code&gt; 이 보다 이전의 수정 날짜가 &lt;code&gt;Baz.hi&lt;/code&gt; 을 한 후 오래된 파일이 최신 상태로 만들어야합니다. 지금까지 그것을 가지고 &lt;code&gt;make&lt;/code&gt; 그렇게 할 규칙 보이는; 앞의 접미사 규칙 중 하나가 작업을 훌륭하게 수행합니다. 이러한 의존성은 &lt;code&gt;ghc&lt;/code&gt; 에 의해 자동으로 생성 될 수 있습니다 . &lt;a href=&quot;#makefile-dependencies&quot;&gt;의존성 생성&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">그것들은 Simon Peyton Jones, Andrew Gordon, Sigbjorn Finne 의 논문 &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; 에 소개 되었지만, 그 구현에 대한 세부 사항은 그 이후로 변경되었지만 (특히 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이제 단순히 블록을 오류로 사용하지만. )</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">알아야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="7491f2cc71840e16ed3ed05e5fb825c9e4a1db46" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">이 &quot;기능&quot;은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 와 피상적으로 유사 하지만 실제로는 혼돈의 악의적 인 에이전트입니다. 일반 규칙이 더 이상 적용되지 않도록 현실의 이음새 (및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드)를 선택 해제합니다. 그것은 합리적이라고 생각하도록 당신을 달래 주지만, 당신이 보지 않을 때 그것은 당신을 뒤에서 찌르고 모든 가변 버퍼를 별칭으로 만듭니다. 노련한 하스켈 프로그래머의 시체가 발 밑에 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">이 &quot;기능&quot;은 &lt;code&gt;unsafePerformIO&lt;/code&gt; 와 피상적 인 유사성을 갖지만 실제로는 혼돈의 악의적 인 에이전트입니다. 현실의 이음새 (및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드)를 선택 해제하여 일반 규칙이 더 이상 적용되지 않도록합니다. 그것은 합리적이라고 생각하도록 당신을 유혹하지만, 당신이 그것을 보지 않을 때는 뒤에서 찌르고 모든 변경 가능한 버퍼의 별칭을 지정합니다. 노련한 Haskell 프로그래머의 시체가 발에 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6dd831f46ec853aa8fce97c6a2a27a512463cc" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">이 &quot;기능&quot;은 &lt;code&gt;unsafePerformIO&lt;/code&gt; 와 피상적으로 유사 하지만 실제로는 혼돈의 악의적 인 에이전트입니다. 일반 규칙이 더 이상 적용되지 않도록 현실의 이음새 (및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드)를 선택 해제합니다. 그것은 합리적이라고 생각하도록 당신을 달래 주지만, 당신이 보지 않을 때 그것은 당신을 뒤에서 찌르고 모든 가변 버퍼를 별칭으로 만듭니다. 노련한 하스켈 프로그래머의 시체가 발 밑에 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">이&amp;ldquo;기능&amp;rdquo;은 반 직관적 일 수 있습니다 : &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; 는 중간 C 코드를 파일에 넣습니다. &lt;code&gt;foo.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 동등 술어는 문자열에 패턴 일치를 제거 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 Windows 이외의 플랫폼에서 명령 행 인수 및 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c332f21db0753a9ce2e0bf5358f7f0659bb25726" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 비 Windows 플랫폼에서 명령 줄 인수와 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 Windows 이외의 플랫폼에서 명령 행 인수 및 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9b155da963f248e8bbd48cdc8d158a756b4231" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 Windows가 아닌 플랫폼에서 명령 줄 인수와 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 기본적으로 제공되는 형식 이외의 형식으로 확장 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 를 인스턴스화 하고 형식에 대한 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 를 제공 하면됩니다. &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 을 제공 할 수 있습니다유형별 수정자를 처리 있지만 일반적으로 기본 인스턴스가 최선의 선택입니다.</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">이 약어는 최상위 선언 슬라이스를 더 조용하고 덜 협박하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">이 추상 데이터 형식은 구문 분석 오류 메시지를 나타냅니다. 다음과 같은 네 가지 종류의 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">이는 pragma 바로 다음의 모든 열 번호를 42에서 시작하도록 조정합니다.이 pragma의 존재는 진단 품질에만 영향을 미치며 코드 자체의 구문은 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">이를 통해 다른 유형의 동일한 런타임 표현을 지정하여 유형에 대한 클래스 인스턴스를 &lt;code&gt;deriving&lt;/code&gt; 시킬 수 있습니다 ( 둘 사이에 &lt;code&gt;Coercible&lt;/code&gt; 인스턴스 가 존재하도록 함 : &lt;a href=&quot;#coercible&quot;&gt;Coercible 제한 조건&lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="b751018507dda770efb90b1f91e7734fdc436369" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;equality_constraints#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">이를 통해 &lt;code&gt;deriving&lt;/code&gt; (a 존재하도록 동일한 런타임 표현의 또 다른 유형을 지정하여 입력하는 클래스 인스턴스를 &lt;code&gt;Coercible&lt;/code&gt; : 참조 둘 사이 인스턴스 &lt;a href=&quot;equality_constraints#coercible&quot;&gt;강제 할 제약&lt;/a&gt; ) 이미 그 클래스의 인스턴스이다.</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">이를 통해 지정된 필드의 레코드 유형에 대해 다형성 인 정의를 사용할 수 있습니다. 예를 들어, 다음은 필드 &lt;code&gt;name :: String&lt;/code&gt; 가진 모든 레코드 유형에서 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">이를 통해 더 짧은 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a1d903f792395fe48e068f8423dc24b82157d5" translate="yes" xml:space="preserve">
          <source>This also applies to GADT-style data instances:</source>
          <target state="translated">이는 GADT 스타일 데이터 인스턴스에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;libfoo.so&lt;/code&gt; 라이브러리 가 현재 디렉토리에 있고 프로그램이 전개되면 실행 가능한 &lt;code&gt;main&lt;/code&gt; 과 동일한 디렉토리에 있다고 가정합니다 . 이와 유사하게 실행 파일과 관련된 하위 디렉토리 (예 : &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="61fe3a7a67ef0295ed3b813ce3259d063c2d2b72" translate="yes" xml:space="preserve">
          <source>This avoid generating Typeable-related bindings for modules and types. This is useful when debugging because it gives smaller modules and dumps, but the compiler will panic if you try to use Typeable instances of things that you built with this flag.</source>
          <target state="translated">이렇게하면 모듈 및 유형에 대한 유형 가능 관련 바인딩이 생성되지 않습니다. 이것은 더 작은 모듈과 덤프를 제공하기 때문에 디버깅 할 때 유용하지만이 플래그로 빌드 한 항목의 Typeable 인스턴스를 사용하려고하면 컴파일러가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f906decfdad529805a16ffec27620b40f24764" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 4.10.0.0에서 타입 클래스 메소드가되었습니다. 그 전에는 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 용어로 정의 된 함수였습니다 .</target>
        </trans-unit>
        <trans-unit id="9638426e03b58cbb0b8529e91d4b2a020cb1636d" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 4.10.0.0에서 타입 클래스 메소드가되었습니다. 그 전에는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 용어로 정의 된 함수였습니다 .</target>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">필요하지 않더라도 소수점이 항상 보장된다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; 로 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">이 동작은 GHC의 내장 Ctrl-C 처리와 다릅니다.이 처리는 사용자가 Ctrl-C를 두 번째로 누른 후 프로그램을 즉시 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">이 동작은 대부분의 응용 프로그램에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">이 동작은 키에 접근 할 수 있다는 의미에 따라 다릅니다. 비공식적으로 루트 세트의 일반 포인터를 따르면 약한 포인터를 따르지 않으면 도달 할 수있는 것이 있습니다. 도달 가능성을 다음과 같이 더 정확하게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="016ad1599c06fe3db26044725923f3c8ab895470" translate="yes" xml:space="preserve">
          <source>This behaviour is considered an implementation detail and code relying on thread local state should instead use one of the interfaces provided in &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; to make this explicit.</source>
          <target state="translated">이 동작은 구현 세부 사항으로 간주되며 스레드 로컬 상태에 의존하는 코드는 대신 &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 에 제공된 인터페이스 중 하나를 사용 하여이를 명시 적으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b2b05c125a4021b12f162035f98b456ef9c82e9" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt;&lt;code&gt;NondecreasingIndentation&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt; &lt;code&gt;NondecreasingIndentation&lt;/code&gt; &lt;/a&gt; 확장에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">이 동작은 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 확장에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">이 동작은 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; = True 옵션이 설정된 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 에 의해 구현됩니다 . 특히, &lt;code&gt;SIGINT&lt;/code&gt; 신호는 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 가 리턴 될 때까지 (또는 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 가 비-아무것도 아닌 결과를 리턴 할 때까지) 무시 되므로 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 특히 중요합니다. 작성된 모든 프로세스에 대해 .</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 동작은 때때로 평가 순서를 제어 할 때 유용합니다. 특히 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 의 라이브러리 정의에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">이것은 모두 작은 스크립트로 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점진적으로 빠릅니다.일부 monoid의 .</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">다음과 같이 컴파일하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e5132d5805fa0f4b66063054f14a1690215ca6" translate="yes" xml:space="preserve">
          <source>This can be exponential in the arity of the pattern and in the number of guards in some cases. The &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt;&lt;/a&gt; limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</source>
          <target state="translated">이는 패턴의 배열과 경우에 따라 가드 수에서 기하 급수적 일 수 있습니다. &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt; &lt;/a&gt; 제한이 있는지 우리가 부분적으로 성공한 경기에서 얻은 정제 된 정보를 잊고에 의해, 패턴의 수에 다항식으로 확장 할 수 있습니다. 위의 예에서 제한이 1이면 정제되지 않은 원래 모델로 다음 절을 계속 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c46a06f859ec4216c3665e278e7c6dd66a8347dc" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly quantifying over &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;k&lt;/code&gt; 를 명시 적으로 정량화하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">프로그램이 &lt;code&gt;head []&lt;/code&gt; 오류 에 대해 불평하고 어떤 코드가 문제의 원인 &lt;code&gt;-prof -fprof-auto&lt;/code&gt; ( &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 참조 )로 컴파일 하고 실행하는 경우 디버깅에 특히 유용 할 수 있습니다. 와 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; 당신에게 오류가 발생 된 지점에서 정확하게 호출 스택을 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">예를 들어, 표준 핸들의 대상을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0931038d623b08783b09e8bd0091edc745c9aed9" translate="yes" xml:space="preserve">
          <source>This can be useful when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">이것은 숫자 데이터 유형의 양수 및 음수 범위가 일치하지 않을 때 유용 할 수 있습니다. 예를 들어, 8 비트 산술에서 -128은 표현 가능하지만 +128은 표현할 수 없습니다. 따라서 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 은 예기치 않은 정수 리터럴 오버플로 메시지를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">면밀히 살펴 보는 표현식에 하단이 아닌 값이 없음을 알고있을 때 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eddd4c05222390632f36d3c6901904480d608851" translate="yes" xml:space="preserve">
          <source>This can be worked around by defining extra functions which are specified to be linear, such as:</source>
          <target state="translated">이는 다음과 같이 선형으로 지정된 추가 함수를 정의하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">이는 숫자 데이터 유형의 양수 및 음수 범위가 일치하지 않을 때 차이를 만들 수 있습니다. 예를 들어, 8 비트 산술에서 -128은 표현 가능하지만 +128은 표현할 수 없습니다. 따라서 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 은 예기치 않은 정수 리터럴 오버플로 메시지를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">이 기능은 주어진 텍스트를 출력하는 동안 터미널의 배경색을 일시적으로 설정 한 다음 터미널을 기본 전경 및 배경색으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">이 기능은 주어진 텍스트를 출력하는 동안 터미널의 전경색을 임시로 설정 한 다음 터미널을 기본 전경색과 배경색으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">GHC가 프로파일 링 된 객체 코드를로드하여 스플 라이스를 실행할 때 사용할 수 없기 때문에 Template Haskell 코드가 포함 된 다중 모듈 프로그램이 있고 프로파일 링을 위해 컴파일해야하는 경우 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">이 변경 사항은 메인 모듈에만 적용됩니다. 다른 모듈은 &lt;code&gt;-main-is&lt;/code&gt; 플래그에 관계없이 여전히 기본 내보내기 목록에서 &lt;code&gt;main&lt;/code&gt; 을 내 보냅니다 . 이 예제에서와 같이 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 다른 진입 점을 가리키는 경우에도 &lt;code&gt;-main-is&lt;/code&gt; 를 기본 내보내기 목록을 통해 &lt;code&gt;main&lt;/code&gt; 을 내보내는 기존 모듈 에서 &lt;code&gt;-main-is&lt;/code&gt; 를 사용할 수 있습니다 ( -main-is MainWrapper.program로 컴파일 됨 ).</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">이 클래스에는 &lt;em&gt;용어에&lt;/em&gt; 포함 된 정보에서 두 가지 유형의 동등성을 배울 수있는 유형이 포함되어 있습니다 . 일반적으로이 클래스에는 단일 유형 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">이 클래스는 형식 수준의 자연과 관련된 정수를 제공합니다. 모든 구체적인 리터럴에는 0, 1, 2 등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">이 클래스는 유형 수준 기호와 관련된 문자열을 제공합니다. 모든 구체적인 리터럴에는 &quot;hello&quot;등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">이 클래스는 FlexibleInstances가 없기 때문에 Haskell98 호환성 해결 방법으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">이 클래스는 재귀의 번역에 사용되는 &lt;code&gt;do&lt;/code&gt; GHC와 포옹 지원 표기.</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">하나의 인스턴스 만있는이 클래스 는 구체적 유형 인 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이 유형 클래스 인스턴스로 허용되지 않는다는 사실에 대한 임시 해결책으로 사용됩니다 . 역 호환성을 위해 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">이 코드 조각은 치명적인 오류를 유발해야하지만 다음과 같은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍 을 이루도록 보장합니다 . (이 코드를 직접 작성하는 것보다 사용하는 것이 좋습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 일반적인 패턴을 추상화하는 대괄호).</target>
        </trans-unit>
        <trans-unit id="0459111867f0b4bf21ea31dbb72a95eb8474fa39" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍 을 이루도록 보장합니다 . (이 코드를 직접 작성하는 것보다 일반적인 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 ).</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="3494ba5905a6ab7393145cd907a3ba47ca64dbf3" translate="yes" xml:space="preserve">
          <source>This code is in the style of both transformers and mtl, and is compatible with them, though doesn't mimic the module structure or offer the complete range of features in those packages.</source>
          <target state="translated">이 코드는 트랜스포머와 mtl의 스타일로되어 있으며 모듈 구조를 모방하거나 해당 패키지의 전체 기능을 제공하지는 않지만 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합기는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 의 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합자는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d271e551be54c1cdaf8d8475b3236094d494ecd" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합자는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">이 명령을 사용하면 적절한 터미널 대신 파이프를 통해 상호 작용할 때에도 GHCi에서 명령 완료를 요청할 수 있으며 GHCi의 완료를 텍스트 편집기 및 IDE와 통합하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">이 명령은 편집기 및 IDE에서 식별자의 모든 사용을 강조 표시하고 탐색하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 goto-definition 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 show-type-under-point 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">이 계산은 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 예외 중 하나와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a53acc002bbe269420ba165928d4d81ea8f10ab" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">이 계산은 다음 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 예외 중 하나와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed67e498f09c1f718f1eeef445a1a02f8f1c9aa1" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">이 계산은 다음 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 예외 중 하나와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">이 계산은 다음과 같이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">이것은 외부 호출과 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 의 상호 작용과 관련이 있습니다. 일반적으로 &lt;code&gt;throwTo&lt;/code&gt; 의 대상이 외래 통화에 관련된 경우에는 통화가 돌아올 때까지 그리고 발신자가 차단 될 때까지 예외가 발생하지 않습니다. 이로 인해 응답하지 않을 수 있으며 이는 사용자 인터럽트 (예 : Control-C)의 경우 특히 바람직하지 않습니다. Control-C 신호가 수신 될 때 ( UNIX의 &lt;code&gt;SIGINT&lt;/code&gt; ) 기본 동작 은 기본 스레드에서 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외를 발생시키는 것입니다. 그 때 메인 스레드가 외래 호출에서 차단되면 프로그램은 사용자 인터럽트에 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">이 조건은 유형별로 확인되지 않습니다. 제공된 값이 유효한 전체 주문인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">이렇게하면 문자열이 변환되지만 공백을 줄 바꿈 불가능으로 유지하고 입력 목록의 각 문자열 사이에 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">이것은 문자열을 변환하지만 공백을 줄 바꿈 불가능한 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">이받는 대응 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 연산에 의해 제공되는 &lt;code&gt;base&lt;/code&gt; 의 &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;수치의&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="b849491aac2caa06d22e6da0aa56daf804da18ae" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">이것은 &lt;code&gt;base&lt;/code&gt; 의 &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; 모듈에서 제공 하는 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 연산에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="d376b70e2f4efe4cf1c1f4fa399b2057e2187eec" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.15.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">이것은 &lt;code&gt;base&lt;/code&gt; 의 &lt;a href=&quot;../base-4.15.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; 모듈에서 제공 하는 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 연산에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">이것은 현재</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">이 데이터 유형은 동등성 관계를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;a&lt;/code&gt; 유형 의 값에서 작동하는 연산자를 지정 합니다 . 연산자는 이진 접두사 또는 단항 접두사 또는 접미사입니다. 이항 연산자에는 관련 연관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">이 데이터 유형은 연산자의 연관성을 지정합니다 (왼쪽, 오른쪽 또는 없음).</target>
        </trans-unit>
        <trans-unit id="831a0b5e449e944bcd13dda14651accbf5a15f97" translate="yes" xml:space="preserve">
          <source>This data type uses a Haskell98-style declaration. The only part of this data type that is not Haskell98 code is &lt;code&gt;unT&lt;/code&gt;, whose type uses higher-rank polymorphism (&lt;a href=&quot;rank_polymorphism#arbitrary-rank-polymorphism&quot;&gt;Arbitrary-rank polymorphism&lt;/a&gt;). To construct the type of the &lt;code&gt;unT&lt;/code&gt; field selector, we will assemble the following:</source>
          <target state="translated">이 데이터 유형은 Haskell98 스타일 선언을 사용합니다. Haskell98 코드가 아닌이 데이터 유형의 유일한 부분은 &lt;code&gt;unT&lt;/code&gt; 이며, 유형은 더 높은 순위의 다형성 ( &lt;a href=&quot;rank_polymorphism#arbitrary-rank-polymorphism&quot;&gt;임의 순위 다형성&lt;/a&gt; )을 사용합니다. &lt;code&gt;unT&lt;/code&gt; 필드 선택기 의 유형을 구성하기 위해 다음을 조합합니다.</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 로 점진적 으로 상승하는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">이 데이터 유형 &lt;code&gt;G&lt;/code&gt; 는 종류와 유형이 모두 GADT와 유사합니다. &lt;code&gt;g :: G a&lt;/code&gt; 있고 &lt;code&gt;a :: k&lt;/code&gt; 가 있다고 가정하십시오 . 그런 다음 &lt;code&gt;g&lt;/code&gt; 가 실제로 &lt;code&gt;GMaybe&lt;/code&gt; 임을 발견하기 위해 패턴 일치 는 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 과 &lt;code&gt;a ~ Maybe&lt;/code&gt; 를 알려줍니다 . &lt;code&gt;G&lt;/code&gt; 에 대한 정의 는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 유효 해야 하지만 &lt;code&gt;G&lt;/code&gt; 에서의 패턴 일치는 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 넘어서는 확장이 필요하지 않습니다 . 이 작업은 실제로 일반 GADT의 간단한 확장이며 종류와 유형이 동일하다는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0ab78fb6ca9a0cac82260654f0f4cc814bc37c64" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;gadt#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">이 데이터 유형 &lt;code&gt;G&lt;/code&gt; 는 종류와 유형 모두에서 GADT와 유사합니다. &lt;code&gt;g :: G a&lt;/code&gt; 가 있다고 가정합니다 . 여기서 &lt;code&gt;a :: k&lt;/code&gt; . 그런 다음 패턴 매칭을 통해 &lt;code&gt;g&lt;/code&gt; 가 실제로 &lt;code&gt;GMaybe&lt;/code&gt; 는 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 및 &lt;code&gt;a ~ Maybe&lt;/code&gt; 를 모두 알려줍니다 . &lt;code&gt;G&lt;/code&gt; 에 대한 정의 는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 유효 해야 하지만 &lt;code&gt;G&lt;/code&gt; 에서의 패턴 일치 에는 &lt;a href=&quot;gadt#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 이상의 확장이 필요하지 않습니다 . 이 작업은 실제로 일반 GADT의 간단한 확장이며 종류와 유형이 동일하다는 사실의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 의 버퍼 별 버퍼 실행을위한 공통 인터페이스 역할을합니다 . 이 인터페이스의 일반적인 사용자는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;enumerator&lt;/code&gt; 와 같은 iteratee 스타일 라이브러리 입니다.</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">이 디코더는 모든 입력을 읽어야 리턴 할 수 있다는 단점이 있습니다. 반면, 디코더 오류없이 디코딩 할 수 있다는 것을 알기 전까지는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 운영 체제를 기반으로 조건부 컴파일을 허용합니다. 여기서 ⟨os⟩는 현재 운영 체제의 이름입니다 (예 : &lt;code&gt;linux&lt;/code&gt; , Windows의 경우 &lt;code&gt;mingw32&lt;/code&gt; , &lt;code&gt;solaris&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 호스트 아키텍처를 기반으로 조건부 컴파일을 허용합니다. 여기서 &quot;arch⟨는 현재 아키텍처의 이름입니다 (예 : &lt;code&gt;i386&lt;/code&gt; , &lt;code&gt;x86_64&lt;/code&gt; , &lt;code&gt;powerpc&lt;/code&gt; , &lt;code&gt;sparc&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">이 정의는 &lt;code&gt;f1&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; 에서 엄격 하게 만드는 반면, 뱅이 없으면 게으를 것입니다. 강타 패턴은 물론 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b91b94fef6db287d03fbeab2dc4d7e8eab765914" translate="yes" xml:space="preserve">
          <source>This definition works for any applicative functor in the co-domain of &lt;code&gt;f&lt;/code&gt;, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">이 정의는 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 에 대한 법칙 이 연관성의 형태를 암시 하기 때문에 &lt;code&gt;f&lt;/code&gt; 의 공동 영역에있는 모든 응용 함수에 대해 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">이는 일반적인 &lt;code&gt;deriving&lt;/code&gt; 조항 과 거의 동일한 방식으로 컨텍스트가 추론 되는 파생 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 인스턴스를 나타냅니다 . 독립형 &lt;code&gt;deriving&lt;/code&gt; 선언 에서 와일드 카드를 사용 하는 것은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 완전한 액세스를 제공합니다 . 따라서 지정된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 내용을 덮어 쓰지 않도록 각별히주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 액션을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때는 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다&lt;/em&gt; . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게하는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 전체 액세스 권한을 제공합니다 . 따라서 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 어떤 것도 덮어 쓰지 않도록 최대한주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다.&lt;/em&gt; 작업을 . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게 할 수있는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="ffd98d4a6017bba368758de2469c58f09f328ffb" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 전체 액세스 권한을 제공합니다 . 따라서 지정된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부에있는 항목을 덮어 쓰지 않도록 최대한주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없다는&lt;/em&gt; 점에 유의하십시오 . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게 할 수있는 코드를 작성하는 것입니다!</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">이 차이점은 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 의&lt;/a&gt; 작동 방식 때문에 중요 합니다. 파생 된 &lt;code&gt;Functor Right&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35e478384f40b7a1e661dbe9f918af72fd276223" translate="yes" xml:space="preserve">
          <source>This distinction is only meaningful for monads which have multiple exit points, such as &lt;code&gt;Except&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt;. For monads that only have a single exit point, there is no difference between &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; has a more constrained type.</source>
          <target state="translated">이 구분은 &lt;code&gt;Except&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; 와 같이 여러 개의 종료 점이있는 모나드에서만 의미가 있습니다 . 단일 종료 지점 만있는 모나드의 경우 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; 가 더 제한된 유형을 갖는 것을 제외하고 는 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; 간에 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">런타임 경로는 포함되지 않습니다. 표준 위치 또는 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수가 제공하는 디렉토리에서 사용 가능한 공유 라이브러리에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">더 이상 작동하지 않습니다. 가정하자 모듈 &lt;code&gt;C&lt;/code&gt; 의 수입 모듈 &lt;code&gt;B&lt;/code&gt; 를 , 및 &lt;code&gt;B&lt;/code&gt; 의 수입 모듈 &lt;code&gt;A&lt;/code&gt; . 모듈의 변경 그래서 &lt;code&gt;A&lt;/code&gt; 는 모듈이 필요할 수 있습니다 &lt;code&gt;C&lt;/code&gt; 를 컴파일하고, 따라서하면된다 &lt;code&gt;A.hi&lt;/code&gt; 은 우리가 여부를 확인해야합니다 변경 &lt;code&gt;C&lt;/code&gt; 가 다시 컴파일해야합니다. 그러나 &lt;code&gt;C&lt;/code&gt; 의 종속성은 &lt;code&gt;B.hi&lt;/code&gt; 가 아닌 &lt;code&gt;A.hi&lt;/code&gt; 만 나열 하며 &lt;code&gt;A&lt;/code&gt; 에 대한 일부 변경 사항 ( &lt;code&gt;B&lt;/code&gt; 에서 내 보낸 함수의 인라인에 나타나는 함수의 정의 변경 )은 &lt;code&gt;B.hi&lt;/code&gt; 변경하지 않을 수 있습니다 . 안녕 하나 그래서 지금&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 가 표현-다형 적 유형을 가질 것이기 때문에 이것은 &lt;code&gt;bad&lt;/code&gt; 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">이것은 코드 생성기의 조립 단계에서 바로 가기를 가능하게합니다. 간단히 말하면 단축 명령은 명령 블록 A가 무조건 점프로만 구성된 경우 A의 후속 점프로 점프하여 A에 대한 모든 점프를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f7bbbb3ab3d29cf5ffa8743547ffc2d2bd5ddb95" translate="yes" xml:space="preserve">
          <source>This enables static control flow prediction on the final Cmm code. If enabled GHC will apply certain heuristics to identify loops and hot code paths. This information is then used by the register allocation and code layout passes.</source>
          <target state="translated">이를 통해 최종 Cmm 코드에서 정적 제어 흐름 예측이 가능합니다. 활성화 된 경우 GHC는 루프 및 핫 코드 경로를 식별하기 위해 특정 휴리스틱을 적용합니다. 이 정보는 레지스터 할당 및 코드 레이아웃 패스에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">이 인코딩은 어느 방향으로도 실패하지 않습니다. 그러나 인코딩하면 정보가 삭제되므로 인코딩 다음에 디코딩하는 것이 ID가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">이 인코딩은 바이트 시퀀스 &quot;xc0x80&quot;을 사용하여 NUL을 나타내며 문자열은 NUL로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이를 통해 Bifold의 각 단계가 적용되기 전에 약한 머리 정상적인 형태로 강요되어 다른 방식으로 발생하는 뭉크의 수집을 피할 수 있습니다. 이것은 종종 유한 구조를 단일 모 놀리 식 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ) 로 엄격하게 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="913f56eb4194e0ecead838a70ce1e6d3cf6501e8" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to Weak Head Normal Form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single strict result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이렇게하면 폴드의 각 단계가 적용되기 전에 Weak Head Normal Form으로 강제 적용되어 다른 방법으로 발생할 수있는 썽크 수집을 방지 할 수 있습니다. 이것은 유한 구조를 엄격한 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; ) 로 엄격하게 축소하려는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="4223c1939c432f75f827180d4e7260a63349ec55" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to Weak Head Normal Form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single strict result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이렇게하면 폴드의 각 단계가 적용되기 전에 Weak Head Normal Form으로 강제 적용되어 다른 방법으로 발생할 수있는 썽크 수집을 방지 할 수 있습니다. 이것은 유한 구조를 엄격한 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; ) 로 엄격하게 축소하려는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">이 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">이를 통해 모듈을 신뢰할 수 있지만 모듈 작성자가 보증을 제공합니다. 그런 다음이 모듈의 클라이언트는 모듈을 포함하는 패키지를 신뢰하도록 지정하여 모듈 작성자를 신뢰하도록 지정합니다. &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 은 모듈을 안전한 언어로 제한하지 않습니다. 그러나 &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;안전한 중복 인스턴스&lt;/a&gt; 만 허용하도록 중복 인스턴스의 해상도를 제한합니다 . 또한 안전한 가져 오기 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">이 예제는 이스케이프 연속이 작동하는 방식을 보여주고 사용법에 대한 일반적인 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">이 예는 다음 중 하나의 컷 다운 버전입니다.</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">이 예제는 &lt;code&gt;Type&lt;/code&gt; 생성자를 직접 사용한 경우 훨씬 복잡한 구성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="352d62082975f9e8c31475e16d2847378caf0fdb" translate="yes" xml:space="preserve">
          <source>This example is rejected, as a visible argument should by definition be explicitly applied. Making them inferred (and thus not appliable) would be conflicting.</source>
          <target state="translated">이 예제는 거부됩니다. 가시적 인수는 정의에 따라 명시 적으로 적용되어야하기 때문입니다. 그것들을 추론 (따라서 적용 할 수 없음)하는 것은 상충 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">이 예제는 &lt;code&gt;Functor&lt;/code&gt; 만 필요합니다. Functor 는 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 변환되기 때문입니다 . 더 복잡한 예제에는 &lt;code&gt;Applicative&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">이 예는 사용 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 마이크로 소프트 워드의 기능을하지만, 제공 &lt;code&gt;HsStart&lt;/code&gt; 는 첫 번째 함수 전에 호출되며, &lt;code&gt;HsEnd&lt;/code&gt; 이 지난 후, 다음 그것을 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예는 원본 Concurrent Haskell 논문에서 수정되었습니다. 상위 레벨 동기화 프리미티브를 빌드하는 데 사용되는 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 더 많은 예는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">이 예제는 다음 예제에서 알 수 있듯이 명령문에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">이 예외는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 를 호출하는 다른 스레드 또는 어떤 이유로 스레드를 종료해야하는 경우 시스템에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">이 예외는 사용자가 일반적인 메커니즘 (예 : 콘솔의 Control-C)을 통해 프로그램 종료를 요청하면 프로그램의 기본 스레드에서 기본적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">이 확장을 통해 프로그래머는 &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;IntMap&lt;/code&gt; , &lt;code&gt;Vector&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 와 같은 구조 구성에 목록 표기법을 사용할 수 있습니다 . 다음 코드 목록은 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">이 확장을 통해 모든 형식의 제약 조건을 작성할 수 있습니다 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 는 &lt;code&gt;(==)&lt;/code&gt; 방법 의 두 번째 사용법에서 발생하는 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 제약 조건 을 해결하는 데 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">이 확장을 사용하면 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#type-instance-declarations&quot;&gt;형식 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#closed-type-families&quot;&gt;닫힌 형식 패밀리&lt;/a&gt; , &lt;a href=&quot;#assoc-inst&quot;&gt;연결된 인스턴스&lt;/a&gt; 및 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; 에서 형식 및 종류 변수를 명시 적으로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="536f19bd6cf13372c7c568246c5a2d2331aa186e" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;type_families#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;type_families#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;type_families#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;type_families#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">이 확장은 또한 &lt;a href=&quot;type_families#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;type_families#type-instance-declarations&quot;&gt;유형 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;type_families#closed-type-families&quot;&gt;닫힌 유형 패밀리&lt;/a&gt; , &lt;a href=&quot;type_families#assoc-inst&quot;&gt;연관된 인스턴스&lt;/a&gt; 및 &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; 에서 유형 및 종류 변수의 명시 적 수량화를 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">이 확장은 또한 데이터 계열 인스턴스에 대한 일부 제한 사항을 완화합니다. 특히 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;newtype instance&lt;/code&gt; 에 &lt;code&gt;Type&lt;/code&gt; 뿐만 아니라 &lt;code&gt;TYPE r&lt;/code&gt; 의 반환 종류를 제공하도록 허용합니다 . 예를 들어, 다음 &lt;code&gt;newtype instance&lt;/code&gt; 선언이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">이 확장은 다음 위치에서 종류 서명을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">이 확장은 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을 일반화&lt;/a&gt; 합니다. GND 를 사용하여 &lt;code&gt;Num Unicode&lt;/code&gt; 를 파생 시키려면 ( &lt;code&gt;deriving newtype Num&lt;/code&gt; ) &lt;code&gt;Num Int&lt;/code&gt; 인스턴스를 재사용해야합니다 . 함께 &lt;code&gt;DerivingVia&lt;/code&gt; , 우리는 명시 적으로 표현 유형을 지정할 수 있습니다 &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3bbc89d69b20fe11c6a3d394e6059acbe8810468" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">이 확장은 &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을 일반화&lt;/a&gt; 합니다. GND ( &lt;code&gt;deriving newtype Num&lt;/code&gt; 하여 &lt;code&gt;Num Unicode&lt;/code&gt; 를 파생하려면 &lt;code&gt;Num Int&lt;/code&gt; 인스턴스를 다시 사용해야합니다 . &lt;code&gt;DerivingVia&lt;/code&gt; 를 사용하면 &lt;code&gt;Int&lt;/code&gt; 표현 유형을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ca40eca072f061d5d015785400da83bc7d6281" translate="yes" xml:space="preserve">
          <source>This extension has been originally conceived of in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/linear-haskell-practical-linearity-higher-order-polymorphic-language/&quot;&gt;Linear Haskell: practical linearity in a higher-order polymorphic language&lt;/a&gt; (POPL 2018)</source>
          <target state="translated">이 확장은 원래 논문 &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/linear-haskell-practical-linearity-higher-order-polymorphic-language/&quot;&gt;Linear Haskell : 고차 다형성 언어의 실용적인 선형성&lt;/a&gt; (POPL 2018)에서 구상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">이 확장은 새 유형에 완전한 사용자 지정 종류 서명 (CUSK)이 있는지 여부를 결정하는 데 영향을줍니다. 정확한 영향은 &lt;a href=&quot;#complete-kind-signatures&quot;&gt;CUSK 섹션에 명시되어 있습니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18783492d32e3c1b270b1600db180644b1ca6936" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">이 확장은 &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)에&lt;/a&gt; 따라 GHC 8.6.1부터 기본적으로 활성화됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
