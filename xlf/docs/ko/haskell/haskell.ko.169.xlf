<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 가 활성화되어 사용 &lt;code&gt;anyclass&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newytype&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">경우 &lt;code&gt;mappend x x = x&lt;/code&gt; ,이 정의가 바람직되어야 오히려 O (로그 N)에 비해 O (1)에 작동하기 때문에</target>
        </trans-unit>
        <trans-unit id="385ace8105515b932625b88764546dcae18aded8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\)</source>
          <target state="translated">경우 &lt;code&gt;mappend x x = x&lt;/code&gt; ,이 정의가 바람직되어야하기 때문에 작동에 \ (\ mathcal {O} (1) \)보다는 \ (\ mathcal {O} (N 로그인 \) \)</target>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; 는 O (1)에서 작동하기 때문에,이 정의가 아닌 O (로그 n)이보다 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="01dfa1f0b575553478bb02cbc1f8d40024bd7518" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\).</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; 가 작동하기 때문에보다 (\ mathcal {O} (1) \) \ (\ mathcal {O} (N 로그인 \ \)),이 정의는 \ 바람직한다.</target>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">GHC가 클래스의 인스턴스를 찾을 수 없으면 알고있는 인스턴스의 일부 목록이 표시됩니다. 이 플래그를 사용하면 알고있는 &lt;em&gt;모든&lt;/em&gt; 인스턴스를 인쇄 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">GHC 가 &lt;code&gt;foreign export&lt;/code&gt; 또는 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 를 사용 하는 모듈 (예 : &lt;code&gt;M.hs&lt;/code&gt; )을 컴파일 할 때 C 프로그램에서 사용할 &lt;code&gt;M_stub.h&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">등록되지 않은 모드에서 GHC를 빌드하면 LLVM 및 C 코드 생성기 만 사용할 수 있습니다. 네이티브 코드 생성기는 그렇지 않습니다. LLVM은 일반적으로 미등록 모드에서 C 백엔드에 비해 상당한 성능 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">GHC를 사용하여 C 파일을 컴파일하는 경우 GHC는 패키지 포함 경로를 추가하고 &lt;code&gt;ghcversion.h&lt;/code&gt; 를 직접 포함 합니다. 컴파일러는 패키지 데이터베이스 의 &lt;code&gt;rts&lt;/code&gt; 패키지에서 &lt;code&gt;ghcversion.h&lt;/code&gt; 파일 의 경로를 찾습니다 . 경우에 따라 컴파일러의 패키지 데이터베이스에 &lt;code&gt;rts&lt;/code&gt; 패키지가 포함되어 있지 않거나 포함 할 특정 &lt;code&gt;ghcversions.h&lt;/code&gt; 를 지정하려고합니다 . 이 옵션을 사용하여 포함 할 &lt;code&gt;ghcversions.h&lt;/code&gt; 파일 의 경로를 지정할 수 있습니다. 이것은 주로 GHC의 빌드 시스템에서 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">GHC는 제약 조건 &lt;code&gt;C Int Bool&lt;/code&gt; 을 해결 하려고 할 때 인스턴스 선언의 헤드를 인스턴스화하여 모든 인스턴스 선언을 제약 조건과 일치시킵니다. 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">GHCi가 중단 점에서 중지되고 프롬프트에 입력 된 표현식이 두 번째 중단 점을 트리거하면 새 중단 점이 &quot;현재&quot;가되고 이전 중단 점이 스택에 저장됩니다. 이러한 방식으로 임의의 수의 중단 점 컨텍스트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">GC가 시작되면 실행중인 모든 뮤 테이터 스레드가 중지되고 동기화되어야합니다. GC가 시작되고 모든 뮤 테이터 스레드가 중지되는 시점을 GC 동기화 단계라고합니다. 이 단계가 오래 걸리는 경우 (1ms보다 긴 것이 긴 것으로 간주 됨) 전체 처리량에 심각한 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">GHC 컴파일 프로그램을 &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS 옵션 과 함께 실행하면 &lt;code&gt;prog.prof&lt;/code&gt; 라는 파일이 생성됩니다 . 이 경우 파일에는 다음과 같은 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1f106b54cbaaef2571f93c8d0393bd0f543851ad" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="translated">Monoid의 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 두 번째 인수에서 게으른 경우 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 은 제한되지 않은 구조에서도 결과를 반환 할 수 있습니다. 예를 들어 지연 누적을 사용하면 &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 가 대규모 데이터 구조를 효율적으로 직렬화하고 점진적으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adb500e0f063ff278c253fad2463e930413ad240" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="translated">Monoid의 &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 두 번째 인수에서 게으른 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 은 제한되지 않은 구조에서도 결과를 반환 할 수 있습니다. 예를 들어 지연 누적을 사용하면 &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 가 대규모 데이터 구조를 효율적으로 직렬화하고 점진적으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">Bare 유형 변수 &lt;code&gt;a&lt;/code&gt; 가 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 각각 &lt;code&gt;fmap&lt;/code&gt; 및 &lt;code&gt;traverse&lt;/code&gt; 정의에 대해 &lt;code&gt;f a&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">특정 행과 열에 중단 점이 설정되면 GHCi는 중단 점을 설정할 위치를 포함하는 가장 작은 하위 표현식을 선택합니다. 참고 : GHC는 TAB 문자의 너비가 1 인 것으로 간주합니다. 즉, 열이 아닌 문자를 계산합니다. 이것은 일부 편집자가하는 것과 일치하고 다른 편집자와는 일치하지 않습니다. 최선의 조언은 소스 코드에서 탭 문자를 모두 사용하지 않는 것입니다 ( &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">특정 행에 중단 점이 설정되면 GHCi는 해당 행에서 시작하고 끝나는 가장 왼쪽의 하위 표현식에 중단 점을 설정합니다. 동일한 열에서 두 개의 완전한 하위 표현식이 시작되면 가장 긴 하위 표현식이 선택됩니다. 줄에 완전한 하위 표현식이 없으면 줄에서 시작하는 가장 왼쪽에있는 표현식이 선택되고 해당 줄을 부분적으로 또는 완전히 덮는 가장 오른쪽에있는 표현식이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">데이터 형식의 경우 &lt;code&gt;T&lt;/code&gt; 는 모든 생성자, 즉 함께 가져 &lt;code&gt;T(..)&lt;/code&gt; 하지만, 추상적 즉 내 보낸 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 할 수있는 오류 코드 목록은 기본 기능에 대한 POSIX 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 될 수있는 errno 코드 목록은 기본 기능에 대한 POSIX 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb8e20bccf6e08f777f996c2c39b5d665dcbf299" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 될 수있는 errno 코드 목록은 기본 기능에 대한 POSIX 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">hs-boot 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 컴파일 될 때 범위 및 유형 오류가 있는지 확인합니다. 상위 모듈 &lt;code&gt;A.hs&lt;/code&gt; 가 컴파일 될 때 두 모듈 이 비교되고 두 모듈 이 일치하지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하여 조치를 생성하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 결과 조치를 수행하며 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">현재 컴파일중인 패키지 (예 : &quot;홈&quot;패키지)에서 제공 한 모듈을 가져 오지만 명령 줄에 대상으로 명시 적으로 나열되지 않은 경우 Cabal이 GHC가 &lt;code&gt;exposed-modules&lt;/code&gt; 이나 &lt;code&gt;other-modules&lt;/code&gt; 모듈 에 나열되지 않은 모듈을 픽업하지 않도록하는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">이름이나 패키지가 범위 내에 없으면 대신 의미가있는 이름이나 패키지를 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">겹치는 인스턴스로 인해 특정 유형 클래스 메서드 호출이 안전하지 않은 것으로 간주되고 컴파일되는 모듈이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 를 사용하면 컴파일이 실패합니다. 들면 &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; , 제한은 적용되지 않고, 안전한 사용을 추론 모듈, 이들은 안전하지 않은 추론한다.</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나 &lt;code&gt;main&lt;/code&gt; 함수는 인수를 직접 사용하지 않으므로 ghci에서 테스트하는 동안 단순히 &lt;code&gt;main&lt;/code&gt; 함수에 인수를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나, 우리는 간단히에 인수를 전달할 수 없습니다 &lt;code&gt;main&lt;/code&gt; 우리가 ghci에서 테스트하는 동안 같은 기능 &lt;code&gt;main&lt;/code&gt; 기능은 직접하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">문자열이이 플래그에 전달되면 이름이 문자열과 접두사를 공유하는 모든 함수에 대한 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식에 생성자가없는 경우 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스는 &lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수의 (아래) 값을 강제로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="d983aaf2b04606b0ab51075f4a016ac754c84212" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;empty_case#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형에 생성자가 없으면 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스는 단순히 &lt;a href=&quot;empty_case#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수의 (하단) 값을 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;foldr&lt;/code&gt; 및 &lt;code&gt;foldMap&lt;/code&gt; 을 재귀 적으로 호출 합니다. 컨텍스트에 따라 &lt;code&gt;null&lt;/code&gt; 은 재귀 적으로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;all null&lt;/code&gt; 을 호출 할 수 있습니다. . 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 재귀 적으로 &lt;code&gt;traverse&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">유형 레벨 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하면 언급 된 각 유형 / 종류 변수도 범위 내에 있거나 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 특히 Haskell의 다른 장소와 달리 자유 변수는 암시 적으로 바인딩되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">값이 &lt;code&gt;do&lt;/code&gt; - notation으로 묶인 경우 &lt;code&gt;&amp;lt;-&lt;/code&gt; 의 왼쪽에있는 패턴 이 일치하지 않을 수 있습니다. 이 경우이 클래스는 복구 할 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">경고가 발생하면이를 제어하는 ​​특정 경고 플래그가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">와일드 카드가 단일 유형으로 인스턴스화되지 않으면 일반 유형으로 일반화됩니다. 예를 들어 새로운 유형 변수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명령문이 내 보내지 않은 엔티티를 숨길 때</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">연관된 데이터 또는 유형 동의어 패밀리 인스턴스가 유형 클래스 인스턴스 내에 선언되면 선택적으로 패밀리 키워드에서 &lt;code&gt;instance&lt;/code&gt; 키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">명시적인 &lt;code&gt;forall&lt;/code&gt; 이 있는 경우 아직 범위에 포함되지 않은 언급 된 &lt;em&gt;모든&lt;/em&gt; 유형 및 종류 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하는 경우, 아직 범위 내에 있지 않은 언급 된 모든 &lt;em&gt;유형&lt;/em&gt; 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 필요한 경우 종류 변수는 암시 적으로 바인딩됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 인스턴스가 정의 된 경우 유형 클래스에 의해 정의 된 비트 단위 연산은 C on &lt;code&gt;t&lt;/code&gt; 의 해당 비트 단위 연산과 동일한 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">인스턴스 때 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 정의되어 &lt;code&gt;CT&lt;/code&gt; 의 값 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 가 일치 &lt;code&gt;t_MIN&lt;/code&gt; 및 &lt;code&gt;t_MAX&lt;/code&gt; C.에서</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 인스턴스 가 정의 되면 유형 클래스에 의해 정의 된 술어는 &lt;code&gt;t&lt;/code&gt; 의 C에서 해당 술어와 동일한 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">인스턴스 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 가 정의되어 &lt;code&gt;CT&lt;/code&gt; , Type 클래스에 의해 정의 된 산술 연산은상의 C에 대응하는 연산과 동일한 기능 (있는 경우)를 구현 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">적용 가능한 경우 특정 병리학 적 경우에는 조금 더 나쁠 수 있지만이 기능 대신 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 거의 항상 좋습니다 . 예를 들어, 문자 목록을 마비 시키려면</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">소스 파일을 컴파일하라는 요청을 받으면 GHC는 일반적으로 객체 파일과 인터페이스 파일의 두 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">데이터베이스를 수정하라는 메시지가 표시되면 &lt;code&gt;ghc-pkg&lt;/code&gt; 는 기본적으로 전역 데이터베이스를 수정합니다. &lt;code&gt;--user&lt;/code&gt; 를 지정 하면 사용자 데이터베이스에서 작동하거나 &lt;code&gt;--package-db&lt;/code&gt; 를 사용하여 다른 데이터베이스에서 완전히 작동 할 수 있습니다. 이러한 옵션이 여러 개 제공되면 가장 오른쪽 옵션이 작동 할 데이터베이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">두 플래그가 제공되면 &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 대체 하고 &lt;code&gt;+&lt;/code&gt; 는 공백을 대체합니다. &lt;code&gt;*&lt;/code&gt; 변환 에서 음의 너비 지정자는 양수로 취급되지만 왼쪽 조정 플래그를 암시합니다.</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">바운드 유형 / 종류 변수가 필요한 경우 두 변수를 모두 포함해야하지만 패턴 변수가 필요하지 않은 경우 두 번째 변수를 비워 둘 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1946e20d1d1096358555ee194ee179a3632a63b" translate="yes" xml:space="preserve">
          <source>When building a shared library, care must be taken to ensure that the resulting object is named appropriately. In particular, GHC expects the name of a shared object to have the form &lt;code&gt;libHS&amp;lt;unit id&amp;gt;-ghc&amp;lt;ghc
version&amp;gt;.&amp;lt;ext&amp;gt;&lt;/code&gt; where &lt;em&gt;unit id&lt;/em&gt; is the unit ID given during compilation via the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag, &lt;em&gt;ghc version&lt;/em&gt; is the version of GHC that produced/consumes the object and &lt;em&gt;ext&lt;/em&gt; is the host system&amp;rsquo;s usual file extension for shared objects.</source>
          <target state="translated">공유 라이브러리를 빌드 할 때 결과 객체의 이름이 적절하게 지정되도록주의해야합니다. 특히, GHC는 공유 객체의 이름이 &lt;code&gt;libHS&amp;lt;unit id&amp;gt;-ghc&amp;lt;ghc version&amp;gt;.&amp;lt;ext&amp;gt;&lt;/code&gt; 형식 일 것으로 예상합니다 . 여기서 &lt;em&gt;unit id&lt;/em&gt; 는 &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt; 통해 컴파일 중에 주어진 단위 ID입니다. -id⟩ 플래그, &lt;em&gt;ghc 버전&lt;/em&gt; 은 객체를 생성 / 소비하는 GHC 버전이고 &lt;em&gt;ext&lt;/em&gt; 는 공유 객체에 대한 호스트 시스템의 일반적인 파일 확장자입니다.</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">패키지를 공유 라이브러리로 빌드 할 때 GHC를 사용하여 링크 단계를 수행 할 수 있습니다. 기본 링커에서 일부 세부 정보를 숨기고 GHC (DLL, ELF DSO 및 Mac OS dylib)에서 지원하는 모든 공유 객체 변형에 대한 공통 인터페이스를 제공합니다. 공유 객체는 다음 두 가지 이유로 특정 방식으로 이름을 지정해야합니다. 호출 규칙과 관련하여 (2) 정적 이름과 달라야합니다. 그렇지 않으면 &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그를 작동 시키는 데 필요한만큼 정확하게 링커를 제어 할 수 없습니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;연결에 영향을주는 옵션&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">호출시 &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; 가 인쇄 ⟨n⟩ &lt;sup&gt;번째&lt;/sup&gt; 행 ⟨m⟩ &lt;sup&gt;번째&lt;/sup&gt; ⟨type⟩ 붙이고 완료 도메인 부분 입력 ⟨string-literal⟩ 수료 후보. 현재 는 입력 프롬프트에서 GHCi가 대화식으로 제공 할 수있는 완료 종류를 나타내는 &lt;code&gt;repl&lt;/code&gt; 도메인 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 변환 할 때 &lt;code&gt;map toUpper&lt;/code&gt; 와 같은 결합 자를 사용하여 문자열의 각 문자를 개별적으로 변환 할 수 없습니다 . 일부 쓰기 시스템의 규칙에 따라 잘못된 결과가 발생하기 때문입니다. &lt;code&gt;toUpper&lt;/code&gt; 와 같은이 모듈의 전체 문자열 대 / 소문자 변환 함수 는 올바른 대 / 소문자 변환 규칙을 따릅니다. 결과적으로,이 기능들은 하나의 입력 문자를 두세 개의 출력 문자로 매핑 할 수 있습니다. 예를 들어, 각 기능의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">폐쇄 형 패밀리 방정식 쌍을 확인할 때 GHC는 RHS를 통합하려고했습니다. 그들이이 방정식 쌍을 통일하지 않으면 주입 주석을 위반하지 않습니다. RHS가 일부 치환 (통화 될 수 있음) 하에서 통일 될 수있는 경우, LHS가 동일한 치환 하에서 통일되거나 후자의 식의 LHS가 이전 식에 포함됩니다. 두 조건이 모두 충족되지 않으면 GHC는 유형 패밀리가 주입 적이 지 않다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="d91afb60853a2bed88378f221146e58bb8e15fde" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;exts/partial_type_signatures#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">&lt;a href=&quot;exts/partial_type_signatures#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 와 결합 하면 사용자는 쿼리에 와일드 카드를 삽입하고 인스턴스와의 ⟨type⟩ 일치를 위해 각 와일드 카드에 필요한 제약 조건을 학습 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 와 결합 하면 사용자는 쿼리에 와일드 카드를 삽입하고 인스턴스와의 ⟨type⟩ 일치를 위해 각 와일드 카드에 필요한 제약 조건을 학습 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef74d5ed6e34befd39c28303ea99762b0677ced" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;exts/template_haskell#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 를 사용&lt;/a&gt; 하여 Template Haskell 코드를 컴파일 할 때 , 인터프리터에서 프로파일 링 된 객체 코드를 실행할 수 있기 때문에 먼저 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 없이 모듈을 컴파일 할 필요가 없습니다 ( &lt;a href=&quot;exts/template_haskell#th-profiling&quot;&gt;프로파일 링과 함께 Template Haskell 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 템플릿 Haskell 코드 를 컴파일 할 때 인터프리터에서 프로파일 링 된 객체 코드를 실행할 수 있으므로 먼저 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 없이 모듈을 컴파일 할 필요가 없습니다 ( &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;프로파일 링에 템플릿 Haskell 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 때 ⟨n⟩ 모듈을 병렬로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="dd600bd791dcd533e241e96d62fd9d5b36e1ddda" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">Haskell 패키지에 대한 공유 객체를 생성 할 때 GHC가이 패키지에 대해 링크 될 때 공유 객체를 인식 할 수 있도록 공유 객체의 이름을 올바르게 지정해야합니다. 공유 객체 이름 맹 글링을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5fcbc5f9e865e6ce637e24cd8412c50b45fce7f7" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linking against this package. See &lt;a href=&quot;packages#building-packages&quot;&gt;shared object name mangling&lt;/a&gt; for details.</source>
          <target state="translated">Haskell 패키지에 대한 공유 객체를 생성 할 때 공유 객체의 이름을 올바르게 지정해야이 패키지에 연결할 때 GHC가 공유 객체를 인식 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;packages#building-packages&quot;&gt;공유 객체 이름 맹 글링&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">이것이 올바른 데이터 구조인지를 결정할 때 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">GHCi 매크로를 정의 할 때, 특히 탭 완성과 관련하여 이름이 내장 명령과 충돌 할 수있는 경우에주의해야 할 중요한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">Haskell에서 임베디드 도메인 특정 언어를 디자인 할 때 유형 수준에서 &lt;code&gt;error&lt;/code&gt; 와 같은 것이 유용 합니다. 이러한 방식으로, EDSL 설계자는 표준 GHC 유형 오류가 아니라 DSL에 특정한 유형 오류를 보여줄 수있다.</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">리스트로 표기하면 desugaring &lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt; GHC가 사용 &lt;code&gt;fromList&lt;/code&gt; 모듈로부터 (등) 방법 &lt;code&gt;GHC.Exts&lt;/code&gt; 를 . &lt;code&gt;GHC.Exts&lt;/code&gt; 를 가져올 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">그렇게 할 때, 선택적으로&amp;ldquo; &lt;code&gt;family&lt;/code&gt; &amp;rdquo;키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b09bd4caf81ecbea6328fe8cec841da926304f" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">활성화되면 GHC는 &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">사용 가능한 경우 GHC는 &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">활성화되면 GHC는 &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">활성화 된 경우 GHC는 유형 검사기에서 추가 정보를 경고로 인쇄합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">활성화되면 GHC는 형식 동의어 확장 형식을 형식 오류로 인쇄합니다. 예를 들어이 형식 동의어를 사용하면</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">활성화 된 경우, 신뢰할 수있는 모듈에 대한 추가 검사를 켜 &lt;code&gt;M&lt;/code&gt; 있는 패키지를 요구, &lt;code&gt;M&lt;/code&gt; 에 대한 고려에 상주 신뢰할 수있는 &lt;code&gt;M&lt;/code&gt; 이 신뢰할 고려되어야합니다.</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드를 생성 할 때 다른 모듈에서 가져온 엔티티가 동적으로 링크 될 수 있다고 가정하십시오. 이 플래그는 &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="translated">내장 명령에 우선 순위를 부여 할 때 &lt;code&gt;::type 3&lt;/code&gt; 과 같이 :: &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt; &lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ee90095bc1ddd211ce603181ac23bb488b4bede" translate="yes" xml:space="preserve">
          <source>When however the traversed container is empty, the result is always a singleton of the empty container, the function is never evaluated as there are no input values for it to be applied to.</source>
          <target state="translated">그러나 순회 된 컨테이너가 비어있는 경우 결과는 항상 빈 컨테이너의 단일 항목이며 적용 할 입력 값이 없으므로 함수가 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b07da55e3e4a468a7f3850c0886d61befe9f38e" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;exts/package_qualified_imports#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">여러 소스의 패키지를 통합 할 때 여러 패키지가 동일한 이름의 모듈을 게시하는 상황이 발생할 수 있습니다. 이전에는 이러한 모듈을 구별하는 유일한 방법은 &lt;a href=&quot;exts/package_qualified_imports#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt; 를 사용하는 것 입니다. 그러나 GHC 7.10 이후로 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 플래그 (및 그 변형)가 확장되어 사용자가 모듈 가져 오기에 첨부 할 수있는 가져 오기 목록과 유사하게 패키지가 범위로 ​​가져 오는 모듈을 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">여러 소스의 패키지를 통합 할 때 여러 패키지가 동일한 이름의 모듈을 게시하는 상황이 발생할 수 있습니다. 이전에는 이러한 모듈을 구별 할 수있는 유일한 방법은 &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;패키지 인증 가져 오기&lt;/a&gt; 를 사용하는 것 입니다. 그러나 GHC 7.10부터 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 플래그 (및 해당 변형)가 확장되어 사용자가 모듈 가져 오기에 첨부 할 수있는 가져 오기 목록과 유사하게 패키지가 범위에 포함되는 모듈을 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서 호출 될 때이 함수를 사용하면 마스크 된 비동기 예외 (있는 경우)가 발생할 수 있습니다. 인터럽트 가능한 작업을 수행하는 것과 같지만 (#interruptible 참조) 실제 차단은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 호출되면 런타임은 비용 중심 프로파일을 기계가 읽을 수있는 JSON 형식으로 생성합니다. 이 형식의 최상위 개체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">&lt;code&gt;-g&lt;/code&gt; 플래그 와 함께 호출되면 GHC는 표준 &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; 디버깅 정보를 생성 합니다. 이 형식은 거의 모든 POSIX 호환 대상에서 사용되며 디버깅 및 성능 도구 (예 : &lt;code&gt;gdb&lt;/code&gt; , &lt;code&gt;lldb&lt;/code&gt; 및 &lt;code&gt;perf&lt;/code&gt; )에서 GHC 컴파일 프로그램의 구조를 이해하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">시작시 &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt; 플래그를 지정 하지 않으면 GHCi 는 다음 파일에서 명령을 읽고 순서대로 실행합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">GHC는 유형을 종류 검사 할 때 유형의 종류를 일반화하는 방법을 알아낼 때 해당 유형으로 작성된 내용 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">바이너리 실행 파일을 링크 할 때 &lt;code&gt;-l&lt;/code&gt; 앞에 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 플래그를 삽입합니다. 하스켈 라이브러리에 대한 플래그를, 그리고 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 이후</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">바이너리 실행 파일을 링크 할 때,이 삽입 플래그 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 어떤 전에 &lt;code&gt;-l&lt;/code&gt; 하스켈 라이브러리에 대한 플래그 및 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; OS X에 (이후, 플래그가 없습니다 &lt;code&gt;-Wl,-all_load&lt;/code&gt; 에는 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 와 동등한 항목이 없습니다 . 이 플래그는 또한 &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; 사용하지 않습니다. &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; ( OS X의 경우 -Wl, -dead_strip )를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3818bf88dbd86c201ca5b0d240e8772c4b466f3c" translate="yes" xml:space="preserve">
          <source>When linking a static library (&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt;) GHC links the RTS automatically, you can reverse this behaviour by reversing this flag: &lt;code&gt;-fno-link-rts&lt;/code&gt;.</source>
          <target state="translated">정적 라이브러리 ( &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt; )를 링크 할 때 GHC는 RTS를 자동으로 링크 할 때 &lt;code&gt;-fno-link-rts&lt;/code&gt; 플래그를 반대로하여이 동작을 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="408951dfca34cc5b21016977e48bc1e9b23d4168" translate="yes" xml:space="preserve">
          <source>When linking shared libraries (&lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt;) GHC does not automatically link the RTS. This is to allow choosing the RTS flavour (&lt;a href=&quot;#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt;, etc) when linking an executable. However when the shared library is the intended product it is useful to be able to reverse this default. See &lt;a href=&quot;shared_libs#shared-libraries-c-api&quot;&gt;Shared libraries that export a C API&lt;/a&gt; for an usage example.</source>
          <target state="translated">공유 라이브러리 ( &lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; )를 연결할 때 GHC는 RTS를 자동으로 연결하지 않습니다. 이는 RTS 맛 (선택 허용하는 것입니다 &lt;a href=&quot;#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; 실행 파일을 링크 할 때 등). 그러나 공유 라이브러리가 의도 한 제품인 경우이 기본값을 되돌릴 수 있으면 유용합니다. 사용 예 &lt;a href=&quot;shared_libs#shared-libraries-c-api&quot;&gt;는 C API&lt;/a&gt; 를 내보내는 공유 라이브러리를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="e65f758cb8818ccee7542109e759d106e5df490b" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;../phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">최종 프로그램을 연결할 때 GHC를 사용하여 연결하는 것이 일반적으로 가장 쉬운 방법이지만 필수는 아닙니다. GHC를 사용하는 경우 &lt;a href=&quot;../phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 플래그를 잊지 마십시오 . 그렇지 않으면 GHC가 &lt;code&gt;Main&lt;/code&gt; Haskell 모듈에 연결을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">최종 프로그램을 링크 할 때 GHC를 사용하여 링크를 수행하는 것이 일반적으로 가장 쉬운 방법이지만 필수는 아닙니다. GHC를 사용하는 경우 플래그 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; 을&lt;/a&gt; 잊지 마십시오 . 그렇지 않으면 GHC가 &lt;code&gt;Main&lt;/code&gt; Haskell 모듈에 연결을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="translated">링크 할 때 링커는 참조되지 않은 모든 섹션을 자동으로 제거하여 더 작은 실행 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결시 링커는 참조되지 않은 모든 섹션을 자동으로 제거하여 더 작은 실행 파일을 생성 할 수 있습니다. 효과는 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 다소 더 효율적입니다. 생성 된 라이브러리 파일은 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 보다 약 30 % 작습니다 .</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">부하 분산시 스레드를 동일한 노드의 다른 기능으로 마이그레이션하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 를 사용&lt;/a&gt; 하여 소스 모듈을로드 할 때 GHCi는 일반적으로 컴파일 된 해당 객체 파일을 찾고 가능한 경우 소스를 해석하기 위해 우선적으로 파일을 사용합니다. 예를 들어, 모듈 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 로 구성된 4 모듈 프로그램이 있다고 가정하십시오 . 모듈 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 모두 가져 &lt;code&gt;D&lt;/code&gt; 만하고 수입 모두 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">프로그램 실행을위한 프로파일을 볼 때 종종 실행에서 특정 지점이나 단계를 표시하고 프로파일에서 시각적으로 볼 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">일치하는 경우 GHC는 인스턴스 선언의 컨텍스트를 고려하지 않습니다 ( &lt;code&gt;context1&lt;/code&gt; 등)를 .</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">클래스 선언을 병합 할 때 수퍼 클래스와 메소드가 정확히 일치해야합니다. 그러나 &lt;code&gt;MINIMAL&lt;/code&gt; pragma는 논리적으로 함께 OR되며 기본 서명이있는 메소드는 그렇지 않은 메소드와 성공적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성 속성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="7f8276c2b13d74d9733b0f4b7964761949b296cc" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성 속성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">cfg 기반 blocklayout 레이아웃을 사용하지 않는 경우 기본 블록의 마지막 점프 또는 cfg에서 블록의 가장 큰 나가는 모서리에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">과부하가 관련되면 결과가 약간 직관적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">해제되지 않은 배열 유형을 외부 C 호출에 인수로 전달할 때 외부 함수는 배열을 포함하는 &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; 힙 개체가 아닌 배열의 페이로드를 참조하는 포인터를 봅니다.&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt; 1&lt;/a&gt; . 반대로 &lt;code&gt;foreign import prim&lt;/code&gt; 에 의해 도입 된 &lt;a href=&quot;#ffi-prim&quot;&gt;외부 Cmm 호출&lt;/a&gt; 은 페이로드뿐만 아니라 힙 객체를 봅니다. 이는 일부 상황에서 외부 C 함수가 RTS 클로저 유형에 대한 지식이 필요하지 않을 수 있음을 의미합니다. 다음의 예는 최초의 3 바이트 요약 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; 에서 아무것도 사용하지 않고 &lt;code&gt;Rts.h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a4c7d10b77d99dca5310fa9f2e2f9dfc8d9db49c" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">해제되지 않은 배열 유형을 외부 C 호출에 대한 인수로 전달할 때 외부 함수는 &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; 힙 객체가 아닌 배열의 페이로드를 참조하는 포인터를 봅니다 &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 대조적 으로 &lt;code&gt;foreign import prim&lt;/code&gt; 에 의해 도입 된 &lt;a href=&quot;#ffi-prim&quot;&gt;외부 Cmm 호출&lt;/a&gt; 은 페이로드뿐만 아니라 힙 객체를 확인합니다. 이는 일부 상황에서 외부 C 함수가 RTS 클로저 유형에 대한 지식이 필요하지 않을 수 있음을 의미합니다. 다음 예에서 제 3 바이트 합산 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; 에서 아무것도없이 &lt;code&gt;Rts.h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">패턴 일치시 각 패턴 일치는 각 존재 유형 변수에 대해 새롭고 고유 한 유형을 도입합니다. 이러한 유형은 다른 유형과 통합 할 수 없으며 패턴 일치 범위에서 벗어날 수도 없습니다. 예를 들어, 이러한 조각은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">패턴 일치시 이러한 제한 조건을 사용하여 일치 본문에서 제한 조건을 해제 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">GADT에서 가져온 데이터 생성자 (예 : &lt;code&gt;case&lt;/code&gt; 표현식) 에 대한 패턴 일치시 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="eed65a0801ab307b876b3214608b9b1af66d76f9" translate="yes" xml:space="preserve">
          <source>When preceded but not followed by whitespace, &lt;code&gt;(@)&lt;/code&gt; is treated as a visible type application.</source>
          <target state="translated">앞에 공백이없는 경우 &lt;code&gt;(@)&lt;/code&gt; 은 표시 유형 응용 프로그램으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">레코드 구성에 레코드 와일드 카드를 사용하는 경우 &lt;code&gt;f&lt;/code&gt; 가 범위 내에 있고 최상위 레벨에서 가져 오거나 바인드되지 않은 경우에만 필드 &lt;code&gt;f&lt;/code&gt; 가 초기화됩니다 . 예를 들어, &lt;code&gt;f&lt;/code&gt; 는 둘러싸는 패턴 일치 또는 let / where-binding에 의해 바인딩 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">입력 된 구멍을보고 할 때 범위 내에있는 구속 조건도 인쇄하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">프로그램에 &lt;code&gt;-hr&lt;/code&gt; 옵션 을 제공하여 보유자 프로파일 링을 요청하면 보유자 세트별로 분류 된 그래프가 생성됩니다. 리테이너 세트는 비용 중심 스택 세트로 표시됩니다. 이는 일반적으로 프로파일 그래프에 맞추기에는 너무 커서 각 보유자 세트의 번호가 매겨지고 그래프에 약어로 표시되며 보유자 세트의 전체 목록이 &lt;code&gt;prog.prof&lt;/code&gt; 파일에 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">대화식 콘솔 프로세스 (예 : 셸, 콘솔 기반 텍스트 편집기 또는 ghci)를 실행할 때 일반적으로 해당 프로세스가 Ctl-C 키보드 인터럽트를 처리하는 방식을 처리 할 수 ​​있기를 원합니다. 예를 들어, 대부분의 프로그램은 단순히 Ctl-C를 종료하지만 일부는 특수하게 처리합니다. 이를 가능하게하려면 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 옵션에서 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">이 파일에서 언어 옵션을 설정하는 경우 일반적으로 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 ( &lt;a href=&quot;#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">Safe Haskell 추론은 언제 사용해야하며 명시적인 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그 는 언제 사용해야 합니까? 후자의 경우는 모듈이 안전해야한다는 어려운 요구 사항이있을 때 사용해야합니다. &lt;a href=&quot;#safe-use-cases&quot;&gt;Safe Haskell&lt;/a&gt; 의 Safe Haskell 사용 : 신뢰할 수없는 코드 실행에 가장 유용 합니다. 안전한 추론은 일반 Haskell 프로그래머가 사용해야합니다. Safe Haskell에 관심이없는 사용자</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">경고를 제어하는 ​​플래그를 표시 할 때 경고가 포함 된 각 경고 그룹 플래그도 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">제약 조건을 해결할 때 사용 가능한 사전을 사용하여 수퍼 클래스를 열심히 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; 를 지정할 때 pragma를 모든 패턴의 결과 유형이 서로 일치해야합니다. 유형이 일치하지 않으면 모든 패턴에서 일치하는 것이 불가능하므로 이는 완전성 점검입니다.</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">중단 점 또는 단일 단계에서 중지되면 GHCi는 변수 &lt;code&gt;_result&lt;/code&gt; 를 현재 활성 표현식의 값에 바인드합니다 . 평가를 중단했기 때문에 &lt;code&gt;_result&lt;/code&gt; 의 값은 아직 사용할 수 없지만 아마도 강제 될 수 있습니다. 유형이 알려지고 표시 가능한 경우 프롬프트에서 &lt;code&gt;_result&lt;/code&gt; 를 입력 하면 표시됩니다. 그러나이 작업을 수행 할 때 한 가지주의 할 사항이 있습니다. &lt;code&gt;_result&lt;/code&gt; 를 평가 하면 현재 중단 된 중단 점부터 시작하여 추가 중단 점을 트리거 할 가능성이 높습니다 ( &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; 아닌 실제 중단 점에서 중단 된 경우 ). 따라서 평가할 때 즉시 &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; 를 발행해야합니다 &lt;code&gt;_result&lt;/code&gt; 를. 또는 사용할 수 있습니다&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;중단 점을 무시하는 : force .</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">중단 점에서 중지했을 때 이미 평가중인 변수를 평가하려고하면 두 번째 평가가 중단됩니다. 그 이유는 GHC가 변수가 평가 중이라는 것을 알고 있기 때문에 새로운 평가는 계속하기 전에 결과를 기다리지 만 첫 번째 평가가 중단 점에서 중지되기 때문에 발생하지 않을 것입니다. Control-C는 중단 된 평가를 중단하고 프롬프트로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f4622c9a9bbe02a9f4c027c4d5d4cd516225b4" translate="yes" xml:space="preserve">
          <source>When surrounded by whitespace on both sides, &lt;code&gt;(@)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="translated">양쪽이 공백으로 둘러싸여 있으면 &lt;code&gt;(@)&lt;/code&gt; 은 GHC에서 일반 중위 연산자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어, 모듈이 신뢰 여부를 특정 패키지가 신뢰할 수있는 경우에 따라 달라집니다. 패키지 신뢰는 GHC를 호출하는 클라이언트 C (즉, 귀하)에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 사용되는 &lt;em&gt;패키지 P에서 모듈 M을 클라이언트 C 신뢰&lt;/em&gt; 의 경우 만</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">때 &lt;code&gt;*&lt;/code&gt; 가 사용되고, GHCi는 미리 컴파일 된 오브젝트 코드를 해석하는 모듈을 무시한다. 이미 많은 수의 모듈을 객체 코드로로드하고 전체 모듈을 다시로드하는 대신 모듈 중 하나를 해석하려는 경우 &lt;code&gt;:add *M&lt;/code&gt; 을 사용하여 &lt;code&gt;M&lt;/code&gt; 을 해석 하도록 지정할 수 있습니다 ( 컴파일 된 모듈은 해석 된 모듈에 의존 할 수 없기 때문에 다른 모듈도 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aedbc26d9c8b6dfa0d4dad036dcef71afa8bd612" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-haddock&lt;/code&gt; option is enabled, GHC collects documentation comments and associates them with declarations, function arguments, data constructors, and other syntactic elements. Documentation comments in invalid positions are discarded:</source>
          <target state="translated">때 &lt;code&gt;-haddock&lt;/code&gt; 의 옵션이 활성화되어, GHC는 문서 주석과 선언, 함수 인수, 데이터 생성자 및 기타 구문 요소와 동료를 수집합니다. 잘못된 위치의 문서 주석은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">때 &lt;code&gt;GADTSyntax&lt;/code&gt; 의 확장이 활성화되어, GHC는 명시 적으로 생성자의 유형 서명을함으로써 대수 데이터 형식을 선언 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9df18db363cd1745ba8506093666b4dbb4c8cd67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">때 &lt;code&gt;InterruptibleFFI&lt;/code&gt; 의 확장이 활성화되어, 외국 통화는 주석 할 수 &lt;code&gt;interruptible&lt;/code&gt; 대신 &lt;code&gt;safe&lt;/code&gt; 또는 &lt;code&gt;unsafe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">때 &lt;code&gt;OverloadedLists&lt;/code&gt; 의 확장이 설정되어 다음과 같이 언급 한 일곱 표기법 desugared 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b88d963a673ec0ba32ba448653b0c170c75e2ae9" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;exts/template_haskell#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;exts/template_haskell#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">컴파일러 유형이 소스 코드를 확인하면 &lt;a href=&quot;exts/template_haskell#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices 및 &lt;a href=&quot;exts/template_haskell#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; 이 생성 된 구문 트리 조각으로 대체됩니다. 그러나 소스 코드에서 작동하는 도구의 경우 일반적으로 생성 된 코드보다 코드 생성기가 더 흥미 롭습니다. 이러한 이유로 우리는 &lt;code&gt;spliceRunAction&lt;/code&gt; 을 포함 했습니다 . 이 필드는 평가되기 전에 각 표현식에서 호출됩니다. 입력은 유형 검사이므로 이러한 구문 트리 조각에 의미 정보를 사용할 수 있습니다. 다른 식을 반환하면 생성 된 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">컴파일러 유형이 소스 코드를 확인하면 &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices 및 &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; 은 소스 코드에서 생성 된 구문 트리 조각으로 대체됩니다. 그러나 소스 코드에서 작동하는 도구의 경우 코드 생성기는 일반적으로 생성 된 코드보다 흥미 롭습니다. 이러한 이유로 &lt;code&gt;spliceRunAction&lt;/code&gt; 을 포함 시켰 습니다 . 이 필드는 평가되기 전에 각 표현식에서 호출됩니다. 입력은 유형 검사되므로 이러한 구문 트리 조각에 대한 의미 정보가 사용 가능합니다. 다른 식을 반환하면 생성 된 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7155c3fb192924591b079e548fd800bda9de1a0b" translate="yes" xml:space="preserve">
          <source>When the demand analysis thinks that the scrutinee does not return (i.e. a bottoming expression)</source>
          <target state="translated">수요 분석에서 scrutinee이 반환되지 않는다고 생각하는 경우 (예 : 바닥 표현)</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">플래그 경우 &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; 내지 An 설정된 &lt;code&gt;n&lt;/code&gt; 보다 큰 &lt;code&gt;0&lt;/code&gt; , GHC는 최대 필요한 유효 정공 적합하다 유효한 정제 정공 맞는 목록까지 제공한다 &lt;code&gt;n&lt;/code&gt; 추가적인 정교화 레벨 각 레벨은 구멍이 뚫린 구멍을 추가로 채워야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2ede94233945ceef730a5c52baafcf873f723c3a" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">&lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그 가 사용 가능하면 왼쪽의 패턴에서 언급되었지만 오른쪽에서는 사용되지 않는 유형 변수가보고됩니다. 왼쪽에서 여러 번 발생하는 변수도 사용 된 것으로 간주됩니다. 경고를 표시하지 않으려면 사용하지 않는 변수를 대체하거나 밑줄 접두사를 붙여야합니다. 밑줄 ( &lt;code&gt;_x&lt;/code&gt; )로 시작하는 유형 변수 는 그렇지 않으면 일반 유형 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그 가 활성화되면 왼쪽 패턴에서 언급되었지만 오른쪽에서는 사용되지 않은 유형 변수가보고됩니다. 왼쪽에서 여러 번 발생하는 변수도 사용 된 것으로 간주됩니다. 경고를 표시하지 않으려면 사용하지 않는 변수를 밑줄로 바꾸거나 접두사를 붙여야합니다. 밑줄 ( &lt;code&gt;_x&lt;/code&gt; )로 시작하는 유형 변수 는 일반 유형 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">마지막 유형 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) 일반적인 알고리즘을 사용하여 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 생성되지 않습니다. 대신, 전체 가치가 강요됩니다.</target>
        </trans-unit>
        <trans-unit id="d0534d81c2091ec317265f39796ac46bfc114919" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">마지막 유형 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스는 일반적인 알고리즘을 사용하여 생성되지 않습니다. 대신 전체 값이 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0e2720d4d44b6279dbfb5714c776d53f456b2a" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt;, the effect in question is to short-circuit the computation on encountering &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나드 &lt;strong&gt; &lt;code&gt;m&lt;/code&gt; &lt;/strong&gt; 이 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 일 때 문제의 효과는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 만났을 때 계산을 단락시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fbd7b3ed9f72374ca75e11634d478bca8f1e358c" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, applying &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; to a list of IO actions, performs each in turn, returning a list of the results:</source>
          <target state="translated">모나드 &lt;strong&gt; &lt;code&gt;m&lt;/code&gt; &lt;/strong&gt; 이 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 를 IO 작업 목록에 적용하면 차례로 각각을 수행하여 결과 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">데이터 또는 형식 인스턴스 선언의 형식 인수 이름이 중요하지 않은 경우 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9438e464295e0f808c720323652b4fe168da340b" translate="yes" xml:space="preserve">
          <source>When the operator is always strict in the second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` is generally a better choice than &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. When &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; is called with a strict operator, evaluation cannot begin until the last element is reached, by which point a deep stack of pending function applications may have been built up in memory.</source>
          <target state="translated">연산자가 항상 두 번째 인수에서 엄격 할 때, 일반적으로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 이 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 보다 나은 선택 입니다. &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 가 엄격한 연산자로 호출 되면 마지막 요소에 도달 할 때까지 평가를 시작할 수 없습니다.이 시점에서 보류중인 함수 응용 프로그램의 깊은 스택이 메모리에 구축되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9f4c1ad6996c1901a0ec2fced4b4100819215e" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 와 연결되면 동시에 여러 OS 스레드에서 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출 할 수 있습니다 . 런타임 시스템은 &lt;code&gt;hs_init()&lt;/code&gt; 를 호출하여 평소와 같이 초기화해야 하며이 호출은 &lt;code&gt;foreign export&lt;/code&gt; 함수를 호출하기 전에 완료되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 와 링크되면 여러 OS 스레드에서 동시에 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출 할 수 있습니다 . 런타임 시스템은 &lt;code&gt;hs_init()&lt;/code&gt; 를 호출하여 평상시와 같이 초기화해야 하며이 호출은 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출하기 전에 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; 옵션 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )으로 링크 되면 런타임 이벤트는 여러 가지 방법으로 로그 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">세분화 수준을 설정하지 않으면 유효한 구멍 맞춤 제안 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bdff41ed009289d642a16083019ce0168e38ec29" translate="yes" xml:space="preserve">
          <source>When the scrutinee is a GADT and its type rules out some constructors, and others constructors are already handled by the case expression.</source>
          <target state="translated">scrutinee이 GADT이고 유형이 일부 생성자를 제외하고 다른 생성자가 이미 case 표현식에 의해 처리 된 경우.</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 표현식 의 명령문 사이에 종속성이 있고 &lt;code&gt;ApplicativeDo&lt;/code&gt; 가 &lt;code&gt;Applicative&lt;/code&gt; 유형을 유추 할 수없는 경우 휴리스틱 알고리즘을 사용하여 가능한 한 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하려고 합니다. 이 알고리즘은 일반적으로 최상의 솔루션을 찾지 만 드문 복잡한 경우에는 기회를 놓칠 수 있습니다. 옵션으로 제공되는 최적의 솔루션을 찾는 알고리즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">형식에 생성자가 없으면 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 가능한 가장 느린 인스턴스를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 (참조 &lt;a href=&quot;#roles&quot;&gt; Roles&lt;/a&gt; ) &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 간단한 인스턴스를 파생합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;역할&lt;/a&gt; 참조) ) &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 이&lt;/a&gt; 해당 인수를 강제합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df5cd675628ff7edd99330931c3924f3651bb0c8" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">유형 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 사소한 인스턴스를 파생합니다. 예를 들어 다음 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="589660ea440e8fa723f008c0478d09f535adede3" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">유형 매개 변수에 가상 역할이있는 경우 ( &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 인수를 강제합니다. 예를 들어 다음 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">사용자가 쓸 때</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="translated">오른쪽이있을 때 GHC는 오른쪽과 일치하는 가장 다형성 종류를 추론합니다. 예 : 일반 데이터 유형 및 GADT 선언, 클래스 선언. 클래스 선언의 경우 &quot;오른쪽&quot;의 역할은 클래스 메서드 서명에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="translated">오른쪽이없는 경우 GHC 는 종류 서명에 의해 달리 지시되는 경우를 제외하고 인수 및 결과 종류를 &lt;code&gt;Type&lt;/code&gt; 으로 기본 설정 합니다. 예 : 데이터 및 개방형 패밀리 선언.</target>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">일련의 명령문에서 엄격한 패턴 일치가있는 경우 &lt;code&gt;ApplicativeDo&lt;/code&gt; 는 해당 명령문과 그 뒤에 오는 명령문 사이에 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 를 배치 합니다. 시퀀스는 다른 곳에서 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하도록 변환 될 수 있지만 엄격한 패턴 일치 및 다음 명령문은 표준 do-notation과 동일한 엄격 의미론을 유지하기 위해 항상 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 와 연결 됩니다. 이것을 원하지 않으면 단순히 패턴 일치에 &lt;code&gt;~&lt;/code&gt; 를 붙이면 게으르게됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">이 플래그가 활성화되고 &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt; 가 비활성화되면 블록 레이아웃은 8.6 이전 버전과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">이 플래그가 설정되면, 변수는 &lt;code&gt;it&lt;/code&gt; 더 이상 이전에 평가 식의 결과로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">이 최적화가 활성화되면 코드 생성기는 모든 자체 재귀 포화 테일 호출을 함수 호출이 아닌 로컬 점프로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 활성화되면, 기능 \ (i \)에 대한 OS 스레드는 스레드 선호도를 설정하기 위해 OS에서 제공하는 API를 사용하여 CPU 코어 \ (i \)에 바인딩됩니다. 예를 들어 Linux GHC에서는 &lt;code&gt;sched_setaffinity()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">이 옵션을 지정하면 중간 부동 소수점 값 이 최종 유형 &lt;em&gt;보다&lt;/em&gt; 정밀도 / 범위가 &lt;em&gt;더 클&lt;/em&gt; 수 있습니다 . 일반적으로 이것은 좋은 일이지만 일부 프로그램은 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 값 의 정확한 정밀도 / 범위에 의존 할 수 있으므로 컴파일에이 옵션을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">이 경고가 활성화되면 다음 조건이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">전원을 &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt; 하여 모듈별로 억제 할 수 있습니다 . 간혹 API를 변경하지 않고 구현을 변경할 수있는 공간을 남기기 위해 함수가 필요 이상으로 제한적인 서명을 갖기를 원할 수 있습니다. 이 경우 데드 바인딩의 호출을 사용하여 기능별로 경고를 표시하지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">모듈을 타입 검사 할 때, GHC는 제약 해결이 시작되기 전에 &lt;code&gt;tcPluginInit&lt;/code&gt; 를 한 번 호출 합니다. 이를 통해 플러그인은 컨텍스트에서 사물을 찾거나 변경 가능한 상태를 초기화하거나 외부 프로세스 (예 : 외부 SMT 솔버)에 대한 연결을 열 수 있습니다. 플러그인은 원하는 모든 유형의 결과를 반환 할 수 있으며 결과는 다른 두 필드로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">유형의 인스턴스 선언에 의하면 &lt;code&gt;F a&lt;/code&gt; , 우리는 슈퍼 클래스의 것을 확인해야 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;F&lt;/code&gt; 가 보유하고 있습니다. 따라서 다음을 포함하는 이론 하에서 제약 조건 &lt;code&gt;C a&lt;/code&gt; 를 수반하려고한다 .</target>
        </trans-unit>
        <trans-unit id="ec95daf87bcd42f783483d51860a38231b97dbf8" translate="yes" xml:space="preserve">
          <source>When used as a value, &lt;code&gt;MkT1&lt;/code&gt; is given a multiplicity-polymorphic type: &lt;code&gt;MkT1 :: forall {m} a. a %m -&amp;gt; T1 a&lt;/code&gt;. This makes it possible to use &lt;code&gt;MkT1&lt;/code&gt; in higher order functions. The additional multiplicity argument &lt;code&gt;m&lt;/code&gt; is marked as inferred (see &lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so that there is no conflict with visible type application. When displaying types, unless &lt;code&gt;-XLinearTypes&lt;/code&gt; is enabled, multiplicity polymorphic functions are printed as regular functions (see &lt;a href=&quot;#printing-linear-types&quot;&gt;Printing multiplicity-polymorphic types&lt;/a&gt;); therefore constructors appear to have regular function types.</source>
          <target state="translated">값으로 사용되면 &lt;code&gt;MkT1&lt;/code&gt; 에는 다중 다형성 유형이 지정됩니다. &lt;code&gt;MkT1 :: forall {m} a. a %m -&amp;gt; T1 a&lt;/code&gt; . 이를 통해 고차 함수에서 &lt;code&gt;MkT1&lt;/code&gt; 을 사용할 수 있습니다. 추가 다중성 인수 &lt;code&gt;m&lt;/code&gt; 은 추론 된 것으로 표시되므로 ( &lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;추론 된 대 지정된 유형 변수 참조&lt;/a&gt; ) 가시적 유형 애플리케이션과 충돌하지 않습니다. 유형을 표시 할 때 &lt;code&gt;-XLinearTypes&lt;/code&gt; 를 사용 하지 않으면 다중 다형성 함수가 일반 함수로 인쇄됩니다 ( &lt;a href=&quot;#printing-linear-types&quot;&gt;다중 다형성 유형 인쇄&lt;/a&gt; 참조 ). 따라서 생성자는 일반 함수 유형을 갖는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 파생을 기반으로하는 인스턴스와 정의한 인스턴스의 순서를 바꿉니다. 예 :</target>
        </trans-unit>
        <trans-unit id="199505ee33e09e03773bf8a7300953a302a36417" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">&lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 파생의 기반이되는 인스턴스와 정의한 인스턴스의 순서를 바꿉니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">safe 키워드를 사용하여 가져올 모듈은 신뢰할 수있는 모듈이어야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 안전한 가져 오기 확장은 &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; 또는 &lt;code&gt;-XUnsafe&lt;/code&gt; 플래그 중 하나에 의해 사용 가능 합니다. 때 &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하는 경우, &lt;code&gt;safe&lt;/code&gt; 모든 가져 오기가 안전한 수입으로 처리됩니다 같은 키워드는 허용하지만 의미한다.</target>
        </trans-unit>
        <trans-unit id="1487a7894277e2151eefd4c6ac81aaf61e058adb" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;../utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; A의 (해시 기호의 메이크업에 사용하는 등 확장) &lt;code&gt;.hsc&lt;/code&gt; 의 파일 (참조 &lt;a href=&quot;../utils#hsc2hs&quot;&gt;C 코드 작성 하스켈 인터페이스 : hsc2hs을&lt;/a&gt; ), 해시 표지판 (쓰기 배가해야 &lt;code&gt;##foo&lt;/code&gt; 는 대신 &lt;code&gt;#foo&lt;/code&gt; 을 피하기 위해를) &lt;code&gt;hsc2hs&lt;/code&gt; 지시어 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; A의 (해시 기호의 메이크업에 사용하는 등 확장) &lt;code&gt;.hsc&lt;/code&gt; 의 파일 (참조 &lt;a href=&quot;utils#hsc2hs&quot;&gt;C 코드 작성 하스켈 인터페이스 : hsc2hs을&lt;/a&gt; ), 해시 표지판 (쓰기 배가해야 &lt;code&gt;##foo&lt;/code&gt; 는 대신 &lt;code&gt;#foo&lt;/code&gt; 을 피하기 위해를) &lt;code&gt;hsc2hs&lt;/code&gt; 지시어 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">&lt;code&gt;-dynamic-too&lt;/code&gt; 를 사용할 때 &lt;code&gt;-dyno&lt;/code&gt; , &lt;code&gt;-dynosuf&lt;/code&gt; 및 &lt;code&gt;-dynhisuf&lt;/code&gt; 옵션 은 각각 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-osuf&lt;/code&gt; 및 &lt;code&gt;-hisuf&lt;/code&gt; 의 대응 항목 이지만 동적 컴파일에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">&lt;code&gt;capi&lt;/code&gt; 를 사용하면 함수가 아닌 값을 가져올 수도 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 를 사용할 때 일반적인 경험 규칙은 나중에 스파크 계산이 필요하지만 너무 빠르지는 않다는 것입니다. 또한 스파크 계산은 너무 작아서는 안됩니다. 그렇지 않으면 병렬로 계산하는 비용이 병렬 처리량에 비해 너무 클 것입니다. 이러한 요소를 올바르게 얻는 것은 실제로 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 입력 문자 바로 다음에 사용 가능한 경우 개행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e3b100300996ccb1d75762df35aa37649891a202" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, consumes a single character from the input which may be non-printable.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 인쇄 할 수없는 입력에서 단일 문자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 문자를 읽기 전에 &lt;code&gt;EOF&lt;/code&gt; 가 발생 하면 이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4a4385a77afcebb26e3a91b60eea37d30d0eaa80" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 문자를 읽기 전에 &lt;code&gt;EOF&lt;/code&gt; 가 발생 하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8389a66f0ad124cb25ad8df28bee52913fc4af75" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 문자를 읽기 전에 &lt;code&gt;EOF&lt;/code&gt; 가 발생 하면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때이 기능은 입력 라인을 읽는 동안 에코를 끕니다.</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">레코드를 사용할 때 다음과 같이 레코드 필드와 이름이 같은 변수를 바인딩하는 패턴을 작성하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">터미널 스타일의 상호 작용을 사용할 때 줄 바꿈을 기다리지 않고 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">터미널 스타일의 상호 작용을 사용할 때 입력 텍스트가 비어있을 때 사용자가 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 누르면 이러한 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd410ab3f115e8c24b1b1823fdc91cadf6703bb8" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">터미널 스타일 상호 작용을 사용할 때 입력 텍스트가 비어있을 때 사용자가 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 누르면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ab6cf8901d69d58a7db8d885c6657768b53b72bb" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">터미널 스타일 상호 작용을 사용할 때 입력 텍스트가 비어있을 때 사용자가 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 누르면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="translated">플래그를 사용할 때 &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;GHC가 생성되고 파이프를 사용하여 별도의 프로세스와 통신합니다. 네트워크를 통해 통신이 이루어지는 것이 유리한 시나리오 (예 : 크로스 컴파일 링)가 있습니다. GHC는이를 위해 두 가지 유틸리티를 제공하며 &lt;code&gt;utils&lt;/code&gt; 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="translated">값이 FFI 호출에 대한 인수로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">그러나 다른 시스템에서 실행중인 다른 프로세스간에 값이 전달되면 각 프로세스가 다른 주소를 사용하여 지정된 값을 저장할 수 있으므로 주소가 더 이상 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">나중에 렌더링 할 때이 셀이 몇 개의 열 또는 행에 걸쳐 있는지 확인하고 올바른 colspan / rowspan 명령을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 레이블을 작성할 때 해시 부호와 다음 식별자 사이에 공백이 없어야합니다. &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 의&lt;/a&gt; 확장 차종은 접미사 해시 기호의 사용; 만약 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 이&lt;/a&gt; 둘은 활성화 &lt;code&gt;x#y&lt;/code&gt; 의미 &lt;code&gt;x# y&lt;/code&gt; 하지만에만 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 다음 수단 활성화 &lt;code&gt;x #y&lt;/code&gt; . &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장 차종 &lt;code&gt;(#&lt;/code&gt; 때 하나의 어휘, 그래서 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; 가&lt;/a&gt; 활성화되어 당신이 여는 괄호와 오버로드 된 라벨 사이에 공백을 작성해야합니다. 혼동을 피하기 위해, 당신은 강력하게 사용하는 경우 해시 앞에 공백을 넣어하는 것이 좋습니다 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2f28f79b3dd940bfa9b2672d60198c0f52c740d0" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 레이블을 작성할 때 해시 기호와 다음 식별자 사이에 공백이 없어야합니다. &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 의&lt;/a&gt; 확장 차종은 접미사 해시 기호의 사용; 만약 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 이&lt;/a&gt; 둘은 활성화 &lt;code&gt;x#y&lt;/code&gt; 의미 &lt;code&gt;x# y&lt;/code&gt; 하지만에만 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 다음 수단 활성화 &lt;code&gt;x #y&lt;/code&gt; . &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장 차종 &lt;code&gt;(#&lt;/code&gt; 때 하나의 어휘, 그래서 &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; 가&lt;/a&gt; 활성화되어 당신이 여는 괄호와 오버로드 된 라벨 사이에 공백을 작성해야합니다. 혼동을 피하기 위해, 당신은 강력하게 사용하는 경우 해시 앞에 공백을 넣어하는 것이 좋습니다 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1502eef4e2dbb983597804aed463fbf9bc83e3f7" translate="yes" xml:space="preserve">
          <source>When written in non-prefix form, &lt;code&gt;(~)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="translated">접두사가 아닌 형식으로 작성되면 &lt;code&gt;(~)&lt;/code&gt; 는 GHC에서 일반 중위 연산자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0f36236024c993c6fded09cd7fee1e5abbb48f" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;exts/primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">&lt;em&gt;정말&lt;/em&gt; 속도 가 절실하고 &quot;원시 비트&quot;로 바로 내려 가고 싶을 때. unboxed 유형 사용에 대한 일부 정보는 &lt;a href=&quot;exts/primitives#glasgow-unboxed&quot;&gt;Unboxed 유형&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">때 당신은 &lt;em&gt;정말&lt;/em&gt; 속도에 대한 절망, 당신은에서 오른쪽으로 내려 싶다 &quot;원시 비트를.&quot; 비 &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;박스형 유형 사용에&lt;/a&gt; 대한 자세한 내용은 비 박스형 유형 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa3258481b642a9c233d877f43b12650ffee34bb" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">&lt;code&gt;safe&lt;/code&gt; (기본값)으로 주석이 달린 &lt;code&gt;foreign import&lt;/code&gt; 함수 를 호출 하고 프로그램이 &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용하여 링크 된 경우 호출은 실행중인 다른 Haskell 스레드와 동시에 실행됩니다. 프로그램이 &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 없이 링크 된 경우 다른 Haskell 스레드는 호출이 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">&lt;code&gt;safe&lt;/code&gt; (기본값)으로 주석이 달린 &lt;code&gt;foreign import&lt;/code&gt; 함수 를 호출 하고 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용하여 링크 된 경우, 호출은 실행중인 다른 Haskell 스레드와 동시에 실행됩니다. 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 없이 링크 된 경우 호출이 리턴 될 때까지 다른 Haskell 스레드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">템플릿 Haskell 스플 라이스가 포함 된 간단한 모듈을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">&lt;code&gt;Wibble&lt;/code&gt; 을 가져 오는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">지정된 엔티티를 가져오고 사용하는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; 을 사용하여 추상 유형을 정의 할 때 새 유형이 해당 표현에서 일부 인스턴스를 상속하도록 할 수 있습니다. Haskell 98에서는 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 인스턴스를 파생시켜 상속받을 수 있지만 다른 클래스의 경우 명시 적 인스턴스 선언을 작성해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">Haskell 소스 모듈을 GHCi에로드하면 일반적으로 바이트 코드로 변환되고 인터프리터를 사용하여 실행됩니다. 그러나 해석 된 코드는 GHCi에서 컴파일 된 코드와 함께 실행될 수도 있습니다. 실제로, 일반적으로 GHCi가 시작되면 &lt;code&gt;Prelude&lt;/code&gt; 를 포함하는 &lt;code&gt;base&lt;/code&gt; 패키지 의 컴파일 된 사본을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="translated">그런 다음 다음을 포함하는 모듈을 컴파일하면</target>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">프롬프트에 표현식을 입력하면 GHCi는 즉시 결과를 평가하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">프롬프트에서 표현식을 입력하면 범위에 속하는 식별자와 유형은 무엇입니까? GHCi는 표현식의 컨텍스트 구성 방식을 정확하게 제어 할 수있는 유연한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">패턴 일치를 사용하면 바운드 변수에 다형성 유형이있을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">소스 코드에 대한 의미 정보가 필요한 플러그인을 정의하려면 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 필드를 사용하십시오 . 예를 들어, 플러그인이 두 이름이 동일한 정의를 참조하는지 여부를 결정해야하거나 의미 정보를 사용하는 함수의 유형을 확인해야하는 경우입니다. 이 경우 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 또는 &lt;code&gt;renamedResultAction&lt;/code&gt; 을 사용하여 구문 트리의 이름이 바뀌거나 유형이 확인 된 버전에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">소스 코드의 구문 트리를 사용하는 플러그인을 정의하려는 경우 &lt;code&gt;parsedResultAction&lt;/code&gt; 필드 를 대체 하려고 합니다. 이 액세스 포인트를 사용하면 소스 코드의 어휘 토큰 및 주석에 대한 정보와 컴파일 된 모듈의 원래 구문 트리에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">Haskell 프로그램이 시작되면 RTS는 &lt;code&gt;+RTS&lt;/code&gt; 와 &lt;code&gt;-RTS&lt;/code&gt; 사이에 괄호로 묶인 명령 줄 인수를 자체적 으로 추출 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">프롬프트에 표현식 (또는 비 바인드 명령문)이 입력 될 때마다 GHCi는 값을 변수에 내재적으로 바인드 &lt;code&gt;it&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">내보내기 목록이없고 데이터 인스턴스가 정의 될 때마다 데이터 패밀리가 로컬로 정의되어 있는지 또는 다른 모듈에 정의되어 있는지에 관계없이 해당 데이터 패밀리 유형 생성자가 새 데이터 생성자와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">어디 &lt;code&gt;@Int&lt;/code&gt; 이 보이는 유형의 응용 프로그램 (이용하여 &lt;a href=&quot;#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램&lt;/a&gt; 이 instantiate하는) &lt;code&gt;b&lt;/code&gt; 의 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 입니다. 이 형식 응용 프로그램이 작동 하려면 &lt;code&gt;bar&lt;/code&gt; 의 기본 형식 서명이 기본 이 아닌 서명과 형식 변수 순서가 같아야합니다! 그러나 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;C'&lt;/code&gt; 가 동일 해야 할 의무는 없습니다 ( 예 를 들어, 위 의 &lt;code&gt;Enum&lt;/code&gt; 예 참조).</target>
        </trans-unit>
        <trans-unit id="b024d670d888125fe31e9ca369b232e66906c997" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">어디 &lt;code&gt;@Int&lt;/code&gt; 이 보이는 유형의 응용 프로그램 (이용하여 &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램&lt;/a&gt; 이 instantiate하는) &lt;code&gt;b&lt;/code&gt; 의 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; . 이 유형 응용 프로그램이 작동 하려면 &lt;code&gt;bar&lt;/code&gt; 의 기본 유형 서명이 기본 이 아닌 서명과 동일한 유형 변수 순서를 가져야합니다! 그러나 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;C'&lt;/code&gt; 가 동일 해야 할 의무는 없습니다 ( 예를 들어 이에 의존하는 위 의 &lt;code&gt;Enum&lt;/code&gt; 예제 참조).</target>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="translated">어디 &lt;code&gt;TypedHole&lt;/code&gt; 은 오류 발생시 GHC 사용할 수있는 구멍에 대한 모든 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">어디 &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; 에 제공되는 convencience 기능입니다 &lt;code&gt;TcHoleErrors&lt;/code&gt; 가 내부 상태를 필요로하지 않는 플러그인을 정의, 모듈을.</target>
        </trans-unit>
        <trans-unit id="fa5a8e5564838fc8779ef3e81fff81e304d2dcad" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convenience function provided in the &lt;code&gt;GHC.Tc.Errors.Hole&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">어디 &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; 에서 제공하는 편리한 기능입니다 &lt;code&gt;GHC.Tc.Errors.Hole&lt;/code&gt; 의 내부 상태를 필요로하지 않는 플러그인을 정의하는 모듈을.</target>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;v&lt;/code&gt; 는 이진 인코딩 된 데이터 구조입니다. 원본 데이터를 재구성하기 위해 우리는 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt; 을 사용합니다</target>
        </trans-unit>
        <trans-unit id="1498debcd36b3f6ddc4c5309c7855ee018a92837" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions in instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">GHC가 인스턴스 선언에서 확장을 허용하는 경우이 새로운 형태의 &lt;code&gt;class&lt;/code&gt; 에 대해 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 를 사용&lt;/a&gt; 하면 구문이 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">GHC가 확장 인스턴스 선언을 허용하는 경우 우리는이 새로운 형태의 &lt;code&gt;class&lt;/code&gt; 에 대해 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 를 사용&lt;/a&gt; 하면 구문이</target>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">GHC가 확장 인스턴스 선언을 허용하는 경우, 우리는이 새로운 &lt;code&gt;class&lt;/code&gt; 의 클래스 와 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; 를 사용 하면 구문이</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">가능한 경우 응용 프로그램은 대신 일반 공용 인터페이스 모듈 (예 : &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe)&lt;/a&gt; 의 기능을 사용해야합니다 . ByteString 시스템을 낮은 수준으로 확장하는 패키지는이 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">사용자 제공 라이브러리를 찾을 수있는 곳&amp;hellip; ⟨dir⟩ 디렉토리를 라이브러리 디렉토리 경로 앞에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">각 라인 입력 세션의 시작과 끝에서 히스토리를 읽고 쓰는 위치.</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">여기서 &quot;식별자&quot;는 현재 GHCi에로드 된 해석 된 모듈의 최상위 기능 이름을 나타냅니다 (자격이 지정된 이름이 사용될 수 있음). 중단 점은 함수가 완전히 적용되었지만 패턴 일치가 이루어지기 전에 함수 본문에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="30f47faad399154cde4ee06e55aadb6d6a7579b0" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied. If the function has several patterns, then a breakpoint will be set on each of them.</source>
          <target state="translated">여기서 ⟨identifier⟩는 현재 GHCi에로드 된 해석 된 모듈의 최상위 함수를 명명합니다 (정규화 된 이름을 사용할 수 있음). 중단 점이 완전히 적용되면 함수 본문에 설정됩니다. 함수에 여러 패턴이있는 경우 각각에 중단 점이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">Haskell에서 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 가 값을 포함하거나 생성하는 것으로 생각할 수있는 반면 , 반 변형 Functor는 &lt;em&gt;소비&lt;/em&gt; 가치 로 생각할 수있는 Functor입니다 .</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">리스트가 유한하거나 무한 할 수있는 반면, 시퀀스는 항상 유한합니다. 결과적으로 시퀀스의 길이는 엄격합니다. 효율성을 무시하고 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 가 정의 되었다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e17f12cf0a73293ad82b3caa4fe2b94113c0b3" translate="yes" xml:space="preserve">
          <source>Whether a data constructor field is linear or not can be customized using the GADT syntax. Given</source>
          <target state="translated">데이터 생성자 필드가 선형인지 여부는 GADT 구문을 사용하여 사용자 정의 할 수 있습니다. 주어진</target>
        </trans-unit>
        <trans-unit id="d859ca679c3f9519d633fadbe164a6690aa53bfc" translate="yes" xml:space="preserve">
          <source>Whether a fold is recursive, corecursive or short-circuiting can depend on both the method chosen to perform the fold and on the operator passed to that method (which may be implicit, as with the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; method of a monoid instance).</source>
          <target state="translated">폴드가 재귀인지, 코어 커 시브인지 단락인지 여부는 폴드를 수행하기 위해 선택한 방법과 해당 메서드에 전달 된 연산자 ( 모노 이드 인스턴스 의 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 방법 과 같이 암시적일 수 있음)에 따라 달라질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">하이퍼 스레딩 코어를 계산해야하는지 여부는 미심쩍은 질문입니다. 자유롭게 실험 해보고 찾은 결과를 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">비용 센터가 CAF (Constant Applicative Form)인지 여부</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">일치가 원래의 데이터 생성자 집합 또는 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 에서 발생하는지 (후자를 우선)</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">이것이 보류되는지 여부는 사용중인 GHC 버전, 작업중인 플랫폼, 작업중인 데이터 및 사용중인 인코딩에 따라 달라 지므로 직접 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">이 단어 뒤에 공백, 끝 따옴표 등이 와야하는지 여부</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">양수에 대해 더하기 부호를 요구할지 여부.</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">필드를 왼쪽으로 조정할지 또는 제로 패드로할지 여부입니다. &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; 가 우선적 으로 상호 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">원본 소스 코드의 스 니펫 표시 여부</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에서 패턴의 적용 범위를 확인할 때 어떤 &lt;code&gt;COMPLETE&lt;/code&gt; pragma를 사용해야 합니까? 우리가 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2&lt;/code&gt; , 다음 &lt;code&gt;f&lt;/code&gt; 철저한이지만, 우리는 다른 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2Internal&lt;/code&gt; 은 다음 &lt;code&gt;f&lt;/code&gt; 하다 &lt;em&gt;하지&lt;/em&gt; 가 일치하지 때문에, 철저한 &lt;code&gt;MkT2Internal&lt;/code&gt; 을 . 이 딜레마를 해결하는 직관적 인 방법은 이전의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 를 선택하면 발견되지 않은 패턴 절 수가 가장 적으므로 더 나은 선택 임을 인식하는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fbd9610ee671b95cb3c4896a6a1d851665229835" translate="yes" xml:space="preserve">
          <source>Which can, for example, be specialised to number ranges:</source>
          <target state="translated">예를 들어 숫자 범위에 특화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">보다 깔끔한 스타일로 함수를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">가비지 수집중인 세대</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">이는 구멍이 &lt;code&gt;foldl1 _&lt;/code&gt; 로 대체 될 수 있음을 보여줍니다 . 구멍을 고정시키지 않으면 서 사용자가 자신이 가진 옵션을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">다음과 같은 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32045914aee96128fc2bfd16f50a2982f4ee64c2" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is required for type variables from the top of a class or instance declaration to scope over the /bodies/ of the methods, it is not required for the type variables to scope over the /type signatures/ of the methods. For example, the following will be accepted without explicitly enabling &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 는 메서드의 / bodies / 범위를 지정하기 위해 클래스 또는 인스턴스 선언의 맨 위에있는 형식 변수에 필요 하지만 형식 변수가 메서드의 / type signatures / 범위를 지정할 필요는 없습니다. 예를 들어 다음은 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 활성화하지 않고 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 은 모든 목록 요소의 평가를 강제로 :</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">하지만 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; 인용 사용 허용 (즉, 많은 문자의 편리 이스케이프) 단일 또는 이중 따옴표의 매칭 세트를 가짐으로써는, &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; 는 항상 공백, 따옴표 및 백 슬래시를 이스케이프합니다 따라서 인용 mechasnism를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">하지만 &lt;code&gt;INLINE&lt;/code&gt; &quot;나 인라인하시기 바랍니다&quot;라고는 &lt;code&gt;INLINABLE&lt;/code&gt; 은 나를 인라인 주시기 바랍니다 &quot;라고; 재량을 사용하십시오&amp;rdquo;. 다시 말해, 선택은 pragma-free 기능과 동일한 규칙을 사용하는 GHC에 맡겨집니다. &lt;code&gt;INLINE&lt;/code&gt; 과 달리 결정은 &lt;em&gt;호출 사이트&lt;/em&gt; 에서 이루어 지므로 인라인 임계 값, 최적화 수준 등에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">상태 &lt;code&gt;a + b&lt;/code&gt; 로 파싱 &lt;code&gt;(+) a b&lt;/code&gt; 와 결합하는 위치로된다 &lt;code&gt;(+)&lt;/code&gt; 형 연산자, &lt;code&gt;a * b&lt;/code&gt; 로 파싱 &lt;code&gt;a (*) b&lt;/code&gt; 및 거부한다.</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">반면 &lt;code&gt;n&lt;/code&gt; 용도에 &lt;code&gt;k&lt;/code&gt; 따라서 도입하고없이 규칙을 위반 그것이 현재 허용된다. 이는 &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; 이 종류 시그니처에서 발생 하기 때문에 종류 변수로 간주 되기 때문 입니다. 실제로 다음 예제에서 볼 수 있듯이 형식 변수와 종류 변수 사이의 경계는 모호합니다.</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">GHC는 기능을 인라인하기를 원하지만 맹목적으로 그렇게하지는 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">Safe Haskell은 확장 기능이지만 실제로는 GHC를 사용하는 모든 컴파일에 대해 백그라운드에서 실행됩니다. Safe Haskell을 명시 적으로 사용하지 않더라도 모듈의 유형 위반을 추적하여 안전을 유추합니다. 자세한 내용은 &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell 추론&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">Safe Haskell의 기본 사용 사례는 신뢰할 수없는 코드를 실행하지만 Safe Haskell은이를 직접 제공하지 않습니다. 대신 Safe Haskell은 엄격한 유형의 안전을 제공합니다. Safe Haskell이 없으면 GHC는 유형 시스템에 많은 예외를 허용하여 추상화를 전복시킬 수 있습니다. Safe Haskell은 엄격한 유형 안전성을 제공함으로써 개발자가 신뢰할 수없는 코드를 실행하기위한 자체 라이브러리 수준 샌드 박스 메커니즘을 구축 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="def095ee0284bcac4322f43e6852c970ad41b290" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="translated">독립형 종류 서명은 형식 생성자의 종류를 결정하지만 그 배열을 결정하지는 않습니다. 이것은 부분적으로 적용될 수 없기 때문에 유형 패밀리 및 유형 동의어에 특히 중요합니다. 보다&lt;a href=&quot;#type-family-declarations&quot;&gt; 유형 제품군 선언을&lt;/a&gt; arity에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f0727c03f093cd8f954da72e1d96477371ae2259" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;type_families#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="translated">독립형 종류 서명은 형식 생성자의 종류를 결정하지만 그 배열을 결정하지는 않습니다. 이것은 부분적으로 적용될 수 없기 때문에 유형 패밀리 및 유형 동의어에 특히 중요합니다. 참조 &lt;a href=&quot;type_families#type-family-declarations&quot;&gt;유형 제품군 선언을&lt;/a&gt; arity에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">개발하는 동안 때로는 코드에 유형 오류가 있어도 컴파일이 성공하도록하는 것이 바람직합니다. 다음과 같은 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c76bcc0e915bb7788c67f5c0d7c2f5a80c7fcbb7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;../ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;../ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 으로 GHCi에로드 된 모듈 은 &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;static&lt;/code&gt; 표현식을 사용할 수 있지만 REPL에 입력 된 명령문은 그렇지 않을 수 있습니다. 이것은 GHCi의 제한 사항입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;# 12356&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="91465cfe2041d24f0183967b4edb1cd4e56225f7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 으로 GHCi에로드 된 모듈 은 &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;static&lt;/code&gt; 표현식을 사용할 수 있지만 REPL에 입력 된 명령문은 그렇지 않을 수 있습니다. 이것은 GHCi의 제한 사항입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;# 12356&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 으로 GHCi에로드 된 모듈 은 &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;static&lt;/code&gt; 표현식을 사용할 수 있지만 REPL에 입력 된 명령문은 그렇지 않을 수 있습니다. 이것은 GHCi의 한계입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;문제 # 12356&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">프로파일 링이 설정된 상태에서 프로그램을 실행하는 동안 GHC는 비용 중심 스택 스택을 유지하고 모든 비용 (메모리 할당 및 시간)을 현재 비용 중심 스택이 비용 발생 시점의 원인이되도록합니다.</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">앞에서 설정 한 2 번 줄의 중단 점에서 중단 된 상태에서 &lt;code&gt;:step qsort [1,3]&lt;/code&gt; 으로 새로운 평가를 시작했습니다 . 이 새로운 평가는 한 단계 후에 ( &lt;code&gt;qsort&lt;/code&gt; 정의에서) 중지되었습니다 . 현재 접두사를 넘어서 저장된 중단 점이 있음을 나타 내기 위해 프롬프트에 &lt;code&gt;...&lt;/code&gt; 접두사가 붙었습니다 . 컨텍스트 스택을 보려면 &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc8800b1f9d492207f0fef148c021ca763c0e0d1" translate="yes" xml:space="preserve">
          <source>While the examples below are not necessarily the most optimal definitions of the intended functions, they are all cases in which &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is far more appropriate (as well as more efficient) than the lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">아래 예제는 의도 한 함수에 대한 가장 최적의 정의는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 이 lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 보다 훨씬 더 적절할뿐만 아니라 더 효율적인 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">다음과 같은 정의는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">이들은 플래그이지만 모듈이 가질 수있는 Safe Haskell 모듈 유형에도 해당합니다. 이것을 모듈이 가지고 있어야하는 명시 적 계약 (또는 유형)을 선언하는 것으로 생각할 수 있습니다. 유효하지 않으면 컴파일이 실패합니다. 또한 GHC는 Safe Haskell에 올바른 유형을 유추합니다 . 자세한 내용은 &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell 추론&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">이 예제는 비슷해 보이지만 컴파일되지는 않습니다. 이는 마지막 유형 매개 변수 &lt;code&gt;a&lt;/code&gt; 의 모든 항목이 공변량이 아닌 &lt;em&gt;반 변형&lt;/em&gt; 위치 에서 발생하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">이러한 함수에는 안정적인 API가 있으며 이러한 함수를 응용 프로그램에서 사용할 수 있지만 문서화 된 사전 조건을 신중하게 고려하십시오. 잘못 사용하면 참조 투명성이 손상되거나 악화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">이 수준은 다소 낮지 만 데이터 작성 방법에 대한 완전한 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e625b4a26a74d86e3769fcae80feac3c80b5c8b0" translate="yes" xml:space="preserve">
          <source>While user-written type or kind variables are specified by default, GHC permits labelling these variables as inferred. By writing the type variable binder in braces as &lt;code&gt;{tyvar}&lt;/code&gt; or &lt;code&gt;{tyvar :: kind}&lt;/code&gt;, the new variable will be classified as inferred, not specified. Doing so gives the programmer control over which variables can be manually instantiated and which can&amp;rsquo;t. Note that the braces do not influence scoping: variables in braces are still brought into scope just the same. Consider for example:</source>
          <target state="translated">사용자가 작성한 유형 또는 종류 변수는 기본적으로 지정되지만 GHC에서는 이러한 변수에 유추 된 레이블을 지정할 수 있습니다. 유형 변수 바인더를 중괄호 안에 &lt;code&gt;{tyvar}&lt;/code&gt; 또는 &lt;code&gt;{tyvar :: kind}&lt;/code&gt; 로 작성하면 새 변수가 지정되지 않고 추론 된 것으로 분류됩니다. 이렇게하면 프로그래머가 수동으로 인스턴스화 할 수있는 변수와 그렇지 않은 변수를 제어 할 수 있습니다. 중괄호는 범위 지정에 영향을주지 않습니다. 중괄호의 변수는 여전히 동일한 범위로 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">일반적인 패턴 동의어는 두 가지 방식으로 사용될 수 있지만 &lt;code&gt;Point&lt;/code&gt; 를 사용하는 일곱 가지 방법이 있습니다 . 정확하게 일반 레코드 생성자를 사용할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="df9fef21f52afbea42c2a537cd033c1f3e472e48" translate="yes" xml:space="preserve">
          <source>Whitespace can be inserted, as in &lt;code&gt;- 123&lt;/code&gt;, to force interpretation as two tokens.</source>
          <target state="translated">&lt;code&gt;- 123&lt;/code&gt; 과 같이 공백을 삽입 하여 두 개의 토큰으로 해석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">왜 링크 오류가 발생 했습니까?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 가 모두 존재하는 이유는 무엇이며 GHC 가 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 대신 파생 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 구현하도록 선택하는 이유는 무엇입니까? &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 유형을 기반으로하기 때문에 HasSell 2010 보고서에 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 가 언급되어 있지만 매우 효율적인 파서 데이터 구조는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">왜 이것이 필요한가요? 외부 라이브러리가 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성된 스레드에서 호출 되면 각 OS 스레드에 대해 특정 값을 갖는 &lt;em&gt;스레드 로컬&lt;/em&gt; 상태 변수에 액세스 할 수 없습니다 (POSIX의 &lt;code&gt;pthread_key_create&lt;/code&gt; 또는 Win32의 &lt;code&gt;TlsAlloc&lt;/code&gt; 참조 ). 따라서 일부 라이브러리 (예 : OpenGL)는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 작성된 스레드에서 작동하지 않습니다 . 그것들은 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 를 사용하여 생성 된 스레드 에서 또는 &lt;code&gt;main&lt;/code&gt; 또는 &lt;code&gt;foreign export&lt;/code&gt; 에서 호출 될 때 정상적으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">왜 우리가 이것을하고 싶습니까? 주된 이유는 해석 된 코드를 실행하는 RTS가 GHC 자체와 다른 특징 (프로파일 링 또는 동적으로 링크 된) 일 수 있기 때문입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">왜 컴파일 된 코드를 실행해야합니까? 컴파일 된 코드는 해석 된 코드보다 약 10 배 빠르지 만 생성하는 데 약 2 배가 더 걸립니다 (최적화가 설정된 경우 더 길어질 수 있음). 따라서 자주 변경되지 않는 프로그램 부분을 컴파일하고 코드가 활발하게 개발되도록 인터프리터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">너비 자릿수는 수정 자 다음과 지정자 앞에 (여기서 &lt;code&gt;z&lt;/code&gt; 로 표시 ) 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">타입 시그니처의 모노 타입 (tau) 부분에서 발생하는 와일드 카드는 &lt;em&gt;타입 와일드 카드입니다&lt;/em&gt; (&amp;ldquo;타입&amp;rdquo;은 기본 와일드 카드 유형이므로 생략되는 경우가 많습니다). 유형 와일드 카드는 함수 및 &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; Int- &amp;gt; Bool) 또는 &lt;code&gt;Maybe&lt;/code&gt; 와 같은 상위 유형을 포함하여 &lt;code&gt;Bool&lt;/code&gt; 또는 &lt;code&gt;Maybe [Bool]&lt;/code&gt; 과 같은 모든 단일 유형 으로 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9658cea5793b3d031fa20c655bb68dd4c32b903a" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;#11197&lt;/a&gt;.</source>
          <target state="translated">잘 입력 된 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 뒤에 잘못된 유형의 용어가 나타나더라도 출력을 내지 않습니다 . . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;# 11197을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">잘못 입력 한 용어가 잘 입력 된 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 뒤에 표시된다는 사실에도 불구하고 출력을 내 보내지 않습니다 . . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;문제 # 11197을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">때문에이 경고를 올릴 것이다 &lt;code&gt;Zero&lt;/code&gt; 와 &lt;code&gt;Succ&lt;/code&gt; 로 작성되지 않은 &lt;code&gt;'Zero&lt;/code&gt; 와 &lt;code&gt;'Succ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">Windows GUI 전용 프로그램에는 stdin, stdout 또는 stderr이 없으므로 일반적인 Haskell 입력 / 출력 기능을 사용하면 다음과 같은 IO 예외로 인해 프로그램이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">Windows 전용 : 디렉토리 링크</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Windows 경로가 모두 같지는 않습니다. 서로 다른 종류의 경로는 각각 다른 의미를 갖습니다. &lt;code&gt;MAX_PATH&lt;/code&gt; 의 제한은 운영 체제 나 파일 시스템의 제한이 없습니다. 이전 버전과의 호환성을 위해 Win32 API에 의해 적용되는 기본 네임 스페이스의 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">Windows 시스템</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows 특정 오류 : 파일 시스템이 기호 링크를 지원하지 않으면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 으로 인해이 작업이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows 관련 오류 : 사용자에게 기호 링크를 작성할 권한이없는 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; 으로이 조작이 실패 할 수 있습니다. 파일 시스템이 기호 링크를 지원하지 않으면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 으로 실패 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC는 모든 데이터 유형을 자동으로 승격시키고 (값) 생성자를 유형 생성자로 승격시킵니다. 다음과 같은 유형</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 Haskell의 목록 및 튜플 유형은 기본적으로 종류로 승격되며 따옴표가 붙어 있지만 유형 수준에서 동일한 편리한 구문을 즐길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; 를&lt;/a&gt; 사용하면 위 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 당신은 다른 클래스를 파생 할 수 있습니다. 컴파일러는 명시 적으로 정의 된 메소드없이 인스턴스 선언을 생성합니다. 이것은 &lt;a href=&quot;#minimal-pragma&quot;&gt;최소 집합&lt;/a&gt; 이 비어 있는 클래스 , 특히 &lt;a href=&quot;#generic-programming&quot;&gt;일반 함수를&lt;/a&gt; 작성할 때 주로 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Data&lt;/code&gt; 에 정의 &lt;code&gt;Data.Data&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; 을&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대한 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Foldable&lt;/code&gt; 정의, &lt;code&gt;Data.Foldable&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 를&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대한 &lt;code&gt;Functor&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Functor&lt;/code&gt; 에 정의 &lt;code&gt;GHC.Base&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Generic&lt;/code&gt; 및 &lt;code&gt;Generic1&lt;/code&gt; 에 정의 &lt;code&gt;GHC.Generics&lt;/code&gt; 을 . &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍에&lt;/a&gt; 설명 된대로이를 사용하여 일반 기능을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; 를&lt;/a&gt; 사용 하면 &lt;code&gt;template-haskell&lt;/code&gt; 패키지 의 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;Lift&lt;/code&gt; 클래스의 인스턴스를 파생시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 을&lt;/a&gt; 사용하면 Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 유형의 데이터 유형에 대해 &lt;code&gt;Traversable&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수 &lt;code&gt;Traversable&lt;/code&gt; 정의, &lt;code&gt;Data.Traversable&lt;/code&gt; 을 . 이후 &lt;code&gt;Traversable&lt;/code&gt; 인스턴스 지시의 인스턴스 &lt;code&gt;Functor&lt;/code&gt; 및 &lt;code&gt;Foldable&lt;/code&gt; , 그래서, 당신은 아마 그들도 도출 할 수 있습니다 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 의미 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">로 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 당신이 사용할 수있는 &lt;em&gt;자격이&lt;/em&gt; 해당 선택은 범위에있는 경우에도 필드 이름을 &lt;em&gt;자격을&lt;/em&gt; 예를 들어 같은 모듈 가정, &lt;code&gt;M&lt;/code&gt; 을 ,이 법적으로 우리의 이전의 예에서와 같이 :</target>
        </trans-unit>
        <trans-unit id="99f7c9801f0ef0a07288415240f5ce1502d72261" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-GHCForeignImportPrim&quot;&gt;&lt;code&gt;GHCForeignImportPrim&lt;/code&gt;&lt;/a&gt;, GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">&lt;a href=&quot;#extension-GHCForeignImportPrim&quot;&gt; &lt;code&gt;GHCForeignImportPrim&lt;/code&gt; 을&lt;/a&gt; 사용하면 GHC는 다음과 같은 추가 호출 규칙 &lt;code&gt;prim&lt;/code&gt; 으로 FFI를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="3633e2ee9e40b7726e0f89355deb245b14e9f8fc" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, both anomalies are resolved:</source>
          <target state="translated">&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; 을&lt;/a&gt; 사용하면 두 가지 이상 현상이 모두 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">&lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는 여러 분기로 조건식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9a679f9cc8ac2f8e0bd4d243711194c8b0678482" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;generics#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;generics#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , 당신은 클래스의 인스턴스 유도 할 수있다 &lt;code&gt;Generic&lt;/code&gt; 및 &lt;code&gt;Generic1&lt;/code&gt; 에 정의 &lt;code&gt;GHC.Generics&lt;/code&gt; 을 . &lt;a href=&quot;generics#generic-programming&quot;&gt;일반 프로그래밍에&lt;/a&gt; 설명 된대로이를 사용하여 일반 함수를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39f1831d8e85cb1a415e324a97c3fdb0f34ffde3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;, we can give the kind of a datatype written in GADT-syntax (see &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; 를&lt;/a&gt; 사용하면 GADT 구문으로 작성된 데이터 유형의 종류를 제공 할 수 있습니다 ( &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt; 참조 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d75b9ce3d652c231eb22d06b84771c3d1879c4f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XLinearTypes&lt;/code&gt;, you can write &lt;code&gt;f :: a %1 -&amp;gt; b&lt;/code&gt; to mean that &lt;code&gt;f&lt;/code&gt; is a linear function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. If &lt;a href=&quot;unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; is enabled, the &lt;code&gt;%1 -&amp;gt;&lt;/code&gt; arrow can be written as &lt;code&gt;⊸&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;-XLinearTypes&lt;/code&gt; , 당신은 쓸 수 있습니다 &lt;code&gt;f :: a %1 -&amp;gt; b&lt;/code&gt; 을 의미하는 &lt;code&gt;f&lt;/code&gt; 는 으로부터 선형 함수 에 &lt;code&gt;b&lt;/code&gt; . &lt;a href=&quot;unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;%1 -&amp;gt;&lt;/code&gt; 화살표는 &lt;code&gt;⊸&lt;/code&gt; 로 쓸 수 있습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61a0296f22c09085434bc8fbe6087bddeed249a7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XRecursiveDo&lt;/code&gt;, &lt;code&gt;rec&lt;/code&gt; and &lt;code&gt;mdo&lt;/code&gt; blocks use &lt;code&gt;M.mfix&lt;/code&gt; and &lt;code&gt;M.return&lt;/code&gt;:</source>
          <target state="translated">로 &lt;code&gt;-XRecursiveDo&lt;/code&gt; , &lt;code&gt;rec&lt;/code&gt; 및 &lt;code&gt;mdo&lt;/code&gt; 블록을 사용 &lt;code&gt;M.mfix&lt;/code&gt; 및 &lt;code&gt;M.return&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;-maxN⟨x⟩&lt;/code&gt; , 즉 &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; , 런타임은 시스템의 프로세서 수에 의해 제한, 대부분의 (X)로 선택합니다. 기본 사용 옵션 &lt;code&gt;-N&lt;/code&gt; 이 필요한 경우 (x)를 생략하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">&lt;code&gt;hpc-tracer&lt;/code&gt; 를 사용하면 8입니다 (탭은 여러 공백을 나타냄).</target>
        </trans-unit>
        <trans-unit id="1f5b790aba3cca991b680469d0ff5aa545bb45ba" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">GHC에서 &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 표현은 &lt;em&gt;고정 된&lt;/em&gt; 메모리를 사용하므로 GC에서 이동할 수 없습니다. 이것은 일반적으로 큰 문자열에 대해 수행하는 올바른 작업이지만 고정 된 메모리를 사용하는 작은 문자열의 경우 공간을 낭비하는 힙 조각화로 이어질 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 의 유형 (과 &lt;code&gt;Text&lt;/code&gt; 로부터 유형 &lt;code&gt;text&lt;/code&gt; 패키지)를 사용하여 &lt;em&gt;고정 해제&lt;/em&gt; 가 힙 단편화에 기여하지 않도록 메모리를. 또한 GHC를 사용하면 고정되지 않은 작은 문자열이 별도의 고정 된 영역이 아닌 일반 힙 할당과 동일한 방식으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">GHC에서 &lt;code&gt;ByteString&lt;/code&gt; 표현은 &lt;em&gt;고정 된&lt;/em&gt; 메모리를 사용하므로 GC로 이동할 수 없습니다. 이는 일반적으로 더 큰 문자열에 대해 올바른 작업이지만 고정 된 메모리를 사용하는 작은 문자열에 대해서는 힙 조각화가 발생하여 공간을 낭비 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 의 유형 (과 &lt;code&gt;Text&lt;/code&gt; 로부터 유형 &lt;code&gt;text&lt;/code&gt; 패키지)를 사용하여 &lt;em&gt;고정 해제&lt;/em&gt; 가 힙 단편화에 기여하지 않도록 메모리를. 또한 GHC를 사용하면 고정되지 않은 작은 문자열이 별도의 고정 영역이 아닌 일반 힙 할당과 동일한 방식으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">GHC를 사용하면 메모리 오버 헤드는 다음과 같이 단어와 바이트로 표시됩니다 (워드는 각각 32 또는 64 비트 시스템에서 4 및 8 바이트입니다).</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">유니 코드 텍스트 의 경우 문자열의 각 문자를 개별적으로 변환하기 위해 &lt;code&gt;map toUpper&lt;/code&gt; 와 같은 결합자를 사용하는 것은 올바르지 않습니다 . 대신이 모듈에서 전체 문자열 대 / 소문자 변환 함수를 사용하십시오. 다른 쓰기 시스템에서의 정확성을 위해 이러한 기능은 하나의 입력 문자를 두세 개의 출력 문자에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">운 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; C 스타일 사전 처리를 지원하는 다른 모든 구현 에서는 __GLASGOW_HASKELL__ 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c44ed7fc274ccaa822b5b3ccf3ecc3bf7adbae81" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;#2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">종속 유형 기능을 사용하면 더 유용합니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;# 2431&lt;/a&gt; 참조 ). 예를 들어, &lt;code&gt;absurd&lt;/code&gt; 두 가지 후보 정의를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">종속적으로 유형이 지정된 기능을 사용하면 더 유용합니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;문제 # 2431&lt;/a&gt; 참조 ). 예를 들어, &lt;code&gt;absurd&lt;/code&gt; 다음 두 후보 정의를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ad7584c8bb969b4ca391280d29051d7fd169de9" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;../using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;../using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">친절한 다형성으로 인해 하스켈 프로그래머에게는 보이지 않는이면에서 꽤 많은 일이 벌어지고 있습니다. GHC는 오류 메시지 및 GHCi 프롬프트에서 유형이 인쇄되는 방식을 제어하는 ​​여러 플래그를 지원합니다. 자세한 &lt;a href=&quot;../using#pretty-printing-types&quot;&gt;내용은 유형 예쁜 인쇄 옵션&lt;/a&gt; 에 대한 설명을 참조하십시오. 종류 다형성을 사용하고 GHC가 프로그램을 거부 (또는 수락)하는 이유에 대해 혼란 &lt;a href=&quot;../using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; 이러한 플래그, 특히 -fprint-explicit-kinds를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">친절한 다형성으로, Haskell 프로그래머에게는 보이지 않을 수있는이면에서 약간의 진행이 있습니다. GHC는 오류 메시지와 GHCi 프롬프트에서 유형이 인쇄되는 방법을 제어하는 ​​여러 플래그를 지원합니다. 자세한 내용은 &lt;a href=&quot;using#pretty-printing-types&quot;&gt;예쁜 인쇄 옵션&lt;/a&gt; 에 대한 설명을 참조하십시오. 친절한 다형성을 사용하고 왜 GHC가 프로그램을 거부 (또는 수락)하는지에 대해 혼란 &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; 이러한 플래그, 특히 -fprint-explicit-kinds를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">범위 내에서 여러 모듈, 특히 여러 &lt;code&gt;*&lt;/code&gt; 양식 모듈을 사용하면 이름 충돌이 발생할 수 있습니다. Haskell은 이름 충돌이 모호한 식별자가 사용될 때만보고되고 GHCi가 프롬프트에 입력 된 표현식에 대해 동일한 방식으로 동작하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">단지 1 세대 (예 &lt;code&gt;-G1&lt;/code&gt; 참조 &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt; )에 &lt;code&gt;-A&lt;/code&gt; 의 할당 영역의 실제 크기가 힙 데이터 량에 따라 크기가 조정되기 때문에 옵션이 최소 할당 영역을 지정한다 (참조 &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; 아래의 ⟨factor below).</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">일부 예외 (아래 참조)를 제외하면 공격자가 사용자의 자격 증명을 사용하여 openTempFile이 파일 시스템의 다른 파일을 덮어 쓸 수 없도록하는 의미로 파일이 안전하게 생성됩니다. 임시 파일이 작성됩니다. Unix에서는 &lt;code&gt;O_CREAT&lt;/code&gt; 및 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그가이 공격을 방지하는 데 사용되지만 NFS 파일 시스템에서는 &lt;code&gt;O_EXCL&lt;/code&gt; 이 지원되지 않는 경우 가 있으므로이 동작에 의존하는 경우 로컬 파일 시스템 만 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="79bbc92aef03765c41804036c58a84e7a3f0d5ed" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt; 확장 GHC이 논문에 기재된 초 화살표 표기법로부터 연결자를 사용하여 번역 지원 &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow 용&lt;/a&gt; 모듈. 다음은 표기법에 대한 간략한 소개입니다. Hughes의 논문을 읽지 않았다면 말이되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는이 두 번째 논문에서 설명하는 화살표 표기법을 지원하며 &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈 의 결합기를 사용하여 번역합니다 . 다음은 표기법에 대한 간략한 소개입니다. 휴즈의 논문을 읽지 않으면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b570873f02bd59cb3d75af7817ea6c7ba50ea43" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt; 확장 GHC 그것이에서 연결자를 이용하여 변환이 논문에 기재된 초 화살표 표시를 지원&lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt; Control.Arrow 용&lt;/a&gt; 모듈. 다음은 표기법에 대한 간략한 소개입니다. Hughes의 논문을 읽지 않았다면 말이 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; 의&lt;/a&gt; 확장, GHC는 프로그램의 제약으로 받아들이는 것에 자유주의된다. 정확하게 말하면,이 플래그를 사용하면 모든 &lt;em&gt;종류&lt;/em&gt; 의 새로운 &lt;code&gt;Constraint&lt;/code&gt; 으로 사용할 수 있습니다. 다음과 같은 종류의 &lt;code&gt;Constraint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; 의&lt;/a&gt; 확장, GHC는없는 생성자와 데이터 유형을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC를 통해 모듈을 가져 오려는 패키지 이름으로 가져 오기 선언을 규정 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 확장자 ( &lt;a href=&quot;#universal-quantification&quot;&gt;어휘 적 형 변수 범위&lt;/a&gt; ), 그 유형의 시작 아닌 다른 형태 인수를 선언 할 수있다. 예를 들어, &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; 을 가질 수 있습니다 . a-&amp;gt; forall b. b-&amp;gt; (a, b) 를 누른 다음 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 유형의 @Bool True @Char 쌍 을 말합니다 .</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 인스턴스 헤드에서 유형 동의어를 사용할 수 있습니다. 항상 그렇듯이, 유형 동의어를 사용하는 것은 유형 동의어 정의의 RHS를 작성하기위한 간단한 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35ffad7832c6db23930e6f76ac2898fcc34375fa" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;scoped_type_variables#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 확장자 ( &lt;a href=&quot;scoped_type_variables#universal-quantification&quot;&gt;어휘 적 형 변수 범위&lt;/a&gt; ), 그 유형의 시작 아닌 다른 형태 인수를 선언 할 수있다. 예를 들어, 우리는 &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; 가질 수 있습니다 . a-&amp;gt; forall b. b-&amp;gt; (a, b) 그런 다음 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 유형을 갖는 @Bool True @Char 쌍 을 말합니다 .</target>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">으로 &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; 언어 플래그, GHC는 옵션 취할 수있는 수입 신고 구문 확장 &lt;code&gt;safe&lt;/code&gt; 애프터 키워드 &lt;code&gt;import&lt;/code&gt; 키워드를. 이 기능은 Safe Haskell GHC 확장의 일부입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">&lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; 옵션을 사용하면 GHC는 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 자동으로 생성 할 수 있습니다 . 예를 들어 다음과 같이 선언하면</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">위의 &lt;code&gt;T&lt;/code&gt; 예제를 사용하면 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;다음 &lt;/em&gt;에 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 바인딩 할 수 있습니다 . 그렇게하면 종속성 문제를 위반하지 않습니다. 그러나 그것은 우리의 일반적인 원칙을 위반하므로 &lt;code&gt;k&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f729b214bbb92dbc7e8b7e039b0ea25bb3f02fc3" translate="yes" xml:space="preserve">
          <source>With the List monad, &quot;empty&quot; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt;, while with &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. With &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; we have an &lt;em&gt;empty&lt;/em&gt; case for each value of &lt;strong&gt;&lt;code&gt;e&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">List 모나드에서 &quot;empty&quot;는 &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt; 이고 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다. &lt;strong&gt; &lt;code&gt;Either e a&lt;/code&gt; &lt;/strong&gt; 사용하면 &lt;strong&gt; &lt;code&gt;e&lt;/code&gt; 의&lt;/strong&gt; 각 값에 대해 &lt;em&gt;빈&lt;/em&gt; 케이스 가 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">위의 &lt;code&gt;(:~~:)&lt;/code&gt; 선언으로 모든 &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; 친절 합니다. k1-&amp;gt; k2-&amp;gt; 유형 . 따라서 타입 &lt;code&gt;(:~~:) a&lt;/code&gt; 는 &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; &lt;code&gt;k2&lt;/code&gt; 에 대한 종류 k2를 갖습니다 . 그런 다음 GHC는 이러한 종류를 &lt;em&gt;다시 생성&lt;/em&gt; 하여 모든 &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; 가 될 수 없습니다 . k2-&amp;gt; 원하는대로 입력하십시오 . 따라서 인스턴스는 잘못된 것으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">&lt;a href=&quot;#constraint-kind&quot;&gt;일종의 제약 조건&lt;/a&gt; 을 추가하는 확장을 사용하면 더 이국적인 수퍼 클래스 정의를 작성할 수 있습니다. 이 경우 수퍼 클래스 사이클 점검이 훨씬 더 자유 롭습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e20b822830d40ffde03919521d0e6cff6321840" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;constraint_kind#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these cases. For example, this is OK:</source>
          <target state="translated">&lt;a href=&quot;constraint_kind#constraint-kind&quot;&gt;일종의 제약 조건&lt;/a&gt; 을 추가하는 확장을 사용하면 보다 이국적인 슈퍼 클래스 정의를 작성할 수 있습니다. 이러한 경우 슈퍼 클래스주기 검사는 훨씬 더 자유 롭습니다. 예를 들어 다음은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tree&lt;/code&gt; 및 기타 데이터 유형 에 대한 &lt;code&gt;encode&lt;/code&gt; 작업을 염두에두고 이제 표현 유형 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 향상된 종류로 Vec &lt;code&gt;Vec Int Char&lt;/code&gt; 와 같은 것들이 잘못되어 GHC가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">언어 확장이 &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; 인&lt;/a&gt; GHC는 수퍼 클래스 제약에 대한 모든 제한을 해제합니다. 정말이 경우 &lt;em&gt;입니다&lt;/em&gt; 루프가, GHC는 유한 깊이로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">이 확장을 설정하면 &lt;code&gt;static&lt;/code&gt; 은 더 이상 유효한 식별자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c483494822eddb06511b9c2103f30e5e7e71ff07" translate="yes" xml:space="preserve">
          <source>With this flag GHC generates a default alternative with &lt;code&gt;error&lt;/code&gt; in these cases. This is helpful when debugging demand analysis or type checker bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">이 플래그를 사용하면 GHC 는 이러한 경우 &lt;code&gt;error&lt;/code&gt; 있는 기본 대안을 생성합니다 . 이는 때때로 세분화 오류로 나타날 수있는 수요 분석 또는 유형 검사기 버그를 디버깅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">이 플래그를 활성화하면 마지막 점프 명령을 블록 단위로 사용합니다. 이 플래그가 없으면 기존 알고리즘은 가장 무거운 발신 에지도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">이 형식의 그룹 설명을 사용하면 f는 단순히 &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; 유형을 가져야합니다 . [a]-&amp;gt; [[a]] , 지금까지 이해를 그룹화하는 데 사용됩니다. 이 형식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;.ghci&lt;/code&gt; 파일 에이 매크로가 정의되어 있으면 &lt;code&gt;:source file&lt;/code&gt; 을 사용하여 &lt;code&gt;file&lt;/code&gt; 에서 GHCi 명령을 읽을 수 있습니다 . 이 Haskell 위키 페이지에서 &lt;code&gt;.ghci&lt;/code&gt; 파일에 대한 다른 제안을 찾아서 제공 할 수 있습니다 : &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb160564b2f5fdfa9c709441f91b64c92758b306" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">이 매크로를 &lt;code&gt;.ghci&lt;/code&gt; 파일에 정의 하면 &lt;code&gt;:source file&lt;/code&gt; 을 사용하여 &lt;code&gt;file&lt;/code&gt; 에서 GHCi 명령을 읽을 수 있습니다 . 이 Haskell 위키 페이지에서 &lt;code&gt;.ghci&lt;/code&gt; 파일에 대한 다른 제안을 찾고 기여할 수 있습니다 : &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07b653d1a2bfaa93b0073e542432ee5c0e412c45" translate="yes" xml:space="preserve">
          <source>With typed expressions, the type error occurs when &lt;em&gt;constructing&lt;/em&gt; the Template Haskell expression:</source>
          <target state="translated">형식화 된 식을 사용 하면 Template Haskell 식을 &lt;em&gt;생성&lt;/em&gt; 할 때 형식 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">지그재그 컷.</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">이러한 이유로 힙 공간에 대한 메모리가 많을수록 GHC에 대한 가비지 수집이 줄어들어 컴파일 시간이 줄어 듭니다. &lt;code&gt;-Rghc-timing&lt;/code&gt; 옵션 을 사용하면 가비지 수집기 보고서가 표시됩니다. (또한 저렴하고 불쾌한 &lt;code&gt;+RTS -S -RTS&lt;/code&gt; 옵션을 사용하여 GC 통계를 표준 오류로 바로 보낼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot;&quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;유효하지 않은 스칼라 값에서 교체를 수행합니다&quot;라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7908234217d5fcd634ff01a732e900f1963d7319" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈 내에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 에서 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot; &quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에 대한 교체 수행&quot;이라는 문구로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="d2664af2a1458216f4637034b8ac10a76e4c6e6e" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈 내에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 에서 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot; &quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에 대한 교체 수행&quot;이라는 문구로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot;&quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;유효하지 않은 스칼라 값에서 교체를 수행합니다&quot;라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e478e972382d28cdc4d59b0f5b4e6ab5fe13da" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈 내에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 에서 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot; &quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에 대한 교체 수행&quot;이라는 문구로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="600646925b44db293829cf7151e09bea6f08885a" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">이 모듈 내에서 많은 함수 는 하나 이상의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 에서 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 구성 합니다. 이러한 함수는 유효한 유니 코드 스칼라 값이 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값을 대체 문자 &quot; &quot;(U + FFFD)로 대체합니다. 이 검사 및 교체를 수행하는 함수는 &quot;잘못된 스칼라 값에 대한 교체 수행&quot;이라는 문구로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 가&lt;/a&gt; 없으면 이러한 모든 정의가 범위 내에 있으면 &lt;code&gt;foo&lt;/code&gt; 를 언급하는 업데이트 가 항상 모호합니다. 확장 기능을 사용하면 명확하게 업데이트 할 수있는 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는 종류 변수에 대한 일반화를 거부합니다. 따라서 가능한 경우 종류 변수를 &lt;code&gt;Type&lt;/code&gt; 기본 설정 합니다. 이것이 불가능하면 오류가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9c3c68ec886ab1a40dbb182885c56e2b6ca831" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;#11679&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt; 가 없으면 목록 이해로 구문 분석됩니다. &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 를&lt;/a&gt; 사용하면 유사 인용문으로 구문 분석됩니다. 그러나 닫는 &lt;code&gt;|]&lt;/code&gt; 이 없기 때문에이 구문 분석은 실패 합니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;# 11679를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt; 가 없으면 목록 이해력으로 해석됩니다. &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 를&lt;/a&gt; 사용하면 이를 준 따옴표로 분석합니다. 그러나이 구문 분석은 닫는 &lt;code&gt;|]&lt;/code&gt; 부족으로 인해 실패 합니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;문제 # 11679를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션이 없으면 &lt;code&gt;SCC&lt;/code&gt; 가 무시됩니다. &lt;code&gt;SCC&lt;/code&gt; 가 포함 된 코드를 변경하지 않고 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">인수없이 프롬프트에서 입력 한 표현식 및 명령에 적용되는 현재 옵션 세트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">손가락을 들어 올리지 않으면, &lt;code&gt;?cmp&lt;/code&gt; 파라미터는 &lt;code&gt;least&lt;/code&gt; 의 파라미터가되도록 전파된다 . 명시 적 매개 변수를 사용하면 기본적으로 매개 변수가 항상 명시 적으로 전파되어야합니다. 암시 적 매개 변수를 사용하면 기본값은 항상 매개 변수를 전파하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="55d043b366c8c5411ad6e6a869f14d78a5f201f3" translate="yes" xml:space="preserve">
          <source>Without newtypes &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; f&lt;/code&gt; equals precomposing with &lt;code&gt;f&lt;/code&gt; (= &lt;code&gt;(. f)&lt;/code&gt;).</source>
          <target state="translated">새로운 유형이 없으면 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; (= &lt;code&gt;(. f)&lt;/code&gt; )로 사전 구성하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">포함하지 않는 &lt;code&gt;MINIMAL&lt;/code&gt; 프라그 경고는 인스턴스가 구현도 방법에 대해 생성되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">&lt;code&gt;forall b&lt;/code&gt; 가 없으면 유형 변수 &lt;code&gt;b&lt;/code&gt; 는 전체 인스턴스 선언에 대해 수량화되며 이는 의도 된 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 접두사가 없으면 &lt;code&gt;Zero&lt;/code&gt; 은 내보내기 목록에서 유형 생성자로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">언 박스 (unboxed) &lt;code&gt;Proxy#&lt;/code&gt; 값에 대한 감시로 런타임 표현이 없습니다.</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">파괴의 흔적을 목격하십시오 :</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">단어 완성</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="70a7003c530361b27dbad2666f3119f63d7aa52c" translate="yes" xml:space="preserve">
          <source>Word32Rep</source>
          <target state="translated">Word32Rep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
        <trans-unit id="6df564da800ea9db332a4e4f70ac3b7baee68108" translate="yes" xml:space="preserve">
          <source>Word64X8#</source>
          <target state="translated">Word64X8#</target>
        </trans-unit>
        <trans-unit id="7d4f09dfc217ef6de83fd0a7817a34a9c524f5f8" translate="yes" xml:space="preserve">
          <source>Word8</source>
          <target state="translated">Word8</target>
        </trans-unit>
        <trans-unit id="1026530b7f2b7d11ceed950f769ae8af9db41c6d" translate="yes" xml:space="preserve">
          <source>Word8#</source>
          <target state="translated">Word8#</target>
        </trans-unit>
        <trans-unit id="46fa1330e06c95858d3c751456971104c43240e6" translate="yes" xml:space="preserve">
          <source>Word8ElemRep</source>
          <target state="translated">Word8ElemRep</target>
        </trans-unit>
        <trans-unit id="bb25378aca5d0bf9417565eddafe0c9955fced88" translate="yes" xml:space="preserve">
          <source>Word8Rep</source>
          <target state="translated">Word8Rep</target>
        </trans-unit>
        <trans-unit id="6d9c171610680a48a7e1adce25e5ef2175c1786b" translate="yes" xml:space="preserve">
          <source>Word8X16#</source>
          <target state="translated">Word8X16#</target>
        </trans-unit>
        <trans-unit id="7d2b3864aa2a328b268de16ec90a676d025166df" translate="yes" xml:space="preserve">
          <source>Word8X32#</source>
          <target state="translated">Word8X32#</target>
        </trans-unit>
        <trans-unit id="420bed9409614065e79233ee278151c88a99c07c" translate="yes" xml:space="preserve">
          <source>Word8X64#</source>
          <target state="translated">Word8X64#</target>
        </trans-unit>
        <trans-unit id="84c6a57a62c9a723bc4c3a3bbe6ffc9a885219d9" translate="yes" xml:space="preserve">
          <source>WordPtr</source>
          <target state="translated">WordPtr</target>
        </trans-unit>
        <trans-unit id="68dc8baeafc9a279622fb5e31be3ed83d95357da" translate="yes" xml:space="preserve">
          <source>WordRep</source>
          <target state="translated">WordRep</target>
        </trans-unit>
        <trans-unit id="7ba9e8f41622b0ccfc835a4f2140ab6eea7b7e9b" translate="yes" xml:space="preserve">
          <source>Work left-to-right through the input list of type variables, with a cursor.</source>
          <target state="translated">커서로 유형 변수의 입력 목록에서 왼쪽에서 오른쪽으로 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="bc1c455e1b31ed1393785a6cdc3045bbb118f243" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell 98 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 가질 수있는 해결 방법 .</target>
        </trans-unit>
        <trans-unit id="9c02809968c5a04b4bf0b6d24112481a63ca6dca" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell 98 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 가질 수 있도록 해결 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="18b99ada0b9847a43772d5b421ac47cdacf3632e" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell 98 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 가질 수 있도록 해결 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="5ab49cd9ef02b20b8f0a395f52a3bac5f961ae20" translate="yes" xml:space="preserve">
          <source>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove &lt;em&gt;all&lt;/em&gt; value lambdas.</source>
          <target state="translated">Worker-wrapper는 사용하지 않는 인수를 제거하지만 일반적으로 함수 클로저를 썽 크로 바꾸어 공간 누출을 유발하거나 인라인을 방해하지 않도록 모든 인수를 제거하지는 않습니다. 이 플래그를 사용하면 작업자 / 래퍼가 &lt;em&gt;모든&lt;/em&gt; 값 람다 를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61f4d4dd918269bf5a5ff69500737f2e3c652d80" translate="yes" xml:space="preserve">
          <source>Working with equality</source>
          <target state="translated">평등하게 일하기</target>
        </trans-unit>
        <trans-unit id="b7851eadac070ddfea609696fdeb164b7899ebe8" translate="yes" xml:space="preserve">
          <source>Would result in a generated &lt;code&gt;Functor&lt;/code&gt; instance like so:</source>
          <target state="translated">다음 과 같이 생성 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ee562876821329b8991ff4daaadbf4f98ef9b98" translate="yes" xml:space="preserve">
          <source>Wrap a BCO in a &lt;code&gt;AP_UPD&lt;/code&gt; thunk which will be updated with the value of the BCO when evaluated.</source>
          <target state="translated">평가할 때 BCO 값으로 업데이트 될 &lt;code&gt;AP_UPD&lt;/code&gt; 썽크에 BCO를 래핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="16397dd6317efa9c9836ee42453758565f8d25ed" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 마이크로 초 ( &lt;code&gt;1/10^6&lt;/code&gt; 초) 내에 결과가없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 시간 종료하고 &lt;code&gt;Nothing&lt;/code&gt; 리턴 하지 않도록 랩핑하십시오 . 시간 초과가 만료되기 전에 결과를 사용할 수있는 경우 &lt;code&gt;Just a&lt;/code&gt; 가 반환됩니다. 음의 시간 초과 간격은 &quot;무한 대기&quot;를 의미합니다. 긴 시간 초과를 지정할 때 &lt;code&gt;maxBound :: Int&lt;/code&gt; 를 초과하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="298bd3ed150b3f0eda86e3bd26b9d517dfc0dc76" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 마이크로 초 ( &lt;code&gt;1/10^6&lt;/code&gt; 초) 내에 결과를 사용할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 시간 초과하고 &lt;code&gt;Nothing&lt;/code&gt; 을 반환하도록 래핑합니다 . 제한 시간이 만료되기 전에 결과를 사용할 수있는 경우 &lt;code&gt;Just a&lt;/code&gt; 가 반환됩니다. 음의 시간 초과 간격은 &quot;무한 대기&quot;를 의미합니다. 긴 시간 제한을 지정할 때 초과하지 않도록주의하십시오. &lt;code&gt;maxBound :: Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0379570077ecabca08995c42a34f4a46b3ee2ced" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 마이크로 초 ( &lt;code&gt;1/10^6&lt;/code&gt; 초) 내에 결과를 사용할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 시간 초과하고 &lt;code&gt;Nothing&lt;/code&gt; 을 반환하도록 래핑합니다 . 제한 시간이 만료되기 전에 결과를 사용할 수있는 경우 &lt;code&gt;Just a&lt;/code&gt; 가 반환됩니다. 시간 초과 간격이 음수이면 &quot;무한 대기&quot;를 의미합니다. 긴 시간 제한을 지정할 때 &lt;code&gt;maxBound :: Int&lt;/code&gt; 를 초과하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="769d436eab4aa870cf748d72592199f75a9fdf28" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 마이크로 초 ( &lt;code&gt;1/10^6&lt;/code&gt; 초) 내에 결과가없는 경우 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 시간 종료하고 &lt;code&gt;Nothing&lt;/code&gt; 리턴 하지 않도록 랩핑하십시오 . 시간 초과가 만료되기 전에 결과를 사용할 수있는 경우 &lt;code&gt;Just a&lt;/code&gt; 가 반환됩니다. 음의 시간 초과 간격은 &quot;무한 대기&quot;를 의미합니다. 긴 시간 초과를 지정할 때 &lt;code&gt;maxBound :: Int&lt;/code&gt; 를 초과하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="052e52e2ec601e51ff67cce14d06f664e23dd732" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;&quot;...&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;...&quot;&lt;/code&gt; 로 문서 랩</target>
        </trans-unit>
        <trans-unit id="3e2463a3964a6d5f90893a0cb4a83e415f58109e" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;'...'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'...'&lt;/code&gt; 로 문서 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="e11d85c98f81ceac1c15ffeb3554f6ef50d942c9" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;(...)&lt;/code&gt;</source>
          <target state="translated">문서 감싸기 &lt;code&gt;(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fefcdd75b8d3ceac5767fa9ddb3485c2fae7387b" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;[...]&lt;/code&gt;</source>
          <target state="translated">문서를 &lt;code&gt;[...]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d9a81e67b5bd2bc5cede4830f07d4ee5769499a" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;{...}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{...}&lt;/code&gt; 로 문서 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="b5150dc051fd47e830d39a1a10a0d5cede823b6b" translate="yes" xml:space="preserve">
          <source>WrapArrow</source>
          <target state="translated">WrapArrow</target>
        </trans-unit>
        <trans-unit id="c92147ea0c2b0677b7c09751757b19d07bd7b17c" translate="yes" xml:space="preserve">
          <source>WrapMonad</source>
          <target state="translated">WrapMonad</target>
        </trans-unit>
        <trans-unit id="4069d5a8b2d61fc44c53d1d69a1603e75124fe55" translate="yes" xml:space="preserve">
          <source>WrapMonoid</source>
          <target state="translated">WrapMonoid</target>
        </trans-unit>
        <trans-unit id="f72344941ecf4dbf3a6b05f7d128cba499a51fde" translate="yes" xml:space="preserve">
          <source>WrappedArrow</source>
          <target state="translated">WrappedArrow</target>
        </trans-unit>
        <trans-unit id="5424268dd193f61b9e7843ef4109dc2a12bac7a6" translate="yes" xml:space="preserve">
          <source>WrappedMonad</source>
          <target state="translated">WrappedMonad</target>
        </trans-unit>
        <trans-unit id="459140ee141c9d01be26238b973ae1046e530be2" translate="yes" xml:space="preserve">
          <source>WrappedMonoid</source>
          <target state="translated">WrappedMonoid</target>
        </trans-unit>
        <trans-unit id="6f21817c0f554ef006f52930cf8b3fb843bafa13" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">GHC를 더 빠르게 구현 하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 래퍼</target>
        </trans-unit>
        <trans-unit id="fb18f208c8e09b8e152ee97be9d763608b85aabc" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">GHC 구현 속도가 빠른 &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; 래퍼</target>
        </trans-unit>
        <trans-unit id="f5bae4c947473ab2febca5eb61bfa9da65f60ac7" translate="yes" xml:space="preserve">
          <source>Wrapping an IO action that can throw an error &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">오류가 발생할 수있는 IO 조치 랩핑 &lt;code&gt;e&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d27d9e2d3a2ad251d4892a773947e707db18720" translate="yes" xml:space="preserve">
          <source>Wrapping documents in delimiters</source>
          <target state="translated">분리 문자로 문서 랩핑</target>
        </trans-unit>
        <trans-unit id="48606f4bb9cb6f76c6d45f0aae55cb4f7a999651" translate="yes" xml:space="preserve">
          <source>Write 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 비트 문자를 작성하십시오. 4 바이트 단어로 오프셋합니다.</target>
        </trans-unit>
        <trans-unit id="132823a14fa0074e9c3549c122a220890e54d9b3" translate="yes" xml:space="preserve">
          <source>Write 8-bit character; offset in bytes.</source>
          <target state="translated">8 비트 문자를 작성하십시오. 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="6cfb95525e855d3c2fb90f553acacc9ffd9b1afe" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">버퍼에 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 쓰기</target>
        </trans-unit>
        <trans-unit id="0296abfbf70a590c6ce425e8d54f6de5c2d195a0" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">버퍼에 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 쓰기</target>
        </trans-unit>
        <trans-unit id="a30ef0a4dea3adbd954b944a856f0d73077a7fef" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">&lt;code&gt;.tix&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2384eda70bde5fbafcdce06c7083ad1f34fba13d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">로케일 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="641fdc517a3a148a3426445c3e2501afc543647f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="19f5831180b0536c875f7fde0710ba2f6b629a3f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="993b7cc9e4c74d2721eedc685664742cc7c82795" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 및 호스트 엔디안으로 기본 으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="025b69c4396276807676b294d74b3b70f46bef94" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">빅 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2300f23523bc1b33ccbbebf657381c02dd05c86c" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">리틀 엔디안 IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a6e3e08979b85f7f159802afa8ee51f8a4eedd1" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 IEEE-754 형식으로 네이티브로 작성 하고 호스트 엔디안을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="100ddab2dd798658dd4fbb44584d4757dded426e" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">로케일 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="34cb939ce09480dcfa16a616504013b186c6decd" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Big endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="17ec2c319cd8c0e2c3a0c3951b37ec1585cee156" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Little endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="545e766b627e659fd52bff3acf015eb9994ae5c5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 및 호스트 엔디안의 기본 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="f65b44a7ea8883932f7651be10c9246fc522dca8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Big endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ead3e3f2656945a589c0165356d2eb079e613140" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Little Endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2feadbf9adb1a358b7e0093340ebf583af8879d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 및 호스트 엔디안의 기본 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fde29449d3f0108ac52954edaff927f556465b38" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">로케일 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3b9ab35d2642c9b5be7308adfb540fe471522384" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Big endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb93655e29d96d133136c01dc591f84e22055de5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Little endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="2c67f5d3071082cd12eed2b10946f5237ea28fd6" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 및 호스트 엔디안의 기본 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="4cad8d95d64d25782658d6f8b5c3b46df8c39dd8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Big endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b24d9d9e097aac96beae3883a886f722fde4c0" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Little Endian IEEE-754 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6238f387e14de2e21a90134fdf8ba25fdaaeefb7" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">IEEE-754 형식 및 호스트 엔디안의 기본 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ed5c3f805685b995398b8616a908c0066ad70a" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ca463eab69a5fff98e0ab2e75dce7ed014b9ab1b" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3ad21d75c6a544747e2e36fcec12a87a1aebe727" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a8e6f690eb143ffdbea5335db0be7244660876a2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="244e830bbe30fb0c3258c35cfc26647f07415c80" translate="yes" xml:space="preserve">
          <source>Write a ByteString to a handle, appending a newline byte</source>
          <target state="translated">줄 바꿈 바이트를 추가하여 핸들에 ByteString을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a70a82a5347cdeed11b696c9567115f30a6a5296" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout</source>
          <target state="translated">stdout에 ByteString 작성</target>
        </trans-unit>
        <trans-unit id="e8ad66b8476a9e49cc072f07250605c906e95e94" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout, appending a newline byte</source>
          <target state="translated">줄 바꿈 바이트를 추가하여 ByteString을 stdout에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c0c3cc8f4573e40e62c43e8422d4118f97ea3fea" translate="yes" xml:space="preserve">
          <source>Write a Int16 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int16 작성</target>
        </trans-unit>
        <trans-unit id="9d73a70f9f179a81035be58cee26e559014c575a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int16 작성</target>
        </trans-unit>
        <trans-unit id="7d8b2b4323c44fde9919abbfb9988c387020100a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안으로 Int16을 작성하십시오. 정렬되지 않은 2 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3123d3e54a5bdf6aa5b4391bbf7b28df79fb37" translate="yes" xml:space="preserve">
          <source>Write a Int32 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int32 작성</target>
        </trans-unit>
        <trans-unit id="7e919ad40c1b9ea38485684cbf74d8a9568b9af7" translate="yes" xml:space="preserve">
          <source>Write a Int32 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int32 작성</target>
        </trans-unit>
        <trans-unit id="c8c3c578503e8e7468915f61ff1fa6751340cce3" translate="yes" xml:space="preserve">
          <source>Write a Int32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안으로 Int32를 작성하십시오. 정렬되지 않은 4 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e181d3a02580a355986a71c12d4507242968cf" translate="yes" xml:space="preserve">
          <source>Write a Int64 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int64 작성</target>
        </trans-unit>
        <trans-unit id="6a15b266b9877bbd729c40ccb87aa3db359c9f58" translate="yes" xml:space="preserve">
          <source>Write a Int64 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int64 작성</target>
        </trans-unit>
        <trans-unit id="001b75a9a615fe6648502bcfe94fd2920ba86af5" translate="yes" xml:space="preserve">
          <source>Write a Int64 in native host order. On a 32 bit machine we write two host order Int32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서로 Int64를 작성하십시오. 32 비트 시스템에서 우리는 큰 엔디안 형태로 두 개의 호스트 순서 Int32를 씁니다. 정렬되지 않은 8 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="50fde014dba0a50360d764d6c2704238d9a9cb90" translate="yes" xml:space="preserve">
          <source>Write a String using UTF-8 encoding.</source>
          <target state="translated">UTF-8 인코딩을 사용하여 문자열을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ca1a04969f07426c1e00b1b3766e301003971851" translate="yes" xml:space="preserve">
          <source>Write a Unicode string to the user's standard output.</source>
          <target state="translated">사용자의 표준 출력에 유니 코드 문자열을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="de13c62099cbcafc759fb5510fbb414e0c611d13" translate="yes" xml:space="preserve">
          <source>Write a Word16 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Word16 작성</target>
        </trans-unit>
        <trans-unit id="1d3480abbd86fc7688fd650a23916c935ed2b876" translate="yes" xml:space="preserve">
          <source>Write a Word16 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Word16 작성</target>
        </trans-unit>
        <trans-unit id="374953a98335b9e84fa5e0a4c035b46b2a892799" translate="yes" xml:space="preserve">
          <source>Write a Word16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안으로 Word16을 작성하십시오. 정렬되지 않은 2 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d543a7902bc6e8e15046b66cf37db05811d00c" translate="yes" xml:space="preserve">
          <source>Write a Word32 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Word32 작성</target>
        </trans-unit>
        <trans-unit id="426bab66f99e758605e62a76ce97b5ce1321c0e7" translate="yes" xml:space="preserve">
          <source>Write a Word32 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Word32 작성</target>
        </trans-unit>
        <trans-unit id="22533b04aaf4738c420c7810c743da18ca10d4e0" translate="yes" xml:space="preserve">
          <source>Write a Word32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안으로 Word32를 작성하십시오. 정렬되지 않은 4 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d00bd933478ce30ee3627449becbce383505e676" translate="yes" xml:space="preserve">
          <source>Write a Word64 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Word64 작성</target>
        </trans-unit>
        <trans-unit id="1ccded859c25705e9ae2dccba946964f2b4b599e" translate="yes" xml:space="preserve">
          <source>Write a Word64 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Word64 작성</target>
        </trans-unit>
        <trans-unit id="fe8b5771af7a4fe3ab30f772b71da7013250ca90" translate="yes" xml:space="preserve">
          <source>Write a Word64 in native host order. On a 32 bit machine we write two host order Word32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">기본 호스트 순서로 Word64를 작성하십시오. 32 비트 시스템에서 우리는 큰 엔디 언 형태로 두 개의 호스트 순서 Word32를 작성합니다. 정렬되지 않은 8 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d084d0a0a3ee70356c669bbf84781436e439ab8d" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">주어진 오프셋에서 배열에 문자를 씁니다. 작성된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="841f4e3a7f9355477f1154322e4d479f881e0fd9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">주어진 오프셋에서 배열에 문자를 씁니다. 쓰여진 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ead19630563db8c3d93106011641efd62bcf10e9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">주어진 오프셋에서 배열에 문자를 씁니다. 쓰여진 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="824db4935989674b3e285858238d002d124cd8b6" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자를 씁니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="7382100d9830a823b89994904abbed419d0ca6e4" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자를 씁니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="f3d825454d2db1c3d3f226a28bb4ebdfec603097" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자를 씁니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="955d70d1572c0c0ab9646927bdac5ea547ae35f8" translate="yes" xml:space="preserve">
          <source>Write a character using UTF-8 encoding.</source>
          <target state="translated">UTF-8 인코딩을 사용하여 문자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0a40d25653018769760da200e171fb69042b97ba" translate="yes" xml:space="preserve">
          <source>Write a floating point value to a &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 값을 &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="6f0e537457e84f16fbaa39fa0827e8c740824c36" translate="yes" xml:space="preserve">
          <source>Write a lazy ByteString efficiently, simply appending the lazy ByteString chunks to the output buffer</source>
          <target state="translated">지연된 ByteString 청크를 출력 버퍼에 간단히 추가하여 지연된 ByteString을 효율적으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4a5a6f538364d52e8d401c4fc9299b67f51eb2c1" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">저장 가능 요소 목록을 새로 할당 된 연속 가능한 저장 가능 값 시퀀스에 작성하십시오 ( &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 와 같지만 여러 요소의 경우).</target>
        </trans-unit>
        <trans-unit id="cdf3a3bd7d79bb717fec0614e932a3f554e7d129" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker</source>
          <target state="translated">저장 가능한 요소 목록을 새로 할당 된 연속적인 저장 가능한 값 시퀀스에 기록합니다. 여기서 끝은 지정된 끝 표시 자에 의해 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="46dde6be964e98cc511af24b16c6e57e81e0249e" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에 새로운 가치를 씁니다</target>
        </trans-unit>
        <trans-unit id="ded1b880637c536601d5622865a8ac5bee12d73f" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 에 새로운 가치를 씁니다</target>
        </trans-unit>
        <trans-unit id="7b15bee858199106a92ca21868dcf92516cce78a" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 에 새 값을 씁니다</target>
        </trans-unit>
        <trans-unit id="cfd1ae109907abef00a2e666c2fb353f397524eb" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에 새로운 가치를 씁니다</target>
        </trans-unit>
        <trans-unit id="a0bbd3fd99a0c8ca169dc0a0800f474e5f53bf14" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 에 새로운 가치를 씁니다</target>
        </trans-unit>
        <trans-unit id="4a779d08a6f4043a50272816a75acd9ee4cacd4c" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에 새로운 가치를 씁니다</target>
        </trans-unit>
        <trans-unit id="20f4593948df5a33a2e433f875c4b3f08e697cff" translate="yes" xml:space="preserve">
          <source>Write a string the end of a file.</source>
          <target state="translated">파일의 끝에 문자열을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c180f2e1d927a73773a56afa0d7e8518dedba44e" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 쓴 다음 줄 바꿈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f7e8eefc7a202ba520c173df9a961b393fa4acc7" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9f730ea108860688ef12de2017ea9ad535914f4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 쓰고 그 뒤에 줄 바꿈 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="45c0c99c259a0bae8a5de169024806ed9278e047" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="adfa6ba6c0cf344b0e6e3107b4b376c5c61df5aa" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 쓰고 그 뒤에 줄 바꿈 을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="10cbb856cec403b79eb6afecd39da04f2c3b3bb4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 문자열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7142ba8529e9f3798882070ee18b16fa9830450d" translate="yes" xml:space="preserve">
          <source>Write a string to a file. The file is truncated to zero length before writing begins.</source>
          <target state="translated">파일에 문자열을 씁니다. 쓰기가 시작되기 전에 파일 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="1c2990ff65d290d7bbb87a7564d0e4e76c8f8255" translate="yes" xml:space="preserve">
          <source>Write a string to a handle, followed by a newline.</source>
          <target state="translated">핸들에 문자열을 쓴 다음 줄 바꿈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bd7a02731ecdcdf45341edba546df5ac23933c67" translate="yes" xml:space="preserve">
          <source>Write a string to a handle.</source>
          <target state="translated">핸들에 문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="ece9511f02a82892ce27b96dda3476e25a7fbdb9" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자열을 씁니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="f865cedd38348737be2e60d87bff870c9a8dd6d6" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자열을 씁니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="ffa575f023b590cb0185153c4e3bb7bcdf3ca8ca" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 출력 장치에 문자열을 씁니다 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="9ddf3308755406ffab4fefd34e1c0f532c36bfca" translate="yes" xml:space="preserve">
          <source>Write a string to the user's standard output, followed by a newline.</source>
          <target state="translated">문자열을 사용자의 표준 출력에 쓴 다음 줄 바꿈을 씁니다.</target>
        </trans-unit>
        <trans-unit id="d649865e90fcbff9ffe50b1a59105ee5172bcad2" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 에 값을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9bb0e77531d8dd5855a5dee42f98bdfb66dea502" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;; blocks if the queue is full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 에 값을 씁니다 . 큐가 가득 찬 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="9b880d3a6f95fb0643f6f8cb86d9febe4b457c2d" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 에 값을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="502f2a89fe6ab954ea36d4a5f5ae4da0588aaadf" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 에 값을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b003c4b3a259d538a4ba6bcb5c8dd4f54a8c348a" translate="yes" xml:space="preserve">
          <source>Write a value to a memory area regarded as an array of values of the same kind. The following equality holds:</source>
          <target state="translated">같은 종류의 값 배열로 간주되는 메모리 영역에 값을 씁니다. 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2278658d6c531603ea71643e435890480712f25e" translate="yes" xml:space="preserve">
          <source>Write a value to a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">기본 주소 및 오프셋으로 지정된 메모리 위치에 값을 씁니다. 다음과 같은 평등이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bcb5f72dff224c65e70a09f3049dbb8677df2f" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">스칼라의 가변 배열의 지정된 인덱스에 벡터를 씁니다. 오프셋은 스칼라 요소입니다.</target>
        </trans-unit>
        <trans-unit id="47fbcdcf5427d81f8e800b2a3be52a9b2780f1f2" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array.</source>
          <target state="translated">가변 배열의 지정된 인덱스에 벡터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="2cbdaab506338b440edffc79752d43d3b372babf" translate="yes" xml:space="preserve">
          <source>Write an Int16 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int16 작성</target>
        </trans-unit>
        <trans-unit id="a4e76ca260148b04e485fd2b3ab9435bef6ca68d" translate="yes" xml:space="preserve">
          <source>Write an Int16 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int16 작성</target>
        </trans-unit>
        <trans-unit id="04d7dd93d431136691244f8a8060c6f710b4c9c7" translate="yes" xml:space="preserve">
          <source>Write an Int32 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int32 작성</target>
        </trans-unit>
        <trans-unit id="ac3eecde6710e67b4fbd62fe5faea7085564b9e9" translate="yes" xml:space="preserve">
          <source>Write an Int32 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int32 작성</target>
        </trans-unit>
        <trans-unit id="4ecb73c918eeb208591574c27bf43973ceabac8a" translate="yes" xml:space="preserve">
          <source>Write an Int64 in big endian format</source>
          <target state="translated">빅 엔디안 형식으로 Int64 작성</target>
        </trans-unit>
        <trans-unit id="062b3fd33b7744aa05c8b488aac57bd5719de134" translate="yes" xml:space="preserve">
          <source>Write an Int64 in little endian format</source>
          <target state="translated">리틀 엔디안 형식으로 Int64 작성</target>
        </trans-unit>
        <trans-unit id="f3475a216b60f541f9561999947a42033537d47f" translate="yes" xml:space="preserve">
          <source>Write an element in a mutable array</source>
          <target state="translated">가변 배열로 요소 작성</target>
        </trans-unit>
        <trans-unit id="3a6dc8d047fec7b46b0233f24f9a28adcd679e26" translate="yes" xml:space="preserve">
          <source>Write an entire list of items to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 아이템 목록을 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f9599a175165c39f1f29ddd9bb8c7e18497bf06b" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;MutVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 내용을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="842c4baf59de10dbe1f4228d4e89548eb6cfad90" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;TVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TVar#&lt;/code&gt; 내용을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3de1d04f7bf6af5e972546fb7777d6bafc52d88" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">메모리에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 로 데이터를 씁니다 . POSIX &lt;code&gt;write&lt;/code&gt; 기능 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3589adf6c850b011d135abac8239e99774d7263d" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">메모리에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 로 데이터를 씁니다 . 이것은 POSIX &lt;code&gt;write&lt;/code&gt; 기능 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3d30b89159dbe8adf88a13bf3ed9d62236eb08e2" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">메모리에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 로 데이터를 씁니다 . 이것은 POSIX &lt;code&gt;write&lt;/code&gt; 기능 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5c15fb50864a59ead622c1afb8db98eae0916f34" translate="yes" xml:space="preserve">
          <source>Write file in UTF-8 encoding. Parent directory will be created if missing.</source>
          <target state="translated">UTF-8 인코딩으로 파일을 씁니다. 누락 된 경우 상위 디렉토리가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b7773c80499d5b3f15854fd0b2e72f86ef50f9e8" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 오류 메시지를 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 종료 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1dcba72b258ea0ed5115b0f30bfb1d0dcb08793" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 오류 메시지를 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="4355c147f16522d41a43d5a06119aedec6f7144b" translate="yes" xml:space="preserve">
          <source>Write output from main C-\- pipeline passes to files</source>
          <target state="translated">기본 C-\-파이프 라인 패스의 출력을 파일에 쓰기</target>
        </trans-unit>
        <trans-unit id="b96bdb27f817c3c1baec26eb6ded0edc44bb3c99" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 값을 주어진 메모리 위치에 씁니다. 정렬 제한이 적용될 수 있습니다. &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77655bd9fbe731998656fdcf621486c02b0a375a" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 값을 주어진 메모리 위치에 씁니다. 정렬 제한이 적용될 수 있습니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="babfd98df4815040b9b8feaf92e4a373432b470f" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory</source>
          <target state="translated">목록 요소를 메모리에 연속적으로 씁니다.</target>
        </trans-unit>
        <trans-unit id="c13f0a2faae8bb31701cafde84fa1d469581a021" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory and terminate them with the given marker element</source>
          <target state="translated">목록 요소를 메모리에 연속적으로 쓰고 주어진 마커 요소로 종료</target>
        </trans-unit>
        <trans-unit id="3e02cf61d4db014ee685a86394e5a58900284ddf" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes starting at a given offset.</source>
          <target state="translated">주어진 오프셋에서 시작하여 지정된 바이트 수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="4bfb3401061c515a5bf897d647437c6e727895e8" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes.</source>
          <target state="translated">지정된 바이트 수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="7948630f19859069bae4a14e2c76f2c7020b9d2a" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 값을 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8756d20514051c6080e747e02c7172e182a101af" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 값을 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f27a7a93b6c3f65c763bd60036589804bd7bf721" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 값을 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="155f12112f4379352bcdee8335e8ff9abd964e75" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the standard output device.</source>
          <target state="translated">터미널 출력을 표준 출력 장치에 씁니다.</target>
        </trans-unit>
        <trans-unit id="2ffb13840f565fd761a331ddc6dc0237d509420b" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 로 관리되는 터미널 또는 파일에 터미널 출력을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3cd750e768a4d8f40411b104e6eddf083a4f201a" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 의해 관리되는 터미널 또는 파일에 터미널 출력을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="354772ef04e9b2d16c5fe14016464a4e279a0ec7" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 의해 관리되는 터미널 또는 파일에 터미널 출력을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="4bab7a81286ec426207ad20332db127f5e40c79b" translate="yes" xml:space="preserve">
          <source>Write to specified index of mutable array.</source>
          <target state="translated">가변 배열의 지정된 인덱스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="8062d7bf97a30b717d53fc3dbe2d6e2c50919458" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking starting at a given offset. Returns the actual number of bytes written.</source>
          <target state="translated">지정된 오프셋에서 시작하여 차단하지 않고 지정된 바이트 수까지 씁니다. 쓰여진 실제 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="faa64ad5644001c4c4dc3bee878a933e8c8aac0e" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking. Returns the actual number of bytes written.</source>
          <target state="translated">차단하지 않고 지정된 바이트 수까지 쓰십시오. 쓴 실제 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74120aff54b3ed793ccfa34d37318c6efb458636" translate="yes" xml:space="preserve">
          <source>Write vector; offset in bytes.</source>
          <target state="translated">벡터 쓰기; 바이트 단위의 오프셋.</target>
        </trans-unit>
        <trans-unit id="fd96182628831a4dab0848bbbb0a8a86256945c3" translate="yes" xml:space="preserve">
          <source>Write vector; offset in scalar elements.</source>
          <target state="translated">벡터 쓰기; 스칼라 요소의 오프셋.</target>
        </trans-unit>
        <trans-unit id="e1f97fa6627971c9b0e683428fd5abfab1ecbdb9" translate="yes" xml:space="preserve">
          <source>Write? (False = read-only)</source>
          <target state="translated">쓰다? (거짓 = 읽기 전용)</target>
        </trans-unit>
        <trans-unit id="09c7377b67eee34defdc1dd0804c879b090650d2" translate="yes" xml:space="preserve">
          <source>WriteBuffer</source>
          <target state="translated">WriteBuffer</target>
        </trans-unit>
        <trans-unit id="3082b1ffe24322eee941ed215c852cffc7410d42" translate="yes" xml:space="preserve">
          <source>WriteHandle</source>
          <target state="translated">WriteHandle</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="60841bf1ad2d01720515c6eb9b3efbeb2e0f7656" translate="yes" xml:space="preserve">
          <source>WriteMode</source>
          <target state="translated">WriteMode</target>
        </trans-unit>
        <trans-unit id="f5ca54e8210ce7deaf5fa1129a91a1f50f08386a" translate="yes" xml:space="preserve">
          <source>WriteOnly</source>
          <target state="translated">WriteOnly</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="a8f135f9c50f7fe5f7a287362386d791fee8800a" translate="yes" xml:space="preserve">
          <source>Writer operations</source>
          <target state="translated">작가 작업</target>
        </trans-unit>
        <trans-unit id="a123ab5d3541d6386c9d34765c7348e78d2bb09e" translate="yes" xml:space="preserve">
          <source>WriterT</source>
          <target state="translated">WriterT</target>
        </trans-unit>
        <trans-unit id="1cccc800c778fc7aea514948aa922ecafd4399e9" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d30a3e22fd6539c1c9d94fc5b04d15e2c9f7e725" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ff69c85320ce63f18bed336a41ffa3b0d101a7b3" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b2b97a0aaa412174782d8ac6874c3f7cc18e81e9" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">일반 인터페이스 파일과 함께 확장 인터페이스 파일을 작성합니다. 일반 인터페이스 파일과 마찬가지로 GHC에는 오래된 인터페이스 파일이나 누락 된 확장 인터페이스 파일을 감지하기 위해 재 컴파일 검사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ed5cefe0e622b3e54c1d44f041cf244581a4d3" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongside regular interface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">일반 인터페이스 파일과 함께 확장 인터페이스 파일을 작성합니다. 일반 인터페이스 파일과 마찬가지로 GHC에는 오래되거나 누락 된 확장 인터페이스 파일을 감지하는 재 컴파일 검사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e584f7c39c3d0e184b912ee7be64b91cc4f0e227" translate="yes" xml:space="preserve">
          <source>Writes the line history to the given file. If there is an error when writing the file, it will be ignored.</source>
          <target state="translated">주어진 파일에 행 히스토리를 작성합니다. 파일을 쓸 때 오류가 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="82675cd0bc2b58173645fe62ed090db0c903a0d8" translate="yes" xml:space="preserve">
          <source>XdgCache</source>
          <target state="translated">XdgCache</target>
        </trans-unit>
        <trans-unit id="a09516bd6fa5e0d22f97cc882d59eced3f611c61" translate="yes" xml:space="preserve">
          <source>XdgConfig</source>
          <target state="translated">XdgConfig</target>
        </trans-unit>
        <trans-unit id="513936143f60ff489cea943b4d3cf5ff7ec804be" translate="yes" xml:space="preserve">
          <source>XdgConfigDirs</source>
          <target state="translated">XdgConfigDirs</target>
        </trans-unit>
        <trans-unit id="b55b13216c4a49a521787620dab302740b661e55" translate="yes" xml:space="preserve">
          <source>XdgData</source>
          <target state="translated">XdgData</target>
        </trans-unit>
        <trans-unit id="5c87de6a1cfa7e4af282e624345c841e7d8bd0bb" translate="yes" xml:space="preserve">
          <source>XdgDataDirs</source>
          <target state="translated">XdgDataDirs</target>
        </trans-unit>
        <trans-unit id="1fbbfb2eaf00935b6eaff85397e2d3159b40fac3" translate="yes" xml:space="preserve">
          <source>XdgDirectory</source>
          <target state="translated">XdgDirectory</target>
        </trans-unit>
        <trans-unit id="2a60deb694d7c793f949c28507f268cafab38ce5" translate="yes" xml:space="preserve">
          <source>XdgDirectoryList</source>
          <target state="translated">XdgDirectoryList</target>
        </trans-unit>
        <trans-unit id="14824d205a044c81fdecf7f246ad054ed0648b74" translate="yes" xml:space="preserve">
          <source>Year and day format</source>
          <target state="translated">년과 일 형식</target>
        </trans-unit>
        <trans-unit id="ed289f57da895ead697dd2c01857ff65cfc7ea93" translate="yes" xml:space="preserve">
          <source>Year.</source>
          <target state="translated">Year.</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="520497482bb4d7526496e8edb3018d95cee38510" translate="yes" xml:space="preserve">
          <source>Yes (Explicit)</source>
          <target state="translated">예 (명시 적)</target>
        </trans-unit>
        <trans-unit id="90c557a6b48e6bc7ef30b6f2d5fb9c703c39cf2f" translate="yes" xml:space="preserve">
          <source>Yes (Inferred)</source>
          <target state="translated">예 (유추 됨)</target>
        </trans-unit>
        <trans-unit id="86200a8547bb15fb3a4cf8bb1368b37de64fb317" translate="yes" xml:space="preserve">
          <source>Yield &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the given &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; value is valid on the system. This implies that the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; is also system dependent as it is only defined for valid values of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">항복 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 주어진 경우 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 값이 시스템에서 유효합니다. 이는 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스가 유효한 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 값에 대해서만 정의되므로 시스템에 따라 달라짐을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1f384c9380a1584c25f0df9644ddfab42bb5794c" translate="yes" xml:space="preserve">
          <source>Yield a &lt;em&gt;non-empty&lt;/em&gt; strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수율 &lt;em&gt;비어&lt;/em&gt; 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="711685e6ca2af214ee9e0c03ff3f6e2991b1fffe" translate="yes" xml:space="preserve">
          <source>Yield not to its blasphemous call! Flee traveller! Flee or you will be corrupted and devoured!</source>
          <target state="translated">신성 모독의 부르심에 굴복하지 마십시오! 도망자! 도망 치거나 타락하고 삼킬 것입니다!</target>
        </trans-unit>
        <trans-unit id="a5cc7a47f6c353cbfbd096e4097551052e651002" translate="yes" xml:space="preserve">
          <source>You can add a module to the scope (via &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt;) only if either (a) it is loaded, or (b) it is a module from a package that GHCi knows about. Using &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt; to try bring into scope a non-loaded module may result in the message &lt;code&gt;module M is not loaded&lt;/code&gt;.</source>
          <target state="translated">(a)로드되었거나 (b) GHCi가 알고있는 패키지의 모듈 인 경우에만 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 범위에 추가 할 수 있습니다 ( : module 또는 &lt;code&gt;import&lt;/code&gt; ). 로드되지 않은 모듈을 범위로 &lt;code&gt;import&lt;/code&gt; 위해 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 또는 import 를 사용 하면 메시지 &lt;code&gt;module M is not loaded&lt;/code&gt; 이로드되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="269b166a8fb9660360ed22bb6ffd6ad1f5dbf714" translate="yes" xml:space="preserve">
          <source>You can add explicit phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; pragma, just like on an &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma; if you do so, the same phase is used for the rewrite rule and the INLINE control of the specialised function.</source>
          <target state="translated">당신은 명시 적 위상 제어 (추가 할 수 있습니다 &lt;a href=&quot;#phase-control&quot;&gt;위상 제어&lt;/a&gt; 에) &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; 단지에서처럼, 프라 그마 &lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; 의&lt;/a&gt; 프라그; 그렇게하면 다시 쓰기 규칙과 특수 함수의 INLINE 제어에 동일한 단계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76b4dc225411289e9acdbfffaafe383a16ca2930" translate="yes" xml:space="preserve">
          <source>You can add phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to the RULE generated by a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, just as you can if you write a &lt;code&gt;RULE&lt;/code&gt; directly. For example:</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 을 직접 작성하는 것과 마찬가지로 &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma가 생성 한 RULE 에 위상 제어 ( &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt; )를 추가 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d19396807b5bb813f8f10443b8f102685ebd9a78" translate="yes" xml:space="preserve">
          <source>You can also define functions at the prompt:</source>
          <target state="translated">프롬프트에서 기능을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2d6d5ccc9f9a9d9f25489b257a5154dc96e794" translate="yes" xml:space="preserve">
          <source>You can also get this in a more future-proof, machine readable format, with &lt;code&gt;-t --machine-readable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;-t --machine-readable&lt;/code&gt; 를 사용 하여 미래에 대비할 수있는 머신 판독 가능 형식으로 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5b15205797af6957ff9cf5c81b6dc586582e3e9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="translated">당신은 또한 대신 독립 파생 선언을 사용 (볼 수있는 &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립 실행 형 유도 선언&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="57941d0a16c36578ea47401b7ab5a6add62861a9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="translated">당신은 또한 대신 독립 파생 선언을 사용 (볼 수있는 &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;독립 실행 형 유도 선언&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf82ec7c5c55deb1e4326a6cd0200b4cd6f00276" translate="yes" xml:space="preserve">
          <source>You can annotate modules with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;module&lt;/code&gt; keyword. For example:</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 키워드 를 사용하여 &lt;code&gt;ANN&lt;/code&gt; pragma로 모듈에 주석을 달 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd200064406d69a57200444728341c157a15f8d7" translate="yes" xml:space="preserve">
          <source>You can annotate types with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;type&lt;/code&gt; keyword. For example:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키워드 를 사용하여 &lt;code&gt;ANN&lt;/code&gt; pragma로 유형에 주석을 달 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="190d499d4f768a4e6267637fa569282ca6b46254" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a forall type:</source>
          <target state="translated">forall 유형에 유형 동의어를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c64d81db37258386a1e4b81a293b2b44f3418af" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a partially applied type synonym:</source>
          <target state="translated">형식 동의어를 부분적으로 적용되는 형식 동의어에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff9739eba78b0ef326aef750e441b5f886825f8" translate="yes" xml:space="preserve">
          <source>You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations:</source>
          <target state="translated">다음과 같은 최상위 선언을 사용하여 함수, 클래스, 유형 또는 데이터 생성자에 경고를 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f496445edbfd2209c4adb64a23b8653fa9374d16" translate="yes" xml:space="preserve">
          <source>You can build Haskell code into a shared library and make a package to be used by other Haskell programs. The easiest way is using Cabal, simply configure the Cabal package with the &lt;code&gt;--enable-shared&lt;/code&gt; flag.</source>
          <target state="translated">Haskell 코드를 공유 라이브러리에 빌드하고 다른 Haskell 프로그램에서 사용할 패키지를 만들 수 있습니다. 가장 쉬운 방법은 Cabal을 사용하는 것입니다. 간단히 &lt;code&gt;--enable-shared&lt;/code&gt; 플래그로 Cabal 패키지를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="84f62a92315cdce6616bfcedb52e44f10633e662" translate="yes" xml:space="preserve">
          <source>You can change the messages printed when the runtime system &amp;ldquo;blows up,&amp;rdquo; e.g., on stack overflow. The hooks for these are as follows:</source>
          <target state="translated">예를 들어, 스택 오버플로와 같이 런타임 시스템이 &quot;작동 할 때&quot;인쇄되는 메시지를 변경할 수 있습니다. 이에 대한 후크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d971c05fa641eaafca23d1a4589109ee786b1b8" translate="yes" xml:space="preserve">
          <source>You can check if your GHC is unregisterised by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ghc --info&lt;/code&gt; 를 호출하여 GHC 등록이 해제되었는지 확인할 수 있습니다 ( &lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4ddf7fef2dbc32cef483b738d74cadfca1ba8b1a" translate="yes" xml:space="preserve">
          <source>You can control GHC&amp;rsquo;s package database stack using the following options:</source>
          <target state="translated">다음 옵션을 사용하여 GHC의 패키지 데이터베이스 스택을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ad73c7ee3619d8e3b374d0e125dd12d41cec6bc" translate="yes" xml:space="preserve">
          <source>You can define a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; by either defining &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; or by defining both &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신은 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 를 하나 정의하여 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 또는 둘 모두가 정의하여 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53d888cce5d1295c1df726fcad67480174d570f2" translate="yes" xml:space="preserve">
          <source>You can disable specific classes, or enable/disable all classes at once:</source>
          <target state="translated">특정 클래스를 비활성화하거나 모든 클래스를 한 번에 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbcd80b12cae4ea9adddbab75b6d400e890e23d" translate="yes" xml:space="preserve">
          <source>You can even implement traverse using foldTree:</source>
          <target state="translated">foldTree를 사용하여 트래버스를 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a260428745d36797e89aab007cfe35565db63b20" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;행복한 홈페이지&lt;/a&gt; 에서 &lt;code&gt;happy&lt;/code&gt; 을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27857069203c5dd912883a5866ed1ec720c2ef7" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="translated">당신이 얻을 수있는 &lt;code&gt;happy&lt;/code&gt; 의 &lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;해피 홈페이지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26072251a75edc8b05b0ea7a052c2c2aab0d70e9" translate="yes" xml:space="preserve">
          <source>You can have an unboxed tuple in a pattern binding, thus</source>
          <target state="translated">패턴 바인딩에 언 박싱 된 튜플을 가질 수 있으므로</target>
        </trans-unit>
        <trans-unit id="e9c31fd3f547dd66812622d105b2e524f835762e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 를 사용 하여 무한한 지연 ByteString을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20f45eef250ed5478e99a9bcb99d2a343f22a32e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 를 사용 하여 무한한 지연 ByteString을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e461b7e374bf4b1ebdad57b113f09b1939fc459" translate="yes" xml:space="preserve">
          <source>You can identify an orphan module by looking in its interface file, &lt;code&gt;M.hi&lt;/code&gt;, using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;a href=&quot;using#modes&quot;&gt;mode&lt;/a&gt;. If there is a &lt;code&gt;[orphan module]&lt;/code&gt; on the first line, GHC considers it an orphan module.</source>
          <target state="translated">&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;a href=&quot;using#modes&quot;&gt;모드를&lt;/a&gt; 사용하여 인터페이스 파일 &lt;code&gt;M.hi&lt;/code&gt; 를 보면 고아 모듈을 식별 할 수 있습니다 . 첫 번째 줄에 &lt;code&gt;[orphan module]&lt;/code&gt; 이 있으면 GHC는이를 고아 모듈로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="38974e60b1eeba7a0c51ba486dac9a8715f3e4cb" translate="yes" xml:space="preserve">
          <source>You can include instance declarations as in Haskell; just omit the &amp;ldquo;where&amp;rdquo; part. An instance declaration need not be implemented directly; if an instance can be derived based on instances in the environment, it is considered implemented. For example, the following signature:</source>
          <target state="translated">Haskell에서와 같이 인스턴스 선언을 포함 할 수 있습니다. &quot;where&quot;부분 만 생략하십시오. 인스턴스 선언은 직접 구현할 필요가 없습니다. 환경의 인스턴스를 기반으로 인스턴스를 파생 할 수있는 경우 구현 된 것으로 간주됩니다. 예를 들어 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="883238e8f9c1b291d24a7f3127451079919bd8ed" translate="yes" xml:space="preserve">
          <source>You can include instance declarations just as in Haskell; but omit the &amp;ldquo;where&amp;rdquo; part.</source>
          <target state="translated">Haskell에서와 같이 인스턴스 선언을 포함 할 수 있습니다. &quot;where&quot;부분은 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe26650bd87158ad61fd3785ea8839ebbef7ad8" translate="yes" xml:space="preserve">
          <source>You can look at particular regions of your profile simply by loading a copy of the &lt;code&gt;.hp&lt;/code&gt; file into a text editor and deleting the unwanted samples. The resulting &lt;code&gt;.hp&lt;/code&gt; file can be run through &lt;code&gt;hp2ps&lt;/code&gt; and viewed or printed.</source>
          <target state="translated">&lt;code&gt;.hp&lt;/code&gt; 파일 의 사본을 텍스트 편집기로 로드 하고 원치 않는 샘플을 삭제하기 만하면 프로파일의 특정 영역을 볼 수 있습니다 . 그 결과 &lt;code&gt;.hp&lt;/code&gt; 파일을 실행할 수 있습니다 &lt;code&gt;hp2ps&lt;/code&gt; 및 보거나 인쇄.</target>
        </trans-unit>
        <trans-unit id="0c84e4d34de9122e33e533828fb9f8724a21faac" translate="yes" xml:space="preserve">
          <source>You can make &lt;code&gt;stdin&lt;/code&gt; reset itself after every evaluation by giving GHCi the command &lt;code&gt;:set +r&lt;/code&gt;. This works because &lt;code&gt;stdin&lt;/code&gt; is just a top-level expression that can be reverted to its unevaluated state in the same way as any other top-level expression (CAF).</source>
          <target state="translated">GHCi에 명령 &lt;code&gt;:set +r&lt;/code&gt; 을 부여하여 모든 평가 후 &lt;code&gt;stdin&lt;/code&gt; 을 자체적으로 재설정 할 수 있습니다 . &lt;code&gt;stdin&lt;/code&gt; 은 다른 최상위 식 (CAF)과 같은 방식으로 평가되지 않은 상태로 되돌릴 수있는 최상위 식일 뿐이 므로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e642c86265941a9874870fbd23a160343b970a77" translate="yes" xml:space="preserve">
          <source>You can make GHC diverge by using &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; on an ordinarily-recursive function.</source>
          <target state="translated">일반 재귀 함수에서 &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; 을 사용하여 GHC 분기를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1af34bbd7e2122f7192f46d93908d24a763ec3d" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell 2010 and GHC by:</source>
          <target state="translated">다음과 같이 Haskell 2010 및 GHC에서 모두 작동하는 코드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410bc62782311c49772c6565c53d200146f4a94c" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell98/Haskell2010 and GHC by:</source>
          <target state="translated">Haskell98 / Haskell2010 및 GHC에서 작동하는 코드는 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfc22cad2a308c7de056289b725564bbb1e0277" translate="yes" xml:space="preserve">
          <source>You can omit any combination of arguments to the tuple, as in the following</source>
          <target state="translated">다음과 같이 튜플에 대한 인수 조합을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4451b727c18bc51073a4d56eb70e8515e899636b" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="translated">컴파일중인 모듈에서 최상위 수준으로 선언 된 엔터티에만 연결할 수 있으며 엔터티 목록에서 정규화되지 않은 이름 만 사용할 수 있습니다. 같은 대문자 이름, &lt;code&gt;T&lt;/code&gt; 는 지칭 &lt;em&gt;어느&lt;/em&gt; 유형 생성자 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;또는&lt;/em&gt; 데이터 생성자 &lt;code&gt;T&lt;/code&gt; , 또는 두 경우 모두이 범주에있다. 둘 다 범위에 속하면 현재 다른 것을 지정하지 않고 하나를 지정할 수있는 방법이 없습니다 (cf fixities &lt;a href=&quot;#infix-tycons&quot;&gt;Infix 유형 생성자, 클래스 및 유형 변수&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e643fb8989b6abc3ab3ad51c09cde6dbbb32996" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="translated">컴파일중인 모듈의 최상위 수준에서 선언 된 엔티티에만 연결할 수 있으며 엔티티 목록에서 정규화되지 않은 이름 만 사용할 수 있습니다. 같은 대문자 이름, &lt;code&gt;T&lt;/code&gt; 는 지칭 &lt;em&gt;어느&lt;/em&gt; 유형 생성자 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;또는&lt;/em&gt; 데이터 생성자 &lt;code&gt;T&lt;/code&gt; , 또는 두 경우 모두이 범주에있다. 둘 다 범위 내에있는 경우 현재 다른 것없이 하나를 지정할 수있는 방법이 없습니다 (고정 &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix 유형 생성자, 클래스 및 유형 변수 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f886d18b90cb7daa351868e61fa0d9da62761871" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module &lt;em&gt;that is not part of a mutually-recursive group of modules that includes the module currently being compiled&lt;/em&gt;. Furthermore, all of the modules of the mutually-recursive group must be reachable by non-SOURCE imports from the module where the splice is to be run.</source>
          <target state="translated">&lt;em&gt;현재 컴파일중인 모듈을 포함하는 상호 재귀 적 모듈 그룹의 일부가 아닌&lt;/em&gt; 다른 모듈에서 함수를 가져 오는 경우 컴파일시에만 함수를 실행할 수 있습니다 . 또한, 상호 재귀 그룹의 모든 모듈은 스플 라이스가 실행될 모듈에서 비 소스 가져 오기를 통해 도달 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2006128483b352bda9f0e5cd0d687c4c8519ed68" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module. That is, you can&amp;rsquo;t define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it&amp;rsquo;s hard to implement.)</source>
          <target state="translated">다른 모듈에서 가져온 함수는 컴파일 타임에만 실행할 수 있습니다. 즉, 모듈에서 함수를 정의 할 수 없으며 같은 모듈의 스플 라이스 내에서 호출 할 수 없습니다. (그렇게하는 것이 합리적이지만 구현하기는 어렵습니다.)</target>
        </trans-unit>
        <trans-unit id="0f32acc6c773313553a7cd09864edd18e6cff35d" translate="yes" xml:space="preserve">
          <source>You can package up a complete Haskell program as a DLL, to be called by some external (usually non-Haskell) program. This is usually used to implement plugins and the like, and is described below.</source>
          <target state="translated">완전한 하스켈 프로그램을 DLL로 패키지하여 외부 (보통 비 하스켈 이외) 프로그램에 의해 호출 될 수 있습니다. 일반적으로 플러그인 등을 구현하는 데 사용되며 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1f2284e872267e26710c33db91da1ce9d66612" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="translated">&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;이 모든&lt;/a&gt; 것이 GHC 해설에서 어떻게 작동하는지 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b48804fb365ae68472ebab1f616e9dd08d1939a" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance&quot;&gt;이 모든&lt;/a&gt; 것이 GHC 해설에서 어떻게 작동하는지 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3199ab54d6438266dcddd5dc087118e34b7a0e2d" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">일반적인 &lt;code&gt;do&lt;/code&gt; -notation과 비슷하지만 모나드 식 대신 명령을 사용하여 읽을 수 있습니다 . 첫 번째 줄은 &lt;code&gt;x+1&lt;/code&gt; 값을 화살표 &lt;code&gt;f&lt;/code&gt; 에 대한 입력으로 보내고 그 출력을 &lt;code&gt;y&lt;/code&gt; 와 일치시킵니다 . 다음 줄에서는 출력이 삭제됩니다. 화살표 &lt;code&gt;returnA&lt;/code&gt; 는 &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에서 &lt;code&gt;arr id&lt;/code&gt; 로 정의됩니다 . 위의 예는</target>
        </trans-unit>
        <trans-unit id="4e9702340c88d3c9a130465b064633bbe3ada3fe" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">이것을 일반적인 &lt;code&gt;do&lt;/code&gt; - notation 과 같이 읽을 수 있지만, 모나 딕 식 대신에 명령을 사용하면됩니다. 첫 번째 행은 &lt;code&gt;x+1&lt;/code&gt; 값을 화살표 &lt;code&gt;f&lt;/code&gt; 에 대한 입력으로 보내고 출력을 &lt;code&gt;y&lt;/code&gt; 에 일치시킵니다 . 다음 줄에서는 출력이 삭제됩니다. 화살표 &lt;code&gt;returnA&lt;/code&gt; 는 &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에서 &lt;code&gt;arr id&lt;/code&gt; 로 정의됩니다 . 위의 예는 다음의 약어로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="e35a1b51b1f66368a4527f3e02178b039c453864" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">일반적인 &lt;code&gt;do&lt;/code&gt; -notation 과 매우 비슷 하지만 모나드 식 대신 명령을 사용하여 읽을 수 있습니다 . 첫 번째 줄은 &lt;code&gt;x+1&lt;/code&gt; 값을 화살표 &lt;code&gt;f&lt;/code&gt; 에 대한 입력으로 보내고 그 출력을 &lt;code&gt;y&lt;/code&gt; 와 일치시킵니다 . 다음 줄에서는 출력이 삭제됩니다. 화살표 &lt;code&gt;returnA&lt;/code&gt; 는 &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에서 &lt;code&gt;arr id&lt;/code&gt; 로 정의됩니다 . 위의 예는 다음에 대한 약어로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1e72e813532509ba13800f35b2a255158378cdcd" translate="yes" xml:space="preserve">
          <source>You can safely replace all the import declarations in &lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; with those found in its respective &lt;code&gt;.imports&lt;/code&gt; file. Why would you want to do that? Because the &amp;ldquo;minimal&amp;rdquo; imports (a) import everything explicitly, by name, and (b) import nothing that is not required. It can be quite painful to maintain this property by hand, so this flag is intended to reduce the labour.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; 모든 가져 오기 선언을 해당 &lt;code&gt;.imports&lt;/code&gt; 파일 에있는 선언으로 안전하게 바꿀 수 있습니다 . 왜 그렇게 하시겠습니까? &quot;최소&quot;수입품은 (a) 이름으로 모든 것을 명시 적으로 수입하고 (b) 필요하지 않은 것은 수입하지 않기 때문입니다. 이 재산을 손으로 관리하는 것은 상당히 고통 스럽기 때문에이 깃발은 노동을 줄이기 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="4cd2c20dc8038404cfcf2cb0390b2cee882280b8" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">&lt;code&gt;Main.hs&lt;/code&gt; 는 원하는 곳에 저장할 수 있지만 현재 디렉토리 &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[3]가&lt;/a&gt; 아닌 다른 곳에 저장하면 GHCi 에서 올바른 디렉토리로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="2311eafd5220e927965cb0ade033a0464e40e05e" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;3&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">&lt;code&gt;Main.hs&lt;/code&gt; 는 원하는 곳에 저장할 수 있지만 현재 디렉토리 &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;3이&lt;/a&gt; 아닌 다른 곳에 저장하면 GHCi 에서 올바른 디렉토리로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d11ab0fd694aaac48c2e11aa4e207640df0eae3" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">&lt;code&gt;Main.hs&lt;/code&gt; 를 원하는 곳에 저장할 수 있지만 현재 디렉토리가 아닌 다른 곳에 저장하면 &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3]&lt;/a&gt; GHCi의 올바른 디렉토리로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d1cddce0e95133d2f0c91e06c39268e36da2d8c" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 경고를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee71858b230e5297e34b408df25cee981faf2858" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 경고를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b5b508f9d570be456fe99f9c95ddc6eecec794" translate="yes" xml:space="preserve">
          <source>You can turn each Haskell package into a DLL, so that multiple Haskell executables using the same packages can share the DLL files. (As opposed to linking the libraries statically, which in effect creates a new copy of the RTS and all libraries for each executable produced.)</source>
          <target state="translated">각 Haskell 패키지를 DLL로 변환하여 동일한 패키지를 사용하는 여러 Haskell 실행 파일이 DLL 파일을 공유 할 수 있습니다. (라이브러리를 정적으로 링크하는 것과는 대조적으로, 실제로는 생성 된 각 실행 파일에 대해 새로운 RTS 사본과 모든 라이브러리를 작성합니다.)</target>
        </trans-unit>
        <trans-unit id="6a0144c3e2ac0c6bb9606a34c0cd2ffa74b49390" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; to obtain integer/word timestamps. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; 을 사용 하여 정수 / 워드 타임 스탬프를 얻을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbf78f5184b54413fec2edf8ed7eaa43cd191246" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a &lt;code&gt;data instance&lt;/code&gt; or &lt;code&gt;newtype instance&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;data instance&lt;/code&gt; 또는 &lt;code&gt;newtype instance&lt;/code&gt; 선언 에 &lt;code&gt;deriving&lt;/code&gt; 절을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4aac8ca00f383844bd9a5a98bae02690f26dd140" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a GADT-style data type declaration. For example, these two declarations are equivalent</source>
          <target state="translated">GADT 스타일 데이터 형식 선언에 &lt;code&gt;deriving&lt;/code&gt; 절을 사용할 수 있습니다 . 예를 들어,이 두 선언은 동일합니다</target>
        </trans-unit>
        <trans-unit id="b44303f497b7577f2a1611533f1079fe99f952ce" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">RTS를 수동으로 초기화하고 &lt;code&gt;-no-hs-main&lt;/code&gt; 을 전달하면 외부 기본 기능을 사용할 수 있습니다 . &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;자신의 main () 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="243f575d20a545ebc20c87833a714937518039c5" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">RTS를 수동으로 초기화하고 &lt;code&gt;-no-hs-main&lt;/code&gt; 을 전달하면 외부 기본 기능을 사용할 수 있습니다 . &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;자체 main () 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e680225c09eb0b9138a98df5d3c63c9df7449b8c" translate="yes" xml:space="preserve">
          <source>You can use record syntax on a GADT-style data type declaration:</source>
          <target state="translated">GADT 스타일 데이터 형식 선언에서 레코드 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa6a1ff9acc225bb23ca386352cd635b7095181d" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;exts/rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="translated">이름 바꾸기를 사용 하여 &lt;a href=&quot;exts/rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable 구문 및 암시 적 Prelude 가져 오기&lt;/a&gt; 확장 대신 &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt; 와 같은 대체 전주곡을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="409585b916d348cb201d92711807df5aad400581" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="translated">이름 바꾸기를 사용 하여 리 &lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;바인드 가능 구문 및 내재 된 Prelude 가져 오기&lt;/a&gt; 확장 대신 대체 &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt; 예 : -hide-all-packages -package &quot;기본 사전 작성 (BasicPrelude as Prelude))&quot; 을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34cd599ca69b1635630c1789384078026b1631bc" translate="yes" xml:space="preserve">
          <source>You can use strictness annotations, in the obvious places in the constructor type:</source>
          <target state="translated">생성자 유형의 명백한 위치에서 엄격 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed972027c3bec7c1eb51e6a5766ee6c2d7ade065" translate="yes" xml:space="preserve">
          <source>You can work on an entire module thus:</source>
          <target state="translated">따라서 전체 모듈에서 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf48999c2bd9335885a5b2d5518e8a1da408a898" translate="yes" xml:space="preserve">
          <source>You can wrap a series of foreign function calls that rely on thread-local state with &lt;code&gt;runInBoundThread&lt;/code&gt; so that you can use them without knowing whether the current thread is &lt;em&gt;bound&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;runInBoundThread&lt;/code&gt; 를 사용하여 스레드 로컬 상태에 의존하는 일련의 외부 함수 호출을 랩 하여 현재 스레드가 &lt;em&gt;바인드되어&lt;/em&gt; 있는지 여부를 알 수없이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01f309884997472a9a1052740889026ae8bf67aa" translate="yes" xml:space="preserve">
          <source>You can write a &lt;code&gt;forall&lt;/code&gt; (including overloading) in a type synonym, thus:</source>
          <target state="translated">형식 동의어 로 &lt;code&gt;forall&lt;/code&gt; (오버로딩 포함)을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c8f6089007a930f61ef159774cdb1a472069313" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t have an implicit parameter in the context of a class or instance declaration. For example, both these declarations are illegal:</source>
          <target state="translated">클래스 또는 인스턴스 선언의 컨텍스트에서 암시 적 매개 변수를 가질 수 없습니다. 예를 들어,이 두 선언은 모두 불법입니다.</target>
        </trans-unit>
        <trans-unit id="4de126d4c7a597b1d236ebb25b9bb6637ffa49d2" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t pattern-match on an existentially quantified constructor in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; group of bindings. So this is illegal:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 바인딩 그룹의 존재 수량화 된 생성자에서는 패턴 일치를 수행 할 수 없습니다 . 따라서 이것은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="c72ea2d044d7e8facee1aae8ded417fac4a31d3f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use &lt;code&gt;deriving&lt;/code&gt; to define instances of a data type with existentially quantified data constructors. Reason: in most cases it would not make sense. For example:;</source>
          <target state="translated">&lt;code&gt;deriving&lt;/code&gt; 을 사용하여 존재 수량화 된 데이터 생성자가있는 데이터 유형의 인스턴스를 정의 할 수 없습니다 . 이유 : 대부분의 경우 이해가되지 않습니다. 예를 들면 다음과 같습니다.;</target>
        </trans-unit>
        <trans-unit id="f58bc414fc59408f4615033fa5f4af7c26c36eb5" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use existential quantification for &lt;code&gt;newtype&lt;/code&gt; declarations. So this is illegal:</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; 선언 에는 실존 적 수량화를 사용할 수 없습니다 . 따라서 이것은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="3b5cdddee5d2f5aa4dc4f653d99b00c57d60b7ea" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;recursive&lt;/em&gt; binding.</source>
          <target state="translated">&lt;em&gt;재귀&lt;/em&gt; 바인딩 에서 상자가 없는 유형의 변수를 바인딩 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc0d15dc8ae90bf550f66d4910d3cffc3b11e0a" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;top-level&lt;/em&gt; binding.</source>
          <target state="translated">&lt;em&gt;최상위 레벨&lt;/em&gt; 바인딩 에서 상자없는 유형으로 변수를 바인딩 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2b1b59bb7b1256234d2e287ed8419a725eea98b4" translate="yes" xml:space="preserve">
          <source>You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:</source>
          <target state="translated">표시 유형 (데이터 생성자의 인수 유형)이 상자없는 유형 인 새 유형을 정의 할 수 없습니다. 따라서 이것은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="53d57a9a763d91b8c3c30f9e88b44d16989b4ef8" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;deriving&lt;/code&gt; on a data type declaration; write an &lt;code&gt;instance&lt;/code&gt; declaration instead.</source>
          <target state="translated">데이터 형식 선언에는 &lt;code&gt;deriving&lt;/code&gt; 을 사용할 수 없습니다 . 쓰기 &lt;code&gt;instance&lt;/code&gt; 대신 선언.</target>
        </trans-unit>
        <trans-unit id="6c32b374e885a0b6d9cb00079f7e8613d4b04f29" translate="yes" xml:space="preserve">
          <source>You cannot use a &lt;code&gt;deriving&lt;/code&gt; clause for a GADT; only for an ordinary data type.</source>
          <target state="translated">GADT에 &lt;code&gt;deriving&lt;/code&gt; 조항을 사용할 수 없습니다 . 일반 데이터 유형에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="30dbefdf45ec49645c5f83a96844f0e523320cd0" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;lsquo;s data constructors, you have to list it separately.</source>
          <target state="translated">&lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; 작성할 수 없습니다 . 즉, 하위 구성 요소 스펙을 중첩 할 수 없습니다. &lt;code&gt;GMap&lt;/code&gt; 의 데이터 생성자 를 지정하려면 별도로 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="504d8482be9fb213017caf5dad95956603bd628a" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;rsquo;s data constructors, you have to list it separately.</source>
          <target state="translated">&lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; 작성할 수 없습니다 . 즉, 하위 구성 요소 사양은 중첩 될 수 없습니다. &lt;code&gt;GMap&lt;/code&gt; 의 데이터 생성자 를 지정하려면 별도로 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="801821aa8abcdb27ec906dde72beecfda446438f" translate="yes" xml:space="preserve">
          <source>You construct values of types &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; by applying the constructor to suitable values, just as usual. For example,</source>
          <target state="translated">평소처럼 생성자를 적합한 값에 적용하여 &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; 유형의 값을 구성합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="35e2c1cf685c898a2ffd48135532e04038f5cd4e" translate="yes" xml:space="preserve">
          <source>You could also refactor to a left-fold, to decode in a more streaming fashion, and get the following decoder. It will start to return data without knowing that it can decode all input.</source>
          <target state="translated">또한 왼쪽으로 리팩토링하고 더 스트리밍 방식으로 디코딩하고 다음 디코더를 얻을 수 있습니다. 모든 입력을 해독 할 수 있다는 것을 모르고 데이터를 반환하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="71ec1076802c7edea768f5f032750297cd230b60" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to write a &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; 을 작성할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="672d8bd48c35b0238c3a6248aa09088d6f74bcfe" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to give a type signature if the lambda bound variable is a constructor argument. Here is an example we saw earlier:</source>
          <target state="translated">람다 바운드 변수가 생성자 인수 인 경우 유형 서명을 제공 할 필요가 없습니다. 우리가 앞에서 본 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e18c34733b256b9593b5ee6ff19c7fc0070729c9" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use &lt;code&gt;-fprof-auto&lt;/code&gt; for interpreted modules, annotations are automatically added at a granularity fine enough to distinguish individual call sites. However, you won&amp;rsquo;t see any call stack information for compiled code unless it was compiled with &lt;code&gt;-fprof-auto&lt;/code&gt; or has explicit &lt;code&gt;SCC&lt;/code&gt; annotations (see &lt;a href=&quot;profiling#scc-pragma&quot;&gt;Inserting cost centres by hand&lt;/a&gt;).</source>
          <target state="translated">해석 된 모듈에는 &lt;code&gt;-fprof-auto&lt;/code&gt; 를 사용할 필요가 없습니다 . 주석은 개별 호출 사이트를 구별 할 수있을만큼 세분화되어 자동으로 추가됩니다. 그러나 컴파일 된 코드에 대해 &lt;code&gt;-fprof-auto&lt;/code&gt; 로 컴파일 되었거나 명시적인 &lt;code&gt;SCC&lt;/code&gt; 주석 이 없는 경우를 제외하고는 호출 스택 정보가 표시되지 않습니다 ( &lt;a href=&quot;profiling#scc-pragma&quot;&gt;수동으로 코스트 센터 삽입&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="31b23007442846d8966d8b9c7845ac06100f1b24" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt;</source>
          <target state="translated">당신은 얻는다 &lt;code&gt;:type 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ece0b208425f5c34d6d99b2faf1ff3266b3af5" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro, not the builtin.</source>
          <target state="translated">내장이 아닌 정의 된 매크로로 &lt;code&gt;:type 3&lt;/code&gt; 을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="55bf28bc378f0c361c15d24c0484d765d31cbd6c" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro.</source>
          <target state="translated">정의 된 매크로로 &lt;code&gt;:type 3&lt;/code&gt; 을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="351ad6e5432243b3e78e9a641aceba23d847888a" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and a macro &lt;code&gt;:type&lt;/code&gt;, and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">매크로 &lt;code&gt;:time&lt;/code&gt; 및 매크로 &lt;code&gt;:type&lt;/code&gt; 이 있고 &lt;code&gt;:t 3&lt;/code&gt; 을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b967e14a3b2c88438d391b51a97e44abc37b8a3" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">매크로 &lt;code&gt;:time&lt;/code&gt; 있고 &lt;code&gt;:t 3&lt;/code&gt; 을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e64bb8bb775010f86695f2cafd801d4cc29f97f" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:type&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">매크로 &lt;code&gt;:type&lt;/code&gt; 이 있고 &lt;code&gt;:t 3&lt;/code&gt; 을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c5292c5b2bc0c1ca9d4ca9e4d5b25bbd9e291c2" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;code&gt;pattern&lt;/code&gt; keyword in an import/export specification to import or export an ordinary data constructor. For example:</source>
          <target state="translated">가져 오기 / 내보내기 스펙에서 &lt;code&gt;pattern&lt;/code&gt; 키워드를 사용하여 일반 데이터 생성자를 가져 오거나 내보낼 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8581425af0954edf998e6f74b1289f4b2aad7a8" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences:</source>
          <target state="translated">다음과 같은 차이점을 제외하고 십진 표기법의 지수와 유사한 명시 적 지수를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74a8315c09d21b66a862d09b6cf623f9312b66e" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences: - the exponent begins with &lt;code&gt;p&lt;/code&gt; instead of &lt;code&gt;e&lt;/code&gt; - the exponent is written in base &lt;code&gt;10&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16) - the base of the exponent is &lt;code&gt;2&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">또한 다음과 같은 차이점 진수 표기법 지수 유사한 명시 적 지수를 쓸 수 있습니다 : - 지수로 시작 &lt;code&gt;p&lt;/code&gt; 대신 &lt;code&gt;e&lt;/code&gt; - 지수를 기초로 작성 &lt;code&gt;10&lt;/code&gt; ( &lt;strong&gt;하지&lt;/strong&gt; 16) - 지수의 기본이다 &lt;code&gt;2&lt;/code&gt; ( &lt;strong&gt;되지&lt;/strong&gt; 16).</target>
        </trans-unit>
        <trans-unit id="fd00758a07ccd8e4012b39a3ffcc36b497dde263" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;../using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="translated">(비재 귀적, 최상위 레벨이 아닌) 패턴 바인딩에서 박싱되지 않은 변수를 바인딩 할 수 있지만 이러한 패턴 일치를 엄격하게 만들어야합니다. (그렇지 않으면 경고 &lt;a href=&quot;../using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt; &lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt; 를 내 보냅니다&lt;/a&gt; .) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8707d0873e271cfc9458fd1a9219b507929f88d1" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="translated">(비재 귀적, 최상위가 아닌) 패턴 바인딩에서 비 박스 화 변수를 바인딩 할 수 있지만 이러한 패턴 일치를 엄격하게 만들어야합니다. (그렇게하지 않으면 경고 &lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt; &lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5864b6382b64fb2ddff9a22e3cb269048cd1a65" translate="yes" xml:space="preserve">
          <source>You may not mix implicit-parameter bindings with ordinary bindings in a single &lt;code&gt;let&lt;/code&gt; expression; use two nested &lt;code&gt;let&lt;/code&gt;s instead. (In the case of &lt;code&gt;where&lt;/code&gt; you are stuck, since you can&amp;rsquo;t nest &lt;code&gt;where&lt;/code&gt; clauses.)</source>
          <target state="translated">단일 &lt;code&gt;let&lt;/code&gt; 표현식 에서 암시 적 매개 변수 바인딩과 일반 바인딩을 혼합 할 수 없습니다 . 대신 두 개의 중첩 &lt;code&gt;let&lt;/code&gt; 을 사용하십시오. &lt;code&gt;where&lt;/code&gt; 절을 중첩 할 수 없으므로 붙어 &lt;code&gt;where&lt;/code&gt; 의 경우 .</target>
        </trans-unit>
        <trans-unit id="8a15b835542506de56c4f0581f50dc84443c25f1" translate="yes" xml:space="preserve">
          <source>You may omit the &lt;code&gt;$(...)&lt;/code&gt; in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice. For example, you can write</source>
          <target state="translated">최상위 선언 스플 라이스에서 &lt;code&gt;$(...)&lt;/code&gt; 를 생략 할 수 있습니다 . 선언이 아닌 표현식을 작성하는 것은 스플 라이스를 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2a2636e1eccaa733c43b723cac9f02b969f1c6f5" translate="yes" xml:space="preserve">
          <source>You may put multiple implicit-parameter bindings in a single binding group; but they are &lt;em&gt;not&lt;/em&gt; treated as a mutually recursive group (as ordinary &lt;code&gt;let&lt;/code&gt; bindings are). Instead they are treated as a non-recursive group, simultaneously binding all the implicit parameter. The bindings are not nested, and may be re-ordered without changing the meaning of the program. For example, consider:</source>
          <target state="translated">단일 바인딩 그룹에 여러 개의 암시 적 매개 변수 바인딩을 넣을 수 있습니다. 그러나 그들은되는 &lt;em&gt;하지&lt;/em&gt; (보통으로 상호 재귀 그룹으로 처리 &lt;code&gt;let&lt;/code&gt; 바인딩이 있습니다). 대신, 이들은 비 재귀 그룹으로 취급되며 모든 암시 적 매개 변수를 동시에 바인딩합니다. 바인딩은 중첩되지 않으며 프로그램의 의미를 변경하지 않고 재정렬 될 수 있습니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="69c2bcd249a51f493b6d8defcfa352db2fe97573" translate="yes" xml:space="preserve">
          <source>You may specify an explicit &lt;em&gt;pattern signature&lt;/em&gt;, as we did for &lt;code&gt;ExNumPat&lt;/code&gt; above, to specify the type of a pattern, just as you can for a function. As usual, the type signature can be less polymorphic than the inferred type. For example</source>
          <target state="translated">함수에 대해 가능한 것처럼 패턴의 유형을 지정하기 위해 위의 &lt;code&gt;ExNumPat&lt;/code&gt; 에서와 같이 명시 적 &lt;em&gt;패턴 서명&lt;/em&gt; 을 지정할 수 있습니다. 통상적으로 타입 시그니처는 유추 된 타입보다 다형성이 적을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e235042667b9c56eb4698542652a4ffe747fce1f" translate="yes" xml:space="preserve">
          <source>You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the &lt;code&gt;ghc&lt;/code&gt; has wired into it. For example, you might want to try a different assembler. The following options allow you to change the external program used for a given compilation phase:</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; 가 연결 한 것을 대신하여 컴파일 시스템의 단계 중 하나에 다른 프로그램을 사용하도록 지정할 수 있습니다 . 예를 들어, 다른 어셈블러를 시도 할 수 있습니다. 다음 옵션을 사용하면 지정된 컴파일 단계에 사용되는 외부 프로그램을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffee81bdfe61682f0576300599ea43f154d0f848" translate="yes" xml:space="preserve">
          <source>You may want to enable this warning on a clean build or enable &lt;a href=&quot;separate_compilation#ghc-flag--fforce-recomp&quot;&gt;&lt;code&gt;-fforce-recomp&lt;/code&gt;&lt;/a&gt; in order to get reliable results.</source>
          <target state="translated">신뢰할 수있는 결과를 얻으려면 클린 빌드에서이 경고를 활성화하거나 &lt;a href=&quot;separate_compilation#ghc-flag--fforce-recomp&quot;&gt; &lt;code&gt;-fforce-recomp&lt;/code&gt; &lt;/a&gt; 를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c11ae553a6507ead096463536fbbb081dce0652" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="translated">인스턴스 컨텍스트와 수퍼 클래스에 이국적인 종류의 제약 조건을 사용하는 프로그램을 작성할 수 있지만, 그렇게하려면 형식 검사기가 종료되지 않으면 신경 쓰지 않음을 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 위해 UndecidableInstances 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5ea20c910ec7f1464378418d006e17f6554a38c" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="translated">인스턴스 컨텍스트와 슈퍼 클래스에서 이국적인 종류의 제약 조건을 사용하는 프로그램을 작성할 수 있지만 그렇게하려면 &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 를 사용 하여 유형 검사기가 종료되지 않는 경우 상관 없다는 신호를 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="d9ac328de126bafdb81fd66142c9606ef9f2bba1" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="translated">힙 프로파일을 표시하기위한 고급 도구 모음 (GHC와 함께 제공되지 않음) 인 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any를&lt;/a&gt; 살펴볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b7c142259a42674ab1afa84950577edf68dc848" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;https://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="translated">힙 프로필을 표시하기위한 고급 도구 모음 (GHC와 함께 배포되지 않음) 인 &lt;a href=&quot;https://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any를&lt;/a&gt; 살펴볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1723e9eaca2c46aa402d493c6d51826bd13e2dec" translate="yes" xml:space="preserve">
          <source>You might find it useful to use Haskell&amp;rsquo;s &lt;code&gt;seq&lt;/code&gt; function to evaluate individual thunks rather than evaluating the whole expression with &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; 로&lt;/a&gt; 전체 표현식을 평가하는 대신 Haskell의 &lt;code&gt;seq&lt;/code&gt; 함수 를 사용 하여 개별 썽크를 평가 하는 것이 유용 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2b2c5879599e9fb9784f8ece7db05367147809" translate="yes" xml:space="preserve">
          <source>You might want to use this if you are you have a type class method which returns a constrained type. For example, a type class where one of the methods implements a traversal.</source>
          <target state="translated">제한된 유형을 리턴하는 유형 클래스 메소드가있는 경우이를 사용할 수 있습니다. 예를 들어, 메소드 중 하나가 순회를 구현하는 유형 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7ca17a83d89102130bc3fbe2303f1ff784f0cd26" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;http://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">LLVM 코드 생성기가 작동하려면 &lt;code&gt;PATH&lt;/code&gt; 에 LLVM을 설치하고 사용할 수 있어야합니다 . 특히 GHC는 &lt;code&gt;opt&lt;/code&gt; 및 &lt;code&gt;llc&lt;/code&gt; 도구 를 호출 할 수 있어야 합니다. 둘째, LLVM 3.0 이상으로 Mac OS X를 실행하는 경우 &lt;code&gt;PATH&lt;/code&gt; 에서 사용할 수 있는 &lt;a href=&quot;http://clang.llvm.org&quot;&gt;Clang C 컴파일러&lt;/a&gt; 컴파일러 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c7bbe7f9ceeb8533c080ff75b9bb78ac5f1bcaf6" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;https://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">LLVM 코드 생성기가 작동하려면 &lt;code&gt;PATH&lt;/code&gt; 에 LLVM을 설치하고 사용할 수 있어야합니다 . 특히 GHC는 &lt;code&gt;opt&lt;/code&gt; 및 &lt;code&gt;llc&lt;/code&gt; 도구 를 호출 할 수 있어야 합니다. 둘째, LLVM 3.0 이상으로 Mac OS X를 실행하는 경우 &lt;code&gt;PATH&lt;/code&gt; 에서 사용할 수 있는 &lt;a href=&quot;https://clang.llvm.org&quot;&gt;Clang C 컴파일러&lt;/a&gt; 컴파일러 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7848640f49a2013635063f5f2a65c426e3adec48" translate="yes" xml:space="preserve">
          <source>You need this when using &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 사용할 때 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5e3e8cd42cf48f666040b93e9cb7bcb77de13e8f" translate="yes" xml:space="preserve">
          <source>You need to build an &amp;ldquo;installed package info&amp;rdquo; file for passing to &lt;code&gt;ghc-pkg&lt;/code&gt; when installing your package. The contents of this file are described in &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: a package specification&lt;/a&gt;.</source>
          <target state="translated">패키지 를 설치할 때 &lt;code&gt;ghc-pkg&lt;/code&gt; 에 전달하기 위해&amp;ldquo;설치된 패키지 정보&amp;rdquo;파일을 작성 해야합니다. 이 파일의 내용은 &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo : a package specification에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecae143bd200467151fc11557c8e8ff56f5c8728" translate="yes" xml:space="preserve">
          <source>You only need to enable this extension if the language you&amp;rsquo;re using is Haskell 98, in which a data type must have at least one constructor. Haskell 2010 relaxed this rule to allow data types with no constructors, and thus &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; is enabled by default when the language is Haskell 2010.</source>
          <target state="translated">사용중인 언어가 Haskell 98 인 경우에만이 확장명을 활성화하면되는데, 여기에는 데이터 유형에 생성자가 하나 이상 있어야합니다. Haskell 2010은이 규칙을 완화하여 생성자가없는 데이터 유형을 허용하므로 언어가 Haskell 2010 인 경우 기본적으로 &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3141ce96bc3bee7e55f9e3720a5ac4bb5237b4" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;../packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="translated">이 기능을 사용할 필요는 없을 것입니다. 주로 API가 변경 될 때 이전 버전과 호환되는 패키지 버전을 빌드 할 수 있도록 추가되었습니다. 일반적인 경우에 취약한 종속성으로 이어질 수 있습니다. 모듈이 때때로 한 패키지에서 다른 패키지로 이동하여 패키지 인증 가져 오기가 중단되도록합니다. 모듈 이름 간의 모호성을 해제하는 다른 방법은 &lt;a href=&quot;../packages#package-thinning-and-renaming&quot;&gt;모듈 축소 및 이름 바꾸기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20e8c6e9c630a979645ea222c79a82dcdd527d41" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="translated">이 기능을 사용할 필요는 없습니다. API가 변경 될 때 이전 버전과 호환되는 패키지 버전을 빌드 할 수 있도록 주로 추가되었습니다. 일반적인 경우에는 취약한 종속성이 발생할 수 있습니다. 모듈은 때때로 한 패키지에서 다른 패키지로 이동하여 패키지 인증 가져 오기가 손상됩니다. 모듈 이름을 명확하게 구분하는 다른 방법은 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;모듈 축소 및 이름 바꾸기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06a8acb7bef4875c53862bd963dfb3bee4782074" translate="yes" xml:space="preserve">
          <source>You should be careful with your installation function, because the list of passes you give back isn&amp;rsquo;t questioned or double checked by GHC at the time of this writing. An installation function like the following:</source>
          <target state="translated">이 글을 쓰는 시점에 GHC가 제공 한 패스 목록에 의문을 제기하거나 이중 점검하지 않기 때문에 설치 기능에주의해야합니다. 다음과 같은 설치 기능 :</target>
        </trans-unit>
        <trans-unit id="c8fb8a0845765453a3b51653e072b1e3775e368f" translate="yes" xml:space="preserve">
          <source>You should not use this module unless you are determined to monkey with the internals, as the functions here do just about nothing to preserve data invariants. You have been warned!</source>
          <target state="translated">내부 함수를 원숭이로 결정하지 않는 한이 모듈을 사용하면 안됩니다. 여기서 함수는 데이터 불변을 보존하기 위해 아무것도 수행하지 않기 때문입니다. 경고를 받았습니다!</target>
        </trans-unit>
        <trans-unit id="e9580720487f8d0a617fa4e79bebc3170cc9fb48" translate="yes" xml:space="preserve">
          <source>You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren&amp;rsquo;t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we&amp;rsquo;ll explain shortly).</source>
          <target state="translated">인터페이스 파일은 어떤 의미에서 오브젝트 파일의 내용에 대한 컴파일러가 읽을 수있는 설명이므로 오브젝트 파일과 인터페이스 파일을 쌍으로 생각해야합니다. 인터페이스 파일과 객체 파일이 어떤 이유로 든 동기화되지 않으면 컴파일러는 객체 파일에 대해 사실이 아닌 것으로 가정 할 수 있습니다. 문제는 거의 확실하게 따릅니다. 이러한 이유로 객체 파일과 인터페이스 파일을 같은 위치에 유지하는 것이 좋습니다 (GHC는 기본적으로이 작업을 수행하지만 곧 설명 할 기본값을 재정의 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="c015ba62398898e9130e51965530b85d77f20111" translate="yes" xml:space="preserve">
          <source>You will eventually need all the values stored.</source>
          <target state="translated">결국에는 저장된 모든 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f1f3422827e73aced4dc67f6bd9053292d8032b6" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 의 정의 가 반드시 타입 체크 라고 생각할 것입니다 ! 모든 &lt;code&gt;f&lt;/code&gt; 는 정확히 같은 유형이며 &lt;code&gt;g=f&lt;/code&gt; 입니다. 그러나 실제로 &lt;code&gt;f&lt;/code&gt; 의 타입은 인스턴스화되고 인스턴스화 된 제약은 &lt;code&gt;g&lt;/code&gt; 의 서명에 의해 구속 된 제약에 대해 해결 됩니다. 따라서 모호한 유형의 경우 해결이 실패합니다. 예를 들어, 이전 정의 &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bacaebd47954a76b1781e22db7949543ec0e3fb" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="translated">당신은 &lt;code&gt;g&lt;/code&gt; 의 정의 가 확실히 typecheck 할 것이라고 생각할 것입니다 ! 결국 &lt;code&gt;f&lt;/code&gt; 는 정확히 동일한 유형이고 &lt;code&gt;g=f&lt;/code&gt; 입니다. 그러나 실제로 &lt;code&gt;f&lt;/code&gt; 의 유형은 인스턴스화되고 인스턴스화 된 제약은 &lt;code&gt;g&lt;/code&gt; 의 서명에 의해 구속 된 제약에 대해 해결 됩니다. 따라서 모호한 유형의 경우 해결이 실패합니다. 예를 들어, 이전 정의 &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a82f52f22d9821ac7862aa36528ae6d83fd3c82d" translate="yes" xml:space="preserve">
          <source>Your GHC must have been built with &lt;code&gt;libdw&lt;/code&gt; support for this to work.</source>
          <target state="translated">이 작업을 수행 하려면 GHC가 &lt;code&gt;libdw&lt;/code&gt; 지원 으로 구축되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9519d527689c73f17e39c0b9add443cee365e48f" translate="yes" xml:space="preserve">
          <source>Your code should just work as before when &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is enabled, provided you use conventional &lt;code&gt;Applicative&lt;/code&gt; instances. However, if you define a &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation, then it will likely get turned into an infinite loop by GHC. For example, if you do this:</source>
          <target state="translated">일반적인 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스 를 사용하는 경우 &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 가 활성화 될 때와 마찬가지로 코드가 작동해야 합니다. 그러나 do-notation을 사용하여 &lt;code&gt;Functor&lt;/code&gt; 또는 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스를 정의하면 GHC에 의해 무한 루프로 바뀔 수 있습니다. 예를 들어, 이렇게하면 :</target>
        </trans-unit>
        <trans-unit id="a1183986a9ffb1b2af584571ceb4a326e3d27e31" translate="yes" xml:space="preserve">
          <source>Z NOTATION LEFT IMAGE BRACKET</source>
          <target state="translated">Z 표기법 왼쪽 이미지 브래킷</target>
        </trans-unit>
        <trans-unit id="0c83924bcb1f702fbc698e5e6e9f9116245051fc" translate="yes" xml:space="preserve">
          <source>Z NOTATION RIGHT IMAGE BRACKET</source>
          <target state="translated">Z 표기법 오른쪽 이미지 브래킷</target>
        </trans-unit>
        <trans-unit id="9ee13b9d7e56ee129a6f6f181a2acc60f3e30fdb" translate="yes" xml:space="preserve">
          <source>Zero and plus:</source>
          <target state="translated">제로 플러스 :</target>
        </trans-unit>
        <trans-unit id="e033898555382f2650b269ecbde512101722e511" translate="yes" xml:space="preserve">
          <source>Zero is represented by an empty error and the plus operation executes its second argument if the first fails.</source>
          <target state="translated">0은 빈 오류로 표시되며 첫 번째 작업이 실패하면 더하기 작업이 두 번째 인수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="89ce708b7ebe149f5f5bb556542ed3a714814ce1" translate="yes" xml:space="preserve">
          <source>Zero or more.</source>
          <target state="translated">0 이상</target>
        </trans-unit>
        <trans-unit id="4f2b9ff1bc4646cc78797dbbfc4b21df6589cf65" translate="yes" xml:space="preserve">
          <source>ZeroPad</source>
          <target state="translated">ZeroPad</target>
        </trans-unit>
        <trans-unit id="2700bd76f0516df842fd9e4abb85f8429575d4af" translate="yes" xml:space="preserve">
          <source>ZigZagMode</source>
          <target state="translated">ZigZagMode</target>
        </trans-unit>
        <trans-unit id="e3c3091702d0663b55dd13e13b164ff519e2737a" translate="yes" xml:space="preserve">
          <source>ZipList</source>
          <target state="translated">ZipList</target>
        </trans-unit>
        <trans-unit id="281d4deef155f3f504d99a312a022a397d572373" translate="yes" xml:space="preserve">
          <source>Zipping</source>
          <target state="translated">Zipping</target>
        </trans-unit>
        <trans-unit id="933679db226a72e96000d73f1c7a880b6ddef5ad" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping</source>
          <target state="translated">압축 및 압축 해제</target>
        </trans-unit>
        <trans-unit id="005dee8618c3540289989daf3c2e77debf4a260b" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping ByteStrings</source>
          <target state="translated">ByteString 압축 및 압축 해제</target>
        </trans-unit>
        <trans-unit id="30dc05c3a24d302f5746bde459be8a25f4a06e2d" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping lists</source>
          <target state="translated">압축 및 압축 해제 목록</target>
        </trans-unit>
        <trans-unit id="07d080af9fb55da8f84a8c1fcaee4852c64bdb52" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping streams</source>
          <target state="translated">압축 및 압축 해제 스트림</target>
        </trans-unit>
        <trans-unit id="aa0ede24e19b5ea08adf33939b19f9036f4d61de" translate="yes" xml:space="preserve">
          <source>Zips and unzip</source>
          <target state="translated">지퍼 및 압축 해제</target>
        </trans-unit>
        <trans-unit id="826ebf2b3d9d03b6187eb018e001d37252118a80" translate="yes" xml:space="preserve">
          <source>Zl: Separator, Line</source>
          <target state="translated">Zl : 분리기, 라인</target>
        </trans-unit>
        <trans-unit id="0f9a135b374272cc3038eb482b2ccf2620a381ea" translate="yes" xml:space="preserve">
          <source>ZonedTime</source>
          <target state="translated">ZonedTime</target>
        </trans-unit>
        <trans-unit id="53df64e0f183ed18f2af00a3cd4b1e5f59e3ad75" translate="yes" xml:space="preserve">
          <source>Zp: Separator, Paragraph</source>
          <target state="translated">Zp : 구분자, 단락</target>
        </trans-unit>
        <trans-unit id="b8543845a37a3bc5a76a7d50c4861b4a9b6ca581" translate="yes" xml:space="preserve">
          <source>Zs: Separator, Space</source>
          <target state="translated">Zs : 분리기, 공간</target>
        </trans-unit>
        <trans-unit id="aa9593b61dbfb1017fac300f13e25e0141bedc4f" translate="yes" xml:space="preserve">
          <source>[ The actual default definitions employ coercions to optimise out &lt;code&gt;&lt;a href=&quot;data-monoid#v:getSum&quot;&gt;getSum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:getProduct&quot;&gt;getProduct&lt;/a&gt;&lt;/code&gt;. ]</source>
          <target state="translated">[실제 기본 정의는 강제 변환을 사용하여 &lt;code&gt;&lt;a href=&quot;data-monoid#v:getSum&quot;&gt;getSum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-monoid#v:getProduct&quot;&gt;getProduct&lt;/a&gt;&lt;/code&gt; 를 최적화합니다 . ]</target>
        </trans-unit>
        <trans-unit id="ed9b7c0478a525885fdc0372f59486ef9c26b349" translate="yes" xml:space="preserve">
          <source>[ This is an experimental feature enabled by the new &lt;code&gt;-fexternal-interpreter&lt;/code&gt; flag that was introduced in GHC 8.0.1. It is currently not supported on Windows.]</source>
          <target state="translated">[이것은 GHC 8.0.1에 도입 된 새로운 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 플래그에 의해 가능한 실험 기능 입니다. 현재 Windows에서는 지원되지 않습니다.]</target>
        </trans-unit>
        <trans-unit id="b46e3a168f06b4470b490118d55d7d684c597c5e" translate="yes" xml:space="preserve">
          <source>[1]  &quot;When You Should Use Lists in Haskell (Mostly, You Should Not)&quot;, by Johannes Waldmann, in arxiv.org, Programming Languages (cs.PL), at &lt;a href=&quot;https://arxiv.org/abs/1808.08329&quot;&gt;https://arxiv.org/abs/1808.08329&lt;/a&gt;.</source>
          <target state="translated">[1]  &quot;When You Should Use Lists in Haskell (Mostly, You Should Not)&quot;, by Johannes Waldmann, in arxiv.org, Programming Languages (cs.PL), at &lt;a href=&quot;https://arxiv.org/abs/1808.08329&quot;&gt;https://arxiv.org/abs/1808.08329&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a82fefb5adab12e07a72eba03b70468034e9d703" translate="yes" xml:space="preserve">
          <source>[1] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="translated">[1] &quot;The Essence of the Iterator Pattern&quot;, Jeremy Gibbons 및 Bruno Oliveira, &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt; , 2006, 온라인 &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/ Publications / # iterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c999771beade54662d4e2bdc8fc42d7c91f4c1a5" translate="yes" xml:space="preserve">
          <source>[2] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="translated">[2] &quot;The Essence of the Iterator Pattern&quot;, Jeremy Gibbons 및 Bruno Oliveira, &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt; , 2006, 온라인 &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/ Publications / # iterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694e63c79a81e63a6094fc98085f24b5441b445d" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="translated">[&lt;a href=&quot;language-haskell-th#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</target>
        </trans-unit>
        <trans-unit id="b61777ed6df2c833c2e7f429e9f96972b755bfa6" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th-syntax#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="translated">[&lt;a href=&quot;language-haskell-th-syntax#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</target>
        </trans-unit>
        <trans-unit id="8d3d9a8e3d2cb9184eb7776e15ffceb7ac844db5" translate="yes" xml:space="preserve">
          <source>[AssocDataTypes2005]</source>
          <target state="translated">[AssocDataTypes2005]</target>
        </trans-unit>
        <trans-unit id="3149026df86df09307a54a32b5ebc7072dbf3911" translate="yes" xml:space="preserve">
          <source>[AssocTypeSyn2005]</source>
          <target state="translated">[AssocTypeSyn2005]</target>
        </trans-unit>
        <trans-unit id="27ff8c3223896183bde17540d1a603485152df8f" translate="yes" xml:space="preserve">
          <source>[Example: &lt;code&gt;-n4m&lt;/code&gt; ] When set to a non-zero value, this option divides the allocation area (&lt;code&gt;-A&lt;/code&gt; value) into chunks of the specified size. During execution, when a processor exhausts its current chunk, it is given another chunk from the pool until the pool is exhausted, at which point a collection is triggered.</source>
          <target state="translated">[예 : &lt;code&gt;-n4m&lt;/code&gt; ] 0이 아닌 값으로 설정되면이 옵션은 할당 영역 ( &lt;code&gt;-A&lt;/code&gt; 값)을 지정된 크기의 청크로 나눕니다 . 실행 중에 프로세서가 현재 청크를 소진하면 풀이 소진 될 때까지 풀에서 다른 청크가 제공되며,이 시점에서 컬렉션이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9c35275c0e496e473d959fc136a682ad3086d9" translate="yes" xml:space="preserve">
          <source>[Generics2010]</source>
          <target state="translated">[Generics2010]</target>
        </trans-unit>
        <trans-unit id="2163465089d2b153e0b8b61b46434eae8e1fe466" translate="yes" xml:space="preserve">
          <source>[Jones1999]</source>
          <target state="translated">[Jones1999]</target>
        </trans-unit>
        <trans-unit id="0c12f0c3c0a3e1aa6318a2e1ca646ed6212245b2" translate="yes" xml:space="preserve">
          <source>[Jones2000]</source>
          <target state="translated">[Jones2000]</target>
        </trans-unit>
        <trans-unit id="5f40289190bf70086cf4ad6fbc3348c060199dc3" translate="yes" xml:space="preserve">
          <source>[Lewis2000]</source>
          <target state="translated">[Lewis2000]</target>
        </trans-unit>
        <trans-unit id="c15f78a0d8a349e988dcf4bdf728980c9aa85b77" translate="yes" xml:space="preserve">
          <source>[TypeFamilies2008]</source>
          <target state="translated">[TypeFamilies2008]</target>
        </trans-unit>
        <trans-unit id="b5891f87311c40fc7e2feb2ed9e6cc0bd4955f76" translate="yes" xml:space="preserve">
          <source>[Vista and later only] The RTS calls the Win32 function &lt;code&gt;CancelSynchronousIo&lt;/code&gt;, which will cause a blocking I/O operation to return with the error &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">[Vista 이상에만 해당] RTS는 Win32 함수 &lt;code&gt;CancelSynchronousIo&lt;/code&gt; 를 호출하여 블로킹 I / O 작업이 오류 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; 와 함께 반환되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="e646f03d1dbd0ea6ebb7f3338bf711149839b070" translate="yes" xml:space="preserve">
          <source>[this is the default setting] Enable only the &amp;ldquo;safe&amp;rdquo; RTS options: (Currently only &lt;code&gt;-?&lt;/code&gt; and &lt;code&gt;--info&lt;/code&gt;.) Any other RTS options on the command line or in the &lt;code&gt;GHCRTS&lt;/code&gt; environment variable causes the program with to abort with an error message.</source>
          <target state="translated">[이것이 기본 설정입니다.] &quot;안전한&quot;RTS 옵션 만 활성화하십시오 : (현재는 &lt;code&gt;-?&lt;/code&gt; 및 &lt;code&gt;--info&lt;/code&gt; ) 명령 줄 또는 &lt;code&gt;GHCRTS&lt;/code&gt; 환경 변수의 다른 RTS 옵션으로 인해 프로그램이 오류와 함께 중단됩니다 메시지.</target>
        </trans-unit>
        <trans-unit id="34cbcaa3ebb2e1b02bbd040476f4a4192d9188e6" translate="yes" xml:space="preserve">
          <source>\( O(1) \). A singleton sequence.</source>
          <target state="translated">\ (O (1) \). 싱글 톤 시퀀스.</target>
        </trans-unit>
        <trans-unit id="3b0d6be93c20b18b6a203f57ca8cdd843632dbbc" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the left end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\ (O (1) \). 시퀀스의 왼쪽 끝에 요소를 추가하십시오. 니모닉 : 뾰족한 끝에 단일 요소가있는 삼각형.</target>
        </trans-unit>
        <trans-unit id="e29f0dd89cf4b98d9f9940c595b922a5dd21f994" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the right end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\ (O (1) \). 시퀀스의 오른쪽 끝에 요소를 추가하십시오. 니모닉 : 뾰족한 끝에 단일 요소가있는 삼각형.</target>
        </trans-unit>
        <trans-unit id="e2f5fbbdc003ed6b6112958c18acd9b5bad4a569" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the left end of a sequence.</source>
          <target state="translated">\ (O (1) \). 시퀀스의 왼쪽 끝을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f32019dd1c2a2c3b992da628e1dbb8fca3a9a405" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the right end of a sequence.</source>
          <target state="translated">\ (O (1) \). 시퀀스의 오른쪽 끝을 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="7b89d619c376ded4ba8029ab80cbbe273480461c" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Is this the empty sequence?</source>
          <target state="translated">\ (O (1) \). 이것이 빈 순서입니까?</target>
        </trans-unit>
        <trans-unit id="4043cdf48e14bbc7bef8e182dfe108b0e21704e2" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The empty sequence.</source>
          <target state="translated">\ (O (1) \). 빈 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="789a94c6e45150494a843083839c99ddbbcbcb8b" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The number of elements in the sequence.</source>
          <target state="translated">\ (O (1) \). 시퀀스의 요소 수</target>
        </trans-unit>
        <trans-unit id="9c9b70cf9a1b94d641385e597a06a4220c6c9d1d" translate="yes" xml:space="preserve">
          <source>\( O(\log n) \). &lt;code&gt;replicate n x&lt;/code&gt; is a sequence consisting of &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log n) \). &lt;code&gt;replicate n x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 개 복사본 으로 구성된 시퀀스 입니다.</target>
        </trans-unit>
        <trans-unit id="546ea35cf6dc085674954ee6937f092065e639a0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;xs&lt;/code&gt; at the index &lt;code&gt;i&lt;/code&gt;, shifting the rest of the sequence over.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; 는 인덱스 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;xs&lt;/code&gt; 에 삽입 하여 나머지 시퀀스를 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="0fe577d234433675e32729fdf0c2bc4f8e4d33da" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). A flipped, infix version of &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 뒤집힌 접미사 버전의 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1d705d397309f0a39429659216e4009c9399c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Delete the element of a sequence at a given index. Return the original sequence if the index is out of range.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 주어진 인덱스에서 시퀀스의 요소를 삭제하십시오. 인덱스가 범위를 벗어난 경우 원래 순서를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="5bf003bead51d54a782a3e3daf5bde07395d33e1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Elements of a sequence after the first &lt;code&gt;i&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; yields the whole sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the empty sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 제 후의 시퀀스의 요소 &lt;code&gt;i&lt;/code&gt; . 경우 &lt;code&gt;i&lt;/code&gt; 부정, &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; 시퀀스 전체 수율. 시퀀스에 &lt;code&gt;i&lt;/code&gt; 보다 적은 요소 가 포함 된 경우 빈 시퀀스가 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca211904aa96b1bd11aefb66842881538beef91d" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Replace the element at the specified position. If the position is out of range, the original sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 지정된 위치에서 요소를 교체하십시오. 위치가 범위를 벗어나면 원래 순서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ebe26c5fed5338d546b09c50f90bdfc79c5c59" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Split a sequence at a given position. &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 주어진 위치에서 시퀀스를 분할합니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b9982ecf4ad26d9bf2a275e1e35fdb06d9eb20b1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 지정된 위치의 요소 (0부터 계산). 지정된 위치가 음수이거나 시퀀스 길이 이상인 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b4d4d2f3cb4b284e3cbd0d7773d4efed269d4097" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 0부터 계산되는 지정된 위치의 요소입니다. 지정된 위치가 음수이거나 적어도 시퀀스 길이 인 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="977efb39460c8fb1285fbb4a0ae2081214a7c664" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 0부터 계산되는 지정된 위치의 요소입니다. 지정된 위치가 음수이거나 최소한 시퀀스 길이 인 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="532d131357cc364ae609f962dfa852c5ecc94891" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. The argument should thus be a non-negative integer less than the size of the sequence. If the position is out of range, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; fails with an error.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 지정된 위치에있는 요소 (0부터 계산). 따라서 인수는 시퀀스 크기보다 작은 음이 아닌 정수 여야합니다. 위치가 범위를 벗어나면 오류가 발생하여 &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="31957683248c73c401120fd6ad1cf601736552c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The first &lt;code&gt;i&lt;/code&gt; elements of a sequence. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; yields the empty sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the whole sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 시퀀스 의 첫 번째 &lt;code&gt;i&lt;/code&gt; 요소 경우 &lt;code&gt;i&lt;/code&gt; 음, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; 빈 시퀀스를 얻을 수 있습니다. 시퀀스에 &lt;code&gt;i&lt;/code&gt; 보다 적은 요소 가 포함 된 경우 전체 시퀀스가 ​​반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3751741ea558f6d0bac38a7743eebeac69c91050" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; can lead to poor performance and even memory leaks, because it does not force the new value before installing it in the sequence. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; should usually be preferred.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 지정된 위치에서 요소를 업데이트하십시오. 위치가 범위를 벗어나면 원래 순서가 반환됩니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; 는 순서대로 설치하기 전에 새로운 값을 강제하지 않기 때문에 성능 저하 및 메모리 누수로 이어질 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; 가 일반적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="899c0369d8a46c9994ff0ff3c2c10f46f7406360" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. The new value is forced before it is installed in the sequence.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). 지정된 위치에서 요소를 업데이트하십시오. 위치가 범위를 벗어나면 원래 순서가 반환됩니다. 순서대로 설치하기 전에 새 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="040c9f3a0d532171b25aefd9fcca6a4a01b60888" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(n_1,n_2))) \). Concatenate two sequences.</source>
          <target state="translated">\ (O (\ log (\ min (n_1, n_2))) \). 두 개의 시퀀스를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="06b9733d915a81dc3c5e947c773106d127b1fbcf" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two sequences and returns a sequence of corresponding pairs. If one input is short, excess elements are discarded from the right end of the longer sequence.</source>
          <target state="translated">\ (O (\ min (n_1, n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 시퀀스를 사용하여 해당 쌍의 시퀀스를 반환합니다. 하나의 입력이 짧으면 초과 시퀀스는 긴 시퀀스의 오른쪽 끝에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d0c309376140b35e15a12bd8a45bdb90c7b61c" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalizes &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;zipWith (+)&lt;/code&gt; is applied to two sequences to take the sequence of corresponding sums.</source>
          <target state="translated">\ (O (\ min (n_1, n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 튜플 링 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 예를 들어, &lt;code&gt;zipWith (+)&lt;/code&gt; 는 두 개의 시퀀스에 적용되어 해당 합계의 시퀀스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dbdb161425b4bae8703cd60a4996961e056d4753" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; takes three sequences and returns a sequence of triples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; 은 3 개의 시퀀스를 취하여 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 과 유사한 3 배 시퀀스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eb3b48ecc1f93c5a7b9927fe5999f5b74e5ec5b7" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; takes a function which combines three elements, as well as three sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 은 3 개의 요소와 3 개의 시퀀스를 결합하고 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 와 유사한 포인트 단위 조합의 시퀀스를 반환하는 함수를 취 합니다.</target>
        </trans-unit>
        <trans-unit id="fa10a5a78855dcba7d813e3ee6a207f58661c276" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; takes four sequences and returns a sequence of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3, n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 는 4 개의 시퀀스를 취하여 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 과 비슷한 네 개의 시퀀스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4390799dddf20a6343ea9646879bb16e7f084e8e" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; takes a function which combines four elements, as well as four sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3, n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 는 4 개의 요소와 4 개의 시퀀스를 결합하고 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 와 유사한 포인트 단위 조합의 시퀀스를 반환하는 함수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="854a5f214f7aa4910183ce26158e2621a9a01034" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the breakpoint index. &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that &lt;em&gt;do not satisfy&lt;/em&gt;&lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 중단 점 색인입니다. 술어 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 에 적용되는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt; 은 첫 번째 요소가 &lt;code&gt;p&lt;/code&gt; 를&lt;em&gt;만족하지 않는 &lt;/em&gt; &lt;code&gt;xs&lt;/code&gt; 요소 중 가장 긴 접두사 (비어있을 수 있음)이고 두 번째 요소가 나머지 시퀀스 인 쌍을 리턴합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb6c136646637ba26b9e4d03ff183d0f2f7f4e9e" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접두사 길이입니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; 반환합니다 후 남아있는 접미사 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf309903f09bc7649ddc265c0f3450f702cefc0" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접두사 길이입니다. 술어 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 에 적용되는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt; 은 첫 번째 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 &lt;code&gt;xs&lt;/code&gt; 의 요소 중 가장 긴 접두사 (비어있을 수 있음)이고 두 번째 요소가 나머지 시퀀스 인 쌍을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8a5eca9907659b3a43380501559c0f8bf072c551" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접두사 길이입니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt; 는 , 술어에인가 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 의 (비어) 최장 프리픽스 반환 &lt;code&gt;xs&lt;/code&gt; 충족 된 것을 소자 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2527991eb02d123ae97e3053f7be92eb76670670" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; returns the prefix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접미사 길이입니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; 반환합니다 후에 남아있는 접두사 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca86e7d1bc6e9440039fd89da4b54ce4dc1b17ba" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose &lt;em&gt;first&lt;/em&gt; element is the longest &lt;em&gt;suffix&lt;/em&gt; (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접미사 길이입니다. 조건 자 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 에 적용되는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;첫 번째&lt;/em&gt; 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 &lt;code&gt;xs&lt;/code&gt; 요소 중 가장 긴 &lt;em&gt;접미사&lt;/em&gt; (비어있을 수 있음)이고 두 번째 요소가 시퀀스의 나머지 부분 인 쌍을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcfc88e467626c77e9e30a0a96b1b1973c08c4cc" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest suffix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \) 여기서 \ (i \)는 접미사 길이입니다. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt; 는 , 술어에인가 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 의 (비어) 긴 접미사 반환 &lt;code&gt;xs&lt;/code&gt; 충족 된 것을 소자 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89864ca7ad3a975e47d1ac468095d918264767d7" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ log d) \). &lt;code&gt;nubOrd&lt;/code&gt; 의 기능은 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 항목 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 을 사용 하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 기능 보다 무증상 상태가 됩니다.</target>
        </trans-unit>
        <trans-unit id="77dbb7bcdeacb5504a0ef6cf2f5ee72db2c1bd02" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ log d) \). &lt;code&gt;nubOrd&lt;/code&gt; 의 기능은 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 발생 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 을 사용 하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수 보다 더 나은 무증상을 보입니다 .</target>
        </trans-unit>
        <trans-unit id="bd7af8c8ab480cb010c335014cc56785e2da88b4" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ log d) \). &lt;code&gt;nubOrd&lt;/code&gt; 의 기능은 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 발생 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 을 사용 하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수 보다 더 나은 무증상을 보입니다 .</target>
        </trans-unit>
        <trans-unit id="5fe404a925ef3c49842338c60efd96b745d6f3be" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 는 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 요소의 자연 순서에 따라 정렬합니다. 정렬이 안정적입니다. 안정성이 필요하지 않으면 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 가 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1098d943b88eab1e390e5ed0bde58e02fe11a30b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 는 지정된 비교자를 기준으로 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . 정렬이 안정적입니다. 안정성이 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="783b6fa9efe8b0aacee689453492ec1f64175be9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 데코레이션-소트-데코레이션 해제 패러다임 또는 슈바르츠 식 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="dd5b729298fbee668ec8a880b8bbf7694c81ab2d" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9f12595eeba36c0d952411979b5ac60fb59e8cd3" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="76919fecc6589c311cc2f157b3a6e318f7753a16" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 는 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 요소의 자연 순서에 따라 정렬하지만 정렬이 안정적이지 않습니다. 이 알고리즘은 종종 더 빠르며 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 보다 적은 메모리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9085dac0a56339479accab8408ea49a6a539f2cb" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 데코레이션-소트-데코레이션 해제 패러다임 또는 슈바르츠 식 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="7a75f512d7ba326f341d19f6a0cb353e820eb396" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="5073f42496be1bb6dc8bed64e2b8570c51821663" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="20373e1ed680ebc14f4b07924b5b470cc33402e5" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 는 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 요소의 자연 순서에 따라 정렬합니다. 정렬이 안정적입니다. 안정성이 필요하지 않으면 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 가 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eccdd8235b36a805ffa872f4e21e6f3de43dfa9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 는 지정된 비교자를 기준으로 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . 정렬이 안정적입니다. 안정성이 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72a13ba7d54627091e4ede4aa6ae6a602d067ef1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 데코레이션-소트-데코레이션 해제 패러다임 또는 슈바르츠 식 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="7753c3a048f9c8faf7bca750396f1ef7c209569b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="acd7d8c0ce3dcaffab36282e02bea41b69b9bbb6" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="7788d5dd9362fea81aef704f1b25c424829d973e" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 는 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 요소의 자연 순서에 따라 정렬하지만 정렬이 안정적이지 않습니다. 이 알고리즘은 종종 더 빠르며 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 보다 적은 메모리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="923bbcdf6473777345bf3471e264e87c7325e7e1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 동등 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , 오직 평가의 성능 이점을 갖는다 &lt;code&gt;f&lt;/code&gt; 입력리스트의 각 요소를 한번. 이를 데코레이션-소트-데코레이션 해제 패러다임 또는 슈바르츠 식 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="1626966051459fb3709cd1435e0670a0dbe0a5a9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="fe625859b24c94134c8d7ccfa867fdcaa9306fe9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 은 각 요소에 적용된 키 함수의 결과를 비교 하여 지정된 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 정렬합니다 . &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 와 동일하지만 입력 목록의 각 요소에 대해 &lt;code&gt;f&lt;/code&gt; 를 한 번만 평가하는 성능 이점이 있습니다. 이를 장식-정렬-비 장식 패러다임 또는 Schwartzian 변환이라고합니다.</target>
        </trans-unit>
        <trans-unit id="8c993d7ee2b9e07347303a1bfa6fbe29b0033e24" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 의 일반화 는 임의의 비교기를 사용하여 지정된 순서를 정렬합니다. 정렬이 안정적이지 않습니다. 이 알고리즘은 종종 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 보다 빠르며 더 적은 메모리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5c91e61a22ccef5e854b0115e7bae5f82a0d4e39" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (n \ log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 의 일반화 는 임의의 비교기를 사용하여 지정된 순서를 정렬합니다. 정렬이 안정적이지 않습니다. 이 알고리즘은 종종 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 보다 빠르며 더 적은 메모리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="930890d550afe6b5871128789424f2ee5f748526" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ 분 (d, W)) \). &lt;code&gt;nubInt&lt;/code&gt; 의 기능들을 제거 중복 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록에서 값을. 특히 각 요소의 첫 번째 항목 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 을 사용하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수 보다 더 나은 무증상 을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="c1a5d9655deddf9d1b59afeca8f46744a66f38b7" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ min (d, W)) \). &lt;code&gt;nubInt&lt;/code&gt; 의 기능들을 제거 중복 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록에서 값을. 특히 각 요소의 첫 번째 발생 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 를 사용하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수 보다 더 나은 무증상을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87cb6746a4d9c74a95424cc23d6dbc2098128a81" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (n \ min (d, W)) \). &lt;code&gt;nubInt&lt;/code&gt; 의 기능들을 제거 중복 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록에서 값을. 특히 각 요소의 첫 번째 발생 만 유지합니다. 내부적 으로 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 을 사용하면 표준 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수 보다 더 나은 무증상을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="603349967cf31a7e7a62cb16fea5e3004150cc9a" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Constructs a sequence by repeated application of a function to a seed value.</source>
          <target state="translated">\( 의 위에) \). 시드 값에 함수를 반복 적용하여 시퀀스를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e68f82855a00f85773c90f1119ff0dc9a7c9916f" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Convert a given sequence length and a function representing that sequence into a sequence.</source>
          <target state="translated">\( 의 위에) \). 주어진 시퀀스 길이와 해당 시퀀스를 나타내는 함수를 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="28abf92fc465e3c6920cbdd18d990aa00bd50bda" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence consisting of the elements of an &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;. Note that the resulting sequence elements may be evaluated lazily (as on GHC), so you must force the entire structure to be sure that the original array can be garbage-collected.</source>
          <target state="translated">\( 의 위에) \). &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 요소로 구성된 시퀀스를 만듭니다 . 결과 시퀀스 요소는 GHC에서와 같이 느리게 평가 될 수 있으므로 원래 배열을 가비지 수집 할 수 있도록 전체 구조를 강제로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7cdb9801d2d28c4375010fb1f7c0579b09caa2d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\( 의 위에) \). 유한 요소 목록에서 시퀀스를 만듭니다. &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 포함 하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 클래스 의 모든 인스턴스에 대해 반대 방향으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 하는 함수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a0fce5498890ae28d63d4fde0c7bd1e787e9c0" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\( 의 위에) \). 유한 요소 목록에서 시퀀스를 만듭니다. &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 포함 하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 클래스 의 모든 인스턴스에 대해 반대 방향으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 함수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cf550315a531f6071acc08c1ba13bc0c5e64675" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\( 의 위에) \). 유한 요소 목록에서 시퀀스를 만듭니다. &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 를 포함 하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 클래스 의 모든 인스턴스에 대해 반대 방향으로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 함수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dbfa82306b38fbfc581f7b62fe7f6936fc85d5d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Intersperse an element between the elements of a sequence.</source>
          <target state="translated">\( 의 위에) \). 시퀀스의 요소 사이에 요소를 산재합니다.</target>
        </trans-unit>
        <trans-unit id="eb33857f95e6abd9b8e92b965742544d371251b4" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all prefixes of this sequence, shortest first. For example,</source>
          <target state="translated">\( 의 위에) \). 이 시퀀스의 모든 접두사 시퀀스를 가장 짧은 순서로 반환합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e9bb88e43721f0ad090dd3079c9ab2d4f7f5e33e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all suffixes of this sequence, longest first. For example,</source>
          <target state="translated">\( 의 위에) \). 이 시퀀스의 모든 접미사 시퀀스를 가장 긴 순서로 반환합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d22fb3ce0a67f04fdebb29f7e29e9664003f24cc" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns a sequence of those elements which satisfy the predicate.</source>
          <target state="translated">\( 의 위에) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 함수 술어 얻어 &lt;code&gt;p&lt;/code&gt; 및 시퀀스 &lt;code&gt;xs&lt;/code&gt; 술어를 만족하는 요소의 순서를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="95c6f2c5a83a628e74aa5f06545408e2cd588fd6" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns sequences of those elements which do and do not satisfy the predicate.</source>
          <target state="translated">\( 의 위에) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 기능 술어 걸리는 &lt;code&gt;p&lt;/code&gt; 과 시퀀스 &lt;code&gt;xs&lt;/code&gt; 않으며 술어를 만족시키지 않는 요소의 복귀 시퀀스.</target>
        </trans-unit>
        <trans-unit id="7d2552d02625413aa29e21b7cef52458a7ad4167" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The reverse of a sequence.</source>
          <target state="translated">\( 의 위에) \). 시퀀스의 반대입니다.</target>
        </trans-unit>
        <trans-unit id="ef7cfa6738484ccd222c60ae3aef6fc4d639c58e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Unzip a sequence using a function to divide elements.</source>
          <target state="translated">\( 의 위에) \). 함수를 사용하여 요소를 나누는 시퀀스를 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="652ee9de3d79897676915fbdfd5346a4ef2470da" translate="yes" xml:space="preserve">
          <source>\(IY\) is strictly more specific than \(IX\). That is, \(IY\) is a substitution instance of \(IX\) but not vice versa.</source>
          <target state="translated">\ (IY \)는 \ (IX \)보다 엄격합니다. 즉, \ (IY \)는 \ (IX \)의 대체 인스턴스이지만 그 반대도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b689d73e7c786fd5b31eb51ed9d31a3f7d6ae37b" translate="yes" xml:space="preserve">
          <source>\(O \Bigl(\bigl(\frac{n}{c}\bigr) \log c\Bigr)\). &lt;code&gt;chunksOf c xs&lt;/code&gt; splits &lt;code&gt;xs&lt;/code&gt; into chunks of size &lt;code&gt;c&amp;gt;0&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; does not divide the length of &lt;code&gt;xs&lt;/code&gt; evenly, then the last element of the result will be short.</source>
          <target state="translated">\ (O \ Bigl (\ bigl (\ frac {n} {c} \ bigr) \ log c \ Bigr) \). &lt;code&gt;chunksOf c xs&lt;/code&gt; 청크 &lt;code&gt;xs&lt;/code&gt; 를 &lt;code&gt;c&amp;gt;0&lt;/code&gt; 크기의 청크로 나눕니다 . 경우 &lt;code&gt;c&lt;/code&gt; 길이 나누지 &lt;code&gt;xs&lt;/code&gt; 고르게, 결과의 마지막 요소는 단락 될 것이다.</target>
        </trans-unit>
        <trans-unit id="582a393b8e576e364ea06e27da19c1588e6f8fa7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail.</source>
          <target state="translated">\ (\ mathcal {O} (1) \). 목록을 머리와 꼬리로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="031813834a74b1dadaec56e6fd8ae694a9b009cf" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail. If the list is empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. If the list is non-empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the head of the list and &lt;code&gt;xs&lt;/code&gt; its tail.</source>
          <target state="translated">\ (\ mathcal {O} (1) \). 목록을 머리와 꼬리로 분해합니다. 목록이 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 . 목록이 비어 있지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 목록의 머리이고 &lt;code&gt;xs&lt;/code&gt; 는 꼬리입니다.</target>
        </trans-unit>
        <trans-unit id="ad354cd8847968b00b2b70d0ab031f10259ac4d8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the elements after the head of a list, which must be non-empty.</source>
          <target state="translated">\ (\ mathcal {O} (1) \). 비어 있지 않아야하는 목록의 헤드 뒤의 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb01ec6468606d885dd9ee1c8060cd2be83385b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the first element of a list, which must be non-empty.</source>
          <target state="translated">\ (\ mathcal {O} (1) \). 비어 있지 않아야하는 목록의 첫 번째 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="12b99888890a9c61dd2423c0ab81f2913922b24e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Test whether a list is empty.</source>
          <target state="translated">\ (\ mathcal {O} (1) \). 목록이 비어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a3c4b8cbae0dd17a08092f0d631dbb1998ec6523" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 목록을 가져와 해당 쌍의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d67a45507675d41829f2b315a401c8f71a813ba2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다.</target>
        </trans-unit>
        <trans-unit id="46e54d598cbb71de41da91f7c2ee3be9de7f3103" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9bc9e758cd9d84ebcae85def1963ef78822338" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 목록을 가져와 해당 쌍의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebddb5be372b47ae03039407756f373048cb2ddd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다.</target>
        </trans-unit>
        <trans-unit id="70a04ba10cd7908bfb667e9ea8808bd65a186093" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a317122ad351fffdc3f91dc27c4644052432abf1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 목록을 가져와 해당 쌍의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1591ed7412a271f839bdf25abc39810689968bd2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4ecf185edfdacf5466e47eba17bbdec5f87190" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c24a0e28dddfc47b013aacfbb632c946442d755" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 은 두 개의 목록을 가져와 해당 쌍의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab086509cd1f632f082e54529945572cafe588de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다.</target>
        </trans-unit>
        <trans-unit id="ac827704abebb27add5429489113d21367e8bfa1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 는 tupling 함수 대신 첫 번째 인수로 제공된 함수로 압축하여 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 을 일반화 합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f307d8b1e0cbd32bcd450346ba66a44e4cb712a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의 목록 및 반환 소요 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 첫 번째 목록이 두 번째의 접두어 IFF에.</target>
        </trans-unit>
        <trans-unit id="b43d2bc79af9c74b11d5e44b6386300c12ecd9b3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 의 기능리스트에서 주어진 접두어 떨어진다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 목록에 주어진 접두사, 또는 시작하지 않은 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 그 않는 경우, 접두사 다음의 목록.</target>
        </trans-unit>
        <trans-unit id="8e393f1d74c3927aa5f45e840a9f08cfdf3cfffc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의 목록 및 반환 소요 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 첫 번째 목록이 두 번째의 접두어 IFF에.</target>
        </trans-unit>
        <trans-unit id="5ca3c12a6796ceba3445b06c35f1a3f5c6f0bdf7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">\ (\ mathcal {O} (\ min (m, n)) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 의 기능리스트에서 주어진 접두어 떨어진다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 목록에 주어진 접두사, 또는 시작하지 않은 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 그 않는 경우, 접두사 다음의 목록.</target>
        </trans-unit>
        <trans-unit id="9021cb823ed71b0f14dc8ecbf8e7fc05cf8940a1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 는 목록 인수에서 &lt;code&gt;x&lt;/code&gt; 의 첫 번째 항목을 제거합니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="8adb610253a7c2ed82688fbab8e80176006f21f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 조건 자와 목록에 적용된 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 조건자를 충족하는 요소의 목록을 반환합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="363f4a1f18a4283de44396530ea1ae5638a488ee" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 조회 합니다.</target>
        </trans-unit>
        <trans-unit id="ad67b949b37d25627cdf55c54ccc28a0b18567f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="67fc4e9ba5783a6561249c23c87c89bbdb31dca1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="76f5573e311cfeaf9565286d9c2c3ea1988551e9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="ef21d250819db26eff216f0d416504ce30f4d30b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="ee6c9ed9451170ea35359a7d1abb01920f6807cc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 누적 함수의 매개 변수 순서는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 과 비교하여 반대 입니다. 또한</target>
        </trans-unit>
        <trans-unit id="86ed9eb12b027cf32babe2f5b1df3b8c66e3fd04" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7a0d2e7ca10638ff9734b38f34a11aa2706ee7e8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="5028c33c05faa97f80685730c0582c0602808e0c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 조건 자와 목록에 적용된 &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 조건자를 충족하는 요소의 목록을 반환합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="cf23c9e5c94b7f7d3b25a474b88633b73cc229b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 유한 목록의 길이를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 반환합니다 . 보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며 결과 유형은 모든 종류의 숫자가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c8e824def72775699108b83220d760c359dce3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 조회 합니다.</target>
        </trans-unit>
        <trans-unit id="44ebc9c133e22bbd087ec267e56895f09fc21ffd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="0016bd28f59bebbb241b023933026728dd4c00b7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="ce62be98b53d014c12224d990af1d700ef199e55" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="26b943958809b42bfecfe0570ab9ec6e1dc3b210" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="05c1c326018743c7d31c528075aa75b47a2ea8c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 누적 함수의 매개 변수 순서는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 과 비교하여 반대 입니다. 또한</target>
        </trans-unit>
        <trans-unit id="4f5e4a2474b3ec55663d6f011ffa981e2950b3c8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="ae8ec2f642139908ce10723399ba124eaef8630f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 는 목록 인수에서 &lt;code&gt;x&lt;/code&gt; 의 첫 번째 항목을 제거합니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="62fced33cc5c7b33d9d71684d52fad9722dc973b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 조건 자와 목록에 적용된 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 조건자를 충족하는 요소의 목록을 반환합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="fb6a174a1fd7221b3347d6f920afe8052f48daf8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 는 유한 목록의 길이를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 반환합니다 . 보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며 결과 유형은 모든 종류의 숫자가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2073b0a706335a98075522476b3b9b33b077aa11" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 조회 합니다.</target>
        </trans-unit>
        <trans-unit id="63e535e383ef8d15b37f8a06cec03c61d0469b34" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="210e580acacdb0184aa961211ec74d91837f67af" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="52fd84173341456035d6e7513a533417a0d6d1aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="9a3f84a77af8df2ddd26982298943d6341e5377e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="4f4d9f0623e9570eb88dd1d9b4c211b4b2a418a2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 누적 함수의 매개 변수 순서는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 과 비교하여 반대 입니다. 또한</target>
        </trans-unit>
        <trans-unit id="125c699b4c4f75c430387e65f7edcfe006396c73" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="9ee3b77945129051b6be71096733cdf6305efae4" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 조건 자와 목록에 적용된 &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 조건자를 충족하는 요소의 목록을 반환합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="3d986caef25fcce8ec2fbfa2e3a0dc59c42f1882" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 는 연관 목록에서 키를 조회 합니다.</target>
        </trans-unit>
        <trans-unit id="b0cae18e658efc58958ff752caf95f4308ba98c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 적용하여 얻어진 목록 &lt;code&gt;f&lt;/code&gt; 각각의 요소 &lt;code&gt;xs&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="169fb686f6e4e8af8e1766f55d01ce7bff250ede" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 은 유사하다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 했으나 왼쪽 연속 감소 된 값의 목록을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="cb1eac2b935737890f86bee44cbce323a7636c44" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="57897d060a78a4637753c44270190af6d990e750" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 참고</target>
        </trans-unit>
        <trans-unit id="99b018f59eeaa79636b5769a631d82b5b1cfd829" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 는 오른쪽에서 왼쪽으로 이중입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; . 누적 함수의 매개 변수 순서는 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 과 비교하여 반대 입니다. 또한</target>
        </trans-unit>
        <trans-unit id="2acc454a4bbccf0272c11eb7a8ea8fe3b08cbb6f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 은 시작 값 인수가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="5b4f342a6627b5c5e3e98b06ab0d9bb701b238aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격한 버전의 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9d169c8174c14ebced68d4109e796cf850ccf6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격한 버전의 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4564c9defe3967981e219d81f0960c41a9d299c1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격한 버전의 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93d8c52726c50668f1a0c6fc1fc17ef37152c05a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="7e4c73b94535ef776519822b6d1a94333ed597de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="d38f78dbd3a76f77afefcc5ac584b11d4b2b52ad" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 엄격하게 누적되는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="88254de4abf9ef851c7036af3d32cd744fb783fe" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Extract the last element of a list, which must be finite and non-empty.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 유한하고 비어 있지 않아야하는 목록의 마지막 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0d17220655fadec151f041d329764528e84ba57c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Return all the elements of a list except the last one. The list must be non-empty.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 마지막 요소를 제외한 목록의 모든 요소를 ​​반환합니다. 목록은 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6453dae020a15d9ae6ff6028cbacc37e5d836953" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 기능처럼 동작합니다 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ,하지만 사용자가 제공하는 평등 술어를합니다.</target>
        </trans-unit>
        <trans-unit id="a6555cf65a2feeb7c26015cc9026f888f6cd0644" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 특히 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스 인 모든 유형을 반환합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 보다 효율성이 떨어 집니다 .</target>
        </trans-unit>
        <trans-unit id="917fcf0e2a1ba80687d4acabf5ac686a2bcfe6f5" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 함수는 다음의 요소와 동일하다보다 작거나 제 위치에서리스트에 요소 및 목록과 인서트 요소 걸린다. 특히, 목록이 호출 전에 정렬되면 결과도 정렬됩니다. 프로그래머가 자신의 비교 함수를 제공 할 수 있도록하는 &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="851047afd0fd3689ecaf18a31831e92a21a0f13c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 요소리스트와 '산재'리스트의 요소 사이의 소자 걸린다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="74a281bf3f4c0834f6462b7a209190891fab7531" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 긴 먼저 반환에게 인수의 모든 최종 세그먼트를 작동합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="f5c53e4d9aadaf482e021157b28390aed21001b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 기능처럼 동작합니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ,하지만 사용자가 제공하는 평등 술어를합니다.</target>
        </trans-unit>
        <trans-unit id="253d3601e9ddce99694b8e80d2efd924994b0ebb" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 특히 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스 인 모든 유형을 반환합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 보다 효율성이 떨어 집니다 .</target>
        </trans-unit>
        <trans-unit id="3d0327046849d2c8bb0ea7e3a381fcc45f6e8524" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 함수는 다음의 요소와 동일하다보다 작거나 제 위치에서리스트에 요소 및 목록과 인서트 요소 걸린다. 특히, 목록이 호출 전에 정렬되면 결과도 정렬됩니다. 프로그래머가 자신의 비교 함수를 제공 할 수 있도록하는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="c871ded24319659125b4444ddec10e6a07b4af41" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 함수는 요소리스트와 '산재'리스트의 요소 사이의 소자 걸린다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="09ab7824a137d7c905554cd420e9b3f5e69e2fd9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">\ (\ mathcal {O} (n) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 긴 먼저 반환에게 인수의 모든 최종 세그먼트를 작동합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="c3f4251118a59d07862ecb1c293d53b091b0483a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 오버로드되지 않은 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="089b1c7aab36fe1e2dc84b70dbf2369dbbad67fa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (\ mathcal {O} (n) \). 오버로드되지 않은 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="d892a0ba8f3f07fab0bf412e6f60b4b7f33b99e6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">\ (\ mathcal {O} (n ^ 2) \). &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수는 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 발생 만 유지합니다. (이름 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 은 '본질'을 의미합니다.) 이것은 프로그래머가 자신의 동등성 테스트를 제공 할 수 있도록하는 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="ed48ec637b0d47680fd76b60e08867ddcbbad74a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">\ (\ mathcal {O} (n ^ 2) \). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수는 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 발생 만 유지합니다. (이름 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 은 '본질'을 의미합니다.) 이것은 프로그래머가 자신의 동등성 테스트를 제공 할 수 있도록하는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="5e6f80a34a9798cafc6a5db96cc57ba4c4db59c2" translate="yes" xml:space="preserve">
          <source>^</source>
          <target state="translated">^</target>
        </trans-unit>
        <trans-unit id="600e600a68a149108f159e39fce17366d56fc4e6" translate="yes" xml:space="preserve">
          <source>_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ = ' &lt;a href=&quot;data-bool#v:False&quot;&gt;거짓&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81245c14fa4af0f8aca817f3aac71e3856bb2e1a" translate="yes" xml:space="preserve">
          <source>_open_osfhandle</source>
          <target state="translated">_open_osfhandle</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="8022fc62249fb25428a03d36552b9662db865b9c" translate="yes" xml:space="preserve">
          <source>a 32-bit floating point number</source>
          <target state="translated">32 비트 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="25484eb33e4ca7fa03af08f774aeade1c4ee2d63" translate="yes" xml:space="preserve">
          <source>a 64-bit floating point number</source>
          <target state="translated">64 비트 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="495a1fe000be6a5008ec4d1eb84e2a1d5d084889" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = a</source>
          <target state="translated">&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:False&quot;&gt;거짓&lt;/a&gt; = a</target>
        </trans-unit>
        <trans-unit id="1048dece3526da535f415f1622b9e7f4b2a0f838" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; =' &lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8d742293ecc54e41ac09b51fa2b2c86cd8c0847" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; a = a</source>
          <target state="translated">&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;a = a</target>
        </trans-unit>
        <trans-unit id="dfc3eece5d5fbbfb2557fdd2f1a0de5ec1613686" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; ' &lt;a href=&quot;data-bool#v:False&quot;&gt;거짓&lt;/a&gt; =' &lt;a href=&quot;data-bool#v:False&quot;&gt;거짓&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01ba601786bc77082f70fd3b2a119e6f137598d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = a</source>
          <target state="translated">&lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; ' &lt;a href=&quot;data-bool#v:True&quot;&gt;진정한&lt;/a&gt; = A</target>
        </trans-unit>
        <trans-unit id="db482d5c52f88bf9c927868acddf21f43b80bd3f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; a = a</source>
          <target state="translated">a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; a = a</target>
        </trans-unit>
        <trans-unit id="46a1e8ea1de968dcf4615a18bb4b53b696036bd4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;바운드&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="2784769421385712bd50e00b7541bc81e814f56a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;열거 형&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="f867947542827acc0d2ea8e0082554ae2d9a293e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;읽기&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="abf8e156382601d33ab4309b568c53d2699611e4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;바운드&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="0375fef85fb75ec4eaea1233da0a84c6a11f70eb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;바운드&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="04456549f2a5abfaa433721a9e4d30e8a18a7b88" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;바운드&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="a89d1de959bd2ba9abd9673e63ea6a45b095b5bd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;열거 형&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="5ce73f6cfcb9fe04f1a9c2ebf0e845f07785c1c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;열거 형&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="027733db5bec3026113257962749176c09fed167" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;열거 형&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="36b1d286e77dd08402089dc786c5d6751384d91a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;읽기&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="16c734ad064a036a3668c749c7ed15b1c82c32e7" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;읽기&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="8e9dc88d9d6b9dc3f6810c3cb75f9b31968412fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;읽기&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="b047af46bc432fe3a62a3c51785c13516dfb1285" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;읽기&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~ :&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="66da0a7f93a9faeeee0de1ce9988147838ae30bc" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a = ' &lt;a href=&quot;data-bool#v:True&quot;&gt;참&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e53f9d6aefd63368970fd8b1c03f48b2146d52ae" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-124-&quot;&gt;:|&lt;/a&gt; [a] infixr 5</source>
          <target state="translated">&lt;a id=&quot;v::-124-&quot;&gt;: | &lt;/a&gt;[a] 인 펜서 5</target>
        </trans-unit>
        <trans-unit id="c09b5ca0ab45efbf368c8f883aaeb643f25da75f" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-60-&quot;&gt;:&amp;lt;&lt;/a&gt; (&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a) infixr 5</source>
          <target state="translated">a &lt;a id=&quot;v::-60-&quot;&gt;: &amp;lt;&lt;/a&gt; ( &lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a) 인 펜서 5</target>
        </trans-unit>
        <trans-unit id="4366d8309e6c4a93d2e6f9fac58abf7190d747db" translate="yes" xml:space="preserve">
          <source>a SIMD vector type</source>
          <target state="translated">SIMD 벡터 타입</target>
        </trans-unit>
        <trans-unit id="2c60a8948409326587e2d80c0533c0b2ba526f53" translate="yes" xml:space="preserve">
          <source>a buffer (whose length may be zero).</source>
          <target state="translated">버퍼 (길이가 0 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="6aba5037454fcbe2497a45a925a7bf0909281177" translate="yes" xml:space="preserve">
          <source>a constant function, returning the lowest and highest values the exponent may assume</source>
          <target state="translated">지수 함수가 가정 할 수있는 가장 낮은 값과 가장 높은 값을 반환하는 상수 함수</target>
        </trans-unit>
        <trans-unit id="5b9c7de41a1536a2cf821f605e86c2793f6bd4c5" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; 에 floatRadix 의 자릿수를 리턴하는 상수 함수</target>
        </trans-unit>
        <trans-unit id="cde248066dbb28c999a2778ce818e55f0128d213" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; 에 floatRadix 의 자릿수를 리턴하는 상수 함수</target>
        </trans-unit>
        <trans-unit id="a633e2dd8b55ec1e8c7eb858ebb8fa756f27e31c" translate="yes" xml:space="preserve">
          <source>a constant function, returning the radix of the representation (often &lt;code&gt;2&lt;/code&gt;)</source>
          <target state="translated">상수의 함수로 표현의 기수를 돌려줍니다 (종종 &lt;code&gt;2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2d112c21b644b5118250a8a70b2538ed21ba15e3" translate="yes" xml:space="preserve">
          <source>a decoding error, if the input begins with an invalid byte sequence in this Handle's encoding.</source>
          <target state="translated">입력이이 Handle 인코딩에서 유효하지 않은 바이트 시퀀스로 시작하는 경우 디코딩 오류</target>
        </trans-unit>
        <trans-unit id="13d51f2874011f80c0fda1c8dd64f87141fd6f14" translate="yes" xml:space="preserve">
          <source>a default value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="efc6e377ad13780bc21173cedd26de2bc7744fdb" translate="yes" xml:space="preserve">
          <source>a function converting a valid digit character to an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">유효한 숫자를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 변환하는 함수</target>
        </trans-unit>
        <trans-unit id="64e5fba578c7d1891365516501058a16fc9e7609" translate="yes" xml:space="preserve">
          <source>a function that can show unsigned values</source>
          <target state="translated">부호없는 값을 표시 할 수있는 함수</target>
        </trans-unit>
        <trans-unit id="4ad166b7834c36795a4fe596e5997879628c7a69" translate="yes" xml:space="preserve">
          <source>a handler for errors in the inner computation</source>
          <target state="translated">내부 계산의 오류 처리기</target>
        </trans-unit>
        <trans-unit id="c3c5aa9d0619cb64fabfcd8bc2312b400a6ca3c8" translate="yes" xml:space="preserve">
          <source>a handler for exceptions in the inner computation</source>
          <target state="translated">내부 계산의 예외 처리기</target>
        </trans-unit>
        <trans-unit id="e9b3db5689251b32a019d1c409373cee04ec49ff" translate="yes" xml:space="preserve">
          <source>a list of &lt;em&gt;associations&lt;/em&gt; of the form (&lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;). Typically, this list will be expressed as a comprehension. An association &lt;code&gt;(i, x)&lt;/code&gt; defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">양식 의 &lt;em&gt;연관&lt;/em&gt; 목록 ( &lt;em&gt;index&lt;/em&gt; , &lt;em&gt;value&lt;/em&gt; ) 일반적으로이 목록은 이해도로 표현됩니다. 연관 &lt;code&gt;(i, x)&lt;/code&gt; 인덱스 어레이 값을 정의 &lt;code&gt;i&lt;/code&gt; 될 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1838769c938ccda3c38c195704df00e6f8f9cac3" translate="yes" xml:space="preserve">
          <source>a list of declarations at top level; the spliced expression must have type &lt;code&gt;Q [Dec]&lt;/code&gt;</source>
          <target state="translated">최상위 수준의 선언 목록; 스 플라이 싱 된 표현식의 유형은 &lt;code&gt;Q [Dec]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c84a8e03c639e4b99b736533f6ce0d75c3d436cc" translate="yes" xml:space="preserve">
          <source>a nested BCO</source>
          <target state="translated">중첩 된 BCO</target>
        </trans-unit>
        <trans-unit id="dacf656c29af63ede7d5a66eb4c195cb7d68d27c" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the first map is passed to &lt;code&gt;only1&lt;/code&gt; and the output is added to the result;</source>
          <target state="translated">첫 번째 맵에서 비어 있지 않은 서브 트리 존재에 전달 &lt;code&gt;only1&lt;/code&gt; 과 출력 결과에 부가되고;</target>
        </trans-unit>
        <trans-unit id="9431cc2ffae3083c6fd4eb94123849e01bcd09de" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the second map is passed to &lt;code&gt;only2&lt;/code&gt; and the output is added to the result.</source>
          <target state="translated">단지 제 맵에서 비어 있지 않은 서브 트리 존재에 전달 &lt;code&gt;only2&lt;/code&gt; 상기 출력 결과에 부가된다.</target>
        </trans-unit>
        <trans-unit id="b079c712d0fda010c398b8b4fc564c5d93d60fd1" translate="yes" xml:space="preserve">
          <source>a pair of &lt;em&gt;bounds&lt;/em&gt;, each of the index type of the array. These bounds are the lowest and highest indices in the array, in that order. For example, a one-origin vector of length &lt;code&gt;10&lt;/code&gt; has bounds &lt;code&gt;(1,10)&lt;/code&gt;, and a one-origin &lt;code&gt;10&lt;/code&gt; by &lt;code&gt;10&lt;/code&gt; matrix has bounds &lt;code&gt;((1,1),(10,10))&lt;/code&gt;.</source>
          <target state="translated">배열의 인덱스 타입 의 &lt;em&gt;범위&lt;/em&gt; 의 &lt;em&gt;경계 &lt;/em&gt;이 범위는 순서대로 배열에서 가장 낮고 가장 높은 지수입니다. 예를 들어 길이가 &lt;code&gt;10&lt;/code&gt; 인 1- 원점 벡터 에는 범위 &lt;code&gt;(1,10)&lt;/code&gt; 이 있고 원-원점 &lt;code&gt;10&lt;/code&gt; x &lt;code&gt;10&lt;/code&gt; 행렬에는 범위가 &lt;code&gt;((1,1),(10,10))&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8e826714a73899830f6ab608075ff579906dbb" translate="yes" xml:space="preserve">
          <source>a pattern; the spliced pattern must have type &lt;code&gt;Q Pat&lt;/code&gt;</source>
          <target state="translated">패턴; 접합 패턴은 &lt;code&gt;Q Pat&lt;/code&gt; 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="684672734eb2f9a021c25216014476296b90b11e" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 표시되는 기존 데이터 청크</target>
        </trans-unit>
        <trans-unit id="73059a8046b1c205b18c2f7d1b925674ed55a915" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;ByteString&lt;/code&gt;</source>
          <target state="translated">엄격한 &lt;code&gt;ByteString&lt;/code&gt; 으로 표시되는 기존 데이터 청크</target>
        </trans-unit>
        <trans-unit id="12724a459ab10a8829360de4d06541b3e47dba30" translate="yes" xml:space="preserve">
          <source>a predicate distinguishing valid digits in this base</source>
          <target state="translated">이 기본에서 유효한 숫자를 구별하는 술어</target>
        </trans-unit>
        <trans-unit id="c68f4a2495d7173548e9a09cb2324b41dff54f59" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path</source>
          <target state="translated">경로에 추가 된 상대 경로</target>
        </trans-unit>
        <trans-unit id="8fed21137ffe5d0c7090ea916a8c3a6106462526" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path; if empty, the base path is returned</source>
          <target state="translated">경로에 추가 된 상대 경로; 비어 있으면 기본 경로가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02e6f3d317a5b730213d444073c4a9d995df7da7" translate="yes" xml:space="preserve">
          <source>a restricted append-only version of a state monad transformer or</source>
          <target state="translated">상태 모나드 변환기의 제한된 추가 전용 버전 또는</target>
        </trans-unit>
        <trans-unit id="00cd8647e896b38e11fdde37050fe414990bbb27" translate="yes" xml:space="preserve">
          <source>a simplified AST</source>
          <target state="translated">단순화 된 AST</target>
        </trans-unit>
        <trans-unit id="0f5ca64142ff0bb325d5429f5831baee94016b9b" translate="yes" xml:space="preserve">
          <source>a standard &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instance may be defined as</source>
          <target state="translated">표준 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4e0527aa2daaff6ce8c67a4930a298ed4dbc12" translate="yes" xml:space="preserve">
          <source>a string describing the &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, e.g. the file path for a file. Used in error messages.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 설명하는 문자열 ( 예 : 파일의 파일 경로) 오류 메시지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="32ae1817dace426c93d098fe2524e0f3abe3aa1a" translate="yes" xml:space="preserve">
          <source>a string literal denoting a common prefix to be added to the returned completion candidates.</source>
          <target state="translated">리턴 된 완료 후보에 추가 될 공통 접 두부를 나타내는 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="654558a0452dc0b9f151efdec13bb4d9e7dd1b7f" translate="yes" xml:space="preserve">
          <source>a string that can be passed to &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; to create an equivalent &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 전달 될 수있는 문자열 &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; 은 동등한 만들 수 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b85621828f70ac37a526068e8083c87be9c3be28" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//IGNORE&lt;/code&gt;, e.g. &lt;code&gt;UTF-8//IGNORE&lt;/code&gt;, will cause all illegal sequences on input to be ignored, and on output will drop all code points that have no representation in the target encoding.</source>
          <target state="translated">&lt;code&gt;//IGNORE&lt;/code&gt; 접미어 ( 예 : &lt;code&gt;UTF-8//IGNORE&lt;/code&gt; )는 입력시 모든 잘못된 시퀀스를 무시하고 출력시 대상 인코딩에 표시되지 않은 모든 코드 포인트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c776055d334ae6a629010d30b766a23c8aa3fde8" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//ROUNDTRIP&lt;/code&gt; will use a PEP383-style escape mechanism to represent any invalid bytes in the input as Unicode codepoints (specifically, as lone surrogates, which are normally invalid in UTF-32). Upon output, these special codepoints are detected and turned back into the corresponding original byte.</source>
          <target state="translated">&lt;code&gt;//ROUNDTRIP&lt;/code&gt; 접미사는 PEP383 스타일 이스케이프 메커니즘을 사용하여 입력의 유효하지 않은 바이트를 유니 코드 코드 포인트 (특히 UTF-32에서는 일반적으로 유효하지 않은 고독한 대리자로 표시)로 표시합니다. 출력시 이러한 특수 코드 포인트가 감지되고 해당 원래 바이트로 다시 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e864fd0038b9dc298144ef97f622ae11f451d8b" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//TRANSLIT&lt;/code&gt; will choose a replacement character for illegal sequences or code points.</source>
          <target state="translated">&lt;code&gt;//TRANSLIT&lt;/code&gt; 접미사는 잘못된 시퀀스 또는 코드 포인트의 대체 문자를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3397cb671916c002d3ff115ddde37cc1a14cdaba" translate="yes" xml:space="preserve">
          <source>a suitable instance would be</source>
          <target state="translated">적절한 예는</target>
        </trans-unit>
        <trans-unit id="db956082ebbae6d6af67d17e3acdaaae903feef0" translate="yes" xml:space="preserve">
          <source>a suitable instance would be:</source>
          <target state="translated">적합한 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d80c6eecdcbcce1a1bc8b7bef1f178ffa9e415f5" translate="yes" xml:space="preserve">
          <source>a type variable that names the result of a type family. Syntax: &lt;code&gt;= tyvar&lt;/code&gt; or &lt;code&gt;= (tyvar :: kind)&lt;/code&gt;. The type variable must be fresh.</source>
          <target state="translated">유형 패밀리의 결과를 명명하는 유형 변수. 구문 : &lt;code&gt;= tyvar&lt;/code&gt; 또는 &lt;code&gt;= (tyvar :: kind)&lt;/code&gt; . 유형 변수는 신선해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
