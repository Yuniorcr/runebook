<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c16541def5ea587ac69bfcc99daad84a959043da" translate="yes" xml:space="preserve">
          <source>Another valid monoid instance of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; It is defined by multiplication and `1` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 또 다른 유효한 monoid 인스턴스 는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; 입니다. 곱셈과 '1'은 중립 요소로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="988994d9ba9baaa058f970931250d478f9f37dc1" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">호출 사이트에서 모호성을 제거하는 또 다른 방법은 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 유형을 지정하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94b8325dc71ed2de396f171eb6cf1fb19dcc26f3" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">호출 사이트에서 모호성을 제거하는 또 다른 방법은 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 유형을 지정하는 것입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c9ca1d00f2ba6c9bdc216ddca02e1e03260d4bda" translate="yes" xml:space="preserve">
          <source>Another way to manipulate the scope is to use the &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command, whose syntax is this:</source>
          <target state="translated">범위를 조작하는 다른 방법은 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령 을 사용하는 것입니다 . 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="55329b02c1416b447df48dea23b5ad00b5ee2f0a" translate="yes" xml:space="preserve">
          <source>Any -On where n &amp;gt; 2 is the same as -O2.</source>
          <target state="translated">n&amp;gt; 2는 -O2와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aed001ecb885bcbc05312253a4102a733b569260" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 즉시 닫힌 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="bcbdf5a60ce9ec92529281711b09ee9755999301" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 즉시 닫힌 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="796335e1acfa34e32b875adacaa05c0d73b8aa9f" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 에 전달 된 모든 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 즉시 닫힌 상태에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="e91b45192e9b0774cf7aefe77d4d40c0d29cd8a2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;COMPLETE&lt;/code&gt; sets of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 모든 &lt;code&gt;COMPLETE&lt;/code&gt; 세트</target>
        </trans-unit>
        <trans-unit id="5dfb3cd648c868b374f6e2677fac36fbe2978a3c" translate="yes" xml:space="preserve">
          <source>Any GHC command-line option that is designated as dynamic (see the table in &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;), may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. To unset an option, you can set the reverse option:</source>
          <target state="translated">동적으로 지정된 GHC 명령 행 옵션 ( &lt;a href=&quot;flags#flag-reference&quot;&gt;플래그 참조&lt;/a&gt; 의 표 참조 )은 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 을&lt;/a&gt; 사용하여 설정할 수 있습니다 . 옵션을 설정 해제하려면 reverse 옵션을 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5306564b28b058683860c0dbb58f6e1ae386c4" translate="yes" xml:space="preserve">
          <source>Any I/O errors encountered while a handle is semi-closed are simply discarded.</source>
          <target state="translated">핸들이 반 닫히는 동안 발생한 모든 I / O 오류는 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c84ffa38e0d42fe1e3c4aafd67e2a273e5029ca" translate="yes" xml:space="preserve">
          <source>Any arbitrary string, no interpretation or parsing is done.</source>
          <target state="translated">임의의 문자열, 해석 또는 구문 분석이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0452f2ab13ab3b0881a1a304cec756faecd5a100" translate="yes" xml:space="preserve">
          <source>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</source>
          <target state="translated">표준 Haskell 98 구문으로 선언 될 수있는 모든 데이터 유형은 GADT 스타일 구문을 사용하여 선언 할 수도 있습니다. 선택은 크게 문체이지만 GADT 스타일 선언은 한 가지 중요한 점에서 다릅니다. 즉, 데이터 생성자에 대한 클래스 제약 조건을 다르게 취급합니다. 특히 생성자에 형식 클래스 컨텍스트가 제공되면 해당 컨텍스트를 패턴 일치로 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d3011ab0c7b5aa4a9a177dbc0ce024f6e055225" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">명령문의 평가 또는 실행 중에 발생하는 예외는 GHCi 명령 행 인터페이스에 의해 포착 및 인쇄됩니다 (예외에 대한 자세한 정보 는 라이브러리 문서에서 &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d671ba93c9259d42fd317ba91ce67c391a4d8b7f" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">명령문을 평가하거나 실행하는 동안 발생하는 모든 예외는 GHCi 명령 줄 인터페이스에 의해 포착되고 인쇄됩니다 (예외에 대한 자세한 내용 은 라이브러리 설명서의 &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f719b6e6c5e275dbf8e07842f21a8f48fe1636e8" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">명령문을 평가하거나 실행하는 동안 발생하는 모든 예외는 GHCi 명령 줄 인터페이스에 의해 포착되고 인쇄됩니다 (예외에 대한 자세한 내용 은 라이브러리 설명서의 &lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb34342e0a6715040492745b6bae6bc125156350" translate="yes" xml:space="preserve">
          <source>Any expression that has both &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances may be attached to a top-level value binding using an &lt;code&gt;ANN&lt;/code&gt; pragma. In particular, this means you can use &lt;code&gt;ANN&lt;/code&gt; to annotate data constructors (e.g. &lt;code&gt;Just&lt;/code&gt;) as well as normal values (e.g. &lt;code&gt;take&lt;/code&gt;). By way of example, to annotate the function &lt;code&gt;foo&lt;/code&gt; with the annotation &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; you would do this:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 인스턴스 가 모두있는 식은 &lt;code&gt;ANN&lt;/code&gt; pragma를 사용하여 최상위 값 바인딩에 연결될 수 있습니다 . 특히, &lt;code&gt;ANN&lt;/code&gt; 을 사용 하여 데이터 생성자 (예 : &lt;code&gt;Just&lt;/code&gt; )와 일반 값 (예 : &lt;code&gt;take&lt;/code&gt; ) 에 주석을 달 수 있습니다 . 예를 들어, 함수 &quot; &lt;code&gt;foo&lt;/code&gt; &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; 주석 &quot;Hello&quot;로 주석을 달려면 다음 과 같이 하십시오.</target>
        </trans-unit>
        <trans-unit id="01212113a76fa0770e6b80bde8974e88d8560b27" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension에&lt;/a&gt; 정의 된 &lt;code&gt;Extension&lt;/code&gt; 유형의 모든 확장을 사용할 수 있습니다. GHC는 요청 된 확장이 지원되지 않는 경우 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="b4b940cc0f6bd9befa4dc2cd571bce369cc78d6f" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension에&lt;/a&gt; 정의 된 &lt;code&gt;Extension&lt;/code&gt; 유형의 모든 확장을 사용할 수 있습니다. 요청 된 확장이 지원되지 않으면 GHC에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="6fe084339688200f9007406f9182c723678a61f9" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension에&lt;/a&gt; 정의 된 &lt;code&gt;Extension&lt;/code&gt; 유형의 모든 확장을 사용할 수 있습니다. 요청 된 확장이 지원되지 않는 경우 GHC에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="45294fce8a408e067f71fcddc66e44fa9a3aa925" translate="yes" xml:space="preserve">
          <source>Any field width is followed optionally by a precision:</source>
          <target state="translated">모든 필드 너비 다음에는 선택적으로 정밀도가옵니다.</target>
        </trans-unit>
        <trans-unit id="ca99cdb1b6224c8f2acca56e49dc80e277ef33e9" translate="yes" xml:space="preserve">
          <source>Any flags are followed optionally by a field width:</source>
          <target state="translated">모든 플래그 다음에는 선택적으로 필드 너비가옵니다.</target>
        </trans-unit>
        <trans-unit id="fe6292886945b8678502b2eed862908e6596bec8" translate="yes" xml:space="preserve">
          <source>Any flags not recognized by runghc are automatically passed to GHC. If a flag is recognized by both runghc and GHC but you want to pass it to GHC then you can place it after a &lt;code&gt;--&lt;/code&gt; separator. Flags after the separator are treated as GHC only flags. Alternatively you can use the runghc option &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass any flag or argument directly to GHC.</source>
          <target state="translated">runghc에 의해 인식되지 않는 모든 플래그는 자동으로 GHC로 전달됩니다. runghc와 GHC에서 플래그를 인식하지만 GHC에 전달하려는 경우 &lt;code&gt;--&lt;/code&gt; 구분 기호 뒤에 배치 할 수 있습니다 . 구분 기호 뒤의 플래그는 GHC 전용 플래그로 처리됩니다. 또는 runghc 옵션 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 를 사용하여 플래그 또는 인수를 GHC에 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a24acb0ed73105a63c6aa8b83c5ce57f71ebe7" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; can be made into an instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; by defining &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 은 인스턴스로 이루어질 수 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; 정의하여 &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c46287c62f0868214d45f152801a23db51bd59d4" translate="yes" xml:space="preserve">
          <source>Any instance should be subject to the following laws:</source>
          <target state="translated">모든 경우에는 다음 법률이 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4adffce07a1e96f7b4aa9f3335793d174570cf6" translate="yes" xml:space="preserve">
          <source>Any modifiers found.</source>
          <target state="translated">모든 수정자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="5cecd2c65d9c46eca630a92c4797e911edc247d7" translate="yes" xml:space="preserve">
          <source>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a &lt;code&gt;Main&lt;/code&gt; module, the program will also be linked into an executable.</source>
          <target state="translated">소스 파일 이름이나 모듈 이름은 얼마든지 지정할 수 있습니다. GHC는 이러한 초기 모듈에서 가져 오기를 수행하여 프로그램의 모든 모듈을 파악합니다. 그런 다음 오래된 각 모듈을 컴파일하려고 시도하고 마지막으로 &lt;code&gt;Main&lt;/code&gt; 모듈 이 있으면 프로그램도 실행 파일에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8a7ee0a6d4ed7c475e886db91c9ca4af5ab7c3c0" translate="yes" xml:space="preserve">
          <source>Any of the command-line options described in the rest of this chapter can be used with &lt;code&gt;--make&lt;/code&gt;, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you&amp;rsquo;ll need to use an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt;).</source>
          <target state="translated">이 장의 나머지 부분에서 설명하는 명령 줄 옵션은 &lt;code&gt;--make&lt;/code&gt; 와 함께 사용할 수 있지만 명령 줄에 제공하는 모든 옵션은 컴파일 된 모든 소스 파일에 적용되므로 옵션을 적용하려면 단일 소스 파일에만 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma 를 사용해야합니다 ( &lt;a href=&quot;#source-file-options&quot;&gt;소스 파일의 명령 행 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4fcac47fb48917b29ef16b080f9169cd49dcd808" translate="yes" xml:space="preserve">
          <source>Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt;. A semi-closed handle becomes closed:</source>
          <target state="translated">핸들이 닫혀서 실패한 조작은 핸들이 반 닫히면 실패합니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 입니다. 반 닫힘 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="74cf8930fe96c667f6ee4ecd6012b01ea066396e" translate="yes" xml:space="preserve">
          <source>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn&amp;rsquo;t actually import the same orphans.</source>
          <target state="translated">최종 구현 모듈이 실제로 동일한 고아를 가져 오지 않더라도 서명에서 가져 오면 범위로 가져 오는 모든 고아 인스턴스는 범위 내에서 무조건 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbfab23f62ec3e48e80e1e5422619cb69668f7f" translate="yes" xml:space="preserve">
          <source>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">술어와 일치하지 않는 다른 예외는 다시 발생하며 둘러싸는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 등에 의해 잡힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a712b26d1cb0416ca0ddd0555d9306a2c267be27" translate="yes" xml:space="preserve">
          <source>Any precision is followed optionally for Integral types by a width modifier; the only use of this modifier being to set the implicit size of the operand for conversion of a negative operand to unsigned:</source>
          <target state="translated">선택적으로 정수 유형의 경우 너비 수정자가 뒤에 오는 모든 정밀도가 따릅니다. 음수 피연산자를 부호없는 것으로 변환하기 위해 피연산자의 암시 적 크기를 설정하는 데이 수정 자의 유일한 사용 :</target>
        </trans-unit>
        <trans-unit id="d8c91f9f9f6e75c41b02098e931d3439ddcf440f" translate="yes" xml:space="preserve">
          <source>Any real interval contains a unique simplest rational; in particular, note that &lt;code&gt;0/1&lt;/code&gt; is the simplest rational of all.</source>
          <target state="translated">모든 실제 구간에는 고유 한 가장 간단한 합리적 요소가 포함됩니다. 특히 &lt;code&gt;0/1&lt;/code&gt; 은 가장 간단한 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="bd6fa11933cdfcdc743d92e3ae1b1b26d19d69a2" translate="yes" xml:space="preserve">
          <source>Any single-constructor data is eligible for unpacking; for example</source>
          <target state="translated">모든 단일 생성자 데이터는 포장을 풀 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a18603a852f4e4b843d8b21962152ae0dc60595e" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 를 통해 파일 디스크립터에서 차단 된 스레드는 IO 예외가 발생하여 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="769148ddf54673e79970f08b70786bcc3aab11e0" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 를 통해 파일 디스크립터에서 차단 된 스레드는 IO 예외가 발생하여 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="87c36f7b926ac2fbec6f667eb5439c00c637c3ef" translate="yes" xml:space="preserve">
          <source>Any type that you wish to throw or catch as an exception must be an instance of the &lt;code&gt;Exception&lt;/code&gt; class. The simplest case is a new exception type directly below the root:</source>
          <target state="translated">예외로 던지거나 잡으려는 모든 유형은 &lt;code&gt;Exception&lt;/code&gt; 클래스 의 인스턴스 여야합니다 . 가장 간단한 경우는 루트 바로 아래에 새로운 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b1bd8e562d1fefda868c7d1ff0cda571db4a02aa" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩의 모든 변수는 바운드 발생이지만 패턴에서 &quot;왼쪽&quot;에 바인딩 된 변수는 범위 내에 있습니다. 이 기능은 예를 들어 함수에 대한 하나의 인수가 다른 인수의 관점에서 사용될 수 있도록합니다. 예를 들어, &lt;a href=&quot;#pattern-guards&quot;&gt;패턴 가드&lt;/a&gt; 에서 &lt;code&gt;clunky&lt;/code&gt; 기능 은 다음과 같이 뷰 패턴을 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be3f3400c369b3d8251c242743fa27338956055" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩의 모든 변수는 바인딩 된 발생이지만 패턴에서 &quot;왼쪽으로&quot;바인딩 된 변수는 범위 내에 있습니다. 예를 들어이 기능을 사용하면 함수에 대한 하나의 인수를 다른 인수보기에서 사용할 수 있습니다. 예를 들어, 함수 &lt;code&gt;clunky&lt;/code&gt; 에서 &lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;패턴 가드는&lt;/a&gt; 다음과 같이 볼 패턴을 사용하여 작성 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="b0f483f182aa56813d1000ce4df4790bcbe905f1" translate="yes" xml:space="preserve">
          <source>Any whitespace which appears outside of either of the quoting and escaping mechanisms, is interpreted as having been added by this special concatenation process to designate where the boundaries are between the original, un-concatenated list of strings. These added whitespace characters are removed from the output.</source>
          <target state="translated">인용 및 이스케이프 메커니즘 외부에 나타나는 공백은이 특수 연결 프로세스에 의해 추가되어 해석되지 않은 원래 문자열 목록 사이의 경계를 지정하는 것으로 해석됩니다. 이러한 추가 된 공백 문자는 출력에서 ​​제거됩니다.</target>
        </trans-unit>
        <trans-unit id="86fba8724925018bcafcede041fc92c898e3eb9b" translate="yes" xml:space="preserve">
          <source>AnyclassStrategy</source>
          <target state="translated">AnyclassStrategy</target>
        </trans-unit>
        <trans-unit id="2d219c6ebc1efaae092effbbdcf3fa6d485c6699" translate="yes" xml:space="preserve">
          <source>Anything else throws an exception:</source>
          <target state="translated">다른 것은 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="036d8f7bd31769453184842860e1d5ca8c639fff" translate="yes" xml:space="preserve">
          <source>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints.</source>
          <target state="translated">플래그없이 제약 조건으로 이미 유효한 것 : 클래스를 입력하기위한 포화 응용 프로그램, 암시 적 매개 변수 및 동등 제약 조건.</target>
        </trans-unit>
        <trans-unit id="ad26f77e74f38dbef3399b317d10c13e53d32aa2" translate="yes" xml:space="preserve">
          <source>Anything whose form is not yet known, but the user has declared to have kind &lt;code&gt;Constraint&lt;/code&gt; (for which they need to import it from &lt;code&gt;Data.Kind&lt;/code&gt;). So for example &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; is allowed, as well as examples involving type families:</source>
          <target state="translated">양식이 아직 알려지지 않았지만 사용자가 친절한 &lt;code&gt;Constraint&lt;/code&gt; ( &lt;code&gt;Data.Kind&lt;/code&gt; 에서 가져와야 함 ) 을 갖도록 선언 했습니다 . 따라서 예를 들어 &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; 및 유형 패밀리 관련 예제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b920fb3adf34d73af2cb7b5c93d8efbc94cd36f7" translate="yes" xml:space="preserve">
          <source>Ap</source>
          <target state="translated">Ap</target>
        </trans-unit>
        <trans-unit id="53d21ca24e640bdf8e7b761f501faaae7e4e72fb" translate="yes" xml:space="preserve">
          <source>Apart from removing intermediate data-structures, encodings can be optimized further by fine-tuning their execution parameters using the functions in &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; and their &quot;inner loops&quot; using the functions in &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;.</source>
          <target state="translated">이 외에, 중간 데이터 구조를 제거하는, 인코딩이 미세 조정에 의해 더 최적화 할 수있는 기능을 사용하여 실행 파라미터 &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; 의 기능을 사용하고 그들의 &quot;내부 루프&quot; &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14dc219def5159ae2ab7cfd4d71881c1c3903e70" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;code&gt;:{ ... :}&lt;/code&gt; syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by &lt;code&gt;:set +m&lt;/code&gt;, &lt;code&gt;:set +m&lt;/code&gt; in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</source>
          <target state="translated">위에서 언급 한 멀티 라인 입력에 대한 &lt;code&gt;:{ ... :}&lt;/code&gt; 구문 외에도 GHCi에는 &lt;code&gt;:set +m&lt;/code&gt; , &lt;code&gt;:set +m&lt;/code&gt; 에 의해 활성화 된 멀티 라인 모드가 있으며 , 현재 명령문이 완료되지 않은 경우 GHCi가 자동으로 감지하여 추가 할 줄. 여러 줄 입력은 빈 줄로 종료됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc4a695f02a8a53a129dcb9ace91e91ee1e7feb9" translate="yes" xml:space="preserve">
          <source>App</source>
          <target state="translated">App</target>
        </trans-unit>
        <trans-unit id="c607b075485b6dc8c400c818769a9c892ea0ffc4" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="f664580544f7f0aa77f101d16e0efbbe807fa6e5" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="e26661dc8c698ec289349a6aeecab4d0a5e5ec82" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="345b0c25bf20f673449b84d7d686b5c70bebf7c2" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="4ebc23e4c1b65a48a70d373d483fafb1ccae8ba3" translate="yes" xml:space="preserve">
          <source>Append two lists, i.e.,</source>
          <target state="translated">두 목록을 추가하십시오. 즉</target>
        </trans-unit>
        <trans-unit id="3e0bf0178a1d360f27255c9a7f025fc03359dcd5" translate="yes" xml:space="preserve">
          <source>AppendHandle</source>
          <target state="translated">AppendHandle</target>
        </trans-unit>
        <trans-unit id="374c012a038cea614a313e941a993048c6cf1210" translate="yes" xml:space="preserve">
          <source>AppendMode</source>
          <target state="translated">AppendMode</target>
        </trans-unit>
        <trans-unit id="3916a3175dfaa3fd999b22f53277fe454f6b7b38" translate="yes" xml:space="preserve">
          <source>AppendOnWrite</source>
          <target state="translated">AppendOnWrite</target>
        </trans-unit>
        <trans-unit id="dbe098d861d9a244dfef0444bcf8ab0f87546a7d" translate="yes" xml:space="preserve">
          <source>AppendSymbol</source>
          <target state="translated">AppendSymbol</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="d311231658a1b3353cd77d4859248f1e061c4cc1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43dbefc4fd00eee5d8e84d6de5dadb9d229d56a1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f58752dc50f3a1aa349659b655c647ebed7f8f30" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">응용 프로그램 운영자. 일반 연산자 &lt;code&gt;(f x)&lt;/code&gt; 는 &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; 와 동일 하므로이 연산자는 중복 됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 오른쪽 연관 바인딩 우선 순위가 낮으므로 때때로 괄호를 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bf898ba305639dbde7f1d71fe68cf723d6796d1" translate="yes" xml:space="preserve">
          <source>Application-specific customizations to the user interface.</source>
          <target state="translated">사용자 인터페이스에 대한 응용 프로그램 별 사용자 정의</target>
        </trans-unit>
        <trans-unit id="0b8a1b21fc212c72c3e7976ca547d1f598c5e314" translate="yes" xml:space="preserve">
          <source>Applicative</source>
          <target state="translated">Applicative</target>
        </trans-unit>
        <trans-unit id="c42b346f9e6450034a0b493919801528c343e948" translate="yes" xml:space="preserve">
          <source>Applicative actions</source>
          <target state="translated">적용 조치</target>
        </trans-unit>
        <trans-unit id="98c9a7602c91954ae00f88c84bb4db90472de9d3" translate="yes" xml:space="preserve">
          <source>Applicative do-notation desugaring preserves the original semantics, provided that the &lt;code&gt;Applicative&lt;/code&gt; instance satisfies &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; and &lt;code&gt;pure = return&lt;/code&gt; (these are true of all the common monadic types). Thus, you can normally turn on &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; without fear of breaking your program. There is one pitfall to watch out for; see &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;Things to watch out for&lt;/a&gt;.</source>
          <target state="translated">Applicative Do-notation Desugaring은 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스가 &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; 및 &lt;code&gt;pure = return&lt;/code&gt; 만족 하는 경우 원래 의미를 유지합니다 (이는 모든 일반적인 모나드 유형에 해당됨). 따라서 일반적으로 프로그램 중단에 대한 두려움없이 &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 를 켤 수 있습니다 . 주의해야 할 함정이 하나 있습니다. 주의 &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3040a310341680e034eec3985152bc5a9e486ec2" translate="yes" xml:space="preserve">
          <source>Applicative functor formed by adding pure computations to a given applicative functor.</source>
          <target state="translated">주어진 펑션 펑터에 순수한 계산을 추가하여 형성된 펑션 펑터.</target>
        </trans-unit>
        <trans-unit id="65f268e6aa6cb1e22480a2a575f39395d4e90f10" translate="yes" xml:space="preserve">
          <source>Applicative functors</source>
          <target state="translated">적용 펑터</target>
        </trans-unit>
        <trans-unit id="e1507c25dc6a64376527010df0e4de108198887a" translate="yes" xml:space="preserve">
          <source>Applicative general combining function</source>
          <target state="translated">응용 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="ba83691e2c1dcc5de53cc3e4b25ca28fcf3f9a3b" translate="yes" xml:space="preserve">
          <source>Applicative merge tactic types</source>
          <target state="translated">적용 가능한 병합 전술 유형</target>
        </trans-unit>
        <trans-unit id="3bb211f1db0886c20dbcbe3aec098bfa4c51a870" translate="yes" xml:space="preserve">
          <source>ApplicativeDo</source>
          <target state="translated">ApplicativeDo</target>
        </trans-unit>
        <trans-unit id="a3e4a569ead07c8bc4d8de675cfd615c69dad24a" translate="yes" xml:space="preserve">
          <source>Applied</source>
          <target state="translated">Applied</target>
        </trans-unit>
        <trans-unit id="919e6fc623e0dc282b30825056bd5dda3c4e6c46" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소가 술어를 만족 하는지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="637b1e1d5c8efd54c8949c6a43abe4555350a327" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">술어 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 모든 요소가 술어를 만족 하는지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="9e82bc67b89a4b9e5b1ef1666971641ffcc4ec35" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">조건부 및 ByteString에인가 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우의 요소 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만족 술어.</target>
        </trans-unit>
        <trans-unit id="bbb6d3ed7b10d0b6c91c1b6b6102c1501910cf5b" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">조건부 및 ByteString에인가 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우의 요소 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만족 술어.</target>
        </trans-unit>
        <trans-unit id="b1b160142b2aab409abf2571e6a42ee896b8231e" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">술어 및 목록에 &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 목록의 모든 요소가 술어를 만족하는지 판별합니다. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 가 되려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="1bb3df1dee5942308d7549a4ff4e6623460c1a98" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">조건부 및리스트에 적용될 &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우리스트의 요소를 만족 술어. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 가되도록 하려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="649319403532f404d1828c385726fa18cf17318d" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">술어 및 목록에 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 되면 모두 목록의 모든 요소가 술어를 만족하는지 판별합니다. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 가 되려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="96fd46ee7a807ee87c60e5d0b9ca946dc3e911cb" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">조건부 및리스트에 적용될 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 판별 할 경우리스트의 요소를 만족 술어. 결과가 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 가되도록 하려면 목록이 유한해야합니다. &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그러나, 결과 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 조건부 용 유한 또는 무한리스트의 인덱스에 유한 요소에 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="be0613a1194858373863a5914ef44b595dda15fa" translate="yes" xml:space="preserve">
          <source>Applies a type to a function type. Returns: &lt;code&gt;Just u&lt;/code&gt; if the first argument represents a function of type &lt;code&gt;t -&amp;gt; u&lt;/code&gt; and the second argument represents a function of type &lt;code&gt;t&lt;/code&gt;. Otherwise, returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">유형을 함수 유형에 적용합니다. 반환 값 : &lt;code&gt;Just u&lt;/code&gt; 첫 번째 인수가 타입의 기능을 나타내는 경우 &lt;code&gt;t -&amp;gt; u&lt;/code&gt; 두 번째 인수가 타입의 기능을 나타내는 &lt;code&gt;t&lt;/code&gt; 을 . 그렇지 않으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fee4a02d62b3b562a9c374f2e31932813920bd3d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;(+1)&lt;/code&gt; to a list, a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 와 목록에 &lt;code&gt;(+1)&lt;/code&gt; 을 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7560eee7a783d22baf2bd6d4444f64f9c9a496fc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; to the second element of a pair:</source>
          <target state="translated">한 쌍의 두 번째 요소 &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="11040b63f3921092eab408bc2b85dc0c41f9e594" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 적용합니다 . &lt;code&gt;Just n&lt;/code&gt; 이 있으면 기본 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 을 표시하려고합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 있으면 &quot;Nothing&quot;대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="615a1ddaf7551b2a4174858609db8c4f030df5a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 적용합니다 . &lt;code&gt;Just n&lt;/code&gt; 이 있으면 기본 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 을 표시하려고합니다 . 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 있으면 &quot;Nothing&quot;대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="edd6c71ec52ff9bccf29d84188bba0b21ce69446" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6b9c8416c76cb38545167e06e3308ec9286dc30" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ad84cd5aa8118e1f8b36881b3b884a1d00f4857" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9745cca7883787ea648c32cd3f515d25f4cb991e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e48ba2760c93e4e34b159d49c1dbbc56799681" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9854504f7be6e574e7bfe679f44b4ee0c6be89cc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f46147f015f62456e6f042fc1fdd0a4e456ff05" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d053cfa4369b1863e68c118fa964a1a17e42f125" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="21bdb9c521d1c7d41257920a997db5a1c432b4d7" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 참이면 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="83bd5f5c6340c2876e03bdf5c78f42f0045fcd17" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">부울이 true 인 경우 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b00536f11c69e40c7baa6a53f5c52fe55c8806e5" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;f&lt;/code&gt;-actions in the reverse order.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 동작을 역순으로 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7fd738556716f25c4a33b181a4727d226b4c919" translate="yes" xml:space="preserve">
          <source>Apply a function to a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; token. When manually applying a function to &lt;code&gt;realWorld#&lt;/code&gt;, it is necessary to use &lt;code&gt;NOINLINE&lt;/code&gt; to prevent semantically undesirable floating. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; is inlined, but only very late in compilation after all floating is complete.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 토큰에 함수를 적용하십시오 . &lt;code&gt;realWorld#&lt;/code&gt; 함수를 수동으로 적용 할 때 의미 적으로 바람직하지 않은 부동을 방지 하려면 &lt;code&gt;NOINLINE&lt;/code&gt; 을 사용해야 합니다. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; 는 인라인되지만 모든 부동이 완료된 후 컴파일에서 매우 늦습니다.</target>
        </trans-unit>
        <trans-unit id="15923e60f19aafe01135e2792144867deb99400e" translate="yes" xml:space="preserve">
          <source>Apply a function to the first element of an optional pair.</source>
          <target state="translated">옵션 쌍의 첫 번째 요소에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="a5aee8e5a78690a96a71ac571dd01657b03993bb" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the continuation passed to a CPS computation.</source>
          <target state="translated">CPS 계산에 전달 된 연속성을 변환하는 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="35e3f909c25395866110729633dad59aecf7af3c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4ff89ef704740fc048b9ba990998fdecd8670f9c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다. &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4993fc434940195f4b64a80d66593316a376d43" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">연속 통과 계산 결과를 변환하는 함수를 적용합니다. &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b51211dea86c79bd6e381cda63ad155fa030e446" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation.</source>
          <target state="translated">선택 계산 결과를 변환하는 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="119d0767fcb8340ed73d84a60d5eb57b7349f3e5" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">선택 계산 결과를 변환하는 함수를 적용하십시오. &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 펑터를 정의하지 않기 때문에 다른 모나드 변환기에 대한 &lt;code&gt;map&lt;/code&gt; 조작 보다 유형이 제한되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c1bc3308702f2e877e752823a6f576e30aa537" translate="yes" xml:space="preserve">
          <source>Apply a transformation to the other computation.</source>
          <target state="translated">다른 계산에 변환을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6f2a899229fc5c6cb94a1a620e95652b86a4f6" translate="yes" xml:space="preserve">
          <source>Apply one equality to another, respectively</source>
          <target state="translated">한 평등을 다른 평등에 각각 적용</target>
        </trans-unit>
        <trans-unit id="3db4052527debed305ed7ac76b5af4b0792839fc" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">무한 구조에 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 를 적용 하는 것은 연산자가 두 번째 인수에서 게으 르면 종료됩니다 (이 경우 초기 누산기는 사용 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 않으므로 undefined 로 남겨질 수 있지만 &lt;code&gt;[]&lt;/code&gt; 더 명확함).</target>
        </trans-unit>
        <trans-unit id="afeb81f9b8e9e1466027165d488925a56b444f58" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">무한 구조에 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 를 적용 하는 것은 연산자가 두 번째 인수에서 게으 르면 종료됩니다 (이 경우 초기 누산기는 사용 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 않으므로 undefined 로 남겨질 수 있지만 &lt;code&gt;[]&lt;/code&gt; 더 명확함).</target>
        </trans-unit>
        <trans-unit id="5136f3e3a8f7d04f3c546ad5ab418d3fbab0caa7" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">무한 구조에 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 를 적용 하는 것은 연산자가 두 번째 인수에서 게으 르면 종료됩니다 (이 경우 초기 누산기는 사용 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 않으므로 undefined 로 남겨질 수 있지만 &lt;code&gt;[]&lt;/code&gt; 더 명확함).</target>
        </trans-unit>
        <trans-unit id="3915aaeccbb6370f41a8ba795caff78447316b72" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;mask&lt;/code&gt; to an exception handler</source>
          <target state="translated">예외 처리기에 &lt;code&gt;mask&lt;/code&gt; 적용</target>
        </trans-unit>
        <trans-unit id="7940fbb624b272a2fc9b14574cab25dadfa00758" translate="yes" xml:space="preserve">
          <source>Applying functions of dynamic type</source>
          <target state="translated">다이나믹 타입의 기능 적용</target>
        </trans-unit>
        <trans-unit id="753097d2ed6ee6ae143b40cc67535412f863e165" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">임의의 정밀도 정수. 같은 고정 크기 정수형와 대조적 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은 정수 전체 무한 범위를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="cea6baf5bc9c5798e19b6c91c89563fb63949b9d" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">임의의 정밀도 정수. 같은 고정 크기 정수형와 대조적 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은 정수 전체 무한 범위를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="8d3c6b448377adca963a9a043ce17ad5b59ebdc9" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">임의의 정밀도 정수. 같은 고정 크기 정수형와 대조적 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은 정수 전체 무한 범위를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="78c0f892889dcc2a8ebf1f6c5901067143d19b65" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">임의의 정밀도 정수. 같은 고정 크기 정수형와 대조적 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은 정수 전체 무한 범위를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="c4918ddd1f06d48d8245e6c5a8235cc03f138f53" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">임의의 정밀도 정수. 같은 고정 크기 정수형와 대조적 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은 정수 전체 무한 범위를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="48a6b0961bc685e7241bda505e193149b1b6e1e7" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">임의의 정밀도 합리적인 숫자로, 두 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값 의 비율로 표시됩니다 . 유리수는 &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f570f682fb6c172cde8b33c6dce79b95de7ed61" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">임의의 정밀도 합리적인 숫자로, 두 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값 의 비율로 표시됩니다 . 유리수는 &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29a35ec82756568480404c0269911333a81119f5" translate="yes" xml:space="preserve">
          <source>Arbitrary-sized tuples</source>
          <target state="translated">임의의 크기의 튜플</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="9932a4cb0405a0729daea0726dad5bca21f86edb" translate="yes" xml:space="preserve">
          <source>ArgDescr</source>
          <target state="translated">ArgDescr</target>
        </trans-unit>
        <trans-unit id="ffc2c4751c406dfe729e68e12fca79cd5235bbd5" translate="yes" xml:space="preserve">
          <source>ArgMax</source>
          <target state="translated">ArgMax</target>
        </trans-unit>
        <trans-unit id="ff6dd3f82d1ef3b64409b1d48173a3489bd3a0de" translate="yes" xml:space="preserve">
          <source>ArgMin</source>
          <target state="translated">ArgMin</target>
        </trans-unit>
        <trans-unit id="33b3818348e9a7abc5ad4f8c9119835de808618f" translate="yes" xml:space="preserve">
          <source>ArgMin, ArgMax</source>
          <target state="translated">ArgMin, ArgMax</target>
        </trans-unit>
        <trans-unit id="24257e1e26a78c97f1a7d50aeb70e00749ebb9e9" translate="yes" xml:space="preserve">
          <source>ArgOrder</source>
          <target state="translated">ArgOrder</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="6e753ec7f8245ae5fdc7a8b075baae341353e5ea" translate="yes" xml:space="preserve">
          <source>ArgumentLimit</source>
          <target state="translated">ArgumentLimit</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="41c35f0b16b9faa92a29f4ed3edbe5f0ea7a74af" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the executable</source>
          <target state="translated">실행 파일에 전달할 인수</target>
        </trans-unit>
        <trans-unit id="e1cbb100861b9948d58a53b976c856c97d398433" translate="yes" xml:space="preserve">
          <source>Arguments which look like &lt;code&gt;@foo&lt;/code&gt; will be replaced with the contents of file &lt;code&gt;foo&lt;/code&gt;. A gcc-like syntax for response files arguments is expected. This must re-constitute the argument list by doing an inverse of the escaping mechanism done by the calling-program side.</source>
          <target state="translated">&lt;code&gt;@foo&lt;/code&gt; 와 같은 인수 는 &lt;code&gt;foo&lt;/code&gt; 파일의 내용으로 대체됩니다 . 응답 파일 인수에 대한 gcc와 유사한 구문이 예상됩니다. 이것은 호출 프로그램 측이 수행하는 이스케이프 메커니즘의 역을 수행하여 인수 목록을 재구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4a70a3f41d906934cb39fa13410a07666b58dc9" translate="yes" xml:space="preserve">
          <source>ArithException</source>
          <target state="translated">ArithException</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="bb08cbe0a6134017a6f7cf472ab8010209d07a2f" translate="yes" xml:space="preserve">
          <source>Arithmetic exceptions.</source>
          <target state="translated">산술 예외.</target>
        </trans-unit>
        <trans-unit id="a9d7caa767383fc4926cd95d59576ba33ee0a3dc" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">산술 &lt;code&gt;Int&lt;/code&gt; 오버플 체크되어 &lt;code&gt;Int&lt;/code&gt; 의 모든 동작하므로, &lt;code&gt;Int&lt;/code&gt; 모듈로 2 일 &lt;sup&gt;⟨n⟩&lt;/sup&gt; ⟨n⟩는 비트의 크기 &lt;code&gt;Int&lt;/code&gt; 타입.</target>
        </trans-unit>
        <trans-unit id="202699f8498d7982cc53b20732251548a363465a" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflowoverflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">산술 &lt;code&gt;Int&lt;/code&gt; overflowoverflow위한 체크되어 &lt;code&gt;Int&lt;/code&gt; 의 모든 동작하므로, &lt;code&gt;Int&lt;/code&gt; 모듈로 2 일 &lt;sup&gt;⟨n⟩&lt;/sup&gt; ⟨n⟩는 비트의 크기 &lt;code&gt;Int&lt;/code&gt; 타입.</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">산술 연산</target>
        </trans-unit>
        <trans-unit id="3fecae258b41570e5190fa75b10edfa2c67f433e" translate="yes" xml:space="preserve">
          <source>Arithmetic shift-right operation</source>
          <target state="translated">산술 시프트 오른쪽 연산</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a070934e81973445b297f3e432a70f43cd9eb647" translate="yes" xml:space="preserve">
          <source>Array classes</source>
          <target state="translated">배열 클래스</target>
        </trans-unit>
        <trans-unit id="1f72bc74b6f28918205f9e6e811785a34a99cae8" translate="yes" xml:space="preserve">
          <source>Array construction</source>
          <target state="translated">배열 구성</target>
        </trans-unit>
        <trans-unit id="b9be2aa72950b9c68024a84de0f4b74e90523e2c" translate="yes" xml:space="preserve">
          <source>Array in which to place the values</source>
          <target state="translated">값을 배치 할 배열</target>
        </trans-unit>
        <trans-unit id="35664ac437e521792c86de2c050b2b9616ad2f9b" translate="yes" xml:space="preserve">
          <source>Array to resize</source>
          <target state="translated">크기를 조정할 배열</target>
        </trans-unit>
        <trans-unit id="55f55ab0f2f0b52c9ee209db3b03b78882aa29c9" translate="yes" xml:space="preserve">
          <source>Array to write from</source>
          <target state="translated">쓸 배열</target>
        </trans-unit>
        <trans-unit id="2dfdceb734024f39f314a3c0b8391586228fb921" translate="yes" xml:space="preserve">
          <source>Array#</source>
          <target state="translated">Array#</target>
        </trans-unit>
        <trans-unit id="898837d96f33bff85a3be5478164cfc6afd0eadc" translate="yes" xml:space="preserve">
          <source>ArrayArray#</source>
          <target state="translated">ArrayArray#</target>
        </trans-unit>
        <trans-unit id="592acb75a6da231d0a2a2173d588c93486db96f4" translate="yes" xml:space="preserve">
          <source>ArrayException</source>
          <target state="translated">ArrayException</target>
        </trans-unit>
        <trans-unit id="93c35e8fd0d3491f05295cbaa9fc1ec445fdc9e3" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;Storable&lt;/code&gt; things.</source>
          <target state="translated">의 배열 &lt;code&gt;Storable&lt;/code&gt; 것.</target>
        </trans-unit>
        <trans-unit id="6f11fdf73ec1f7aec4ea144e79eb109ff942b709" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements</source>
          <target state="translated">박스가없는 요소를 가진 배열</target>
        </trans-unit>
        <trans-unit id="9d7392dc546e184e07e6daaacd277a5d43a5c7da" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">박스형 요소가있는 배열. 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 가 제공됩니다 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 특정 요소 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 등; 투시 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 전체 목록은 클래스).</target>
        </trans-unit>
        <trans-unit id="641e7befb70fe85093114258ec0852dc24a766bf" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">박싱되지 않은 요소가있는 배열. 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 가 제공됩니다 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 특정 요소 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 등; 투시 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 전체 목록은 클래스).</target>
        </trans-unit>
        <trans-unit id="fa4ab058d3a73e22b09d2ccc980d2abebbfa6f13" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">박싱되지 않은 요소가있는 배열. 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; 가 제공됩니다 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 특정 요소 유형 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 등; 투시 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 전체 목록은 클래스).</target>
        </trans-unit>
        <trans-unit id="3a4758c3cc8dac2d76026d0733816741f9b21d43" translate="yes" xml:space="preserve">
          <source>Arrow</source>
          <target state="translated">Arrow</target>
        </trans-unit>
        <trans-unit id="4a7111dcaf1b4237c13ed045e218a14996e9fbe6" translate="yes" xml:space="preserve">
          <source>Arrow application</source>
          <target state="translated">화살표 응용</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">화살표 키</target>
        </trans-unit>
        <trans-unit id="a6216e2bed8396214323ababdee0bc0041b0726d" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">표기법 화살표 (참조 &lt;a href=&quot;#arrow-notation&quot;&gt;화살표 표기&lt;/a&gt; 대로 사용함) &lt;code&gt;arr&lt;/code&gt; , &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; , &lt;code&gt;(|||)&lt;/code&gt; 및 &lt;code&gt;loop&lt;/code&gt; 기능의 범위에있다. 그러나 다른 구성과 달리 이러한 함수의 유형은 Prelude 유형과 매우 밀접하게 일치해야합니다. 세부 사항은 유동적입니다. 이것을 사용하려면 물어보십시오!</target>
        </trans-unit>
        <trans-unit id="55386b3ae61f88d0f525742d799552dd74e88c99" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;arrows#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">표기법 화살표 (참조 &lt;a href=&quot;arrows#arrow-notation&quot;&gt;화살표 표기&lt;/a&gt; 대로 사용함) &lt;code&gt;arr&lt;/code&gt; , &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;app&lt;/code&gt; , &lt;code&gt;(|||)&lt;/code&gt; 및 &lt;code&gt;loop&lt;/code&gt; 기능의 범위에있다. 그러나 다른 구성과 달리 이러한 함수의 유형은 Prelude 유형과 매우 밀접하게 일치해야합니다. 세부 사항은 유동적입니다. 이걸 사용하고 싶다면 물어봐요 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!</target>
        </trans-unit>
        <trans-unit id="8f1f0db1f62fbb0e92d1c7e980a5aefb808bd919" translate="yes" xml:space="preserve">
          <source>ArrowApply</source>
          <target state="translated">ArrowApply</target>
        </trans-unit>
        <trans-unit id="3c11beff8b02b8f9cbaa16ca3ab20327c65da1ba" translate="yes" xml:space="preserve">
          <source>ArrowChoice</source>
          <target state="translated">ArrowChoice</target>
        </trans-unit>
        <trans-unit id="47595fe84f8dd1e9405b5200e89860454330a77e" translate="yes" xml:space="preserve">
          <source>ArrowLoop</source>
          <target state="translated">ArrowLoop</target>
        </trans-unit>
        <trans-unit id="e45164f39602039a081dfdb414a58cdcb90fce01" translate="yes" xml:space="preserve">
          <source>ArrowMonad</source>
          <target state="translated">ArrowMonad</target>
        </trans-unit>
        <trans-unit id="31cc2db65fb67d75aaa03855c6522bc61f0c5f08" translate="yes" xml:space="preserve">
          <source>ArrowPlus</source>
          <target state="translated">ArrowPlus</target>
        </trans-unit>
        <trans-unit id="a6cef6a13748337ec64d72cbbfdef1e1d56c28ba" translate="yes" xml:space="preserve">
          <source>ArrowT</source>
          <target state="translated">ArrowT</target>
        </trans-unit>
        <trans-unit id="c5b3adde056c0b01047cb4ee63a6ade2f14b6bf6" translate="yes" xml:space="preserve">
          <source>ArrowZero</source>
          <target state="translated">ArrowZero</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="c27973de6a30851ee83300e482ede863a41f7f94" translate="yes" xml:space="preserve">
          <source>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</source>
          <target state="translated">화살표는 John Hughes가 소개 한 모나드의 일반화입니다. 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="50de5e9983b77e93c151fa7abf423177ee062d7f" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 있지만, 각 단계에서의 기능 저하의 결과 엄격한.</target>
        </trans-unit>
        <trans-unit id="192565b6bc1ac3ccf6bc1023c2ebb1325b5351f9" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 있지만, 각 단계에서의 기능 저하의 결과 엄격한.</target>
        </trans-unit>
        <trans-unit id="5af372b8d1d974d76bfe10c942fe9d73af03dd9b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;, but with the structure as the primary argument. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 하지만, 기본 인수로 구조. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa8707f2ab83f8daca8094457adcacefc1dfcf09" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; are just binary operators, one might ask what happens if the datatype has more than two constructors, or a constructor with more than two fields. The answer is simple: the operators are used several times, to combine all the constructors and fields as needed. However, users /should not rely on a specific nesting strategy/ for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; being used. The compiler is free to choose any nesting it prefers. (In practice, the current implementation tries to produce a more-or-less balanced nesting, so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 는 하나의 데이터 유형이 두 개 이상의 생성자, 또는 두 개 이상의 필드가있는 생성자가 경우 발생하는 요청할 수 있습니다, 단지 이항 연산자입니다. 답은 간단합니다. 연산자는 여러 번 사용되어 필요에 따라 모든 생성자와 필드를 결합합니다. 그러나 사용자 는 사용중인 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 에 대해 특정 중첩 전략 /에 의존해서는 안됩니다 . 컴파일러는 원하는 중첩을 자유롭게 선택할 수 있습니다. (실제로, 현재 구현에서는 다소 균형 잡힌 중첩을 생성하여 루트에서 특정 구성 요소로의 데이터 유형 구조 순회를 선형 시간이 아닌 로그로 수행 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d1abb43b60664f44000bb7f5a55f0ee83b119b80" translate="yes" xml:space="preserve">
          <source>As GHC&amp;rsquo;s compilation products don&amp;rsquo;t map perfectly onto DWARF constructs, GHC takes advantage of the extensibility of the DWARF standard to provide additional information.</source>
          <target state="translated">GHC의 컴파일 제품이 DWARF 구성에 완벽하게 매핑되지 않기 때문에 GHC는 DWARF 표준의 확장 성을 활용하여 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e35067b51e094e56d5ae4f8f876dfb483b8f92fd" translate="yes" xml:space="preserve">
          <source>As a binary semaphore &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt;, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as wait and signal.</source>
          <target state="translated">이진 세마포어로서 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt; 와, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 대기 신호있다.</target>
        </trans-unit>
        <trans-unit id="86cdad137d8956982af57685ad5fdd7f0b7b6c9c" translate="yes" xml:space="preserve">
          <source>As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt;. However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</source>
          <target state="translated">의 결과로서 &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;경솔 다형 바인더 제한&lt;/a&gt; , 경솔 다형 필드 데이터 유형의 데이터 생성자에서 허용되는 사용하여 선언 &lt;code&gt;data&lt;/code&gt; . 그러나 &lt;code&gt;newtype&lt;/code&gt; 데이터 생성자 응용 프로그램은 함수 응용 프로그램 대신 강제로 구현 되므로이 제한은 &lt;code&gt;newtype&lt;/code&gt; 데이터 생성자 내부의 필드에는 적용되지 않습니다 . 따라서 유형 검사기는</target>
        </trans-unit>
        <trans-unit id="e1bbfcb820033011b427f73f5d8e7b567bf9a401" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="f93309e1645a680e5a41f639c6d8007d29bdfd58" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="80b0e3a1e8c000dc891586ccc71861ad6328cf11" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">이 법의 결과로, &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 에 대한 예 &lt;code&gt;f&lt;/code&gt; 를 만족시킬 것</target>
        </trans-unit>
        <trans-unit id="243016489dff72f5ede560d16315ebcafa404bd9" translate="yes" xml:space="preserve">
          <source>As a consequence, zero is represented with a WordArray# whose size is 0.</source>
          <target state="translated">결과적으로 0은 크기가 0 인 WordArray #으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">생성자로서</target>
        </trans-unit>
        <trans-unit id="5d801d83cd9e0b19d834377699e0695ddc3ca42e" translate="yes" xml:space="preserve">
          <source>As a constructor with record syntax</source>
          <target state="translated">레코드 구문을 가진 생성자</target>
        </trans-unit>
        <trans-unit id="495b629e3096b9e923e5d90d66fa536008c4f084" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">편의상 GHC에서는 이름이 모호하지 않은 경우 따옴표를 생략 할 수 있습니다. 그러나 우리의 경험에 따르면 따옴표는 코드를 더 읽기 쉽고 오류가 발생하지 않도록하는 데 도움이됩니다. 따라서 GHC 는 앞의 따옴표없이 승격 된 데이터 생성자를 사용하는 경우 경고 하는 &lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9189865da8d3692a10ab79cac723aaeb6eea7be7" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">편의상 GHC를 사용하면 이름이 분명 할 때 따옴표를 생략 할 수 있습니다. 그러나 우리의 경험에 따르면 따옴표는 코드를 더 쉽게 읽을 수 있고 오류가 적은 경향이 있습니다. 따라서 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt; 를 지원 하여 선행 인용 부호없이 승격 된 데이터 생성자를 사용하는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ce1486ef373f517210a834efa7f6eeb842e7f926" translate="yes" xml:space="preserve">
          <source>As a general rule, if a data type has a derived &lt;code&gt;Functor&lt;/code&gt; instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., &lt;code&gt;newtype Id a = Id a&lt;/code&gt;), or (2) occur as the last argument of a type constructor (as in &lt;code&gt;Right&lt;/code&gt; above).</source>
          <target state="translated">일반적으로 데이터 유형에 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 있고 마지막 유형 매개 변수가 데이터 선언의 오른쪽에서 발생하는 경우 (1) 베어 발생해야합니다 (예 : &lt;code&gt;newtype Id a = Id a&lt;/code&gt; ) 또는 (2)는 형식 생성자의 마지막 인수로 발생합니다 ( &lt;code&gt;Right&lt;/code&gt; 위와 같이).</target>
        </trans-unit>
        <trans-unit id="e5b650f5b24353725153d71d0ace5287fade8a17" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">Parsec 파서를 디버깅하기위한보다 포괄적 인 대안으로 &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; 패키지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="77de548b67c5a91d54fca9a27ff2e0d7ee04de4b" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">Parsec 파서를 디버깅하기위한보다 포괄적 인 대안으로 &lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsec이없는&lt;/a&gt; 패키지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="826ab8729c5c6b675ee7477d0a06b532fb5de96a" translate="yes" xml:space="preserve">
          <source>As a more substantial example of the rules in action, consider</source>
          <target state="translated">실제 규칙의보다 실질적인 예로, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8478fed6cf150b0bde8267af58280dff83b3ef83" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</source>
          <target state="translated">빠른 예로, 여기에 전달 된 인수를 인쇄 한 다음 종료되는 프론트 엔드 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="991de1e28384a51531170b3384f7afcc4d87ef71" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says &amp;lsquo;Hello&amp;rsquo;:</source>
          <target state="translated">간단한 예로, 여기에 아무것도하지 않고 수정되지 않은 원래 컴파일 파이프 라인을 반환하고 'Hello'라고하는 간단한 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85bb4cc8874a7fe78368b1f43fbe3cade8bd0615" translate="yes" xml:space="preserve">
          <source>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), &lt;em&gt;except&lt;/em&gt;&lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;, which really behave differently for the newtype and its representation.</source>
          <target state="translated">이 확장의 결과로, newtype 선언에서 파생 된 모든 인스턴스는 &lt;code&gt;Show&lt;/code&gt; 및 &lt;code&gt;Read&lt;/code&gt; 를&lt;em&gt;제외하고&lt;/em&gt; 는 newtype 및 표현에 대해 다르게 동작하는 Show 및 Read를 &lt;em&gt;제외하고&lt;/em&gt; 균일하게 처리됩니다 (그리고 표현 유형에 사전을 다시 사용하여 구현) .</target>
        </trans-unit>
        <trans-unit id="2f623b893d4cdf977b1e0a124c17974b2bd70476" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;inst_top&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;.</source>
          <target state="translated">결과적으로 &lt;code&gt;inst_top&lt;/code&gt; 은 &lt;code&gt;opt_forall&lt;/code&gt; 및 &lt;code&gt;opt_context&lt;/code&gt; 를 사용하여 모든 수량화 및 제약 조건을 앞에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="b46bedb78774bd2cc4f8ff31c4366eaf33f5bd61" translate="yes" xml:space="preserve">
          <source>As a result, it requires approximately twice as much memory as its result to construct its result. For files more than a half of available RAM in size, this may result in memory exhaustion.</source>
          <target state="translated">결과적으로 결과를 구성하려면 결과보다 약 2 배 많은 메모리가 필요합니다. 사용 가능한 RAM의 절반 이상인 파일의 경우 메모리가 소진 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23608896f360a0680014f0f847570a9754d15267" translate="yes" xml:space="preserve">
          <source>As a result, traversal with a function &lt;strong&gt;&lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt;&lt;/strong&gt;, over an input container &lt;strong&gt;&lt;code&gt;t a&lt;/code&gt;&lt;/strong&gt;, yields a list &lt;strong&gt;&lt;code&gt;[t b]&lt;/code&gt;&lt;/strong&gt;, whose length is the product of the lengths of the lists that the function returns for each element of the input container! The individual elements &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; of the container are replaced by each element of &lt;strong&gt;&lt;code&gt;f a&lt;/code&gt;&lt;/strong&gt; in turn:</source>
          <target state="translated">결과적으로 함수 &lt;strong&gt; &lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt; &lt;/strong&gt; 를 사용하여 입력 컨테이너 &lt;strong&gt; &lt;code&gt;t a&lt;/code&gt; &lt;/strong&gt; 탐색 하면 목록 &lt;strong&gt; &lt;code&gt;[t b]&lt;/code&gt; &lt;/strong&gt; 생성됩니다.이 목록 의 길이는 함수가 각 요소에 대해 반환하는 목록 길이의 곱입니다. 입력 컨테이너! 컨테이너 의 개별 요소 &lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt; 는 차례로 &lt;strong&gt; &lt;code&gt;f a&lt;/code&gt; &lt;/strong&gt; 각 요소로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e9d8d378558658c4bde3d6e6c2d01732f382a26" translate="yes" xml:space="preserve">
          <source>As a simple example of an encoding implementation, we show how to efficiently convert the following representation of mixed-data tables to an UTF-8 encoded Comma-Separated-Values (CSV) table.</source>
          <target state="translated">인코딩 구현의 간단한 예로, 다음 혼합 데이터 테이블 표현을 UTF-8로 인코딩 된 CSV (Comma-Separated-Values) 테이블로 효율적으로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca12c18463b6879d5a860720c0092cdccee7f627" translate="yes" xml:space="preserve">
          <source>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</source>
          <target state="translated">하나의 추가 제약 조건 와일드 카드로 여러 개의 제약 조건을 유추 할 수 있으므로 형식 서명에는 하나만 허용되며 제약 조건 목록에서 마지막에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="ba8ae9d2e67cab36cf8dbfe80e256d78b5863ef7" translate="yes" xml:space="preserve">
          <source>As a workaround, we allow to bind &lt;code&gt;(*)&lt;/code&gt; in prefix form:</source>
          <target state="translated">이 문제를 해결하기 위해 접두사 형식으로 &lt;code&gt;(*)&lt;/code&gt; 를 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b52875799ff2828c6eeb24db51f51ce6b5d35654" translate="yes" xml:space="preserve">
          <source>As always, for RTS options that take ⟨size⟩s: If the last character of ⟨size⟩ is a K or k, multiply by 1000; if an M or m, by 1,000,000; if a G or G, by 1,000,000,000. (And any wraparound in the counters is &lt;em&gt;your&lt;/em&gt; fault!)</source>
          <target state="translated">항상 그렇듯이 ⟨size⟩를 취하는 RTS 옵션의 경우 : ⟨size⟩의 마지막 문자가 K 또는 k이면 1000을 곱하십시오. M 또는 m 인 경우 1,000,000; G 또는 G 인 경우 1,000,000,000 (그리고 카운터의 모든 랩 어라운드는 &lt;em&gt;당신의&lt;/em&gt; 잘못입니다!)</target>
        </trans-unit>
        <trans-unit id="99567f4b6e834794323885b782256cd2c328ea5e" translate="yes" xml:space="preserve">
          <source>As always, type synonyms must be fully applied. You cannot, for example, write:</source>
          <target state="translated">항상 그렇듯이 유형 동의어를 완전히 적용해야합니다. 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="13c3594421b98bd2bf10cd954eb77cee53d78c7c" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AS를 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를가 아니 어서 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 는 에서 처리 오류 무시 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 모나드에 의해 차단 될 수 없습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 으로부터 &lt;a href=&quot;prelude&quot;&gt;서곡&lt;/a&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 이며 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 함수를 사용하여 잡을 수 있습니다 . 즉 , &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 추가 된 정리 계산 도 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 에서 제대로 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a64b93c54367f32283d34b8466c83c540d04226" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AS를 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를가 아니 어서 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 는 에서 처리 오류 무시 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 모나드에 의해 차단 될 수 없습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 으로부터 &lt;a href=&quot;prelude&quot;&gt;서곡&lt;/a&gt; . 그러나 이것은 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 이며 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 함수를 사용하여 잡을 수 있습니다 . 이는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;control-exception&quot;&gt;Control.Exception에서&lt;/a&gt; )로 추가 된 정리 계산 도 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 에서 올바르게 실행 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="39edd1cc6e94c784b4f7e11ad121c08ce0f9db79" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AS를 &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를가 아니 어서 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 는 에서 처리 오류 무시 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 모나드에 의해 차단 될 수 없습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 으로부터 &lt;a href=&quot;prelude&quot;&gt;서곡&lt;/a&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 이며 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 함수를 사용하여 잡을 수 있습니다 . 즉 , &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 추가 된 정리 계산 도 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 에서 제대로 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a4cafca22cd8d1a307b13e29242f4d26666e5a9" translate="yes" xml:space="preserve">
          <source>As an example of signaling an error in the error monad &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, consider a safe division function &lt;code&gt;safeDiv x y&lt;/code&gt; that returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the denominator &lt;code&gt;y&lt;/code&gt; is zero and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div`
 y)&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">오류에 오류 신호의 예 모나드으로 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , 안전한 분할 기능을 고려 &lt;code&gt;safeDiv x y&lt;/code&gt; 반환이 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 분모 때 &lt;code&gt;y&lt;/code&gt; 는 0이고 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div` y)&lt;/code&gt; 그렇지. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c06e5fe5eaba60d194f35398d388c5324d3e8468" translate="yes" xml:space="preserve">
          <source>As an example which does &lt;em&gt;not&lt;/em&gt; work, consider</source>
          <target state="translated">작동 하지 &lt;em&gt;않는&lt;/em&gt; 예로서 , 고려하십시오</target>
        </trans-unit>
        <trans-unit id="6347b158715a28dac26c8c73ed1a2953999b56f9" translate="yes" xml:space="preserve">
          <source>As an example, consider a simple pretty-printer class &lt;code&gt;SPretty&lt;/code&gt;, which outputs pretty strings:</source>
          <target state="translated">예를 들어, 예쁜 문자열을 출력 하는 간단한 pretty-printer 클래스 &lt;code&gt;SPretty&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="522dfa47c182924ecba88bb21606211e4b6f02fd" translate="yes" xml:space="preserve">
          <source>As an example, consider the following pipeline:</source>
          <target state="translated">예를 들어 다음 파이프 라인을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="42d246ca4c667eae440bdea085741dec65a2d440" translate="yes" xml:space="preserve">
          <source>As an example, consider the type of predicate functions &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt;. One such predicate might be &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt;, which classifies integers as to whether they are negative. However, given this predicate, we can re-use it in other situations, providing we have a way to map values &lt;em&gt;to&lt;/em&gt; integers. For instance, we can use the &lt;code&gt;negative&lt;/code&gt; predicate on a person's bank balance to work out if they are currently overdrawn:</source>
          <target state="translated">예를 들어, 술어 기능의 유형을 고려 &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; . 이러한 술어 중 하나는 &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt; 일 수 있으며, 음의 여부에 따라 정수를 분류합니다. 그러나이 술어가 주어지면 다른 상황에서 재사용하여 값 &lt;em&gt;을&lt;/em&gt; 정수 로 맵핑 할 수 있습니다 . 예를 들어, 은행 잔고에 &lt;code&gt;negative&lt;/code&gt; 술어를 사용하여 현재 초과 인출 된 경우이를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c76375fc08b8bec18373864d63325042996901b" translate="yes" xml:space="preserve">
          <source>As an example, in order to load the plugin exported by &lt;code&gt;Foo.Plugin&lt;/code&gt; in the package &lt;code&gt;foo-ghc-plugin&lt;/code&gt;, and give it the parameter &amp;ldquo;baz&amp;rdquo;, we would invoke GHC like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;Foo.Plugin&lt;/code&gt; 에서 내 보낸 플러그인을 &lt;code&gt;foo-ghc-plugin&lt;/code&gt; 패키지 에로드하고 &amp;ldquo;baz&amp;rdquo;파라미터를 지정하려면 다음과 같이 GHC를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="362dc967d86ad4ea9a7d9c73fea6acc2cbd89dbf" translate="yes" xml:space="preserve">
          <source>As an example, let us look at a function &lt;code&gt;encode&lt;/code&gt; that produces a naive, but lossless bit encoding of values of various datatypes. So we are aiming to define a function</source>
          <target state="translated">예를 들어, 다양한 데이터 유형의 값에 대한 순진하지만 무손실 비트 인코딩을 생성하는 함수 &lt;code&gt;encode&lt;/code&gt; 을 살펴 보겠습니다 . 함수 정의를 목표로하고 있습니다</target>
        </trans-unit>
        <trans-unit id="33852151126c630432f1fdab8e0ba978ca5481a5" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted &lt;code&gt;IO&lt;/code&gt; monad that we have defined. The restricted &lt;code&gt;IO&lt;/code&gt; monad will only allow a safe subset of &lt;code&gt;IO&lt;/code&gt; actions to be executed. We define the plugin interface so that it requires the plugin module, &lt;code&gt;Danger&lt;/code&gt;, to export a single computation, &lt;code&gt;Danger.runMe&lt;/code&gt;, of type &lt;code&gt;RIO ()&lt;/code&gt;, where &lt;code&gt;RIO&lt;/code&gt; is a monad defined as follows:</source>
          <target state="translated">예를 들어, 플러그인 작성자를 신뢰할 수없는 플러그인 시스템 (악의적 인 타사)에 대한 인터페이스를 정의 해 보겠습니다. 플러그인 인터페이스를 순수 함수 또는 정의한 제한된 &lt;code&gt;IO&lt;/code&gt; 모나드 로 제한하여이를 수행합니다 . 제한된 &lt;code&gt;IO&lt;/code&gt; 모나드는 안전한 &lt;code&gt;IO&lt;/code&gt; 작업 하위 집합 만 실행할 수 있습니다. 플러그인 인터페이스 인 &lt;code&gt;Danger&lt;/code&gt; 가 &lt;code&gt;RIO ()&lt;/code&gt; 유형 의 단일 계산 &lt;code&gt;Danger.runMe&lt;/code&gt; 를 내보내 려면 플러그인 인터페이스를 정의합니다 . 여기서 &lt;code&gt;RIO&lt;/code&gt; 는 다음과 같이 정의 된 모나드입니다.</target>
        </trans-unit>
        <trans-unit id="70582809de8cd9e89c6a9bd154c02621c8e3fe1c" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have following special printing module:</source>
          <target state="translated">예를 들어 다음과 같은 특수 인쇄 모듈이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6adf45b29a6631ff6d424f3a35e51b0c62f84184" translate="yes" xml:space="preserve">
          <source>As an example, suppose you read a large string, of which you need only a small portion. If you do not use &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt;, the entire original array will be kept alive in memory by the smaller string. Making a copy &quot;breaks the link&quot; to the original array, allowing it to be garbage collected if there are no other live references to it.</source>
          <target state="translated">예를 들어, 큰 문자열을 읽는데 그 중 작은 부분 만 필요하다고 가정하십시오. &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt; 를 사용하지 않으면 전체 원본 배열이 더 작은 문자열로 메모리에 유지됩니다. 복사본을 만들면 원래 배열에 대한 &quot;링크가 끊어지고&quot;다른 실제 참조가없는 경우 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63ea3a1b75b9abed859b37118efd2bdfeda9979" translate="yes" xml:space="preserve">
          <source>As an example, this data declaration:</source>
          <target state="translated">예를 들어이 데이터 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="490082850527086dedfac3775659ee1738c0ae5d" translate="yes" xml:space="preserve">
          <source>As another example, this is the layout for the unboxed version of &lt;code&gt;Maybe a&lt;/code&gt; type, &lt;code&gt;(# (# #) | a #)&lt;/code&gt;:</source>
          <target state="translated">또 다른 예로, 이것은 박스형 버전의 &lt;code&gt;Maybe a&lt;/code&gt; 유형 &lt;code&gt;(# (# #) | a #)&lt;/code&gt; 의 레이아웃입니다 .</target>
        </trans-unit>
        <trans-unit id="18151bc795d27e140f421a3a96b2c553b0826f0d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">또 다른 예로서, 우리는 유형 고려할 수있는 &lt;code&gt;Set a&lt;/code&gt; 에 따라 데이터의 집합을 나타냅니다을 주문 의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스입니다. 그것은 일반적으로 형태 보증 고려해야 할 것 동안 &lt;code&gt;a&lt;/code&gt; 역할 구상에있는 것으로, 가능성이 &lt;code&gt;newtype&lt;/code&gt; 은 하고 그것의 기본 유형이 &lt;em&gt;서로 다른&lt;/em&gt; 각각의 인코딩 된 순서, &lt;code&gt;Ord&lt;/code&gt; 인스턴스를. 이로 인해 런타임시 오작동이 발생할 수 있습니다. 따라서 &lt;code&gt;Set&lt;/code&gt; 데이터 유형 의 작성자는 해당 매개 변수가 역할 명목에 있기를 원합니다. 이것은 선언으로 이루어집니다 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e081e131ffbc4e13afc7b95b1192b51f216cb4d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">또 다른 예로서, 우리는 유형 고려할 수있는 &lt;code&gt;Set a&lt;/code&gt; 에 따라 데이터의 집합을 나타냅니다을 주문 의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스입니다. 일반적으로 &lt;code&gt;a&lt;/code&gt; 를 역할 표현 으로 간주 하는 것이 형식에 안전 하지만, &lt;code&gt;newtype&lt;/code&gt; 과 기본 형식이 각각의 &lt;code&gt;Ord&lt;/code&gt; 인스턴스 에서 인코딩 된 &lt;em&gt;다른&lt;/em&gt; 순서를 가질 수 있습니다 . 이로 인해 런타임에 오작동이 발생할 수 있습니다. 따라서 &lt;code&gt;Set&lt;/code&gt; 데이터 유형 의 작성자 는 매개 변수가 역할 명목이되기를 원합니다. 이것은 선언으로 수행됩니다. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971f3c8e7fa04aa11b176990e12b0d8a905825b5" translate="yes" xml:space="preserve">
          <source>As before, only one selector function is generated here, that for &lt;code&gt;tag&lt;/code&gt;. Nevertheless, you can still use all the field names in pattern matching and record construction.</source>
          <target state="translated">이전과 마찬가지로 여기에는 &lt;code&gt;tag&lt;/code&gt; 에 대한 선택기 함수가 하나만 생성됩니다 . 그럼에도 불구하고 패턴 일치 및 레코드 구성에서 모든 필드 이름을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa864a2dee7d7cdb239046ddc338c3e2554307a5" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;base&lt;/code&gt; package. &lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt;&lt;code&gt;-flink-rts&lt;/code&gt;&lt;/a&gt; additionally links against the shared library version of the &lt;code&gt;rts&lt;/code&gt; package (linking against the &lt;code&gt;rts&lt;/code&gt; package is not enabled by default when building shared libraries). You may also omit &lt;code&gt;-flink-rts&lt;/code&gt; and link the RTS library into your final executable.</source>
          <target state="translated">이전과 마찬가지로 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그는이 라이브러리가 &lt;code&gt;base&lt;/code&gt; 패키지 의 공유 라이브러리 버전에 대해 링크되도록 지정 합니다. &lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt; &lt;code&gt;-flink-rts&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;rts&lt;/code&gt; 패키지 의 공유 라이브러리 버전에 추가로 링크 합니다 ( 공유 라이브러리를 빌드 할 때 &lt;code&gt;rts&lt;/code&gt; 패키지 에 대한 링크는 기본적으로 활성화되지 않음). &lt;code&gt;-flink-rts&lt;/code&gt; 를 생략 하고 RTS 라이브러리를 최종 실행 파일에 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b294469f3600688f3c16a9375ab450bd92e329f" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;rts&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; package. The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">이전과 같이 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그는이 라이브러리가 &lt;code&gt;rts&lt;/code&gt; 및 &lt;code&gt;base&lt;/code&gt; 패키지 의 공유 라이브러리 버전과 링크되도록 지정 합니다. &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 플래그는 공유 라이브러리에 결국 모든 코드가 필요합니다. &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 플래그를 지정하는 공유 라이브러리가 아닌 프로그램을 확인합니다. 이를 명확하게하기 위해이를 별도의 컴파일 및 링크 단계로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7075fa9b7f0c6ece6ef586ef8232718a3c4e1adf" translate="yes" xml:space="preserve">
          <source>As channels, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as receive and send, and</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신 및 전송으로 하여 채널 로</target>
        </trans-unit>
        <trans-unit id="5f8a308216057de51dc8e2d87492c599832235ef" translate="yes" xml:space="preserve">
          <source>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-x ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">위에서 설명한 것처럼 GHC에서 파일을 처리하는 방법은 접미사에 따라 다릅니다. 이 동작은 &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-x ⟨suffix⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac41a6f7a2ba794206a1881f72e83bfc76ecc4c5" translate="yes" xml:space="preserve">
          <source>As discussed earlier, use &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to disambiguate GHC flags when needed. For example, &lt;code&gt;-f&lt;/code&gt; is recognized by runghc, therefore to pass &lt;code&gt;-fliberate-case&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">앞에서 설명한대로 &lt;code&gt;--&lt;/code&gt; 또는 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 를 사용하여 필요할 때 GHC 플래그를 명확하게하십시오. 예를 들어, &lt;code&gt;-f&lt;/code&gt; 는 runghc에 의해 인식되므로 &lt;code&gt;-fliberate-case&lt;/code&gt; 를 GHC 에 전달 하려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="67cc7c655699a8e4a2e0b555a8afa1e30261d029" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수에 대해이 함수는 부분 문자열을 복사하지 않고 원본의 조각 인 새 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8991e65b25a1268c5578c175657da1832d9cb512" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수에 대해이 함수는 부분 문자열을 복사하지 않고 원본의 조각 인 새 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="78cc6104aca9fb1ec54052832ddebd0c39befee4" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수에 대해이 함수는 부분 문자열을 복사하지 않고 원본의 조각 인 새 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="47a4bb98e7bde318e0428ee9df25a1247392901b" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수에 대해이 함수는 부분 문자열을 복사하지 않고 원본의 조각 인 새 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="fe90224af19846dad1a17ef9f898f327403d732c" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;ByteStrings&lt;/code&gt; that are slices of the original.</source>
          <target state="translated">이 라이브러리의 모든 분할 함수와 관련하여이 함수는 하위 문자열을 복사하지 않고 원본 조각 인 새 &lt;code&gt;ByteStrings&lt;/code&gt; 을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="66418d326af7c7178dbcf345c383fa758cb34200" translate="yes" xml:space="preserve">
          <source>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</source>
          <target state="translated">타입 시그니처의 경우, 오버로드되지 않은 타입에 대해서도 암시 적 정량이 발생합니다. 따라서 이것을 쓰면 :</target>
        </trans-unit>
        <trans-unit id="131c4ed80f84ad7adaad005b0b251d5561f2e9bd" translate="yes" xml:space="preserve">
          <source>As iconv is missing in some minimal environments (e.g. #10298), this checks to ensure that iconv is working properly before returning the encoding, returning &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">일부 최소 환경 (예 : # 10298)에서는 iconv가 누락되므로 인코딩을 반환하기 전에 iconv가 제대로 작동하는지 확인하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a094fb6c3fac4ea42a5b01e068a43a07a1612b8" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#define&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">적절한 &lt;code&gt;#define&lt;/code&gt; 지시문이 소스에있는 것처럼 .</target>
        </trans-unit>
        <trans-unit id="0b3a2a9b0861349d1000eb5c63f5fe83939ea7af" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#include&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">적절한 &lt;code&gt;#include&lt;/code&gt; 지시문이 소스에있는 것처럼 .</target>
        </trans-unit>
        <trans-unit id="beaf430a25d7c8a7463fc714eeb5bef652c1ca18" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt; 의 FFI는 실제로 필요하지 않습니다. &lt;code&gt;GHC.Exts&lt;/code&gt; 에는 &lt;code&gt;ArrayArray#&lt;/code&gt; 에서 읽기위한 프리미티브가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="098c067155c3928cc8e309c0b70434dda18ac150" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;[2]&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;[2]&lt;/a&gt; 상기 FFI은 실제로 필요하지 않다. &lt;code&gt;GHC.Exts&lt;/code&gt; 에는 &lt;code&gt;ArrayArray#&lt;/code&gt; 에서 읽기위한 프리미티브가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3704be0b1f85ea495e4739ed1a37ef32e604634f" translate="yes" xml:space="preserve">
          <source>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of &amp;ldquo;acyclic&amp;rdquo; involves only the superclass relationships. For example, this is okay:</source>
          <target state="translated">Haskell 98에서와 같이 클래스 계층 구조는 비 주기적이어야합니다. 그러나 &quot;비순환&quot;의 정의에는 수퍼 클래스 관계 만 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a18ecf9c948be4e27d139d19b812430b86052cfe" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">Haskell-98과 유사한 레코드 구문 ( &lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt; )을 사용하여 선언 된 실존의 경우와 같이 레코드 선택기 함수는 형식이 잘 지정된 선택기가있는 필드에 대해서만 생성됩니다. 다음은 GADT 스타일 구문에서 해당 섹션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="92ba8fd84c6bd0e839142f8b7eca6e02c9f392cc" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">Haskell-98과 유사한 레코드 구문 ( &lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt; )을 사용하여 선언 된 존재의 경우처럼 레코드 선택기 함수는 올바른 유형의 선택기가있는 필드에 대해서만 생성됩니다. 다음은 GADT 스타일 구문으로 된 해당 섹션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e3cd19795acf719bdbdadfeb240558bb97933bfa" translate="yes" xml:space="preserve">
          <source>As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</source>
          <target state="translated">종류와 유형이 동일하기 때문에 종류 에는 유형 제약 조건이 포함될 수 있습니다 ( &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; 사용&lt;/a&gt; ). 그러나 동일 제약 조건 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b688c040bfb0b19971fb0ce773edf49cba5c5c6c" translate="yes" xml:space="preserve">
          <source>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</source>
          <target state="translated">유형 변수가 이러한 클래스 중 하나에 의해 제한되는 한, 위에서 설명한대로 기본값이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44161a74606a6af43d39c349f3c26f8c14875c50" translate="yes" xml:space="preserve">
          <source>As long as you are happy to only be able to link to the DLL using &lt;code&gt;GetProcAddress&lt;/code&gt; and friends, you can supply the &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt;&lt;code&gt;-fno-shared-implib&lt;/code&gt;&lt;/a&gt; flag to disable the creation of the import library entirely.</source>
          <target state="translated">&lt;code&gt;GetProcAddress&lt;/code&gt; 및 friends를 사용하여 DLL에만 링크 할 수 있으면 가져 오기 라이브러리 작성을 완전히 사용하지 않도록 &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt; &lt;code&gt;-fno-shared-implib&lt;/code&gt; &lt;/a&gt; 플래그를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e315249f68fda8aaff176e296d66a05a6132ca0" translate="yes" xml:space="preserve">
          <source>As mapFile, but returns ByteString</source>
          <target state="translated">mapFile과 같지만 ByteString을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a545221512e878619258ca5f17df48cfac240523" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e1afd64bce824d5669c2abf1ae7f5ca39a54331" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a668f275f9aa656c990c93f68c69e117d56a6a9" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">위에서 언급 한 바와 같이, 파생 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; GHC의 인스턴스를 구현합니다 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (및 그 사촌 인 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ) 의 기본 구현 은 단순히 후드 아래에서 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 를 사용 합니다. 직접 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하는 경우 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f65b46df8fe6c264c596a4ee57c977d2fcd44935" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">&lt;a href=&quot;#gadt-style&quot;&gt;명시 적 생성자 서명으로 데이터 유형 선언&lt;/a&gt; 에서 언급 한대로 레코드 구문이 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f2d8d704ce406fdcf65da6dff1ef0084db00f7c" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;명시 적 생성자 서명을 사용하여 데이터 유형 선언&lt;/a&gt; 에서 언급했듯이 레코드 구문이 지원됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="180500d2c123f41ae24d4c741a0e7e11617119d4" translate="yes" xml:space="preserve">
          <source>As observed in the &lt;a href=&quot;#leftright&quot;&gt;above description&lt;/a&gt; of left and right folds, there are three general ways in which a structure can be reduced to a summary value:</source>
          <target state="translated">&lt;a href=&quot;#leftright&quot;&gt;위&lt;/a&gt; 의 왼쪽 및 오른쪽 접기 설명 에서 볼 수 있듯이 구조를 요약 값으로 축소 할 수있는 세 가지 일반적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b20aa3bf540201cc843068062611e2c68e78f44" translate="yes" xml:space="preserve">
          <source>As of 1.3.5.0, the environment variable is ignored if set to a relative path, per revised XDG Base Directory Specification. See &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;#100&lt;/a&gt;.</source>
          <target state="translated">1.3.5.0부터 수정 된 XDG 기본 디렉토리 사양에 따라 상대 경로로 설정하면 환경 변수가 무시됩니다. &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;# 100&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="66155d480946b24160dbc04cb1009ec185e9eb15" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d54fac1ed5477bc40ff0f48a11003303f605712" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68bb1e4d347f7e14f0730566cfe86c41cf0cf621" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; 는 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431c3d0f7612a40f6ff5eb1278e282741242a19d" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; 는 로 대체되었습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="165ec2af84cd6d6f877d1e69014b6333343144ea" translate="yes" xml:space="preserve">
          <source>As of GHC 8.0.1 you may also &amp;ldquo;bundle&amp;rdquo; pattern synonyms with an exported type constructor, making that pattern appear as a data constructor of that type. To bundle a pattern synonym, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">GHC 8.0.1부터는 내 보낸 유형 생성자와 패턴 동의어를 &quot;번들&quot;하여 해당 패턴이 해당 유형의 데이터 생성자로 표시되도록 할 수도 있습니다. 패턴 동의어를 묶기 위해 형식 생성자를 내보내는 모듈의 내보내기 목록에 패턴 동의어를 나열합니다. 예를 들어 &lt;code&gt;Zero&lt;/code&gt; 를 &lt;code&gt;MyNum&lt;/code&gt; 과 번들 로 묶기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff725c4e2000e4c32e7a70322b85a55a85f4f248" translate="yes" xml:space="preserve">
          <source>As of GHC version 6.8, we have adopted the following policy for numbering GHC versions:</source>
          <target state="translated">GHC 버전 6.8부터 GHC 버전 번호 지정에 다음 정책을 채택했습니다.</target>
        </trans-unit>
        <trans-unit id="6667e67a30d7295682c9410cb1e7f0f855d9f77a" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189b02d51b70039f2bb98397c33331f99f38f72e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="3ffe502c088313295fc8544881ef2e7de642be25" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="4755017eb545075e257326e642258214d89957c4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be1d09e17e8e02c7031393483495ad5d61f69b4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="7f37649ade650085aa0f65cecdda074623b0b69e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="995d3e4e58500aa9b1bd3701177a6dbe6d9b1cb8" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">4.8.0.0 기준으로 &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="0137e920b69fe62239fad821757f41940234bff2" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0부터 &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 특화된 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="63452b7c7f465acb4dded12e10643c0a80c59e1c" translate="yes" xml:space="preserve">
          <source>As of bytestring 0.9.0.3, this function is stricter than its list cousin.</source>
          <target state="translated">바이트 문자열 0.9.0.3부터이 함수는 목록 사촌보다 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="039bbe9675865514fb60ebed364f1df32b98df77" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; data structures, which have one variety of element on which an action can be performed, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; data structures have two such varieties of elements.</source>
          <target state="translated">반대로 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 동작을 수행 할 수있는 다양한 요소 중 하나가 데이터 구조, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 데이터 구조는 그러한 요소의 두 종류가있다.</target>
        </trans-unit>
        <trans-unit id="1ae607bddf78967e412e95f44ed5f98b62257887" translate="yes" xml:space="preserve">
          <source>As part of the same extension, you can put kind annotations in types as well. Thus:</source>
          <target state="translated">동일한 확장의 일부로 종류에 주석을 넣을 수도 있습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="7699c90ab29019673b3fd8db1b1767ae9771115b" translate="yes" xml:space="preserve">
          <source>As soon as GHC plus its &amp;ldquo;fellow citizens&amp;rdquo; (other processes on your machine) start using more than the &lt;em&gt;real memory&lt;/em&gt; on your machine, and the machine starts &amp;ldquo;thrashing,&amp;rdquo; &lt;em&gt;the party is over&lt;/em&gt;. Compile times will be worse than terrible! Use something like the csh builtin &lt;strong&gt;time&lt;/strong&gt; command to get a report on how many page faults you&amp;rsquo;re getting.</source>
          <target state="translated">GHC와 &quot; &lt;em&gt;중요한&lt;/em&gt; 시민&quot;(시스템의 다른 프로세스)이 시스템의 &lt;em&gt;실제 메모리&lt;/em&gt; 보다 더 많은 &lt;em&gt;메모리&lt;/em&gt; 를 사용하기 시작하면 시스템이 &quot;스 래싱&quot;을 시작 &lt;em&gt;하면 파티는 끝납니다&lt;/em&gt; . 컴파일 시간이 끔찍한 것보다 나빠질 것입니다! csh builtin &lt;strong&gt;time&lt;/strong&gt; 명령 과 같은 것을 사용하여 페이지 결함 수에 대한 보고서를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="5c65dae701ef99ffffbad1ccc118a5d026621cac" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;purePlugin&lt;/code&gt; is defined as a function which always returns &lt;code&gt;NoForceRecompile&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;purePlugin&lt;/code&gt; 은 항상 &lt;code&gt;NoForceRecompile&lt;/code&gt; 을 리턴하는 함수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="83c27882ec4f84c2b1c7547fee6d29bef6299680" translate="yes" xml:space="preserve">
          <source>As synchronized mutable variables,</source>
          <target state="translated">동기화 된 가변 변수로서</target>
        </trans-unit>
        <trans-unit id="8c68344402c4c848cd9948b1b997a6cdee8b6472" translate="yes" xml:space="preserve">
          <source>As text to standard output, for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 텍스트를 표준 출력으로.</target>
        </trans-unit>
        <trans-unit id="181b02f4903ccd97fffcaf58addb10482aefc450" translate="yes" xml:space="preserve">
          <source>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; above would be valid field type signatures.</source>
          <target state="translated">데이터 형식 선언에서 생성자 또는 필드 형식의 인수로 사용됩니다. 예를 들어, 위의 &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; 는 유효한 필드 유형 서명입니다.</target>
        </trans-unit>
        <trans-unit id="2c75efee694fce1348012a0f71a5ff8152fe1dea" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">의 이중으로 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;noneOf cs&lt;/code&gt; 성공하면 현재의 문자 &lt;em&gt;없는&lt;/em&gt; 문자의 제공된 목록에서 &lt;code&gt;cs&lt;/code&gt; . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ccb0b2bddb73f4bc8b6273e372d5253cba90fe8b" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">의 이중으로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;noneOf cs&lt;/code&gt; 성공하면 현재의 문자 &lt;em&gt;없는&lt;/em&gt; 문자의 제공된 목록에서 &lt;code&gt;cs&lt;/code&gt; . 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="595d79d9d63a7ad5c2be3b061e3dc58b00a5d260" translate="yes" xml:space="preserve">
          <source>As the type of an implicit parameter</source>
          <target state="translated">암시 적 매개 변수의 유형으로</target>
        </trans-unit>
        <trans-unit id="d153cbf6806b7b35bd0413a66f8a99b8d11cec38" translate="yes" xml:space="preserve">
          <source>As this suggests, each occurrence is replaced exactly once. So if &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;replacement&lt;/code&gt;, that occurrence will &lt;em&gt;not&lt;/em&gt; itself be replaced recursively:</source>
          <target state="translated">이것이 암시 하듯이, 각 발생은 정확히 한 번 대체됩니다. 따라서 &lt;code&gt;needle&lt;/code&gt; 이 &lt;code&gt;replacement&lt;/code&gt; 에서 발생하면 해당 발생 자체는 재귀 적으로 대체 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e53867775e4428028623be9fceee714ed0171be0" translate="yes" xml:space="preserve">
          <source>As usual, for every constructor that has a field &lt;code&gt;f&lt;/code&gt;, the type of field &lt;code&gt;f&lt;/code&gt; must be the same (modulo alpha conversion). The &lt;code&gt;Child&lt;/code&gt; constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the &amp;ldquo;type&amp;rdquo; that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A &amp;ldquo;type&amp;rdquo; of this form can appear only in a constructor signature.)</source>
          <target state="translated">통상, 전계가있는 모든 생성자 &lt;code&gt;f&lt;/code&gt; , 필드의 타입 &lt;code&gt;f&lt;/code&gt; 동일해야한다 (알파 변환 모듈로). 위 의 &lt;code&gt;Child&lt;/code&gt; 생성자는 서명이 레코드가 아닌 경우와 마찬가지로 컨텍스트, 실질적으로 수량화 된 변수 및 엄격 주석을 가질 수 있음을 보여줍니다. (NB : 이중 콜론 뒤에 오는 &quot;유형&quot;은 레코드 구문 및 엄격 주석으로 인해 실제로 유형이 아닙니다.이 형식의 &quot;유형&quot;은 생성자 서명에만 나타날 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="424c7f952d5ac1aa74645c5f27a67eda13f56e6f" translate="yes" xml:space="preserve">
          <source>As usual, the meta-variables &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc., can be arbitrary patterns. In general, the statement &lt;code&gt;rec ss&lt;/code&gt; is desugared to the statement</source>
          <target state="translated">통상적으로, 메타-변수 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 등은 임의의 패턴 일 수있다. 일반적으로, 진술서 &lt;code&gt;rec ss&lt;/code&gt; 는 진술서 로 탈당됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf1bb90d2a6c5267034d92cb3db4ce82d1bfdff" translate="yes" xml:space="preserve">
          <source>As we demonstrated earlier (&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt;), the debugger has some intelligence built-in to update the type of &lt;code&gt;f&lt;/code&gt; whenever the types of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;_result&lt;/code&gt; are discovered. So what we do in this scenario is force &lt;code&gt;x&lt;/code&gt; a bit, in order to recover both its type and the argument part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">앞에서 설명한 것처럼 ( &lt;a href=&quot;#breakpoints&quot;&gt;브레이크 포인트 및 변수 검사&lt;/a&gt; ) 디버거에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;_result&lt;/code&gt; 유형 이 검색 될 때마다 &lt;code&gt;f&lt;/code&gt; 유형을 업데이트하기위한 일부 지능 기능이 내장 되어 있습니다 . 따라서이 시나리오에서 우리가하는 일은 그것의 타입과 &lt;code&gt;f&lt;/code&gt; 의 인수 부분을 모두 복구하기 위해 &lt;code&gt;x&lt;/code&gt; 를 조금씩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="480449ae21e88b5153c176f83519328d5843ab58" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the &lt;code&gt;ArrowPlus&lt;/code&gt; class includes a combinator</source>
          <target state="translated">보시다시피, 화살표 표기법은 식, 시퀀싱, 값 재귀 및 조건에 대한 구문을 모델링 한 구문을 제공합니다. 그러나 일반적인 Haskell에서 정의 할 수있는 적절한 결합기를 사용하여 기존 명령으로 새 명령을 작성할 수도 있습니다. 기본 아이디어는 명령이 환경에서 값으로 화살표를 정의한다는 것입니다. 이러한 환경은 명령의 사용 가능한 로컬 변수에 값을 지정합니다. 따라서, 화살표로부터 화살표를 생성하는 콤비 네이터는 또한 커맨드로부터 커맨드를 구축하는데 사용될 수있다. 예를 들어 &lt;code&gt;ArrowPlus&lt;/code&gt; 클래스에는 결합기가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cabbc3d4e2b43e627bd00b9475f0bf29950d8f" translate="yes" xml:space="preserve">
          <source>As well as in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">형식 시그니처뿐만 아니라 인스턴스 선언에서 명시 적 &lt;code&gt;forall&lt;/code&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="196191205f2b62c541cf8a5ff3836b4bc01787da" translate="yes" xml:space="preserve">
          <source>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</source>
          <target state="translated">불필요한 패턴 일치를 피할뿐만 아니라 불필요한 할당을 피할 수 있습니다. 이는 재귀 호출 자체에서 인수가 엄격하지만 초기 항목이 아닌 경우에 적용됩니다. 함수의 엄격한 재귀 분기가 위의 예제와 유사하게 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8c16e4471532afea529c20b4ff2e8a8a16601be0" translate="yes" xml:space="preserve">
          <source>As well in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">타입 시그니처에서도 인스턴스 선언에 명시 적 &lt;code&gt;forall&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ead26c4f8d8b65c7691881f1d8045e494c57debb" translate="yes" xml:space="preserve">
          <source>As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</source>
          <target state="translated">모든 알려진 Haskell 시스템과 마찬가지로 GHC는 표준 Haskell 언어에 대한 일부 확장을 구현합니다. 이들은 모두 명령 행 플래그 또는 언어 pragma에 의해 활성화 또는 비활성화 될 수 있습니다. 기본적으로 GHC는 최신 Haskell 버전과 소수의 확장을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="fcd43e9a7f0adbd4e1cdcb63a469dbf86f84b840" translate="yes" xml:space="preserve">
          <source>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there&amp;rsquo;s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</source>
          <target state="translated">일반 변수 바인딩과 마찬가지로 이후 정의는 이전 정의를 어둡게하므로 선언을 다시 입력하여 문제를 해결하거나 확장 할 수 있습니다. 그러나 새로운 유형 선언이 이전 유형을 가리면 이전 유형을 참조하는 다른 선언이있을 수 있습니다. 기억해야 할 것은 이전 유형이 여전히 존재하고 이러한 다른 선언은 여전히 ​​이전 유형을 참조한다는 것입니다. 그러나 이전 유형과 새 유형의 이름은 동일하지만 GHCi는 해당 유형을 고유 한 것으로 취급합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="637fa52fc6437e00230d9db2fe6b3adca8d89276" translate="yes" xml:space="preserve">
          <source>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;:</source>
          <target state="translated">다른 유형 서명과 마찬가지로 여러 데이터 생성자에 단일 서명을 제공 할 수 있습니다. 이 예에서는 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 에 대한 단일 서명을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9a5d0276624512bf5b98fc03c361aa6bea31b80c" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; function, if any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 함수 와 마찬가지로 목록의 두 연관이 동일한 색인을 갖는 경우 해당 색인의 값은 구현에 따라 다릅니다. GHC에서는 해당 인덱스에 대해 지정된 마지막 값이 사용됩니다. 다른 구현에서도 언 박스형 배열에 대해서도이 작업을 수행하지만 Haskell 98에서는 &lt;code&gt;Array&lt;/code&gt; 에 대해 해당 인덱스의 값이 맨 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="290e57760e517898d7b9efcc098bc5d22f645f5f" translate="yes" xml:space="preserve">
          <source>As you can guess &lt;code&gt;justOnes&lt;/code&gt; will evaluate to &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt;.</source>
          <target state="translated">당신이 추측 할 수 있듯이 &lt;code&gt;justOnes&lt;/code&gt; 는 &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="44e503436bbd1b51c2f4671a6a4bc6e7cfdbb40d" translate="yes" xml:space="preserve">
          <source>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</source>
          <target state="translated">보시다시피, 이런 식으로 연산자를 사용하는 것은 그리 유용하지 않으며 Haskell 98은 심지어 연산자를 삽입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b751c77c03006544a696243e4f9983a43fa624e" translate="yes" xml:space="preserve">
          <source>As-patterns must not be surrounded by whitespace on either side:</source>
          <target state="translated">As-pattern은 양쪽의 공백으로 둘러싸여서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="67dc44d97f00c988807bcf67aa9d1c8f84fff7c6" translate="yes" xml:space="preserve">
          <source>Ascii Drawings</source>
          <target state="translated">아스키 그림</target>
        </trans-unit>
        <trans-unit id="cca21e0df87aca3b913734b67e2e333b718bae99" translate="yes" xml:space="preserve">
          <source>Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</source>
          <target state="translated">애슐리 야 켈리 &amp;lt;ashley@semantic.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7f327535400c99b415e9d1ddaa6d9904d1bfafa2" translate="yes" xml:space="preserve">
          <source>Ask that GHC specialize a polymorphic value to a particular type.</source>
          <target state="translated">GHC가 특정 유형에 다형성 값을 특수화하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="bc24cd3c8b6ddb112a336c5966d0506d3b2fd9ca" translate="yes" xml:space="preserve">
          <source>Assembly language (.s)</source>
          <target state="translated">조립 언어 (.s)</target>
        </trans-unit>
        <trans-unit id="4ffedc04e994a9aefd97d00e379f2d4f383ff9bc" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">어설 션 실패를 포착 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; 라이브러리에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d8e00d7a54a273c595978f5b3e92d75c8e0981a9" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">어설 션 오류가 발생할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; 라이브러리 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cde31a8393d46785fc228979a73996dac43391ba" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">어설 션 실패를 포착 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; 라이브러리에 대한 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="74319d6a5a4eb02ecd1401e7a9faed7d9660ea69" translate="yes" xml:space="preserve">
          <source>AssertionFailed</source>
          <target state="translated">AssertionFailed</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e8ddc914ca09e8e31648b53bc077284126a4cbdc" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">어설 션은 일반적으로 컴파일러 플래그를 사용하여 설정하거나 해제 할 수 있습니다 (GHC의 경우 &lt;code&gt;-O&lt;/code&gt; 를 사용하여 최적화를 설정하지 않거나 &lt;code&gt;-fignore-asserts&lt;/code&gt; 옵션을 지정 하지 않은 경우 일반적으로 어설 션이 설정 됨 ). 주장이 해제 될 때까지 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 무시되고, 두 번째 인수는 결과로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="492da7da6121915584e059d74109845fdbc2bb99" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">어설 션은 일반적으로 컴파일러 플래그를 사용하여 설정하거나 해제 할 수 있습니다 (GHC의 경우 &lt;code&gt;-O&lt;/code&gt; 를 사용하여 최적화를 설정하지 않거나 &lt;code&gt;-fignore-asserts&lt;/code&gt; 옵션을 지정 하지 않은 경우 일반적으로 어설 션이 설정 됨 ). 주장이 해제 될 때까지 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; 무시되고, 두 번째 인수는 결과로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a67c621ce56962ea20451247e4968660972fdfe" translate="yes" xml:space="preserve">
          <source>Assoc</source>
          <target state="translated">Assoc</target>
        </trans-unit>
        <trans-unit id="68b22545bb595a6b43f06bac583241d8e11a31a0" translate="yes" xml:space="preserve">
          <source>AssocLeft</source>
          <target state="translated">AssocLeft</target>
        </trans-unit>
        <trans-unit id="aa2f28d5f211bc5ecef78542598f880f8e318baa" translate="yes" xml:space="preserve">
          <source>AssocNone</source>
          <target state="translated">AssocNone</target>
        </trans-unit>
        <trans-unit id="56894dfcf0b1ff176191c0989a9045db04e81fe2" translate="yes" xml:space="preserve">
          <source>AssocRight</source>
          <target state="translated">AssocRight</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="28d556f025319f64419ff88734b119ab1b87004b" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">연관된 유형 및 데이터 인스턴스 선언은 엔 클로징 인스턴스에 지정된 컨텍스트를 상속하지 않습니다. 형식 인스턴스 선언의 경우 컨텍스트가 무엇을 의미하는지 명확하지 않습니다. 데이터 인스턴스 선언의 경우 사용자가 모든 데이터 생성자마다 컨텍스트가 반복되는 것을 원하지 않을 것입니다. 컨텍스트가 유용 할 수있는 유일한 위치 는 연관된 데이터 인스턴스 의 &lt;code&gt;deriving&lt;/code&gt; 조항에 있습니다. 그러나 여기서도 외부 인스턴스 컨텍스트의 역할은 어둡습니다. 따라서 명확성을 위해 위의 규칙을 고수합니다. 둘러싸는 인스턴스 컨텍스트는 무시됩니다. 파생 인스턴스에서 사소한 컨텍스트를 사용해야하는 경우 &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt; 절 (최상위 수준)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d29f80f6f8aff1ac6afd29591fc1ab7479bcba6" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">연관된 유형 및 데이터 인스턴스 선언은 둘러싸는 인스턴스에 지정된 컨텍스트를 상속하지 않습니다. 유형 인스턴스 선언의 경우 컨텍스트가 의미하는 바가 명확하지 않습니다. 데이터 인스턴스 선언의 경우 사용자가 모든 데이터 생성자에 대해 컨텍스트를 반복하기를 원하지 않을 것입니다. 컨텍스트가 유용 할 수있는 유일한 위치 는 연관된 데이터 인스턴스 의 &lt;code&gt;deriving&lt;/code&gt; 절입니다. 그러나 여기에서도 외부 인스턴스 컨텍스트의 역할은 모호합니다. 따라서 명확성을 위해 위의 규칙을 고수합니다. 둘러싸는 인스턴스 컨텍스트는 무시됩니다. 파생 된 인스턴스에서 중요하지 않은 컨텍스트를 사용해야하는 경우 &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt; 절을 사용합니다 (최상위 수준에서).</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="1c3f48563bf3394a3a3f951813cae0818e684494" translate="yes" xml:space="preserve">
          <source>Associativity is not used to reduce the occurrence of parentheses, although precedence may be.</source>
          <target state="translated">괄호의 발생을 줄이기 위해 연관성이 사용되지는 않지만 우선 순위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b99ff8f8291b4b50e3921986b0bce0e781dbc7e" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; to write a very simple error-reporting function that does absolutely nothing in the case of success, and outputs &quot;ERROR&quot; if any error occurred.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값이 일종의 오류를 의미 한다고 가정하면 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 를 사용 하여 성공시 전혀 아무것도하지 않는 매우 간단한 오류보고 기능을 작성하고 오류가 발생하면 &quot;ERROR&quot;를 출력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d055592ad02200007ba459bbee0ab4e26e918369" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; to write a very simple reporting function that only outputs &quot;SUCCESS&quot; when a computation has succeeded.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값이 일종의 오류를 의미 한다고 가정하면 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 를 사용 하여 계산이 성공했을 때 &quot;SUCCESS&quot;만 출력하는 매우 간단한보고 기능을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="483f89adba9ea9c40c941cf4a83fdac02ee4e4a5" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; has already been defined on the partially built structure:</source>
          <target state="translated">부분적으로 빌드 된 구조에 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 가 이미 정의 되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1c834581788562362bcf330136a30982991522f6" translate="yes" xml:space="preserve">
          <source>Assumption: Integer is strictly positive</source>
          <target state="translated">가정 : 정수는 엄격하게 양수</target>
        </trans-unit>
        <trans-unit id="77fd17f027574bb2f7df35f4ef90ead2e9b60836" translate="yes" xml:space="preserve">
          <source>AsyncException</source>
          <target state="translated">AsyncException</target>
        </trans-unit>
        <trans-unit id="603f73055272502639dd306a8bca156dc618be89" translate="yes" xml:space="preserve">
          <source>AsyncIOAvailable</source>
          <target state="translated">AsyncIOAvailable</target>
        </trans-unit>
        <trans-unit id="e1aac0f84af1ee48fafd058955607776e453cc9b" translate="yes" xml:space="preserve">
          <source>Asynchronous Exceptions</source>
          <target state="translated">비동기 예외</target>
        </trans-unit>
        <trans-unit id="1fde34ce4b1dca7f44eebcbaf7ae6171e5ddd42a" translate="yes" xml:space="preserve">
          <source>Asynchronous exception control</source>
          <target state="translated">비동기 예외 제어</target>
        </trans-unit>
        <trans-unit id="90e8f43c2f265d7e22350697496f72118afa53f2" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; are two examples of system-generated asynchronous exceptions.</source>
          <target state="translated">비동기 예외는 외부 영향으로 인해 발생하기 때문에 이른바 실행 중 언제라도 발생할 수 있습니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; 는 시스템 생성 비동기 예외의 두 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="e9087c26270e45969905025ed0c6876268b8e459" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되면 마스킹 된 상태에서 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="303a11aed286b513643b565c89072a6a7aa3770b" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되는 경우 마스킹 된 상태에있는 동안 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cedca602451f983242010d922a6b8f21df9fe142" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되는 경우 마스킹 된 상태에있는 동안 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c6f92d83ff3d5f34604121aadc15840ac708368" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">마스킹 된 스레드 가 특정 방식으로 &lt;em&gt;차단&lt;/em&gt; 되면 마스킹 된 상태에서 비동기 예외가 계속 수신 될 수 있습니다 . &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="631cd36315ff03e677e0243fa4a94f4335edad65" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions.</source>
          <target state="translated">비동기 예외.</target>
        </trans-unit>
        <trans-unit id="de23bf55d43f3cb1369402e7877d3faa61f2949f" translate="yes" xml:space="preserve">
          <source>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and &lt;em&gt;appends&lt;/em&gt; it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</source>
          <target state="translated">함수 호출에서 GHC는 호출되는 함수에 저장된 스택 (최상위 함수의 경우 비어 있음)을 가져 와서 현재 스택의 접두사와 동일한 접두사를 무시하고 현재 스택에 &lt;em&gt;추가&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb19257a1286f9e500a61c5dfeacaecfe019ec79" translate="yes" xml:space="preserve">
          <source>At any time you can use the command &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt; to get a list of the modules currently loaded into GHCi:</source>
          <target state="translated">언제든지 &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 현재 GHCi에로드 된 모듈 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3461cf3addc608aea10037826585d0df504e072e" translate="yes" xml:space="preserve">
          <source>At definition site, the arity determines what inputs can be matched on:</source>
          <target state="translated">정의 사이트에서 arity는 일치 할 수있는 입력을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cc7e513d6fe875bf90b4a728f124a7f9ff012de2" translate="yes" xml:space="preserve">
          <source>At first blush, &lt;code&gt;UnEx&lt;/code&gt; seems poorly-kinded. The return kind &lt;code&gt;k&lt;/code&gt; is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of &lt;code&gt;k&lt;/code&gt;&lt;em&gt;for any&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, this is not the case. The type family &lt;code&gt;UnEx&lt;/code&gt; is a kind-indexed type family. The return kind &lt;code&gt;k&lt;/code&gt; is an implicit parameter to &lt;code&gt;UnEx&lt;/code&gt;. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</source>
          <target state="translated">언뜻보기에 &lt;code&gt;UnEx&lt;/code&gt; 는 좋지 않은 것 같습니다. 반환 종류 &lt;code&gt;k&lt;/code&gt; 는 인수에 언급되어 있지 않으므로 인스턴스가 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;에 대해 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 멤버를 반환해야 할 것 같습니다 . 그러나 그렇지 않습니다. 유형 군 &lt;code&gt;UnEx&lt;/code&gt; 는 종류별로 분류 된 유형 군입니다. 반환 종류 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;UnEx&lt;/code&gt; 에 대한 암시 적 매개 변수 입니다. 정교한 정의는 다음과 같습니다 (암시 적 매개 변수는 중괄호로 표시됨).</target>
        </trans-unit>
        <trans-unit id="082a6d8510562c71bea9da704521358ac4884d2e" translate="yes" xml:space="preserve">
          <source>At least one of the classes &lt;code&gt;Ci&lt;/code&gt; is numeric.</source>
          <target state="translated">클래스 &lt;code&gt;Ci&lt;/code&gt; 중 적어도 하나 는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="da4d3ab8aa4bf1c457aa64eadbb0f7599f12c862" translate="yes" xml:space="preserve">
          <source>At least one overlapped instance, &lt;code&gt;Iy&lt;/code&gt;, is both:</source>
          <target state="translated">하나 이상의 겹친 인스턴스 &lt;code&gt;Iy&lt;/code&gt; 는 둘 다입니다.</target>
        </trans-unit>
        <trans-unit id="95b0afae80408c0a928a6ff24b58dae9588bff21" translate="yes" xml:space="preserve">
          <source>At present, &lt;code&gt;-O2&lt;/code&gt; is nearly indistinguishable from &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;-O2&lt;/code&gt; 는 &lt;code&gt;-O&lt;/code&gt; 와 거의 구별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2d06e4b175297e1faf1e01c3741923b7d7eb11e9" translate="yes" xml:space="preserve">
          <source>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results&amp;mdash; in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of &lt;code&gt;(+)&lt;/code&gt;, for example.</source>
          <target state="translated">현재 GHC는 산술에 대한 추론이 상당히 제한되어 있습니다. 다른 유형 함수와 동일한 방식으로 산술 형식 함수 만 평가하고 결과를 비교합니다. 특히, 예를 들어 &lt;code&gt;(+)&lt;/code&gt; 의 commutativity 및 associativity와 같은 산술에 대한 더 일반적인 사실을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="14a75af6823b475d201cdaf02b67cfc7b30f5d3d" translate="yes" xml:space="preserve">
          <source>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type &lt;code&gt;TypeError&lt;/code&gt;. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</source>
          <target state="translated">런타임시, 유형 오류가 포함 된 용어를 평가해야 할 때마다 오류는 &lt;code&gt;TypeError&lt;/code&gt; 유형의 런타임 예외로 변환됩니다 . 런타임 중에는 유형 오류가 가능한 한 많이 지연되지만 결과적으로 올바른 유형의 값을 초래하더라도 유효하지 않은 강제 변환은 수행되지 않습니다. 예를 들어 다음 코드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1e7a17deca9b74f37ec0a39800ad357611600d" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt you can also enter any top-level Haskell declaration, including &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;deriving&lt;/code&gt;, and &lt;code&gt;foreign&lt;/code&gt; declarations. For example:</source>
          <target state="translated">GHCi 프롬프트에서 &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;newtype&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;instance&lt;/code&gt; , &lt;code&gt;deriving&lt;/code&gt; 및 &lt;code&gt;foreign&lt;/code&gt; 선언을 포함한 최상위 Haskell 선언을 입력 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd0949a6c29925c12d1d048d17633d245e1a3ebf" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt, or with GHC if the &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; flag is given, the types are instead resolved with the following method:</source>
          <target state="translated">GHCi 프롬프트에서 또는 &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt; 플래그가 제공되는 경우 GHC를 사용 하여 유형은 대신 다음 방법으로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="faae2aa7c10c0885466c17a8edd2f6d0318681f4" translate="yes" xml:space="preserve">
          <source>At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</source>
          <target state="translated">샘플 기간이 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; 이벤트가 발생합니다. 이는 샘플링 기간을 적절하게 구분하고 프로파일 링에 소요 된 총 시간을 기록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d062db617e8b184eee773ae86e765aa598c88a3" translate="yes" xml:space="preserve">
          <source>At the moment GHCi supports most of GHC&amp;rsquo;s language extensions.</source>
          <target state="translated">현재 GHCi는 대부분의 GHC 언어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="af7cac97440198fcc962770e0f96df4e013c2492" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command doesn&amp;rsquo;t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; will not do what you expect.</source>
          <target state="translated">현재 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령은 인수에서 어떤 종류의 따옴표도 지원하지 않습니다. 따옴표는 제거되지 않으며 단어를 함께 그룹화하는 데 사용할 수 없습니다. 예를 들어, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; 는 예상 한대로 작동 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82ba5640e0de386d6cc85d3de209bb9cdb633f12" translate="yes" xml:space="preserve">
          <source>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in &lt;code&gt;build-depends&lt;/code&gt; (which uses the conventional &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</source>
          <target state="translated">현재 Cabal의 플러그인에 의존성을 지정하는 유일한 방법은 &lt;code&gt;build-depends&lt;/code&gt; (전통적인 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그를 사용)에 넣는 것입니다 . 그러나 앞으로는 플러그인 종속성을 구체적으로 지정하기위한 별도의 필드가있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="36f6fc6a8b5e23e239eeef3e4a0f085a44f79d37" translate="yes" xml:space="preserve">
          <source>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</source>
          <target state="translated">사용 사이트에서 arity는 더 높은 순위의 시나리오에서 정의를 사용할 수 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7f078fc66826e48322f51a990469bfd247658746" translate="yes" xml:space="preserve">
          <source>Atomic blocks.</source>
          <target state="translated">원자 블록.</target>
        </trans-unit>
        <trans-unit id="92c10450c672866027afd2c75b1a19f1a5daa4db" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용에 함수를 원자 적으로 적용 하고 이전 값과 새 값을 반환합니다. 기능의 결과는 강요됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8c029e8fddf8615e7bdb4f7438b3feba64ae42" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is not forced. As this can lead to a memory leak, it is usually better to use &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용에 함수를 원자 적으로 적용 하고 이전 값과 새 값을 반환합니다. 기능의 결과는 강요되지 않습니다. 메모리 누수가 발생할 수 있으므로 일반적으로 &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="420f4999cbf62263237bdbe7d15cefd4576bc583" translate="yes" xml:space="preserve">
          <source>Atomically modifies the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="5976845b8f84b952ac2fc7192f0a75f69d2927f0" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cee328d42a656c88f81a24f4db1782769f19c73" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 수신을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="184b9dc038e8a43ed0e8ffb796e5fef400df0150" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="be6bc09ee654abc40df66bc414fa4a9c12171cb5" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="23386c18719208e0c4d15b8720f6d737027a0291" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원자 적으로 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 내용을 읽습니다 . 는 IF &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 현재 비어, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 가 가득 찰 때까지 기다립니다. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 는 다음 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수신하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d13722b70b72345abf719add29b1a51d34aad57" translate="yes" xml:space="preserve">
          <source>Atomically replace the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, returning the old contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용을 원자 적으로 대체하여 이전 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ab5a0a6f732e3010e4b8d4b1f44a6fc68552e9b" translate="yes" xml:space="preserve">
          <source>Attach a timeout event to arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 시간 초과 이벤트를 첨부하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb303f555c293bc6ebb398fedf551b67ed2ee6e1" translate="yes" xml:space="preserve">
          <source>Attach an annotation to a document.</source>
          <target state="translated">문서에 주석을 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="83a56249e5cff48f561d2d725143f1fc2eb3228c" translate="yes" xml:space="preserve">
          <source>Attachment</source>
          <target state="translated">Attachment</target>
        </trans-unit>
        <trans-unit id="6771ade6e8965a499bc298107ffb52e9a18dd7e3" translate="yes" xml:space="preserve">
          <source>Attachments</source>
          <target state="translated">Attachments</target>
        </trans-unit>
        <trans-unit id="358b4cc5015b0aa8d923e59ec8734cadaa58c21f" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the capacity (in bytes) given by the first argument. The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous compact block of the CNF or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new CNF with a single compact block.</source>
          <target state="translated">첫 번째 인수가 제공하는 용량 (바이트)을 가진 압축 블록 할당을 시도합니다. &lt;code&gt;Addr#&lt;/code&gt; CNF에 또는 이전 소형 블록에 대한 포인터입니다 &lt;code&gt;nullAddr#&lt;/code&gt; 하나의 소형 블록과 새로운 CNF을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c3e18c8fd88ff49a30c3e7b04045a40e92e438" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the given size (in bytes, given by the first argument). The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous block of the compact or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new compact.</source>
          <target state="translated">주어진 크기 (첫 번째 인수가 제공 한 바이트)로 컴팩트 블록을 할당하려고합니다. &lt;code&gt;Addr#&lt;/code&gt; 소형 또는 이전 블록에 대한 포인터입니다 &lt;code&gt;nullAddr#&lt;/code&gt; 새로운 소형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aa6f2a111a7ae3d1c85ad97bb0176dbe687d1c3" translate="yes" xml:space="preserve">
          <source>Attempt to convert an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;a&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;b&lt;/code&gt; using the size of the types as measured by &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">변환하려고 시도 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 형 &lt;code&gt;a&lt;/code&gt; 내지 An &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 타입 &lt;code&gt;b&lt;/code&gt; 를 에 의해 측정 한 종류의 사이즈 사용 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="eb6ccc5388b3a3515cdd4a9fde980934200b5b13" translate="yes" xml:space="preserve">
          <source>Attempt to ignore and recover if an illegal sequence is encountered</source>
          <target state="translated">잘못된 시퀀스가 ​​발생하면 무시하고 복구하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1dd801e8dde9f614ee3cf534bfcd9bf71825677c" translate="yes" xml:space="preserve">
          <source>Attempt to lock the semaphore without blocking. Immediately return False if it is not available.</source>
          <target state="translated">차단하지 않고 세마포어를 잠그려고합니다. 사용할 수없는 경우 즉시 False를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="5ce185b0aec3184ea8d85cd399f6b27591eecf61" translate="yes" xml:space="preserve">
          <source>Attempt to perform the given action, silencing any IO exception thrown by it.</source>
          <target state="translated">지정된 조치를 수행하여 처리 된 IO 예외를 침묵 시키십시오.</target>
        </trans-unit>
        <trans-unit id="1c903a1acb600fe485f2c4a45d92c0ad8eff63d5" translate="yes" xml:space="preserve">
          <source>Attempting to use of linear types in Template Haskell will probably not work.</source>
          <target state="translated">템플릿 Haskell에서 선형 유형을 사용하려는 시도는 아마도 작동하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="95eba1f265744c575faabec4b145e9a698745932" translate="yes" xml:space="preserve">
          <source>Attempts to reload the current target set (see &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</source>
          <target state="translated">세트 의 모듈 또는 종속 모듈이 변경된 경우 현재 대상 세트를 다시로드하려고합니다 ( &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 참조 ). 이를 위해서는 새로운 모듈을로드하거나 대상에서 더 이상 간접적으로 요구하지 않는 모듈을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db06067c8f8d76e8b68fa4b9186a9b50479a85d3" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the specified process. This function should not be used under normal circumstances - no guarantees are given regarding how cleanly the process is terminated. To check whether the process has indeed terminated, use &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 프로세스를 종료하려고 시도합니다. 이 기능은 정상적인 상황에서는 사용하지 않아야합니다. 프로세스가 얼마나 깨끗하게 종료되는지에 대한 보장은 없습니다. 프로세스가 실제로 종료되었는지 확인하려면 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="c4b6f77c88d20ca04f9a50aec205f45262f5d7ab" translate="yes" xml:space="preserve">
          <source>Attributes in XHTML Strict</source>
          <target state="translated">XHTML Strict의 속성</target>
        </trans-unit>
        <trans-unit id="16128ba0c9d08bb0dde15482b5b394897473b886" translate="yes" xml:space="preserve">
          <source>Attributes of I/O errors</source>
          <target state="translated">I / O 오류의 속성</target>
        </trans-unit>
        <trans-unit id="1360a6d5f84dba15e5314081238a2fd3066ee932" translate="yes" xml:space="preserve">
          <source>Attributes with name and value.</source>
          <target state="translated">이름과 값이있는 속성</target>
        </trans-unit>
        <trans-unit id="993065bb1a56fd21869c669ca617b04976cb0030" translate="yes" xml:space="preserve">
          <source>Author: Ben Gamari</source>
          <target state="translated">저자 : 벤 가마리</target>
        </trans-unit>
        <trans-unit id="75c4b805a306f8a99221f82ad1e776dcaee1276b" translate="yes" xml:space="preserve">
          <source>Authors importing this module are expected to track development closely.</source>
          <target state="translated">이 모듈을 가져 오는 작성자는 개발을 면밀히 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac440c0ee95ad46797ff526e4fa32c25032310cf" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all CAFs</source>
          <target state="translated">모든 CAF에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="3e6d90a8087bfbc9d56637d926baaee06bb11b50" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; \ s 자동 추가</target>
        </trans-unit>
        <trans-unit id="926781921f42c31bb0687106a4a150bb577b974e" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all call sites</source>
          <target state="translated">모든 통화 사이트에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="aba3425843f29781a7a8d03a07af127ba3b7b9b2" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all exported bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 내 보낸 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="f39d1b641099009478c941384a7ddb92d9adc118" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all top-level bindings not marked INLINE</source>
          <target state="translated">INLINE으로 표시되지 않은 모든 최상위 바인딩 에 &lt;code&gt;SCC&lt;/code&gt; 를 자동 추가</target>
        </trans-unit>
        <trans-unit id="fc392ab09cabed566e31abcea7714e1a9fbd59f8" translate="yes" xml:space="preserve">
          <source>AutoDeriveTypeable</source>
          <target state="translated">AutoDeriveTypeable</target>
        </trans-unit>
        <trans-unit id="0f3997661b5230a1d4a29603d354a226f203caa0" translate="yes" xml:space="preserve">
          <source>Automatically enable compacting collection when the live data exceeds ⟨n⟩% of the maximum heap size (see the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; option). Note that the maximum heap size is unlimited by default, so this option has no effect unless the maximum heap size is set with &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">라이브 데이터가 최대 힙 크기의 ⟨n⟩ %를 초과하면 압축 수집을 자동으로 활성화합니다 ( &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; 옵션 참조 ). 최대 힙 크기는 기본적으로 무제한이므로 최대 힙 크기가 &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; 로 설정되어 있지 않으면이 옵션이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6deb87b596d87ecee88f79fe651652c552010dcc" translate="yes" xml:space="preserve">
          <source>Available on &lt;code&gt;base &amp;gt;=4.9&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;base &amp;gt;=4.9&lt;/code&gt; 에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="5e4e7aa329cbbf38ad0669fe65c87a2d764ac59f" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude를&lt;/a&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ace826e18102f6899794ad3ef89b5a4cafb9c1c" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude를&lt;/a&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="d046fd0eedb33417414a7f1c2d12f68e0c748ad0" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude를&lt;/a&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6bcda3182218ed04e058e2a3e7f3b82979718dc" translate="yes" xml:space="preserve">
          <source>Avoid using Bytes constructor directly as it is likely to change in the future. Use helpers such as &lt;code&gt;mkBytes&lt;/code&gt; in Language.Haskell.TH.Lib instead.</source>
          <target state="translated">나중에 변경 될 가능성이 있으므로 Bytes 생성자를 직접 사용하지 마십시오. 대신 Language.Haskell.TH.Lib의 &lt;code&gt;mkBytes&lt;/code&gt; 와 같은 도우미를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="be332d307b7edd783371ed9722af4d2891b5ddd8" translate="yes" xml:space="preserve">
          <source>Avoiding multi-pass folds</source>
          <target state="translated">다중 패스 접기 방지</target>
        </trans-unit>
        <trans-unit id="ca874deaab16366191c7957785eea44d50d3a744" translate="yes" xml:space="preserve">
          <source>B0</source>
          <target state="translated">B0</target>
        </trans-unit>
        <trans-unit id="8fa6afc648cb35f98b314ec87af904a1320a565f" translate="yes" xml:space="preserve">
          <source>B110</source>
          <target state="translated">B110</target>
        </trans-unit>
        <trans-unit id="69983106476a1baa3e173eb0da9525d4e05a1e94" translate="yes" xml:space="preserve">
          <source>B115200</source>
          <target state="translated">B115200</target>
        </trans-unit>
        <trans-unit id="63db1d5e1025a5dca03dde90aaee4ab1689048ef" translate="yes" xml:space="preserve">
          <source>B1200</source>
          <target state="translated">B1200</target>
        </trans-unit>
        <trans-unit id="e74b06339c34831ce0b9ab483e8c8a61a8068208" translate="yes" xml:space="preserve">
          <source>B134</source>
          <target state="translated">B134</target>
        </trans-unit>
        <trans-unit id="a9905f37be71ad27b06428c2ae3de56996c96c7e" translate="yes" xml:space="preserve">
          <source>B150</source>
          <target state="translated">B150</target>
        </trans-unit>
        <trans-unit id="966d5ab4ced9ae0785e30c1280734e03950b8b43" translate="yes" xml:space="preserve">
          <source>B1800</source>
          <target state="translated">B1800</target>
        </trans-unit>
        <trans-unit id="e535913533dad54a5814041ea8ecb91d9eeccbc1" translate="yes" xml:space="preserve">
          <source>B19200</source>
          <target state="translated">B19200</target>
        </trans-unit>
        <trans-unit id="559bc674c0bef2843ad28f3b0807a3bc8c3a905e" translate="yes" xml:space="preserve">
          <source>B200</source>
          <target state="translated">B200</target>
        </trans-unit>
        <trans-unit id="8b9d4b133283a998a17790c5482a1a7e5ea5ef89" translate="yes" xml:space="preserve">
          <source>B2400</source>
          <target state="translated">B2400</target>
        </trans-unit>
        <trans-unit id="1100370c026795a2ba481e6ed685267255662a5a" translate="yes" xml:space="preserve">
          <source>B300</source>
          <target state="translated">B300</target>
        </trans-unit>
        <trans-unit id="967e9e4821f80944c4a011159dea85581127b02d" translate="yes" xml:space="preserve">
          <source>B38400</source>
          <target state="translated">B38400</target>
        </trans-unit>
        <trans-unit id="3e5bbebbfb2d76d5eb4a77c12b899a53cb0e824b" translate="yes" xml:space="preserve">
          <source>B4800</source>
          <target state="translated">B4800</target>
        </trans-unit>
        <trans-unit id="70e67f1d5a37cf067a56baf4ce16e1420d5e3b02" translate="yes" xml:space="preserve">
          <source>B50</source>
          <target state="translated">B50</target>
        </trans-unit>
        <trans-unit id="763970e59e7e204186ab4318ebc79d0aad573df8" translate="yes" xml:space="preserve">
          <source>B57600</source>
          <target state="translated">B57600</target>
        </trans-unit>
        <trans-unit id="e41fa1e36cc5ce5485a1da88669ebf6c181b64fc" translate="yes" xml:space="preserve">
          <source>B600</source>
          <target state="translated">B600</target>
        </trans-unit>
        <trans-unit id="0a96b59160d52c4d3a94a14b630cd642e970d726" translate="yes" xml:space="preserve">
          <source>B75</source>
          <target state="translated">B75</target>
        </trans-unit>
        <trans-unit id="38ed67ee58867b1ed339e07a0a0e350aefba9899" translate="yes" xml:space="preserve">
          <source>B9600</source>
          <target state="translated">B9600</target>
        </trans-unit>
        <trans-unit id="d9004f19dea2dc973e0d147f71242cc2bebca3f3" translate="yes" xml:space="preserve">
          <source>BCO#</source>
          <target state="translated">BCO#</target>
        </trans-unit>
        <trans-unit id="d387e5e412686186588f12198f87a79c11ecf2f3" translate="yes" xml:space="preserve">
          <source>BLACK STAR</source>
          <target state="translated">검은 별</target>
        </trans-unit>
        <trans-unit id="ed7592b91885c70d24cf8681c067a4604fe9f9a7" translate="yes" xml:space="preserve">
          <source>BN#</source>
          <target state="translated">BN#</target>
        </trans-unit>
        <trans-unit id="292c7af4fff95bcd09dba6dcdd4b5f6d636b95c8" translate="yes" xml:space="preserve">
          <source>BOOL</source>
          <target state="translated">BOOL</target>
        </trans-unit>
        <trans-unit id="42c5e705983ae56cd93e4c5f6314e815eb160593" translate="yes" xml:space="preserve">
          <source>BSD-style</source>
          <target state="translated">BSD-style</target>
        </trans-unit>
        <trans-unit id="9332433de0ed1632f2bcc6d0a44e38c2f119263d" translate="yes" xml:space="preserve">
          <source>BSD-style (see LICENSE)</source>
          <target state="translated">BSD 스타일 (라이센스 참조)</target>
        </trans-unit>
        <trans-unit id="44f04e5b329f5940c142f534423ac2c4e47a1a2d" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file in the distribution)</source>
          <target state="translated">BSD 스타일 (배포판의 LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="c6ca990beea2501ec303342859beced421c42eb6" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file)</source>
          <target state="translated">BSD 스타일 (LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="965d82d9479d90e4c8debb630580bf0a1b1ba92f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE in this distribution)</source>
          <target state="translated">BSD 스타일 (이 배포판의 LICENSE 파일 참조)</target>
        </trans-unit>
        <trans-unit id="768626facad260a6f891ec7130589a5f3309d501" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE)</source>
          <target state="translated">BSD 스타일 (라이센스 파일 참조)</target>
        </trans-unit>
        <trans-unit id="81e1671a0b4eeb6f499727101f56c68023874e7f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/base/LICENSE)</source>
          <target state="translated">BSD 스타일 (파일 라이브러리 / base / LICENSE 참조)</target>
        </trans-unit>
        <trans-unit id="ef57f6a3a070b95b64e77f5a36de3561ef544d65" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/parsec/LICENSE)</source>
          <target state="translated">BSD 스타일 (파일 라이브러리 / parsec / LICENSE 참조)</target>
        </trans-unit>
        <trans-unit id="19a47f35c441c8dd2576f588079955402fb90b82" translate="yes" xml:space="preserve">
          <source>BSD3</source>
          <target state="translated">BSD3</target>
        </trans-unit>
        <trans-unit id="7f9c1e64342b8d68000ad605b095d79dad9a02d3" translate="yes" xml:space="preserve">
          <source>BSD3-style (see LICENSE)</source>
          <target state="translated">BSD3 스타일 (라이센스 참조)</target>
        </trans-unit>
        <trans-unit id="1d7caa593761d5e9b3a933c7c28bf276e5fe0725" translate="yes" xml:space="preserve">
          <source>BYTE</source>
          <target state="translated">BYTE</target>
        </trans-unit>
        <trans-unit id="c6d4a87dd731399addc42bfa4639f9363a8c4260" translate="yes" xml:space="preserve">
          <source>BY_HANDLE_FILE_INFORMATION</source>
          <target state="translated">BY_HANDLE_FILE_INFORMATION</target>
        </trans-unit>
        <trans-unit id="80ed9fd98b57c91f78562ce126c39ae7b67ed567" translate="yes" xml:space="preserve">
          <source>Back-quotes work as for expressions, both for type constructors and type variables; e.g. &lt;code&gt;Int `Either` Bool&lt;/code&gt;, or &lt;code&gt;Int `a` Bool&lt;/code&gt;. Similarly, parentheses work the same; e.g. &lt;code&gt;(:*:) Int Bool&lt;/code&gt;.</source>
          <target state="translated">역 따옴표는 형식 생성자와 형식 변수 모두에 대해 식과 같이 작동합니다. 예를 들어 &lt;code&gt;Int `Either` Bool&lt;/code&gt; 또는 Int`a` &lt;code&gt;Int `a` Bool&lt;/code&gt; 입니다. 마찬가지로 괄호도 동일하게 작동합니다. 예 : &lt;code&gt;(:*:) Int Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe2ff7fc27afe7d547b5eb980ad60a5d316a61a8" translate="yes" xml:space="preserve">
          <source>Background: some systems have a Non-Uniform Memory Architecture, whereby main memory is split into banks which are &amp;ldquo;local&amp;rdquo; to specific CPU cores. Accessing local memory is faster than accessing remote memory. The OS provides APIs for allocating local memory and binding threads to particular CPU cores, so that we can ensure certain memory accesses are using local memory.</source>
          <target state="translated">배경 : 일부 시스템에는 비 균일 메모리 아키텍처가있어 주 메모리는 특정 CPU 코어에 &quot;로컬&quot;인 뱅크로 분할됩니다. 로컬 메모리에 액세스하는 것이 원격 메모리에 액세스하는 것보다 빠릅니다. OS는 로컬 메모리를 할당하고 스레드를 특정 CPU 코어에 바인딩하는 API를 제공하므로 특정 메모리 액세스가 로컬 메모리를 사용하고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72bac718669114015a5f4f323dbfd19315cc9c1e" translate="yes" xml:space="preserve">
          <source>BackgroundWriteInterrupt</source>
          <target state="translated">BackgroundWriteInterrupt</target>
        </trans-unit>
        <trans-unit id="95e848a0c727105f2393d59e2c3843e625c17c16" translate="yes" xml:space="preserve">
          <source>Backwards</source>
          <target state="translated">Backwards</target>
        </trans-unit>
        <trans-unit id="13be7afef8413dabb18fb208bcddc8487eccc989" translate="yes" xml:space="preserve">
          <source>Bang</source>
          <target state="translated">Bang</target>
        </trans-unit>
        <trans-unit id="8c8ebd2c416a792dfc576bb10ca4e468125c1a6e" translate="yes" xml:space="preserve">
          <source>Bang patterns (&lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;) makes pattern matching and let bindings stricter.</source>
          <target state="translated">Bang 패턴 ( &lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt; )은 패턴을 일치시키고 바인딩을보다 엄격하게합니다.</target>
        </trans-unit>
        <trans-unit id="5ec90a9a17a2969ccda25430595be20a569e3fe9" translate="yes" xml:space="preserve">
          <source>Bang patterns and strict matching do not affect the type system in any way.</source>
          <target state="translated">뱅 패턴 및 엄격한 일치는 어떤 식 으로든 형식 시스템에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4331913421f3f413f4d723cb7bf92c5118afdbaf" translate="yes" xml:space="preserve">
          <source>Bang patterns work in &lt;code&gt;case&lt;/code&gt; expressions too, of course:</source>
          <target state="translated">플레이 패턴에서 일하는 &lt;code&gt;case&lt;/code&gt; 물론, 너무 표현 :</target>
        </trans-unit>
        <trans-unit id="50466cee465187abc9af9cab7155eae9f7c01b4f" translate="yes" xml:space="preserve">
          <source>BangPatterns</source>
          <target state="translated">BangPatterns</target>
        </trans-unit>
        <trans-unit id="23753b97b7d02a9e0370366e9fbeda13137a82c9" translate="yes" xml:space="preserve">
          <source>BangQ</source>
          <target state="translated">BangQ</target>
        </trans-unit>
        <trans-unit id="48d652eba9b41d0c825ca713155f565dc1ca77d2" translate="yes" xml:space="preserve">
          <source>BangType</source>
          <target state="translated">BangType</target>
        </trans-unit>
        <trans-unit id="b5159683817a7c6e14cfc2ce8186bac739ef41b1" translate="yes" xml:space="preserve">
          <source>BangTypeQ</source>
          <target state="translated">BangTypeQ</target>
        </trans-unit>
        <trans-unit id="b97a50336dc10f904675fe44fbb4e1e0f9f62610" translate="yes" xml:space="preserve">
          <source>Bart Massey &amp;lt;bart@cs.pdx.edu&amp;gt;</source>
          <target state="translated">바트 매시 &amp;lt;bart@cs.pdx.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="15c502386eb41ec778f48f0426dd044e61902a8f" translate="yes" xml:space="preserve">
          <source>Based on the original Text.Html library by Andy Gill. See &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; for an introduction to that library.</source>
          <target state="translated">Andy Gill의 원본 Text.Html 라이브러리를 기반으로합니다. 해당 라이브러리에 대한 소개는 &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2140f37579f36362da3719562444661d727afe4" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">기본 &lt;code&gt;Integer&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="ee73c6548371a6788caa59207b82400814c02764" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Monad&lt;/code&gt; functions</source>
          <target state="translated">기본 &lt;code&gt;Monad&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="c88db86b8d674e03dbcad77f83787a7e61a8e034" translate="yes" xml:space="preserve">
          <source>Basic Input and output</source>
          <target state="translated">기본 입출력</target>
        </trans-unit>
        <trans-unit id="f9b3e5bd963e2b38618aa474b3e7102fc295adcc" translate="yes" xml:space="preserve">
          <source>Basic UTF-8 validation and character manipulation.</source>
          <target state="translated">기본 UTF-8 유효성 검사 및 문자 조작.</target>
        </trans-unit>
        <trans-unit id="9568da19057c26bab59b9243581c623c02943b7f" translate="yes" xml:space="preserve">
          <source>Basic arrow definitions, based on</source>
          <target state="translated">기본 화살표 정의 (기준)</target>
        </trans-unit>
        <trans-unit id="6a1b59604dd8bf31bed9746b89fda90c3467c9aa" translate="yes" xml:space="preserve">
          <source>Basic concurrency operations</source>
          <target state="translated">기본 동시성 작업</target>
        </trans-unit>
        <trans-unit id="0c54046043ce73859746be9b39ba7b190dacdaf6" translate="yes" xml:space="preserve">
          <source>Basic concurrency stuff.</source>
          <target state="translated">기본 동시성</target>
        </trans-unit>
        <trans-unit id="a7e69e7791ed667a403de47b04497c349887deca" translate="yes" xml:space="preserve">
          <source>Basic data types</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c9d432205b7dc1b2af1472a1dcd6e06b2740bef0" translate="yes" xml:space="preserve">
          <source>Basic data types and classes.</source>
          <target state="translated">기본 데이터 유형 및 클래스</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="b9548c7037e25b8bf7a7572126d2cc1b16e01f80" translate="yes" xml:space="preserve">
          <source>Basic interface</source>
          <target state="translated">기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="ea133ee8187b37bb71d85236dac3108829ef4b40" translate="yes" xml:space="preserve">
          <source>Basic kinds</source>
          <target state="translated">기본 종류</target>
        </trans-unit>
        <trans-unit id="50a832ade293f6e2e4b29e68fbed8adbb4f5292b" translate="yes" xml:space="preserve">
          <source>Basic non-strict arrays.</source>
          <target state="translated">기본 엄격하지 않은 배열.</target>
        </trans-unit>
        <trans-unit id="5f012dfa959f01c06a8f22651163550a83550e42" translate="yes" xml:space="preserve">
          <source>Basic numeric class.</source>
          <target state="translated">기본 숫자 클래스.</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">기본 조작</target>
        </trans-unit>
        <trans-unit id="25c075b5afd0fa65abaa64881721f9e82dad1e33" translate="yes" xml:space="preserve">
          <source>Basic operations on type-level Booleans.</source>
          <target state="translated">타입 레벨 불리언에 대한 기본 연산.</target>
        </trans-unit>
        <trans-unit id="ce2e8249a9c31f9132666369cb296c36dc8cbe0d" translate="yes" xml:space="preserve">
          <source>Basic type classes</source>
          <target state="translated">기본 타입 클래스</target>
        </trans-unit>
        <trans-unit id="5f5e9b287612ac50252f03aed2ec4f912c26ab6b" translate="yes" xml:space="preserve">
          <source>Basic types for the implementation of IO Handles.</source>
          <target state="translated">IO 핸들 구현을위한 기본 유형.</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="57869d5cb688abb53fb6a3ccefe136c430873b62" translate="yes" xml:space="preserve">
          <source>BasicFormat</source>
          <target state="translated">BasicFormat</target>
        </trans-unit>
        <trans-unit id="edd76f36427e0be6ee4ea72fcc2b48f9dc5f829a" translate="yes" xml:space="preserve">
          <source>BaudRate</source>
          <target state="translated">BaudRate</target>
        </trans-unit>
        <trans-unit id="13b75e02d46b87821b8e6bb2e907caf22536eaeb" translate="yes" xml:space="preserve">
          <source>Be aware of that &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; do require filenames containing spaces to be escaped using quotes:</source>
          <target state="translated">그주의 &lt;code&gt;ghc&lt;/code&gt; 및 &lt;code&gt;ghci&lt;/code&gt; 는 따옴표를 사용하여 이스케이프하는 공백이 포함 된 파일 이름을 필요로 않습니다 :</target>
        </trans-unit>
        <trans-unit id="2a750147c0b7e7b2524f6f876a3edd09786994a4" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="833fbd733b968c1c689e377b206c44a8ba2c1393" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8b4f2dc8bf0c5571de02a483e44a0efdc7eb624d" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList'에 유의하십시오. 에만 고정되지 않은에 대한 toList = 아이디 ' &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 의 이후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 이 frozenness 정보를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4dc420edbf82aa0a2fac0909c5f04bacaae0ad94" translate="yes" xml:space="preserve">
          <source>Be careful not to recompile any packages that GHC itself depends on, as this may render the &lt;code&gt;ghc&lt;/code&gt; package itself broken, and &lt;code&gt;ghc&lt;/code&gt; cannot be simply recompiled. The only way to recover from this would be to re-install GHC.</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; 패키지 자체가 손상 될 수 있으며 &lt;code&gt;ghc&lt;/code&gt; 를 단순히 재 컴파일 할 수 없으므로 GHC 자체가 의존하는 패키지를 다시 컴파일하지 않도록주의하십시오 . 이를 복구하는 유일한 방법은 GHC를 다시 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e58b8e7a7708dab3c9a2bfb9884abe1e3e42613" translate="yes" xml:space="preserve">
          <source>Be careful when using all the processors in your machine: if some of your processors are in use by other programs, this can actually harm performance rather than improve it. Asking GHC to create more capabilities than you have physical threads is almost always a bad idea.</source>
          <target state="translated">컴퓨터에서 모든 프로세서를 사용할 때는주의하십시오. 일부 프로세서가 다른 프로그램에서 사용중인 경우 성능을 향상시키기보다는 실제로 성능을 저하시킬 수 있습니다. 실제 스레드보다 더 많은 기능을 만들도록 GHC에 요청하는 것은 거의 항상 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="030ba515acd2d25ee94d7a99ab66ba47851bdf13" translate="yes" xml:space="preserve">
          <source>Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; to check that the called foreign function is prepared to deal with the consequences of the call being interrupted. On Unix it is considered good practice to always check for &lt;code&gt;EINTR&lt;/code&gt; after system calls, so you can expect it not to crash (but in that case &lt;code&gt;interruptible&lt;/code&gt; will not work as intended unless the code then returns all the way up to Haskell as described above). But on Windows it is not typically common practice to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">호출 된 외부 함수가 인터럽트되는 호출의 결과를 처리 할 준비가되었는지 확인하기 위해 &lt;code&gt;interruptible&lt;/code&gt; 을 사용할 때 특히주의하십시오 . Unix에서는 시스템 호출 후에 항상 &lt;code&gt;EINTR&lt;/code&gt; 을 확인하는 것이 좋습니다 . 따라서 충돌하지 않을 것으로 예상 할 수 있습니다 (하지만이 경우 코드가 위에서 설명한대로 Haskell까지 반환하지 않는 한 &lt;code&gt;interruptible&lt;/code&gt; 은 의도 한대로 작동하지 않습니다). . 그러나 Windows에서는 일반적으로 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; 를 처리하는 것이 일반적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e6215070ac7ba503783ef4dcd9847d43461c01e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 즉, 프로그램이 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 값을 거의 사용하지 않는 경우 썽크가 메모리에 쌓여 공간 누수가 발생합니다. 이것은 IORef를 카운터로 사용할 때 흔히 범하는 실수입니다. 예를 들어 다음은 스택 오버플로를 생성 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e632134338b9cc24cdcec9c2ad59ac6cbe767e2" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 이것은 프로그램이 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 그 값을 거의 사용하지 않으면 썽크가 메모리에 쌓여 공간이 누출되는 것을 의미합니다. IORef를 카운터로 사용할 때 흔히 발생하는 실수입니다. 예를 들어 다음과 같은 경우 스택 오버플로가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55340cb5b344cb0896b46c3e02107cead57c765e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 즉, 프로그램이 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 값을 거의 사용하지 않는 경우 썽크가 메모리에 쌓여 공간 누수가 발생합니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 를 카운터로 사용할 때 흔히 범하는 실수 입니다. 예를 들어, 다음은 메모리 누수로 인해 스택 오버플로가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9146268e3a870b89574a63d603a9a4c2b804fc8e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">경고 수 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 가 엄격 기능이 적용되지 않습니다. 즉, 프로그램이 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; 를 여러 번 호출 하지만 값을 거의 사용하지 않으면 썽크가 메모리에 쌓여 공간이 누출됩니다. &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 를 카운터로 사용할 때 흔히 발생하는 실수 입니다. 예를 들어, 다음은 메모리 누수로 인해 스택 오버플로가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac5eb692c23fe608a9eb6b4fa5f11c0d62b8835" translate="yes" xml:space="preserve">
          <source>Be warned, these functions can be used to construct ill-kinded type representations.</source>
          <target state="translated">이러한 함수를 사용하여 잘못된 유형 표현을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7554aac55bd08ae4a1829bdc1657e239450fe1f9" translate="yes" xml:space="preserve">
          <source>Be warned: this is an experimental facility, with fewer checks than usual. Use &lt;code&gt;-dcore-lint&lt;/code&gt; to typecheck the desugared program. If Core Lint is happy you should be all right.</source>
          <target state="translated">경고 : 이것은 평소보다 점검이 적은 실험 시설입니다. &lt;code&gt;-dcore-lint&lt;/code&gt; 를 사용하여 desugared 프로그램을 유형 검사하십시오. 코어 린트가 행복하다면 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdd46744a0edc96d38a6d8119838b4d615e82dd7" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">연관된 패밀리 인스턴스 의 &lt;em&gt;오른쪽&lt;/em&gt; 에 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 확장 을 사용하여 &lt;em&gt;종류&lt;/em&gt; 매개 변수 를 포함 할 수도 있습니다 . 예를 들어이 클래스와 인스턴스는 완벽하게 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4123c9a7cc2c0e3ec676685e293b58dd27e565" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">연관된 패밀리 인스턴스 의 &lt;em&gt;오른쪽에 &lt;/em&gt;&lt;em&gt;종류&lt;/em&gt; 매개 변수 가 포함될 수도 있습니다 ( &lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 확장 사용). 예를 들어,이 클래스와 인스턴스는 완벽하게 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7efc4e2f9d66a82f758a773da6630b93a7985e7a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 는 Haskell 문법에서 특별히 취급 되기 때문에 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 섹션이 아니라 접두사 부정의 적용입니다. 그러나 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 허용되지 않는 섹션과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c608a2b36ee0d8fe295adfc9f68da466a5a7382" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 는 Haskell 문법에서 특별히 취급 되기 때문에 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;-e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 섹션이 아니라 접두사 부정의 적용입니다. 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; 는 허용되지 않는 섹션과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b2c5ca5dad541aa7265cf458075ac55886113df" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; is the only field of &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; depending on &lt;code&gt;m&lt;/code&gt;, the expression &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; leads to a type error from being too general. This function works around that issue, and may become unnecessary if another field depending on &lt;code&gt;m&lt;/code&gt; is added.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;m&lt;/code&gt; 에 따라 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; 의 유일한 필드 이므로 , &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; 식은 유형 오류가 너무 일반적이지 않습니다. 이 기능은이 문제를 해결하며 &lt;code&gt;m&lt;/code&gt; 에 따라 다른 필드 를 추가 하면 필요하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b457de1c6b2d821b49b86e8b76d929d48f11800" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">때문에 &lt;code&gt;~&lt;/code&gt; 이 일반적인 평등 관계이며, GHC는 출력합니다 &lt;code&gt;~~&lt;/code&gt; 처럼 &lt;code&gt;~&lt;/code&gt; 하지 않는 &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt; 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e7e24ec7e3c0fdbaa3e27a95a2858ab8e68585" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 가 더 일반적인 등식 관계 이기 때문에 &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt; 가 설정되어 있지 않으면 GHC는 &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; 를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a7118064a4d44aa8f245264afef0d428f57c57f6" translate="yes" xml:space="preserve">
          <source>Because Haskell objects and libraries tend to be large, it can take many real seconds to slurp the bits to/from a remote filesystem.</source>
          <target state="translated">Haskell 객체와 라이브러리는 크기가 크므로 원격 파일 시스템과 비트를 교환하는 데 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e3d53125a21f513cc7ad6223feeb5607db810b" translate="yes" xml:space="preserve">
          <source>Because bounded primitives are the more general case, in this documentation we only refer to fixed size primitives where it matters that the resulting sequence of bytes is of a fixed length. Otherwise, we just refer to bounded size primitives.</source>
          <target state="translated">경계 프리미티브가 더 일반적인 경우이므로이 문서에서는 결과 바이트 시퀀스의 길이가 고정 길이 인 고정 크기 프리미티브 만 참조합니다. 그렇지 않으면, 우리는 경계 크기 프리미티브를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b5fdc31bfd5809c4f1c4e511c746ab15cfe4b9d1" translate="yes" xml:space="preserve">
          <source>Because local fixity declarations are technically Haskell 98, no extension is necessary to enable them.</source>
          <target state="translated">로컬 고정 선언은 기술적으로 Haskell 98이므로이를 활성화하기 위해 확장이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de8ee7dd4338a2055669c56f86b3139945bd3682" translate="yes" xml:space="preserve">
          <source>Because of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; is unclear name, we use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; for alias of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 때문에 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 가 불분명 한 이름을, 우리는 사용 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; 을 의 별칭 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fcb8636cfa970f434fa5b94db2cb53e2de61b75" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;#12971&lt;/a&gt; for more.</source>
          <target state="translated">도구 체인 제한으로 인해 Windows에서 전체 유니 코드 경로를 지원할 수 없습니다. Windows에서는 Latin-1까지 지원합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;# 12971&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fbf59b2f9a8d04abba49afed510bca079acda23" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;Issue #12971&lt;/a&gt; for more.</source>
          <target state="translated">툴체인 제한으로 인해 Windows에서 전체 유니 코드 경로를 지원할 수 없습니다. Windows에서는 최대 Latin-1을 지원합니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;문제 # 12971&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1351fede99f7574d382011519c832e48e2febe1" translate="yes" xml:space="preserve">
          <source>Because of the aggressive optimization that GHC performs to the programs it compiles it is quite difficult to pin-point exactly which point in the source program a given machine instruction should be attributed to. In fact, internally GHC associates each instruction with a &lt;strong&gt;set&lt;/strong&gt; of source locations. When emitting the standard debug information used by &lt;code&gt;gdb&lt;/code&gt; and other language-agnostic debugging tools, GHC is forced to heuristically choose one location from among this set.</source>
          <target state="translated">GHC가 프로그램에 대해 수행하는 적극적인 최적화로 인해 소스 프로그램에서 주어진 머신 명령어의 정확한 포인트를 정확히 찾아내는 것은 매우 어렵습니다. 실제로 내부 GHC는 각 명령어를 소스 위치 &lt;strong&gt;세트&lt;/strong&gt; 와 연관시킵니다 . &lt;code&gt;gdb&lt;/code&gt; 및 기타 언어에 구애받지 않는 디버깅 도구에서 사용하는 표준 디버그 정보를 내보낼 때 GHC는이 세트 중에서 하나의 위치를 ​​경험적으로 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="526af66ce39268b28da886109bb8d1f1638720be" translate="yes" xml:space="preserve">
          <source>Because of the lack of an outermost &lt;code&gt;forall&lt;/code&gt; in the type of &lt;code&gt;MkT&lt;/code&gt;, the &lt;code&gt;b&lt;/code&gt; would be implicitly quantified. In effect, it would be as if one had written &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt;, which contains nested &lt;code&gt;forall&lt;/code&gt;s. See &lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;Formal syntax for GADTs&lt;/a&gt;.</source>
          <target state="translated">때문에 최의 부족 &lt;code&gt;forall&lt;/code&gt; 유형의 &lt;code&gt;MkT&lt;/code&gt; 상기 &lt;code&gt;b&lt;/code&gt; 내재적으로 정량화 될 것이다. 실제로는 마치 &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt; 작성한 것과 같습니다. (forall a. a-&amp;gt; b-&amp;gt; T) , 중첩 된 &lt;code&gt;forall&lt;/code&gt; 을 포함 합니다. &lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;GADT의 형식적 구문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d22c87e1c1a19e64881fa0a5c29ea8d152160afd" translate="yes" xml:space="preserve">
          <source>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; should come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;-l ⟨bar⟩&lt;/code&gt; on the command line.</source>
          <target state="translated">대부분의 UNIX 링커의 상태가 좋지 않기 때문에 이러한 옵션의 순서는 중요합니다. 라이브러리 ⟨foo⟩에 라이브러리 ⟨bar⟩가 필요한 경우, 일반적으로 &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; 는 명령 행에서 &lt;code&gt;-l ⟨bar⟩&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야 합니다.</target>
        </trans-unit>
        <trans-unit id="aefb27d5d1f818fec24e956de3be5cc43a462d50" translate="yes" xml:space="preserve">
          <source>Because of this, unlike &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, explicit binding of type/kind variables in default declarations is not permitted by &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 때문에 &lt;a href=&quot;#assoc-inst&quot;&gt;연결된 인스턴스&lt;/a&gt; 와 달리 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 은 기본 선언에서 형식 / 종류 변수의 명시 적 바인딩을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f47acccf5b190df69b3205bc25cdf837d4bc4d64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;IArray&lt;/code&gt; interface provides operations overloaded on the type of the array, it should be possible to just change the array type being used by a program from say &lt;code&gt;Array&lt;/code&gt; to &lt;code&gt;UArray&lt;/code&gt; to get the benefits of unboxed arrays (don't forget to import &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; instead of &lt;a href=&quot;data-array&quot;&gt;Data.Array&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;IArray&lt;/code&gt; 인터페이스는 배열 유형에 오버로드 된 작업을 제공 하기 때문에 프로그램에서 사용하는 배열 유형을 &lt;code&gt;Array&lt;/code&gt; 에서 &lt;code&gt;UArray&lt;/code&gt; 로 변경하면 상자없는 배열 의 이점을 얻을 수 있습니다 ( &lt;a href=&quot;data-array-unboxed&quot;&gt;데이터&lt;/a&gt; 를 가져 오는 것을 잊지 마십시오) . Data.Array 대신 &lt;a href=&quot;data-array&quot;&gt;Array.Unboxed&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="73825efb186a67ab4235b4b330529ec46440f89c" translate="yes" xml:space="preserve">
          <source>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be levity-polymorphic.</source>
          <target state="translated">코드 생성기는 변수뿐만 아니라 인수를 저장하고 이동해야하기 때문에 위의 논리는 함수 인수에 동일하게 적용되며, 이는 유사도 다형성이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b922e23af5d396ea51043a6f5495cb7265ef575" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대해 인덱스를 검사해야하므로 &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 은 bounds 인수와 연관 목록의 인덱스에서 엄격하지만 값은 엄격하지 않습니다. 따라서 다음과 같은 재발이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="744b8a2e53d06a3c0594d327e50d361273a6ea66" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list. Whether &lt;code&gt;array&lt;/code&gt; is strict or non-strict in the elements depends on the array type: &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; is a non-strict array type, but all of the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; arrays are strict. Thus in a non-strict array, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대한 인덱스를 확인해야하므로 범위 인수와 연관 목록의 인덱스에서 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 이 엄격합니다. 여부 &lt;code&gt;array&lt;/code&gt; : 요소의 엄격한 또는 비 엄격한 것은 배열 유형에 따라 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 아닌 엄격한 배열 유형이지만, 모든 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 의 배열은 엄격합니다. 따라서 엄격하지 않은 배열에서는 다음과 같은 반복이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1ead8ebe60edd2b98db40ca3daeca484e250542a" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">이러한 오류에 대해 인덱스를 검사해야하므로 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; 은 bounds 인수와 연관 목록의 인덱스에서 엄격하지만 값은 엄격하지 않습니다. 따라서 다음과 같은 재발이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3877a6244217b5631d19062ad9620975d2dde55e" translate="yes" xml:space="preserve">
          <source>Because the preprocessor targets Haskell (rather than Core), &lt;code&gt;let&lt;/code&gt;-bound variables are monomorphic.</source>
          <target state="translated">전처리 기가 Core가 아닌 Haskell을 대상으로하기 때문에 &lt;code&gt;let&lt;/code&gt; - bound 변수는 단형입니다.</target>
        </trans-unit>
        <trans-unit id="808844f69c7e9605bc105a4ad20ea2d366849e5a" translate="yes" xml:space="preserve">
          <source>Because there is no unboxed unit tuple, the following expression</source>
          <target state="translated">박스 단위의 튜플이 없기 때문에 다음 식</target>
        </trans-unit>
        <trans-unit id="76fec9d9feb8d4cfd75fa0cf83ef0298228be150" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">까다로운 프로파일 링에는 GHC 내부에 대해 어느 정도 익숙해야하므로 설명서를 GHC 개발자 위키로 옮겼습니다. 틱 틱한 프로파일 링 페이지에 대한 링크가 포함 된 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;프로파일 링 옵션 개요를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="50cb7c0b41fc81c206b893c65bdf7993f9032da2" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">까다로운 프로파일 링을 위해서는 GHC 내부에 대한 어느 정도의 친숙 함이 필요하기 때문에 문서를 GHC 개발자 위키로 옮겼습니다. 까다로운 프로파일 링 페이지에 대한 링크가 포함 된 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;프로파일 링 옵션 개요를&lt;/a&gt; 살펴보세요 .</target>
        </trans-unit>
        <trans-unit id="0697b298a873826983783cd5e687ae37a97dd6a7" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includes a link to the ticky-ticky profiling page.</source>
          <target state="translated">까다로운 프로파일 링을 위해서는 GHC 내부에 대한 어느 정도의 친숙 함이 필요하기 때문에 문서를 GHC 개발자 위키로 옮겼습니다. 까다로운 프로파일 링 페이지에 대한 링크가 포함 된 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;프로파일 링 옵션 개요를&lt;/a&gt; 살펴보세요 .</target>
        </trans-unit>
        <trans-unit id="2d85fe57284106ee9c63c6a96e2335fd4a4543d3" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in a polymorphic datatype. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">unboxed 유형은 포인터를 사용하지 않고 표현되기 때문에 다형성 데이터 유형에 저장할 수 없습니다. 예를 들어, &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42#&lt;/code&gt; 로부터 다를 할 것입니다 &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42&lt;/code&gt; ; 전자는 정수를 직접 저장하고 후자는 포인터를 저장합니다. GHC는 현재 이러한 다양한 &lt;code&gt;Just&lt;/code&gt; 노드를 지원하지 않습니다 (다른 데이터 유형도 지원하지 않음 ). 따라서, &lt;em&gt;종류&lt;/em&gt; 박싱 형은 박스 타입의 종류는 다르다.</target>
        </trans-unit>
        <trans-unit id="f3d41195121db8c561952d390998012e5adf5323" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in use a polymorphic datatype at an unboxed type. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">박스형이 아닌 포인터는 포인터를 사용하지 않고 표현되기 때문에 박스형이 아닌 다형성 데이터 형을 사용하여 저장할 수 없습니다. 예를 들어, &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42#&lt;/code&gt; 로부터 다를 할 것입니다 &lt;code&gt;Just&lt;/code&gt; 의 노드 &lt;code&gt;Just 42&lt;/code&gt; ; 전자는 정수를 직접 저장하고 후자는 포인터를 저장합니다. GHC는 현재이 다양한 &lt;code&gt;Just&lt;/code&gt; 노드를 지원하지 않습니다 (다른 데이터 유형은 아님). 따라서, &lt;em&gt;종류&lt;/em&gt; 박싱 형은 박스 타입의 종류는 다르다.</target>
        </trans-unit>
        <trans-unit id="fe6fce85b24f15b5d65932c379eeca8ae6b18466" translate="yes" xml:space="preserve">
          <source>Becomes this:</source>
          <target state="translated">이것이된다 :</target>
        </trans-unit>
        <trans-unit id="0ef17ad67edcf83107e1af3022c4061c85509f1d" translate="yes" xml:space="preserve">
          <source>Before data is written, it is first encoded as UTF-8.</source>
          <target state="translated">데이터를 쓰기 전에 먼저 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="595c4c743cb61dcc0704188c65ab1109a331f426" translate="yes" xml:space="preserve">
          <source>Before going into the Safe Haskell details, let&amp;rsquo;s point out some of the reasons this security mechanism would fail without Safe Haskell:</source>
          <target state="translated">Safe Haskell 세부 정보로 이동하기 전에 Safe Haskell없이이 보안 메커니즘이 실패하는 몇 가지 이유를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="74554fdf503e2d7e6e96019d0ebd03e229b9e50a" translate="yes" xml:space="preserve">
          <source>Before resorting to explicit unboxed types, try using strict constructor fields and &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; first (see above). That way, your code stays portable.</source>
          <target state="translated">명시 적 언 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 타입에 의지하기 전에 먼저 엄격한 생성자 필드와 -funbox-strict-fields를 사용 하십시오 (위 참조). 그렇게하면 코드를 이식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505eb2064aacbd9cf542da06128d3e808f292b7" translate="yes" xml:space="preserve">
          <source>Before using the Continuation monad, be sure that you have a firm understanding of continuation-passing style and that continuations represent the best solution to your particular design problem. Many algorithms which require continuations in other languages do not require them in Haskell, due to Haskell's lazy semantics. Abuse of the Continuation monad can produce code that is impossible to understand and maintain.</source>
          <target state="translated">연속 모나드를 사용하기 전에 연속 전달 스타일에 대해 잘 알고 있고 연속이 특정 설계 문제에 대한 최상의 솔루션인지 확인하십시오. 다른 언어로 연속을 요구하는 많은 알고리즘은 Haskell의 게으른 의미로 인해 Haskell에서 필요하지 않습니다. Continuation 모나드의 남용은 이해하고 유지하기 어려운 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da8e18ee240f54f494c1090de6f01f19305fb9e" translate="yes" xml:space="preserve">
          <source>Before you get too carried away working at the lowest level (e.g., sloshing &lt;code&gt;MutableByteArray#&lt;/code&gt;s around your program), you may wish to check if there are libraries that provide a &amp;ldquo;Haskellised veneer&amp;rdquo; over the features you want. The separate &lt;a href=&quot;../libraries/index&quot;&gt;libraries documentation&lt;/a&gt; describes all the libraries that come with GHC.</source>
          <target state="translated">가장 낮은 수준 (예 : 프로그램 주변의 &lt;code&gt;MutableByteArray#&lt;/code&gt; 에서 작업을 너무 많이 수행하기 전에 원하는 기능에 대해 &quot;Haskellised veneer&quot;를 제공하는 라이브러리가 있는지 확인할 수 있습니다. 별도의 &lt;a href=&quot;../libraries/index&quot;&gt;라이브러리 설명서&lt;/a&gt; 는 GHC와 함께 제공되는 모든 라이브러리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6e79eaaaac969988bacd211dc7719f705249b6b2" translate="yes" xml:space="preserve">
          <source>Begin or end a multi-line GHCi command block.</source>
          <target state="translated">여러 줄 GHCi 명령 블록을 시작하거나 종료합니다.</target>
        </trans-unit>
        <trans-unit id="aaa2d30b9548c8c6360214c67d65f8f2b43a2ef2" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to lock</source>
          <target state="translated">잠글 파일의 시작 오프셋</target>
        </trans-unit>
        <trans-unit id="a88e403def4a0ef34fb4cbdd6fb4234e3d4de40f" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to unlock</source>
          <target state="translated">잠금 해제 할 파일의 시작 오프셋</target>
        </trans-unit>
        <trans-unit id="a603260088041becc44147197033a240091e8107" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 6.12, text I/O is performed using the system or handle's current locale and line ending conventions.</source>
          <target state="translated">GHC 6.12부터 시스템 또는 핸들의 현재 로케일 및 줄 끝 규칙을 사용하여 텍스트 I / O가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f3aa22597a1e0633e605134fce9271b6f0ab9592" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 7.2, it is possible to use binary serialization without writing any instance boilerplate code.</source>
          <target state="translated">GHC 7.2부터 인스턴스 상용구 코드를 작성하지 않고도 이진 직렬화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="3b615d319efe934d18d838650aea75dd222232f9" translate="yes" xml:space="preserve">
          <source>Behaviors</source>
          <target state="translated">Behaviors</target>
        </trans-unit>
        <trans-unit id="198a78dbe4628d2be1564fc1b18cd50856f7b448" translate="yes" xml:space="preserve">
          <source>Behind all these special cases there is a simple guiding principle. Consider</source>
          <target state="translated">이러한 모든 특수한 사례 뒤에는 간단한 지침 원칙이 있습니다. 치다</target>
        </trans-unit>
        <trans-unit id="9927980f0adf7f518791c8284a901dec62d24eaf" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹 의 일부인 이 경고는 기본적으로 해제되어 있지만 향후 GHC 릴리스에서 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)의&lt;/a&gt; 일부로 켜집니다 .</target>
        </trans-unit>
        <trans-unit id="7b666df63b130afff3eedd81208b2e0a7a134951" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부 이므로이 경고는 기본적으로 해제되어 있지만 향후 GHC 릴리스에서 켜집니다.</target>
        </trans-unit>
        <trans-unit id="2dc8c83454270735d86a9e3ef3fee23e1a680d7a" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹 의 일부인 이 경고는 기본적으로 꺼져 있지만 &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MFP (MonadFail Proposal)의&lt;/a&gt; 일부로 향후 GHC 릴리스에서 켜질 예정 입니다.</target>
        </trans-unit>
        <trans-unit id="f03e9e7f99ad75ac4d7551b349bf9316b17b8429" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부이기 때문에이 경고는 기본적으로 꺼져 있지만 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MFP (MonadFail Proposal)의&lt;/a&gt; 일부로 향후 GHC 릴리스에서 켜질 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e424286d0dd9624ae70bbdecffd2b0043a24233e" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부 이므로이 경고는 기본적으로 꺼져 있지만 향후 GHC 릴리스에서 켜질 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c04a6e766fbff8072acd4912e7880d5f0b4d39b" translate="yes" xml:space="preserve">
          <source>Being strict by being lazy</source>
          <target state="translated">게으름으로써 엄격함</target>
        </trans-unit>
        <trans-unit id="969fbe69d4fd12dcb8cd78548a9408fd636a4a1d" translate="yes" xml:space="preserve">
          <source>Bell alerts</source>
          <target state="translated">벨 알림</target>
        </trans-unit>
        <trans-unit id="36c94be5c6badc8ef160f60b3f9d24d9b2c8db30" translate="yes" xml:space="preserve">
          <source>Below are two examples showing a definition of a reusable less-polymorphic &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and a one-off in-line specialisation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음은 재사용 가능한 덜 다형성 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 의 정의 와 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 일회성 인라인 특수화를 보여주는 두 가지 예 입니다 .</target>
        </trans-unit>
        <trans-unit id="9405867e098bc21ea37caa6071fbd884463207a3" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음은 &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="631e6a2e29c9e7487b85c9d3fda8e1229ccc3cd2" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음은 &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt; 의 샘플 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b2041b4df1603971cd99daa2131b9173fce20a5d" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음은 &lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; 을&lt;/a&gt; 사용한 동일한 샘플의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="7895436348a83297630a392863829501eafbcaec" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">아래는 &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; 을&lt;/a&gt; 사용한 동일한 샘플의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="9dafb52c45cfdbf863160a686861b97310393d60" translate="yes" xml:space="preserve">
          <source>Below we construct a &lt;code&gt;Foldable&lt;/code&gt; instance for a data type representing a (finite) binary tree with depth-first traversal.</source>
          <target state="translated">아래에서는 깊이 우선 순회를 사용하여 (유한) 이진 트리를 나타내는 데이터 유형에 대한 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a29d5a1f385485805511ac832659c0faf4251bd6" translate="yes" xml:space="preserve">
          <source>Below we implement an analogous data structure using a representation based on &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This is an example of &lt;em&gt;Church encoding&lt;/em&gt; (named after Alonzo Church, inventor of the lambda calculus).</source>
          <target state="translated">아래에서는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 기반의 표현을 사용하여 유사한 데이터 구조를 구현합니다 . 이것은 &lt;em&gt;교회 인코딩&lt;/em&gt; 의 예입니다 (람다 미적분의 발명가 인 Alonzo Church의 이름을 따서 명명 됨).</target>
        </trans-unit>
        <trans-unit id="98ad2d7635fc111746d76bbebe8290141e95c77d" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 를 다른 사전 구현과 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="accf09ba43e68b9c38f3e58c7eda4b805b21f104" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; 와 다른 사전 구현을 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8166d1f6f68785d8abaf21c7a0c48450cb6c1c1e" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; 를 다른 사전 구현과 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c3dee153b5361c9c8871a11980becccab3e42dc" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; 와 다른 사전 구현을 비교하는 벤치 마크 는 &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ffe14aeb84cb87ee3186a9571b06e8928ba55d3" translate="yes" xml:space="preserve">
          <source>Beside</source>
          <target state="translated">Beside</target>
        </trans-unit>
        <trans-unit id="fe92499c572ca34751830e44318f456f3cef3984" translate="yes" xml:space="preserve">
          <source>Beside, separated by space</source>
          <target state="translated">옆으로, 공간으로 구분</target>
        </trans-unit>
        <trans-unit id="788b6f6586539d7fc47b8fcc55c19730cea68d99" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e330d7aca54bde1e02fdeabed64fcc133a6401a" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e618be55395d8238a159850eddcfbe3ac7a7c273" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지 않으면 공백으로 구분됩니다 . &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 아이디가 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="624607c86787dd5201e891b5c7bb38bfd2a78db7" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88ff324bd9ae359aacf25e29a3916a4ff7c3758" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d384f6b4d5525841d1e0cf79b191835355e54bd2" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">빗나가서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있고 ID는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ed1a12122824af84b077aa03948e1d13a22d0d" translate="yes" xml:space="preserve">
          <source>Besides an extra-constraints wildcard (see &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;Extra-Constraints Wildcard&lt;/a&gt;), only named wildcards can occur in the constraints, e.g. the &lt;code&gt;_x&lt;/code&gt; in &lt;code&gt;Show _x&lt;/code&gt;.</source>
          <target state="translated">여분 제약 (참조 와일드 카드 외에 &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;엑스트라 제약 와일드 카드&lt;/a&gt; ) 만라는 이름의 와일드 카드는 예를 들어, 제약 조건에서 발생할 수 &lt;code&gt;_x&lt;/code&gt; 에 &lt;code&gt;Show _x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a472de725e2ab48d4de069fd18a472bb691f2e" translate="yes" xml:space="preserve">
          <source>Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</source>
          <target state="translated">모든 메소드 정의를 생성하여 인스턴스를 파생하는 재고 접근 방식 외에도 GHC는 임의의 클래스를 파생시킬 수있는 두 가지 추가 파생 전략을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bf2ddad2d8faffde93e2583147aba1ed84271cf8" translate="yes" xml:space="preserve">
          <source>Beware that for many monads (those for which the &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict) this instance will &lt;em&gt;not&lt;/em&gt; satisfy the right-tightening law required by the &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">많은 모나드를위한 (그 대상이되는 것을주의 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 이 인스턴스가됩니다 작업이 엄격하다) &lt;em&gt;하지&lt;/em&gt; 에 의해 요구되는 오른쪽 조임 법률 만족 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; 의 클래스를.</target>
        </trans-unit>
        <trans-unit id="5d549c234ccdd45fa67e66fd17e9aa5b7f98bef5" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">경우에 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 기능 을 사용하려면 UndecidableInstances 확장 을 활성화해야 할 수도 있습니다. 이것이 왜 일어날 수 있는지를 보여주는 병리학 적 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c1558fc208f9daac585e394451c0ebdd033dbc" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">경우에 &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 기능 을 사용하려면 UndecidableInstances 확장 을 활성화해야 할 수도 있습니다. 이것이 왜 일어날 수 있는지를 보여주는 병리학적인 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="653c3c82d14b666acef082f6f19dc453202cc92e" translate="yes" xml:space="preserve">
          <source>Beware that this function allocates a new file descriptor. A consequence of this is that calling &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; on the standard Windows handles will not give you &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For example, if you run this code:</source>
          <target state="translated">이 함수는 새로운 파일 디스크립터를 할당합니다. 그 결과 표준 Windows 핸들에서 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; 을 호출 해도 &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 가 제공되지 않습니다 . 예를 들어이 코드를 실행하면</target>
        </trans-unit>
        <trans-unit id="7827a30613f0ebab2ac4ede20720ab2ad59250c6" translate="yes" xml:space="preserve">
          <source>Beware: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; truncates multi-byte characters to octets. e.g. &quot;枯朶に烏のとまりけり秋の暮&quot; becomes �6k�nh~�Q��n�</source>
          <target state="translated">주의 : &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; 은 멀티 바이트 문자를 8 진수로 자릅니다. 예를 들어, &quot;枯 朶 に 烏 の と ま り け り 秋 の 暮&quot;는 6k nh ~ Q n이됩니다.</target>
        </trans-unit>
        <trans-unit id="2d677a45c1242d143f2da8c0235a4156fc9aed39" translate="yes" xml:space="preserve">
          <source>Bidirectional</source>
          <target state="translated">Bidirectional</target>
        </trans-unit>
        <trans-unit id="03af5d044e78c5ca2a87b11a0cd3ee30426faaa4" translate="yes" xml:space="preserve">
          <source>Bifoldable</source>
          <target state="translated">Bifoldable</target>
        </trans-unit>
        <trans-unit id="6148a7120e3e6bee1841037a0e66edba57f2b59d" translate="yes" xml:space="preserve">
          <source>Bifunctor</source>
          <target state="translated">Bifunctor</target>
        </trans-unit>
        <trans-unit id="a1ec611991374940381b1e25467f733adcf02bbc" translate="yes" xml:space="preserve">
          <source>Big-endian</source>
          <target state="translated">Big-endian</target>
        </trans-unit>
        <trans-unit id="f84c8cdd20adeb4d710d8f5e51b3ed37c2ffc31f" translate="yes" xml:space="preserve">
          <source>Big-endian decoding</source>
          <target state="translated">빅 엔디안 디코딩</target>
        </trans-unit>
        <trans-unit id="a75e84204fb542f8fffbe1d93f24c4127709d703" translate="yes" xml:space="preserve">
          <source>Big-endian primitives</source>
          <target state="translated">빅 엔디안 프리미티브</target>
        </trans-unit>
        <trans-unit id="d80f000c501b0702089f0a6d5d685b3b13d95ab4" translate="yes" xml:space="preserve">
          <source>Big-endian writes</source>
          <target state="translated">빅 엔디안 쓰기</target>
        </trans-unit>
        <trans-unit id="b092fd4b540ba704e7eab5010e33d073c85baa3e" translate="yes" xml:space="preserve">
          <source>BigEndian</source>
          <target state="translated">BigEndian</target>
        </trans-unit>
        <trans-unit id="4a103563aecb5d07999bf55551e2840da08dea6b" translate="yes" xml:space="preserve">
          <source>BigNat</source>
          <target state="translated">BigNat</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="ca596333bdb84d8c57915427010182cfc758ccf1" translate="yes" xml:space="preserve">
          <source>Binary encodings</source>
          <target state="translated">이진 인코딩</target>
        </trans-unit>
        <trans-unit id="b7a0b74a0efeea7a4ae51a1506822c7ba3cdfd5b" translate="yes" xml:space="preserve">
          <source>Binary input and output</source>
          <target state="translated">이진 입력 및 출력</target>
        </trans-unit>
        <trans-unit id="977f362d04f5411618935479aa90d3c2cbbc8fc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation</source>
          <target state="translated">이진 직렬화</target>
        </trans-unit>
        <trans-unit id="e899d0e0bf36df2f1e4a7c2fa0c0833fc062acdf" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">과 게으른에서 하스켈 값의 바이너리 직렬화 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 의. 이진 라이브러리는 Haskell 값을 바이트 스트림으로 메모리에 직접 인코딩하는 방법을 제공합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 디스크에 쓰거나 네트워크를 통해 보내거나 추가로 처리 할 수 ​​있습니다 (예 : gzip으로 압축).</target>
        </trans-unit>
        <trans-unit id="21a20ed9e4ba0673faa9314d967e4c8a18a9ddc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 간의 Haskell 값의 이진 직렬화 . Binary 라이브러리는 Haskell 값을 메모리에서 직접 바이트 스트림으로 인코딩하는 방법을 제공합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 디스크에 기록하거나 네트워크를 통해 전송하거나 추가 처리 (예 : gzip으로 압축) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f05e0ce4c49719ca18e235c0a5338e6c9f82d92" translate="yes" xml:space="preserve">
          <source>Binary-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s do no newline translation at all.</source>
          <target state="translated">이진 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 개행 변환을 전혀하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e65c3b7cae6dd45ee04f43d6dc7e91ad9857ed8" translate="yes" xml:space="preserve">
          <source>BinaryLiterals</source>
          <target state="translated">BinaryLiterals</target>
        </trans-unit>
        <trans-unit id="ef29ec8d1db838c8e1a48ba8918f31da08b74947" translate="yes" xml:space="preserve">
          <source>BinaryType</source>
          <target state="translated">BinaryType</target>
        </trans-unit>
        <trans-unit id="6bc6b5d113e80feddce377fd7a1ee8583e9b656f" translate="yes" xml:space="preserve">
          <source>Bind worker threads on a capability to the appropriate node.</source>
          <target state="translated">기능의 작업자 스레드를 적절한 노드에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="250887693e686f9b9bf4bfdc01f65dbe05d0a943" translate="yes" xml:space="preserve">
          <source>Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.</source>
          <target state="translated">함수를 모나드 값에 바인딩하면 함수를 모나드 계산의 연속으로 사용하는 새로운 연속이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="df37671abb2b5d29837d448a150784288f14c591" translate="yes" xml:space="preserve">
          <source>Binding strategy:</source>
          <target state="translated">바인딩 전략 :</target>
        </trans-unit>
        <trans-unit id="f86ed004f3a732d1f540de4195d20a7e54011bbe" translate="yes" xml:space="preserve">
          <source>Bindings are translated with the &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; functions to the usual do-notation:</source>
          <target state="translated">바인딩은 함께 번역 &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; 및 &lt;code&gt;return&lt;/code&gt; 일반적인 DO-표기법 기능 :</target>
        </trans-unit>
        <trans-unit id="c5508d22bc8524cbfc21537e7df0e0da3d89023d" translate="yes" xml:space="preserve">
          <source>Bindings:</source>
          <target state="translated">Bindings:</target>
        </trans-unit>
        <trans-unit id="d77c376e13dda253679750f2f2a4005705a750a7" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;response&lt;/code&gt; to the result of the following &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; block, binds &lt;code&gt;exit&lt;/code&gt; to the continuation.</source>
          <target state="translated">귀속의 &lt;code&gt;response&lt;/code&gt; 은 다음의 결과에 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; 의 블록은 결합 &lt;code&gt;exit&lt;/code&gt; 계속합니다.</target>
        </trans-unit>
        <trans-unit id="2fe1387ba65691c262469ad0ad878d77f589b9fd" translate="yes" xml:space="preserve">
          <source>Biographical profiling samples start with the &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; event. These events also include a timestamp which indicates when the sample was taken. This is because all these samples will appear at the end of the eventlog due to how the biographical profiling mode works. You can use the timestamp to reorder the samples relative to the other events.</source>
          <target state="translated">전기 프로파일 링 샘플은 &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트로 시작합니다 . 이러한 이벤트에는 샘플을 가져온시기를 나타내는 타임 스탬프도 포함됩니다. 이는 전기 프로파일 링 모드가 작동하는 방식으로 인해 이러한 모든 샘플이 이벤트 로그 끝에 표시되기 때문입니다. 타임 스탬프를 사용하여 다른 이벤트를 기준으로 샘플을 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bca52e9cf05fd2b526ca79883fe209959fdb0eb" translate="yes" xml:space="preserve">
          <source>Bit reversal</source>
          <target state="translated">비트 반전</target>
        </trans-unit>
        <trans-unit id="bd55858742523f8eb1bcf4b2ff338846c79cd3cf" translate="yes" xml:space="preserve">
          <source>Bit-operations</source>
          <target state="translated">Bit-operations</target>
        </trans-unit>
        <trans-unit id="3bb87577cfbf6b194391f9fd2449d3a6daeb5a6e" translate="yes" xml:space="preserve">
          <source>BitMap</source>
          <target state="translated">BitMap</target>
        </trans-unit>
        <trans-unit id="792ac9c6e86cf4159b4253d880e8d576591cad45" translate="yes" xml:space="preserve">
          <source>BitQueue</source>
          <target state="translated">BitQueue</target>
        </trans-unit>
        <trans-unit id="16859195f5f61ebc3eeb05fc2fd6fe7e5753102f" translate="yes" xml:space="preserve">
          <source>BitQueueB</source>
          <target state="translated">BitQueueB</target>
        </trans-unit>
        <trans-unit id="b3f2f3df0a3eb7ef036e378ae33aea93f8400b62" translate="yes" xml:space="preserve">
          <source>Bitraversable</source>
          <target state="translated">Bitraversable</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="f4eecb0837ac1302da3d67883bc955eb28db73ff" translate="yes" xml:space="preserve">
          <source>Bits are numbered from 0 with bit 0 being the least significant bit.</source>
          <target state="translated">비트는 0부터 번호가 매겨지며 비트 0은 최하위 비트입니다.</target>
        </trans-unit>
        <trans-unit id="51a3d80c1096a062a320e452d30389dbba6e7b2e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;</source>
          <target state="translated">비트 단위 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="c00a3cca6e0ab63567c09149e3d79bf22145be8a" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;.</source>
          <target state="translated">비트 단위 &quot;and&quot;.</target>
        </trans-unit>
        <trans-unit id="0762de2cf0c6e6b77d828208804bb630467f8b11" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;not&quot;, also known as the binary complement.</source>
          <target state="translated">이진 보수라고도하는 비트 단위 &quot;not&quot;.</target>
        </trans-unit>
        <trans-unit id="2ddacb26a9c51fdf4ca8a56ff66cbb76c9340f8f" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;</source>
          <target state="translated">비트 단위 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="c4b3b9bbde6c754b04ce738f6f2d6bfaa36d025e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;.</source>
          <target state="translated">비트 단위 &quot;또는&quot;.</target>
        </trans-unit>
        <trans-unit id="06ae84f662f3c26c21557288d7b8b92876ca8dee" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;</source>
          <target state="translated">비트 &quot;xor&quot;</target>
        </trans-unit>
        <trans-unit id="e3c7281d1f961f980af39f221c595b00177f9020" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;.</source>
          <target state="translated">비트 단위 &quot;xor&quot;.</target>
        </trans-unit>
        <trans-unit id="1aa01b99c6c9acf5a48b2725a9ba94e0bfd7f80c" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;code&gt;NOT&lt;/code&gt; operation</source>
          <target state="translated">비트 &lt;code&gt;NOT&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="683d2fe77a00a83b71f7046b5e0207bef8f8b05e" translate="yes" xml:space="preserve">
          <source>Bitwise AND operation</source>
          <target state="translated">비트 AND 연산</target>
        </trans-unit>
        <trans-unit id="812234cb7852ab2e4152ebfeecff0e34bbc8f331" translate="yes" xml:space="preserve">
          <source>Bitwise OR operation</source>
          <target state="translated">비트 OR 연산</target>
        </trans-unit>
        <trans-unit id="566da620243c869eb9093b1d9109361f7deab173" translate="yes" xml:space="preserve">
          <source>Bitwise XOR operation</source>
          <target state="translated">비트 XOR 연산</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="8f231bba8956b90d7be7998e87d3ff0f36931637" translate="yes" xml:space="preserve">
          <source>Blackholing is the act of marking a thunk (lazy computation) as being under evaluation. It is useful for three reasons: firstly it lets us detect certain kinds of infinite loop (the &lt;code&gt;NonTermination&lt;/code&gt; exception), secondly it avoids certain kinds of space leak, and thirdly it avoids repeating a computation in a parallel program, because we can tell when a computation is already in progress.</source>
          <target state="translated">블랙홀 링은 썽크 (게으른 계산)를 평가중인 것으로 표시하는 작업입니다. 세 가지 이유로 유용합니다. 첫째, 특정 종류의 무한 루프 ( &lt;code&gt;NonTermination&lt;/code&gt; 예외)를 감지 하고, 둘째로 특정 종류의 공간 누출을 피하고, 세 번째로 병렬 프로그램에서 계산을 반복하지 않습니다. 계산이 이미 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="574a76735e33bbd57fb0a916028cacc6070b3973" translate="yes" xml:space="preserve">
          <source>Block size</source>
          <target state="translated">블록 크기</target>
        </trans-unit>
        <trans-unit id="8b9a1d81d5887c9c67a6b20d2df16d43fe81caa7" translate="yes" xml:space="preserve">
          <source>Block the current thread until data can be written to the given file descriptor (GHC only).</source>
          <target state="translated">주어진 파일 디스크립터에 데이터를 쓸 수있을 때까지 현재 스레드를 차단하십시오 (GHC 만 해당).</target>
        </trans-unit>
        <trans-unit id="7065922fead5956b30a4880d4db36fbe6025cd84" translate="yes" xml:space="preserve">
          <source>Block the current thread until data is available to read on the given file descriptor (GHC only).</source>
          <target state="translated">주어진 파일 디스크립터에서 데이터를 읽을 수있을 때까지 현재 스레드를 차단하십시오 (GHC 전용).</target>
        </trans-unit>
        <trans-unit id="2032cada98db5faaa0692223c8180668544f801d" translate="yes" xml:space="preserve">
          <source>Block until input is available on specified file descriptor.</source>
          <target state="translated">지정된 파일 디스크립터에서 입력을 사용할 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="37d7b821bc5d453b65c16db21a1b548c820c28a2" translate="yes" xml:space="preserve">
          <source>Block until output is possible on specified file descriptor.</source>
          <target state="translated">지정된 파일 디스크립터에서 출력이 가능할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba5e142177e718c386fc68a7e5656d6003bdbf3" translate="yes" xml:space="preserve">
          <source>BlockArguments</source>
          <target state="translated">BlockArguments</target>
        </trans-unit>
        <trans-unit id="21ee9c95fd5afb5bc56f8da9452091ffececfb39" translate="yes" xml:space="preserve">
          <source>BlockReason</source>
          <target state="translated">BlockReason</target>
        </trans-unit>
        <trans-unit id="bc1ab004ab80487da68b0fe585fadda53b1d746e" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnMVar</source>
          <target state="translated">BlockedIndefinitelyOnMVar</target>
        </trans-unit>
        <trans-unit id="69236e61bca3edecfc65ca8a204134ba0de3fd74" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnSTM</source>
          <target state="translated">BlockedIndefinitelyOnSTM</target>
        </trans-unit>
        <trans-unit id="45dfab9fc5bfc0e525595e3313ce2a25dd4d7faa" translate="yes" xml:space="preserve">
          <source>BlockedOnBlackHole</source>
          <target state="translated">BlockedOnBlackHole</target>
        </trans-unit>
        <trans-unit id="93c9452da95239560e86200369ac0d634e21fb28" translate="yes" xml:space="preserve">
          <source>BlockedOnException</source>
          <target state="translated">BlockedOnException</target>
        </trans-unit>
        <trans-unit id="b61c27531d4d77cf1630fbca19ceced64a349e39" translate="yes" xml:space="preserve">
          <source>BlockedOnForeignCall</source>
          <target state="translated">BlockedOnForeignCall</target>
        </trans-unit>
        <trans-unit id="f3b3ba940976333504078cae62e2eabe3bbf8432" translate="yes" xml:space="preserve">
          <source>BlockedOnIOCompletion</source>
          <target state="translated">BlockedOnIOCompletion</target>
        </trans-unit>
        <trans-unit id="53d58631b450ca365b0ba176488a8441b143b2c2" translate="yes" xml:space="preserve">
          <source>BlockedOnMVar</source>
          <target state="translated">BlockedOnMVar</target>
        </trans-unit>
        <trans-unit id="895bd85890de6d5092a051ca56773fa4f0cd0c75" translate="yes" xml:space="preserve">
          <source>BlockedOnOther</source>
          <target state="translated">BlockedOnOther</target>
        </trans-unit>
        <trans-unit id="3804172b29d85f99db9a290a3dd685ef7d5c8d84" translate="yes" xml:space="preserve">
          <source>BlockedOnSTM</source>
          <target state="translated">BlockedOnSTM</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="0120b648baeefab9ba6ebfa6450b325f6a60cba8" translate="yes" xml:space="preserve">
          <source>BodyQ</source>
          <target state="translated">BodyQ</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="3f8b6ea3af3c50fa9d094ce543d63a1358584bcf" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;</source>
          <target state="translated">부울 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="04332ab31b7691eb315a3b0e8934a864c9ebacfa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;, lazy in the second argument</source>
          <target state="translated">두 번째 인수에서 게으른 부울 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="69265825ad6d4c4d64bf7e08030ff39e70a968fa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;not&quot;</source>
          <target state="translated">부울 &quot;not&quot;</target>
        </trans-unit>
        <trans-unit id="b22b4e8199107440fbfe7d97c6a6e57037c7151d" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;</source>
          <target state="translated">부울 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="0266fdeda44ec514d099d2f8107813680104acda" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;, lazy in the second argument</source>
          <target state="translated">두 번째 인수에서 게으른 부울 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="eb9c2517131e28267052868fb04f87dd8cb84e01" translate="yes" xml:space="preserve">
          <source>Boolean monoid under conjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 된 부울 모노 이드 ( &lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c181263cf12be8452e7085b87f90b355a0cc7ef9" translate="yes" xml:space="preserve">
          <source>Boolean monoid under disjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">분리 된 부울 모노 이드 ( &lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8ee67baf0a124b81be7277cfa2a8ff919c8c8724" translate="yes" xml:space="preserve">
          <source>Boolean predicate folds. These functions examine elements strictly until a condition is met, but then return a result ignoring the rest (lazy in the tail). These may loop forever given an unbounded input where no elements satisy the termination condition.</source>
          <target state="translated">부울 술어 접기. 이 함수는 조건이 충족 될 때까지 요소를 엄격하게 검사하지만 나머지를 무시한 결과를 반환합니다 (꼬리에 게으름). 종료 조건을 충족하는 요소가없는 경우 제한되지 않은 입력이 주어지면 영원히 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2732eeea43125f2e843ab5f5666a8d163b3d9289" translate="yes" xml:space="preserve">
          <source>Boolean type-level equality</source>
          <target state="translated">부울 유형 수준 평등</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="98b4ea6bcdbb948d8cbe34481cd1c0a07bd194e0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">두 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 는 에서 제공하는 인터페이스에 맞게 존재하는 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 유형 클래스를 있지만 구현하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 사용하여 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 을 반대 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 전자가 후자보다 더 효율적이기 때문에를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f34f496978794b63af2a314d45c261e70ec11ca" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">두 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 는 에서 제공하는 인터페이스에 맞게 존재하는 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 유형 클래스를 있지만 구현하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 사용하여 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 을 반대 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 전자가 후자보다 더 효율적이기 때문에를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b731e5f2cccb2521565e021975320c572150ee8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;, and pick an arbitrary one if multiple choices are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 둘 다 선택 가능하고 여러 선택 사항이있는 경우 임의의 것을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4d60c7bb83c292da504a6719a69ebefefdf4659e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">모두 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b44c00c13cb83fe026cbd5b8d4d766f125c9858" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F0&lt;/code&gt; have kind &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but their arity differs.</source>
          <target state="translated">둘 다 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F0&lt;/code&gt; &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 대해 종류가 있습니다 . k-&amp;gt; 유형 이지만 배열이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c5124f48e35e2fbfeb662d20bdb90a9e2a8cb8e0" translate="yes" xml:space="preserve">
          <source>Both module &lt;code&gt;Class&lt;/code&gt; and module &lt;code&gt;Dangerous&lt;/code&gt; will compile under &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; without issue. However, in module &lt;code&gt;TCB_Runner&lt;/code&gt;, we must check if the call to &lt;code&gt;op&lt;/code&gt; in function &lt;code&gt;f&lt;/code&gt; is safe.</source>
          <target state="translated">모듈 &lt;code&gt;Class&lt;/code&gt; 와 모듈 &lt;code&gt;Dangerous&lt;/code&gt; 모두 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 없이 안전하게 컴파일됩니다 . 그러나 &lt;code&gt;TCB_Runner&lt;/code&gt; 모듈 에서 함수 &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;op&lt;/code&gt; 호출 이 안전한지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="49ffa16e1c07272dd28d622d9dbdc1c18ed54d66" translate="yes" xml:space="preserve">
          <source>Both of these hold:</source>
          <target state="translated">이 두 가지 모두 보유 :</target>
        </trans-unit>
        <trans-unit id="2bafd70b5ada2ef0c84297ccc53777ff415bca1e" translate="yes" xml:space="preserve">
          <source>Both the type &lt;code&gt;Ex&lt;/code&gt; and the data constructor &lt;code&gt;MkEx&lt;/code&gt; get promoted, with the polymorphic kind &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt;. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</source>
          <target state="translated">&lt;code&gt;Ex&lt;/code&gt; 유형 과 데이터 생성자 &lt;code&gt;MkEx&lt;/code&gt; 모두 다형성 종류 &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt; 승격 됩니다. k-&amp;gt; 예 . 놀랍게도, 유형 레벨 존재의 멤버를 추출하기 위해 유형 패밀리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361b42712506425fdcf2b1ea50a51aa8dea82ef8" translate="yes" xml:space="preserve">
          <source>Both upper- and lower-case &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'F'&lt;/code&gt; are converted as well, to &lt;code&gt;10..15&lt;/code&gt;.</source>
          <target state="translated">대문자와 소문자 &lt;code&gt;'A'&lt;/code&gt; 에서 &lt;code&gt;'F'&lt;/code&gt; &lt;code&gt;10..15&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecb0b65529079a3af9e45a8098a612b9728453e3" translate="yes" xml:space="preserve">
          <source>BothQueues</source>
          <target state="translated">BothQueues</target>
        </trans-unit>
        <trans-unit id="403591682693529ea8d764be443089ceac85ad97" translate="yes" xml:space="preserve">
          <source>Bound Threads</source>
          <target state="translated">바운드 스레드</target>
        </trans-unit>
        <trans-unit id="60da7217d44bdc40c1eb907204fa54294872b81f" translate="yes" xml:space="preserve">
          <source>Bound threads can be created using the &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; function below. All foreign exported functions are run in a bound thread (bound to the OS thread that called the function). Also, the &lt;code&gt;main&lt;/code&gt; action of every Haskell program is run in a bound thread.</source>
          <target state="translated">바운드 스레드는 아래 의 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 만들 수 있습니다 . 외부로 내 보낸 모든 함수는 바운드 스레드 (함수를 호출 한 OS 스레드에 바운드)에서 실행됩니다. 또한 모든 Haskell 프로그램 의 &lt;code&gt;main&lt;/code&gt; 동작은 바운드 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb360f4682f39da897d5087bec41a43fcf97967" translate="yes" xml:space="preserve">
          <source>Bounded</source>
          <target state="translated">Bounded</target>
        </trans-unit>
        <trans-unit id="5cf53f246d50f6260632d008d2b6db3a49861eea" translate="yes" xml:space="preserve">
          <source>Bounded-size builder primitives</source>
          <target state="translated">경계 크기 빌더 기본 요소</target>
        </trans-unit>
        <trans-unit id="67c8c593c7bd9a6879a0fe1147f8534d16210197" translate="yes" xml:space="preserve">
          <source>Bounded-size primitives</source>
          <target state="translated">경계 크기 프리미티브</target>
        </trans-unit>
        <trans-unit id="1d198c2728b2ed26f54e7cf85c8fe977ccb9dc30" translate="yes" xml:space="preserve">
          <source>BoundedPrim</source>
          <target state="translated">BoundedPrim</target>
        </trans-unit>
        <trans-unit id="b95a97052e20a036c292b97a8ef02a42631be78d" translate="yes" xml:space="preserve">
          <source>Bounds</source>
          <target state="translated">Bounds</target>
        </trans-unit>
        <trans-unit id="c32b8e824fbf6eb465582d1de11fcd8513bd5c9c" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 경계는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd273039c19f3757a5b2fd1fd257892b02f8e2dc" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 경계는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c07a1483ae52efde58c537e9e0e90f76af8d10c2" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 경계는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f69cf141b98e3135d46e5dad39602462872e7538" translate="yes" xml:space="preserve">
          <source>BoxLabel</source>
          <target state="translated">BoxLabel</target>
        </trans-unit>
        <trans-unit id="2ede889b135cd77a1e71ca9eac7d985ad2849d48" translate="yes" xml:space="preserve">
          <source>Boxed arrays</source>
          <target state="translated">박스형 배열</target>
        </trans-unit>
        <trans-unit id="b252e3099c6de97ebf23d4d3dad230e7eb5f4d7a" translate="yes" xml:space="preserve">
          <source>Break a string on a substring, returning a pair of the part of the string prior to the match, and the rest of the string.</source>
          <target state="translated">일치하기 전에 문자열 부분과 나머지 문자열을 반환하여 하위 문자열에서 문자열을 분리합니다.</target>
        </trans-unit>
        <trans-unit id="48c9c26fa469922bae1a8d989dbc3283a3056b99" translate="yes" xml:space="preserve">
          <source>Break on any exception thrown</source>
          <target state="translated">발생 된 예외에 대한 위반</target>
        </trans-unit>
        <trans-unit id="a3c2a397d9584ae0b3fce8742f96600f8f4f3b73" translate="yes" xml:space="preserve">
          <source>Break on uncaught exceptions and errors</source>
          <target state="translated">잡히지 않은 예외 및 오류에 대한 침입</target>
        </trans-unit>
        <trans-unit id="5255e26cd5c57de2f55fb7938271f8fe86a6ef18" translate="yes" xml:space="preserve">
          <source>Breaking into lines and words</source>
          <target state="translated">줄과 단어로 나누기</target>
        </trans-unit>
        <trans-unit id="e436763b8c5113cc5e50ec031996d87ced4c8b9f" translate="yes" xml:space="preserve">
          <source>Breaking into many substrings</source>
          <target state="translated">많은 부분 문자열로 나누기</target>
        </trans-unit>
        <trans-unit id="9572241e9e3834b00e85795597b97e3ac3c0330f" translate="yes" xml:space="preserve">
          <source>Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.</source>
          <target state="translated">예외를 깨는 것은 프로그램이 무한 루프 상태 일 때 수행 한 작업을 찾는 데 특히 유용합니다. Control-C를 누르고 기록을 검사하여 진행 상황을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ef5f02e366bdd5b1bc2750710d3b437ec6c866e" translate="yes" xml:space="preserve">
          <source>Breaking strings</source>
          <target state="translated">속보 문자열</target>
        </trans-unit>
        <trans-unit id="9462db075d64fc4a3db967b37fffd444976427cc" translate="yes" xml:space="preserve">
          <source>Breakpoints can also be set by line (and optionally column) number:</source>
          <target state="translated">줄 (및 선택적으로 열) 번호로 중단 점을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a59cc6fc01f63be8e198f2fd5dd150495e86da" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set in various ways. Perhaps the easiest way to set a breakpoint is to name a top-level function:</source>
          <target state="translated">중단 점은 다양한 방법으로 설정할 수 있습니다. 중단 점을 설정하는 가장 쉬운 방법은 최상위 기능의 이름을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3e8df33a1deb2bc938e5368fcc9fe73e94b3bdd" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set on arbitrarily deeply nested functions, but the whole chain of nested function names must be specified.</source>
          <target state="translated">임의로 중첩 된 함수에 중단 점을 설정할 수 있지만 중첩 된 함수 이름의 전체 체인을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d7429ed06486112488321794f766798e806ffe7" translate="yes" xml:space="preserve">
          <source>Breaks down the graph by heap closure type.</source>
          <target state="translated">힙 클로저 유형별로 그래프를 분류합니다.</target>
        </trans-unit>
        <trans-unit id="b6426715004373ae21dcdb366f81839cc52b183c" translate="yes" xml:space="preserve">
          <source>Bringing type variables into scope is particularly important for existential data constructors. For example:</source>
          <target state="translated">유형 변수를 범위 내로 가져 오는 것은 실존 데이터 생성자에게 특히 중요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a676d7117cb70fed108c464413db56b7582a1b58" translate="yes" xml:space="preserve">
          <source>Broadcast a scalar to all elements of a vector.</source>
          <target state="translated">스칼라를 벡터의 모든 요소에 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="63915c89cc9540e39b93d3bbb0389bf834c12179" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">버퍼 할당 기능. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어지지 않으면 , 새로운 첫 번째 버퍼가 할당되어야합니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; 지정되고있는 경우, 최소 크기의 버퍼 &lt;code&gt;minSize&lt;/code&gt; 반환해야합니다. 이 참조가 투명하고 &lt;code&gt;oldBuffer&lt;/code&gt; 가 충분히 크다는 것을 보장 할 수 있으면 전략은 &lt;code&gt;oldBuffer&lt;/code&gt; 를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ffb5bb34208049e05e2848a2a464b9554b0c581" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">버퍼 할당 기능. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어, 새로운 첫번째 버퍼를 할당해야합니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; 최소 크기를 갖는, 다음 버퍼 주어진다 &lt;code&gt;minSize&lt;/code&gt; 반환해야합니다. 이 전략은 참조 적으로 투명하고 &lt;code&gt;oldBuffer&lt;/code&gt; 가 충분히 크다는 것을 보장 할 수있는 경우 &lt;code&gt;oldBuffer&lt;/code&gt; 를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2421eb366ac457d20e3b2bf63b1d22adfd90f3a8" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuf&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuf&lt;/code&gt; is large enough.</source>
          <target state="translated">버퍼 할당 기능. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어, 새로운 첫번째 버퍼를 할당해야합니다. 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; 지정되고있는 경우, 최소 크기의 버퍼 &lt;code&gt;minSize&lt;/code&gt; 반환해야합니다. 이 전략은 참조 적으로 투명하고 &lt;code&gt;oldBuf&lt;/code&gt; 가 충분히 크다는 것을 보장 할 수 있다면 &lt;code&gt;oldBuf&lt;/code&gt; 를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1511aac3b884d36da1f7bb8a91d1b07265d2d60" translate="yes" xml:space="preserve">
          <source>Buffer allocation strategy to use</source>
          <target state="translated">사용할 버퍼 할당 전략</target>
        </trans-unit>
        <trans-unit id="efe38e877d87cf3a601574f61e8c6112056e7eb0" translate="yes" xml:space="preserve">
          <source>Buffer management</source>
          <target state="translated">버퍼 관리</target>
        </trans-unit>
        <trans-unit id="9824aaadc3118ca3339cc9676a3f0f7e0217d736" translate="yes" xml:space="preserve">
          <source>Buffer range to fill.</source>
          <target state="translated">채울 버퍼 범위.</target>
        </trans-unit>
        <trans-unit id="07882a47335e43d38370ae44c05618c4c0286951" translate="yes" xml:space="preserve">
          <source>BufferCodec</source>
          <target state="translated">BufferCodec</target>
        </trans-unit>
        <trans-unit id="a9ae0ebad1f560c0b01d474fcf8a1259da2e45b3" translate="yes" xml:space="preserve">
          <source>BufferList</source>
          <target state="translated">BufferList</target>
        </trans-unit>
        <trans-unit id="85c84c25d56fc13d452000134b60f28ba5e1e022" translate="yes" xml:space="preserve">
          <source>BufferListNil</source>
          <target state="translated">BufferListNil</target>
        </trans-unit>
        <trans-unit id="f7f013f67bedbafe6a6a6713f8fba0341a8b5915" translate="yes" xml:space="preserve">
          <source>BufferMode</source>
          <target state="translated">BufferMode</target>
        </trans-unit>
        <trans-unit id="107a37d237e86ecf0a07109468ec7abb99d1adfa" translate="yes" xml:space="preserve">
          <source>BufferRange</source>
          <target state="translated">BufferRange</target>
        </trans-unit>
        <trans-unit id="322e5d09d79c6009f5674e7117a1114889fbffad" translate="yes" xml:space="preserve">
          <source>BufferState</source>
          <target state="translated">BufferState</target>
        </trans-unit>
        <trans-unit id="4e850fb4754d7daddef54b1081f53c061e2277d2" translate="yes" xml:space="preserve">
          <source>BufferWriter</source>
          <target state="translated">BufferWriter</target>
        </trans-unit>
        <trans-unit id="f000f6a3275f9800597ad7f1ac98d43bdd868368" translate="yes" xml:space="preserve">
          <source>BufferedIO</source>
          <target state="translated">BufferedIO</target>
        </trans-unit>
        <trans-unit id="9639fd1e6014e384d9b0d21001270a4532eabd44" translate="yes" xml:space="preserve">
          <source>Buffering operations</source>
          <target state="translated">버퍼링 작업</target>
        </trans-unit>
        <trans-unit id="1705358c6a0b24af297b254b2108454741ff4557" translate="yes" xml:space="preserve">
          <source>Buffers of any element</source>
          <target state="translated">모든 요소의 버퍼</target>
        </trans-unit>
        <trans-unit id="aec7810cb2c876e23b0033e46aae5289ebf0c07c" translate="yes" xml:space="preserve">
          <source>Buffers used in the IO system</source>
          <target state="translated">IO 시스템에서 사용되는 버퍼</target>
        </trans-unit>
        <trans-unit id="0c6dee2a7b5942268d8c231ef297e7abf881535b" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;lsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle은 &lt;code&gt;Prelude&lt;/code&gt; 만 가져 오며 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 로 컴파일됩니다 . &lt;code&gt;Prelude&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; 가 신뢰 하는 &lt;code&gt;base&lt;/code&gt; 패키지에 있으며 모든 &lt;code&gt;Prelude&lt;/code&gt; 의 수입품을 신뢰할 수 있습니다. 따라서 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;Prelude&lt;/code&gt; 를 신뢰 하고 &lt;code&gt;C&lt;/code&gt; 는 Buggle도 신뢰합니다. (하지만 &lt;code&gt;Prelude&lt;/code&gt; 일반적으로 암시 적으로 가져, 그것은 여전히 같은 규칙이 여기에 설명 순종).</target>
        </trans-unit>
        <trans-unit id="dab94f662adaf1659e7f05eebbac08d52174fe85" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;rsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle 은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 &lt;code&gt;Prelude&lt;/code&gt; 만 가져옵니다 . &lt;code&gt;Prelude&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; 가 신뢰 하는 &lt;code&gt;base&lt;/code&gt; 패키지에 있으며 &lt;code&gt;Prelude&lt;/code&gt; 의 모든 가져 오기를 신뢰할 수 있다고 가정 합니다. 따라서 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;Prelude&lt;/code&gt; 를 신뢰 하므로 &lt;code&gt;C&lt;/code&gt; 도 Buggle을 신뢰합니다. ( &lt;code&gt;Prelude&lt;/code&gt; 는 일반적으로 암시 적으로 가져 오지만 여기에 설명 된 것과 동일한 규칙을 따릅니다).</target>
        </trans-unit>
        <trans-unit id="8081798290cefd3d54a8b9c792ffff9da0c521f1" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) forest from a list of seed values in breadth-first order.</source>
          <target state="translated">시드 값 목록에서 폭이 넓은 순서로 (아마도 무한한) 포리스트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4bf90ac98bb2341a2075164c532c21f819b14548" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) tree from a seed value in breadth-first order.</source>
          <target state="translated">시드 값에서 (아마도 무한한) 나무를 너비 우선으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c1d9cde7a54b308063f3fd73d9babe621683dd31" translate="yes" xml:space="preserve">
          <source>Build a function type.</source>
          <target state="translated">함수 타입을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="884c3b47e0ba76cd8f3c27d14e011d3bd05577da" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of edges.</source>
          <target state="translated">모서리 목록에서 그래프를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a94df834fcc88712c4822652bc46a21adf37eec8" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of nodes uniquely identified by keys, with a list of keys of nodes this node should have edges to.</source>
          <target state="translated">키로 고유하게 식별 된 노드 목록에서이 노드에 가장자리가 있어야하는 노드 키 목록으로 그래프를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2fea8f78ed97ff98cabd9dfcff293718197383f4" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt; for details.</source>
          <target state="translated">종속성을 자동으로 파악하여 다중 모듈 Haskell 프로그램을 빌드하십시오. &lt;code&gt;make&lt;/code&gt; 를 사용 하는 것보다 훨씬 쉽고 빠를 것 같습니다 . 자세한 내용은 &lt;a href=&quot;using#make-mode&quot;&gt;ghc &amp;ndash;make 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a5960117b6ce95230aee2dd05eee4a451e3faba" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc --make&lt;/a&gt; for details.</source>
          <target state="translated">다중 모듈 Haskell 프로그램을 빌드하여 종속성을 자동으로 파악합니다. 사용하는 것보다 훨씬 쉽고 빠를 것 같습니다. &lt;code&gt;make&lt;/code&gt; 를 하는 것 같습니다 . 자세한 내용은 &lt;a href=&quot;using#make-mode&quot;&gt;ghc --make 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecfe54531e239227dfe711c2483b41196f665224" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">제공된 초기 수량 으로 새로운 &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 을 구축하십시오 . 초기 수량은 0 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0dbc0898ffb2401cdf281b35699fcbe7978e4839" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">제공된 초기 수량 으로 새로운 &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; 을 구축하십시오 . 초기 수량은 0 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="70552251bfc019f0a6642059f0e75968472b7607" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 구축</target>
        </trans-unit>
        <trans-unit id="203ae674b4968ad5dbc66e2600cec2ba9f05797f" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">현재 상태 스레드에서 새 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b2ccc32e3940757246852fc694480f4189287bca" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; 구축</target>
        </trans-unit>
        <trans-unit id="2300e21cc0d85b3217ced13fe2e4d327643182d7" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 구축</target>
        </trans-unit>
        <trans-unit id="82733393c21fc1714245da66647bbf83f8a411fd" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">현재 상태 스레드에서 새 &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="c48c92907a18be455e4e537a0232ec22e0c8bf45" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 구축</target>
        </trans-unit>
        <trans-unit id="97fae16599eb28b19c06553bf02629e165abbc5e" translate="yes" xml:space="preserve">
          <source>Build a term and use a generic function for subterms</source>
          <target state="translated">용어 작성 및 하위 용어에 대한 일반 함수 사용</target>
        </trans-unit>
        <trans-unit id="cdf22117ef668c1724b6471862c994146899c2a2" translate="yes" xml:space="preserve">
          <source>Build a term skeleton</source>
          <target state="translated">용어 골격 만들기</target>
        </trans-unit>
        <trans-unit id="6e114d1f641bd96174ecb4be857124ba1201641c" translate="yes" xml:space="preserve">
          <source>Build and return a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 의 새로운 인스턴스를 구축하고 반환</target>
        </trans-unit>
        <trans-unit id="3ec1bed141573c1c17cf02d6a5d0bb6f437db403" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 의 새 인스턴스를 빌드하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="35be25a421fa9ce73459655bf04e9204af3809b5" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 의 새 인스턴스를 빌드하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e8370129f628872766fbc00d3f80875610f346b1" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;#10352&lt;/a&gt;.</source>
          <target state="translated">동적 연결을위한 코드를 빌드합니다. 이것은 코드 크기를 엄청나게 줄일 수 있지만 인라인되지 않은 함수의 모듈 간 호출 속도를 늦출 수 있습니다. Linux에서 RTS의 링크와 관련 하여 &lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 와이 플래그를 결합하면 몇 가지 문제가 발생할 수 있습니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;# 10352를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81f76d0f10c8f6fc4b46e538ab3beeacb47b224a" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;Issue #10352&lt;/a&gt;.</source>
          <target state="translated">동적 연결을위한 코드를 작성하십시오. 이렇게하면 코드 크기가 엄청나게 줄어들 수 있지만 인라인되지 않은 함수의 모듈 간 호출 속도가 느려질 수 있습니다. Linux에서 RTS의 링크와 관련하여이 플래그와 &lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 하는 일부 합병증이있을 수 있습니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;문제 # 10352를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5add7a5a63c06d485a23e304e415303fa124ca5" translate="yes" xml:space="preserve">
          <source>Build dynamic object files &lt;em&gt;as well as&lt;/em&gt; static object files during compilation</source>
          <target state="translated">컴파일하는 동안 정적 객체 파일 &lt;em&gt;뿐만 아니라&lt;/em&gt; 동적 객체 파일 작성</target>
        </trans-unit>
        <trans-unit id="4d3910a254eaafd1fc8455fdeef9fbad4ea46494" translate="yes" xml:space="preserve">
          <source>Build dynamically-linked object files and executables</source>
          <target state="translated">동적으로 링크 된 객체 파일 및 실행 파일 작성</target>
        </trans-unit>
        <trans-unit id="eacb633fef8080b6f0e8a1849d462864fe4d86c5" translate="yes" xml:space="preserve">
          <source>Build signals and steps</source>
          <target state="translated">신호와 단계를 구축</target>
        </trans-unit>
        <trans-unit id="0b5df5cd9791079aa609e1eaab6f8fc1c1ffdb8d" translate="yes" xml:space="preserve">
          <source>Build step to use for filling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우는 데 사용할 단계를 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="333dc9940206cf3fadb3fab2461dac23ee93f097" translate="yes" xml:space="preserve">
          <source>BuildSignal</source>
          <target state="translated">BuildSignal</target>
        </trans-unit>
        <trans-unit id="801f513654150879c914869a1ad18da56a51311a" translate="yes" xml:space="preserve">
          <source>BuildStep</source>
          <target state="translated">BuildStep</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="364a8a9074eaff8c9a4b742aefb97068ac895a25" translate="yes" xml:space="preserve">
          <source>Builder construction</source>
          <target state="translated">빌더 건설</target>
        </trans-unit>
        <trans-unit id="9bb1e848b4810eae4e0aa47509b87fbea136f359" translate="yes" xml:space="preserve">
          <source>Builder primitives are contravariant so it's like the normal fmap, but backwards (look at the type). (If it helps to remember, the operator symbol is like (&lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt;) but backwards.)</source>
          <target state="translated">빌더 프리미티브는 반 변형이므로 일반 fmap과 비슷하지만 뒤로 (유형을보십시오). (기억하는 것이 도움이되면 연산자 기호는 ( &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; )와 같지만 거꾸로됩니다.)</target>
        </trans-unit>
        <trans-unit id="080b4431eac6064309a77089493ad982c5492b9a" translate="yes" xml:space="preserve">
          <source>Builder primitives come in two forms: fixed-size and bounded-size.</source>
          <target state="translated">빌더 프리미티브는 고정 크기와 경계 크기의 두 가지 형태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="69f74097b2a4cac8d5c3948fa9f727f1ceca5558" translate="yes" xml:space="preserve">
          <source>Building ByteStrings</source>
          <target state="translated">바이트 문자열 작성</target>
        </trans-unit>
        <trans-unit id="e7a886492e100281858af7babfd3d1560f1a0fa1" translate="yes" xml:space="preserve">
          <source>Building Haskell code into a shared library is a good way to include Haskell code in a larger mixed-language project. While with static linking it is recommended to use GHC to perform the final link step, with shared libraries a Haskell library can be treated just like any other shared library. The linking can be done using the normal system C compiler or linker.</source>
          <target state="translated">Haskell 코드를 공유 라이브러리에 빌드하면 대규모 혼합 언어 프로젝트에 Haskell 코드를 포함시킬 수 있습니다. 정적 링크를 사용하는 경우 GHC를 사용하여 최종 링크 단계를 수행하는 것이 좋지만 공유 라이브러리를 사용하면 Haskell 라이브러리를 다른 공유 라이브러리처럼 처리 할 수 ​​있습니다. 연결은 일반 시스템 C 컴파일러 또는 링커를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c345d8576de571b12d40732f130fe8f621f52549" translate="yes" xml:space="preserve">
          <source>Building a static library is done by using the &lt;strong&gt;ar&lt;/strong&gt; tool, like so:</source>
          <target state="translated">다음 과 같이 &lt;strong&gt;ar&lt;/strong&gt; 도구 를 사용하여 정적 라이브러리를 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="8152d2ec7d17304f7305d9df262ac39349bac99f" translate="yes" xml:space="preserve">
          <source>Building and using shared libraries is slightly more complicated than building and using static libraries. When using Cabal much of the detail is hidden, just use &lt;code&gt;--enable-shared&lt;/code&gt; when configuring a package to build it into a shared library, or to link it against other packages built as shared libraries. The additional complexity when building code is to distinguish whether the code will be used in a shared library or will use shared library versions of other packages it depends on. There is additional complexity when installing and distributing shared libraries or programs that use shared libraries, to ensure that all shared libraries that are required at runtime are present in suitable locations.</source>
          <target state="translated">공유 라이브러리를 만들고 사용하는 것은 정적 라이브러리를 만들고 사용하는 것보다 약간 더 복잡합니다. Cabal을 사용하는 경우 많은 세부 사항이 숨겨져 있으므로 패키지를 공유 라이브러리로 빌드하거나 공유 라이브러리로 빌드 된 다른 패키지와 패키지를 구성 할 때 &lt;code&gt;--enable-shared&lt;/code&gt; 를 사용하십시오. 코드를 작성할 때의 추가적인 복잡성은 코드가 공유 라이브러리에서 사용되는지 또는 의존하는 다른 패키지의 공유 라이브러리 버전을 사용하는지 구별하는 것입니다. 공유 라이브러리를 사용하는 공유 라이브러리 또는 프로그램을 설치 및 분배 할 때 런타임에 필요한 모든 공유 라이브러리가 적절한 위치에 있는지 확인하기 위해 추가 복잡성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d47db5b33b51c402bdb2a8a2fb36f1133fc85e" translate="yes" xml:space="preserve">
          <source>Building computations from sequences of functions that may fail or using exception handling to structure error handling.</source>
          <target state="translated">오류 처리를 구성하기 위해 실패하거나 예외 처리를 사용하는 함수 시퀀스에서 계산을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5c9c803f9e45294cd3c242c8eff2a73203984f1b" translate="yes" xml:space="preserve">
          <source>Building lists</source>
          <target state="translated">건물 목록</target>
        </trans-unit>
        <trans-unit id="59b3ac6a1ebc1aa3f0dee53bb672cdabad274ba4" translate="yes" xml:space="preserve">
          <source>Building streams</source>
          <target state="translated">건물 스트림</target>
        </trans-unit>
        <trans-unit id="f2136c9449e4d2207252445899311ca019c571b7" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">나만의 패키지를 구축하는 것도 매우 간단합니다. 패키지 구성, 구축, 설치 및 배포 프로세스를 자동화하는 &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 인프라를 제공합니다 . 간단한 구성 파일을 작성하고 올바른 위치에 몇 개의 파일을 배치하면 패키지가 생성됩니다. 자세한 내용은 &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal 설명서&lt;/a&gt; 와 Cabal 라이브러리 ( 예 : &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="468ffacf83b540eb8029fa77183ff7a6bbbe4845" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">자체 패키지 구축도 매우 간단합니다. 패키지 구성, 구축, 설치 및 배포 프로세스를 자동화하는 &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 인프라를 제공합니다 . 간단한 구성 파일을 작성하고 올바른 위치에 몇 개의 파일을 저장하면 패키지 만 있으면됩니다. 자세한 내용은 &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal 설명서&lt;/a&gt; 및 Cabal 라이브러리 ( 예 : &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08e50fabbac322297c0380dab80b06348335688e" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">자신 만의 패키지를 구축하는 것도 매우 간단합니다. 패키지 구성, 구축, 설치 및 배포 프로세스를 자동화하는 &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 인프라를 제공합니다 . 간단한 구성 파일을 작성하고 올바른 위치에 몇 개의 파일을 배치하면 패키지가 생성됩니다. 자세한 내용은 &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal 설명서&lt;/a&gt; 와 Cabal 라이브러리 ( 예 : &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="327fc0c96310e3524acc6da1fe01e6c67634802c" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to an undefined value. In a monadic context in which operations must be deterministic (e.g. the ST monad), the array elements are initialised to a fixed but undefined value, such as zero.</source>
          <target state="translated">모든 요소가 정의되지 않은 값으로 초기화 된 새 배열을 작성합니다. 작업이 결정 론적이어야하는 모나드 컨텍스트 (예 : ST 모나드)에서 배열 요소는 0과 같이 고정되지만 정의되지 않은 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="9185529c0692a9b618d7cbf93f4568e19c94d3ee" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to the supplied value.</source>
          <target state="translated">모든 요소를 ​​제공된 값으로 초기화하여 새 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8214ecb33cfb7974c4f39c8c9d05735a2e2c8271" translate="yes" xml:space="preserve">
          <source>Builds a sequence from a seed value. Takes time linear in the number of generated elements. &lt;em&gt;WARNING:&lt;/em&gt; If the number of generated elements is infinite, this method will not terminate.</source>
          <target state="translated">시드 값에서 시퀀스를 작성합니다. 생성 된 요소 수에서 선형으로 시간이 걸립니다. &lt;em&gt;경고 :&lt;/em&gt; 생성 된 요소의 수가 무한하면이 방법이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b20d8714b6e61b13e739bc27b8ce588d42b92f5" translate="yes" xml:space="preserve">
          <source>Builds a time value from a parsed input string. If the input does not include all the information needed to construct a complete value, any missing parts should be taken from 1970-01-01 00:00:00 +0000 (which was a Thursday). In the absence of &lt;code&gt;%C&lt;/code&gt; or &lt;code&gt;%Y&lt;/code&gt;, century is 1969 - 2068.</source>
          <target state="translated">구문 분석 된 입력 문자열에서 시간 값을 작성합니다. 입력 값에 완전한 값을 구성하는 데 필요한 모든 정보가 포함되어 있지 않은 경우 누락 된 부품은 1970-01-01 00:00:00 +0000 (목요일)에서 가져와야합니다. &lt;code&gt;%C&lt;/code&gt; 또는 &lt;code&gt;%Y&lt;/code&gt; 가 없으면 세기는 1969-2068입니다.</target>
        </trans-unit>
        <trans-unit id="0e8e2b2ccd17965cacc18d35e9f5403a32e7112a" translate="yes" xml:space="preserve">
          <source>Builds and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 의 새 인스턴스를 빌드하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="76ca7a4e55fa9d29e200dbea08886efb9fb74322" translate="yes" xml:space="preserve">
          <source>Built-in names</source>
          <target state="translated">내장 이름</target>
        </trans-unit>
        <trans-unit id="e2f8f611e0d7e4911d6a941a4fb69322eea24213" translate="yes" xml:space="preserve">
          <source>Built-in rule ensures that applications of this function to literal Word# are lifted into Natural literals.</source>
          <target state="translated">기본 제공 규칙을 사용하면이 기능을 리터럴 워드 #에 적용하여 자연 리터럴로 들어 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="396f77e795df5a4def2612076c16d77e30f3c69e" translate="yes" xml:space="preserve">
          <source>Bundled Patterns</source>
          <target state="translated">번들 패턴</target>
        </trans-unit>
        <trans-unit id="26b720e58894a51047c1c6e9ca37a4f1f3595b00" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">번들로 제공되는 패턴 동의어는 함께 제공되는 유형 생성자와 동일한 유형인지 확인하기 위해 유형을 검사합니다. 패턴의 동의어 &lt;code&gt;P&lt;/code&gt; 는 타입 생성자와 함께 번들로 할 수없는 &lt;code&gt;T&lt;/code&gt; 경우 &lt;code&gt;P&lt;/code&gt; 의 유형과 눈에 띄게 호환되지 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bbc0ee622ef87f959fb1f6a96e0d378e9dec049" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">번들 패턴 동의어는 번들로 제공되는 유형 생성자와 동일한 유형인지 확인하기 위해 유형 검사됩니다. &lt;code&gt;P&lt;/code&gt; 의 유형이 &lt;code&gt;T&lt;/code&gt; 와 눈에 띄게 호환되지 않는 경우 패턴 동의어 &lt;code&gt;P&lt;/code&gt; 는 유형 생성자 &lt;code&gt;T&lt;/code&gt; 와 함께 번들로 제공 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4464772fd83cffa489cd2cb879896c855ed166d2" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have distinct types, and so can&amp;rsquo;t be compared. It&amp;rsquo;s just about possible to imagine examples in which the derived instance would make sense, but it seems altogether simpler simply to prohibit such declarations. Define your own instances!</source>
          <target state="translated">그러나 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 고유 한 유형을 가지므로 비교할 수 없습니다. 파생 인스턴스가 의미가있는 예를 상상하는 것은 거의 가능하지만, 그러한 선언을 금지하는 것이 더 간단 해 보입니다. 자신의 인스턴스를 정의하십시오!</target>
        </trans-unit>
        <trans-unit id="b6ef53f84ff5027bc07ac3842944ad3414ad9d1f" translate="yes" xml:space="preserve">
          <source>But Haskell programmers can safely think of the ordinary &lt;em&gt;universally&lt;/em&gt; quantified type given above, thereby avoiding adding a new existential quantification construct.</source>
          <target state="translated">그러나 Haskell 프로그래머는 위에서 언급 한 일반적인 &lt;em&gt;보편적으로&lt;/em&gt; 정량화 된 유형을 안전하게 생각할 수 있으므로 새로운 실존 적 정량화 구조를 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5eaf2134b45ec93619a779aa721cc224a4fe25" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">그러나 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt; 가 활성화 되었으므로 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 문자열 리터럴은 이제 &lt;code&gt;String&lt;/code&gt; 이 아니라 &lt;code&gt;Text&lt;/code&gt; 유형이 되며 &lt;code&gt;showString&lt;/code&gt; 은이를 수락하지 않습니다! 이로 인해 생성 된 &lt;code&gt;Show&lt;/code&gt; 인스턴스가 유형 검사에 실패합니다. 파생 된 코드 내에 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 동작 이 필요한 시나리오는 상상하기 어렵 기 때문에 GHC는 파생 된 코드를 확인할 때 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; 를&lt;/a&gt; 완전히 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="a148ffd04c373d017a1eeb4091389373b44c4def" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">때문에 그러나 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; 가&lt;/a&gt; 활성화되어는 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 문자열 리터럴은 이제 형식이 될 것입니다 &lt;code&gt;Text&lt;/code&gt; 가 아닌 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;showString&lt;/code&gt; 은 허용하지 않습니다! 이로 인해 생성 된 &lt;code&gt;Show&lt;/code&gt; 인스턴스가 유형 검사에 실패합니다. 파생 코드 내에서 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 동작을 갖는 것이 바람직한 시나리오를 상상하기 어렵 기 때문에 GHC는 파생 코드를 확인할 때 단순히 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; 를&lt;/a&gt; 완전히 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="513f043a73b80db70c830181c526df028997f561" translate="yes" xml:space="preserve">
          <source>But it is not clear what GHC would fill in for &lt;code&gt;???&lt;/code&gt;, as each data family instance must generate fresh data constructors.</source>
          <target state="translated">그러나 GHC가 기입 될지 분명하지 않다 &lt;code&gt;???&lt;/code&gt; 각 데이터 패밀리 인스턴스는 새로운 데이터 생성자를 생성해야하므로</target>
        </trans-unit>
        <trans-unit id="35278e742589993fb14c61a18c5b5d7e9aec1d0d" translate="yes" xml:space="preserve">
          <source>But more efficiently than using length on the intermediate list.</source>
          <target state="translated">그러나 중간 목록에서 길이를 사용하는 것보다 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5845751806ebabdf9499df5449f17bf8fdf1e9d2" translate="yes" xml:space="preserve">
          <source>But not on lists with more than one element:</source>
          <target state="translated">그러나 둘 이상의 요소가있는 목록에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1747f875a6f39afa8ae9cf4d467a26e849fc8649" translate="yes" xml:space="preserve">
          <source>But not this (since the free variable &lt;code&gt;a&lt;/code&gt; is in the wrong place):</source>
          <target state="translated">그러나 이것이 아닙니다 (자유 변수 &lt;code&gt;a&lt;/code&gt; 가 잘못된 위치에 있기 때문에 ) :</target>
        </trans-unit>
        <trans-unit id="65daa9e4b1075dc22f97b5e99c95b67c30d85438" translate="yes" xml:space="preserve">
          <source>But note that doing this will cause all currently loaded modules to be unloaded, and you&amp;rsquo;ll be dumped back into the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">그러나 이렇게하면 현재로드 된 모든 모듈이 언로드되고 &lt;code&gt;Prelude&lt;/code&gt; 로 다시 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f500af96a3dd31762b3cd040fbfe22ac1abfff8" translate="yes" xml:space="preserve">
          <source>But some more exotic characters are (like HTML's &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;):</source>
          <target state="translated">그러나 좀 더 이국적인 캐릭터는 HTML의 &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a9f84020f58d91882dbfc0db953fb2f507004d2" translate="yes" xml:space="preserve">
          <source>But sometimes you really do need to catch any exception, and actually see what the exception is. One example is at the very top-level of a program, you may wish to catch any exception, print it to a logfile or the screen, and then exit gracefully. For these cases, you can use &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; (or one of the other exception-catching functions) with the &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">그러나 때로는 예외를 잡아야하고 실제로 예외가 무엇인지 확인해야합니다. 한 가지 예는 프로그램의 최상위 수준에 있으며 예외를 잡아 로그 파일이나 화면에 인쇄 한 다음 정상적으로 종료 할 수 있습니다. 이러한 경우, &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 유형 과 함께 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; (또는 다른 예외 잡기 함수 중 하나)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e72f01b86fcf7d8b9f975c29c3a1117f8ed8c6a" translate="yes" xml:space="preserve">
          <source>But superclass constraints like these are sometimes useful, and the conservative check is annoying where no actual recursion is involved.</source>
          <target state="translated">그러나 이와 같은 수퍼 클래스 제약 조건은 때로는 유용하며 실제 재귀가 포함되지 않은 곳에서는 보수적 인 검사가 성가시다.</target>
        </trans-unit>
        <trans-unit id="73f40a957f0eafaef43b7412e6b7eae8ca1629e4" translate="yes" xml:space="preserve">
          <source>But suppose we made a slight adjustment to the order of the instance context, putting &lt;code&gt;E a&lt;/code&gt; before &lt;code&gt;D a&lt;/code&gt;:</source>
          <target state="translated">그러나 인스턴스 컨텍스트의 순서를 약간 조정하여 &lt;code&gt;E a&lt;/code&gt; 를 &lt;code&gt;D a&lt;/code&gt; 앞에 두었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="cfea8bf40fe32a0b6ae6eb32e50457a3bbe00861" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그러나 다음은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7731812692d70803e0e0e350c8da86a84a0c20be" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그러나 다음은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d348a97b3765db0e297f4b99bd3286d0a14a90" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그러나 다음은 모두 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91df2416d261e941ac64542c14e564e449aadd62" translate="yes" xml:space="preserve">
          <source>But the following doesn't terminate:</source>
          <target state="translated">그러나 다음은 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7717e46be083515ecb72e392ec90c5060d7fc5a3" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;'m'&lt;/code&gt; 을 구문 분석하려는 첫 번째 작업이 실패하므로 다음은 전체적으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1a58bd6d5d0e7ba62e5be7b51f024f151d484faf" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;'m'&lt;/code&gt; 을 구문 분석하려는 첫 번째 작업이 실패하므로 다음은 전체적으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8f2d73619f8d796daeb72fd392f5ed8f12263a1e" translate="yes" xml:space="preserve">
          <source>But there is one exception: free variables mentioned in the outermost kind signature on the right hand side are quantified implicitly. Thus, in the following example the variables &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are all in scope on the right hand side of &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">그러나 한 가지 예외가 있습니다. 오른쪽의 가장 바깥 쪽 종류 서명에 언급 된 자유 변수는 암시 적으로 수량화됩니다. 따라서 다음 예제에서 변수 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;k&lt;/code&gt; 는 모두 &lt;code&gt;S&lt;/code&gt; 의 오른쪽 범위에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ca875b680fdb97fc74f9300d7be351d9a268b49" translate="yes" xml:space="preserve">
          <source>But these are not:</source>
          <target state="translated">그러나 이것들은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="808cb3b77f5d26da60e12a8c2e267fb2361422db" translate="yes" xml:space="preserve">
          <source>But this instantiation and re-generalisation happens only at the top level of a type. In particular, none of this happens if the foralls are underneath an arrow. For example:</source>
          <target state="translated">그러나이 인스턴스화 및 재 일반화는 유형의 최상위 수준에서만 발생합니다. 특히 포올이 화살표 아래에 있으면 이런 일이 발생하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e7307e0fa3f238675a94c67154f45c09774348d" translate="yes" xml:space="preserve">
          <source>But this is unsound:</source>
          <target state="translated">그러나 이것은 불건전합니다.</target>
        </trans-unit>
        <trans-unit id="032c3ace0e924d44f9ac3686950012f6f9c642b4" translate="yes" xml:space="preserve">
          <source>But when pattern matching on &lt;code&gt;Baz1&lt;/code&gt; the matched values can be compared for equality, and when pattern matching on &lt;code&gt;Baz2&lt;/code&gt; the first matched value can be converted to a string (as well as applying the function to it). So this program is legal:</source>
          <target state="translated">그러나 &lt;code&gt;Baz1&lt;/code&gt; 에서 패턴 일치를 수행 하면 일치하는 값이 동일한 지 비교할 수 있고 &lt;code&gt;Baz2&lt;/code&gt; 에서 패턴 일치를 수행 하면 첫 번째 일치 된 값을 문자열로 변환 할 수 있습니다 (함수를 적용 할 수도 있음). 따라서이 프로그램은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="48b6f05d33c295f64d2c3b6836ca407ebef98238" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;Maybe&amp;rdquo; we mean that the usual heuristic inlining rules apply (if the function body is small, or it is applied to interesting-looking arguments etc). Another way to understand the semantics is this:</source>
          <target state="translated">&quot;아마도&quot;는 일반적인 휴리스틱 인라이닝 규칙이 적용됨을 의미합니다 (함수 본문이 작거나 흥미로운 모양의 인수 등에 적용되는 경우). 의미를 이해하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5e954f010734bc63857acf7253cb96bcc09c253" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;ambiguous&amp;rdquo; we mean that there is a type variable &lt;code&gt;e&lt;/code&gt; that appears on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, but not on the right. The problem with this is that, according to the theoretical foundations of Haskell overloading, we cannot guarantee a well-defined semantics for any term with an ambiguous type.</source>
          <target state="translated">&quot;모호한&quot;이라는 말 은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 왼쪽에는 나타나지만 오른쪽에는없는 유형 변수 &lt;code&gt;e&lt;/code&gt; 가 있음을 의미합니다 . 문제는 Haskell 과부하의 이론적 기초에 따르면 모호한 유형의 용어에 대해 잘 정의 된 의미를 보장 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9626f1ba2bf1f860641df5bd3f3382835b801df" translate="yes" xml:space="preserve">
          <source>By contrast, &lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lifted-base&lt;/a&gt;'s version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; always discards all of &lt;code&gt;g&lt;/code&gt;'s non-IO effects, and &lt;code&gt;g&lt;/code&gt; never sees any of &lt;code&gt;f&lt;/code&gt;'s non-IO effects, regardless of the layer ordering and regardless of whether &lt;code&gt;f&lt;/code&gt; throws an error. This is not the result of interacting effects, but a consequence of &lt;code&gt;MonadBaseControl&lt;/code&gt;'s approach.</source>
          <target state="translated">대조적으로, &lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lifted-base&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 버전은 항상 &lt;code&gt;g&lt;/code&gt; 의 비 IO 효과를 모두 버리고 , &lt;code&gt;g&lt;/code&gt; 는 레이어 순서와 &lt;code&gt;f&lt;/code&gt; 가 오류를 던 졌는지 여부에 관계없이 &lt;code&gt;f&lt;/code&gt; 의 비 IO 효과를 보지 않습니다. . 이것은 상호 작용 효과의 결과가 &lt;code&gt;MonadBaseControl&lt;/code&gt; 의 접근 방식 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="9f8fa066b62ce9de7834b32b1ffd79abe4903ede" translate="yes" xml:space="preserve">
          <source>By convention, overloaded functions have a non-overloaded counterpart whose name is suffixed with `&lt;code&gt;By&lt;/code&gt;'.</source>
          <target state="translated">관례 적으로, 오버로드 된 함수에는 이름에` &lt;code&gt;By&lt;/code&gt; ' 가 붙는 오버로드되지 않은 대응 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="896bbb1ee06a6fe71b9beeaa9d18f1143bc8c3b4" translate="yes" xml:space="preserve">
          <source>By default (when &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is not specified), GHC exposes only one version of a package, all other versions become hidden. If &lt;code&gt;-package&lt;/code&gt; option is specified multiple times for the same package the last one overrides the previous ones. On the other hand, if &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is used, GHC allows you to expose multiple versions of a package by using the &lt;code&gt;-package&lt;/code&gt; option multiple times with different versions of the same package.</source>
          <target state="translated">기본적으로 ( &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt; 가 지정되지 않은 경우) GHC는 패키지의 한 버전 만 노출하며 다른 모든 버전은 숨겨집니다. 동일한 패키지에 대해 &lt;code&gt;-package&lt;/code&gt; 옵션이 여러 번 지정된 경우 마지막 패키지는 이전 패키지를 대체합니다. 반면, &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 GHC를 사용하면 &lt;code&gt;-package&lt;/code&gt; 옵션을 여러 번 같은 패키지의 다른 버전과 함께 사용하여 여러 버전의 패키지를 노출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c08f7a94109584e7aa0e6d79a4e77ce07a68fae9" translate="yes" xml:space="preserve">
          <source>By default Ctl-C will generate a &lt;code&gt;SIGINT&lt;/code&gt; signal, causing a &lt;code&gt;UserInterrupt&lt;/code&gt; exception to be sent to the main Haskell thread of your program, which if not specially handled will terminate the program. Normally, this is exactly what is wanted: an orderly shutdown of the program in response to Ctl-C.</source>
          <target state="translated">기본적으로 Ctl-C는 &lt;code&gt;SIGINT&lt;/code&gt; 신호 를 생성하여 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외가 프로그램의 기본 Haskell 스레드로 전송되도록하며, 특별히 처리하지 않으면 프로그램이 종료됩니다. 일반적으로 Ctl-C에 응답하여 프로그램이 정상적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="85da6991904e0f3fd3e4bbad20cbc4f4be16d997" translate="yes" xml:space="preserve">
          <source>By default GHC builds applications that open a console window when they start. If you want to build a GUI-only application, with no console window, use the flag &lt;code&gt;-optl-mwindows&lt;/code&gt; in the link step.</source>
          <target state="translated">기본적으로 GHC는 시작할 때 콘솔 창을 여는 응용 프로그램을 빌드합니다. 콘솔 창이없는 GUI 전용 응용 프로그램을 빌드 하려면 링크 단계에서 &lt;code&gt;-optl-mwindows&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d919b56909f1bc95e959f98255a58354f13898" translate="yes" xml:space="preserve">
          <source>By default GHC will be very quiet about what it is doing, only printing error messages. If you want to see in more detail what&amp;rsquo;s going on behind the scenes, add &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; to the command line.</source>
          <target state="translated">기본적으로 GHC는 수행중인 작업에 대해 매우 조용하며 오류 메시지 만 인쇄합니다. 배후에서 일어나는 일을 더 자세히 보려면 명령 행에 &lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; 를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="188b3edf5485565e6e6ef6439aa7adfb9f3f40c8" translate="yes" xml:space="preserve">
          <source>By default only type class methods and methods marked &lt;code&gt;INLINABLE&lt;/code&gt; or &lt;code&gt;INLINE&lt;/code&gt; are specialised. This flag will specialise any overloaded function regardless of size if its unfolding is available. This flag is not included in any optimisation level as it can massively increase code size. It can be used in conjunction with &lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt;&lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt;&lt;/a&gt; if you want to ensure all calls are specialised.</source>
          <target state="translated">기본적으로 &lt;code&gt;INLINABLE&lt;/code&gt; 또는 &lt;code&gt;INLINE&lt;/code&gt; 으로 표시된 유형 클래스 메소드 및 메소드 만 특화됩니다. 이 플래그는 펼쳐질 수있는 경우 크기에 관계없이 오버로드 된 기능을 전문화합니다. 이 플래그는 코드 크기를 크게 증가시킬 수 있으므로 최적화 수준에 포함되지 않습니다. 모든 통화가 전문화되도록하려면 &lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt; &lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="624e8cce7ea7cdb4e472abd23a004063a0206d28" translate="yes" xml:space="preserve">
          <source>By default the valid hole fits are sorted to show the most relevant hole fits at the top of the list of valid hole fits. This can be toggled off with this flag.</source>
          <target state="translated">기본적으로 유효한 구멍 맞춤은 유효한 구멍 맞춤 목록 맨 위에 가장 관련성이 높은 구멍 맞춤을 표시하도록 정렬됩니다. 이 플래그를 사용하여 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1764f7c7473b983f83b4e96209c1fd4c0ad4af0" translate="yes" xml:space="preserve">
          <source>By default this module is set up to parse character data. If you'd like to parse the result of your own tokenizer you should start with the following imports:</source>
          <target state="translated">기본적으로이 모듈은 문자 데이터를 구문 분석하도록 설정되어 있습니다. 자체 토크 나이저의 결과를 구문 분석하려면 다음 가져 오기로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ce3ebf665bc95b496362425218966d039437681" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ghc -M&lt;/code&gt; generates all the dependencies, and then concatenates them onto the end of &lt;code&gt;makefile&lt;/code&gt; (or &lt;code&gt;Makefile&lt;/code&gt; if &lt;code&gt;makefile&lt;/code&gt; doesn&amp;rsquo;t exist) bracketed by the lines &amp;ldquo;&lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt;&amp;rdquo;. If these lines already exist in the &lt;code&gt;makefile&lt;/code&gt;, then the old dependencies are deleted first.</source>
          <target state="translated">기본적으로 &lt;code&gt;ghc -M&lt;/code&gt; 모든 종속성을 생성 한 다음의 말에 그것들을 연결해, &lt;code&gt;makefile&lt;/code&gt; (또는 &lt;code&gt;Makefile&lt;/code&gt; 경우 &lt;code&gt;makefile&lt;/code&gt; 존재하지 않음) &quot;를 선으로 괄호 &lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt; &quot;과 &quot; &lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt; &amp;rdquo;. 이러한 행이 &lt;code&gt;makefile&lt;/code&gt; 에 이미 존재 하면 이전 종속성이 먼저 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a1836101dccd7400532d625ffcce0904ab5ebfa5" translate="yes" xml:space="preserve">
          <source>By default, GHC (as the Haskell 2010 standard prescribes) parses identifiers starting with an underscore in a type as type variables. To treat them as named wildcards, the &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; extension should be enabled. The example below demonstrated the effect.</source>
          <target state="translated">기본적으로 GHC (Haskell 2010 표준 규정)는 밑줄로 시작하는 식별자를 형식 변수로 형식에서 구문 분석합니다. 이들을 명명 된 와일드 카드로 취급하려면 &lt;a href=&quot;#extension-NamedWildCards&quot;&gt; &lt;code&gt;NamedWildCards&lt;/code&gt; &lt;/a&gt; 확장을 활성화해야합니다. 아래 예제는 그 효과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="375ba54e7f496ec128d1b7ef8611af8553668782" translate="yes" xml:space="preserve">
          <source>By default, GHC ignores Haddock comments (&lt;code&gt;-- | ...&lt;/code&gt; and &lt;code&gt;-- ^ ...&lt;/code&gt;) and does not check that they&amp;rsquo;re associated with a valid term, such as a top-level type-signature. With this flag GHC will parse Haddock comments and include them in the interface file it produces.</source>
          <target state="translated">기본적으로 GHC는 Haddock 주석 ( &lt;code&gt;-- | ...&lt;/code&gt; 및 &lt;code&gt;-- ^ ...&lt;/code&gt; )을 무시 하고 최상위 유형 서명과 같은 유효한 용어와 연결되어 있는지 확인하지 않습니다. 이 플래그를 사용하면 GHC는 Haddock 주석을 구문 분석하고 생성하는 인터페이스 파일에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5545ec84b6af100d02a17fdcb1293a391503367a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">기본적으로 GHC는 주로 Haskell 2010 컴파일러처럼 동작하는 것을 목표로하지만 &lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 특정 버전의 언어처럼 동작하도록 말할 수 있습니다 . 표준에서 알려진 편차는 아래에 설명되어 있습니다. 달리 명시되지 않는 한 편차는 Haskell 98, Haskell 2010 및 기본 모드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="12df8ed1e15edda69c0c572579814ea973c3f99c" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">기본적으로 GHC는 주로 Haskell 2010 컴파일러처럼 동작하는 것을 목표로하지만, &lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt; 플래그를. 표준에서 알려진 편차는 아래에 설명되어 있습니다. 달리 명시되지 않는 한 편차는 Haskell 98, Haskell 2010 및 기본 모드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9abdae9b40906f9cfda31d516ba3c096c45e1e1a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;code&gt;-XHaskell98&lt;/code&gt; and &lt;code&gt;-XHaskell2010&lt;/code&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">기본적으로 GHC는 주로 Haskell 2010 컴파일러처럼 작동하는 것을 목표로하지만 &lt;code&gt;-XHaskell98&lt;/code&gt; 및 &lt;code&gt;-XHaskell2010&lt;/code&gt; 플래그를 사용하여 특정 버전의 언어처럼 작동하도록 할 수 있습니다 . 표준에서 알려진 편차는 아래에 설명되어 있습니다. 달리 명시되지 않는 한 편차는 Haskell 98, Haskell 2010 및 기본 모드에서 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec779fb59a0c807c306278944368725099b24555" translate="yes" xml:space="preserve">
          <source>By default, GHC will automatically link in the &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages. This flag disables that behaviour.</source>
          <target state="translated">기본적으로 GHC는 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;rts&lt;/code&gt; 패키지 에서 자동으로 연결 됩니다. 이 플래그는 해당 동작을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="df55ad44f83f85e9c4e4f4d6d779d38193eb5c3e" translate="yes" xml:space="preserve">
          <source>By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system. GHCi can also compile Haskell code to object code: to turn on this feature, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; flag either on the command line or with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (the option &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; restores byte-code compilation again). Compiling to object code takes longer, but typically the code will execute 10-20 times faster than byte-code.</source>
          <target state="translated">기본적으로 GHCi는 Haskell 소스 코드를 런타임 시스템이 해석하는 바이트 코드로 컴파일합니다. GHCi는 오브젝트 코드에 하스켈 코드를 컴파일 할 수 있습니다 :이 기능을 켜면 사용 &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; 명령 줄이나와 중 플래그 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; (옵션 &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt; 를 다시 복원 바이트 코드 컴파일). 객체 코드로 컴파일하는 데 시간이 오래 걸리지 만 일반적으로 코드는 바이트 코드보다 10-20 배 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e88504b814b1fec26bf7b42a2f12aaadb66f2cc" translate="yes" xml:space="preserve">
          <source>By default, GHCi keeps global history in &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; or &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt;, but you can use current directory, e.g.:</source>
          <target state="translated">기본적으로 GHCi는 &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; 또는 &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt; 글로벌 히스토리를 유지 하지만 다음과 같은 현재 디렉토리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbafe643d46838671b1a066fee2f9329338669e" translate="yes" xml:space="preserve">
          <source>By default, all exposed packages in the normal, source import namespace are also available for plugins. This causes those packages to be hidden by default. If you use this flag, then any packages with plugins you require need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">기본적으로 일반 소스 가져 오기 네임 스페이스의 모든 노출 된 패키지도 플러그인에 사용할 수 있습니다. 이로 인해 해당 패키지가 기본적으로 숨겨집니다. 이 플래그를 사용하는 경우, 플러그인이있는 모든 패키지는 &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 명시 적으로 노출되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="82625d74a09e8d4b74d07dfbe3c657128326ccf1" translate="yes" xml:space="preserve">
          <source>By default, all fields in algebraic data types are linear (even if &lt;code&gt;-XLinearTypes&lt;/code&gt; is not turned on). Given</source>
          <target state="translated">기본적으로 대수 데이터 유형의 모든 필드는 선형입니다 ( &lt;code&gt;-XLinearTypes&lt;/code&gt; 가 설정되지 않은 경우에도 ). 주어진</target>
        </trans-unit>
        <trans-unit id="46539ad051a890125fb96d050b762a5dd85eaf9d" translate="yes" xml:space="preserve">
          <source>By default, all of the capabilities participate in parallel garbage collection. If we want to use a very large &lt;code&gt;-N&lt;/code&gt; value, however, this can reduce the performance of the GC. For this reason, the &lt;code&gt;-qn&lt;/code&gt; flag can be used to specify a lower number for the threads that should participate in GC. During GC, if there are more than this number of workers active, some of them will sleep for the duration of the GC.</source>
          <target state="translated">기본적으로 모든 기능은 병렬 가비지 콜렉션에 참여합니다. 그러나 매우 큰 &lt;code&gt;-N&lt;/code&gt; 값 을 사용하려는 경우 GC의 성능이 저하 될 수 있습니다. 이러한 이유로 &lt;code&gt;-qn&lt;/code&gt; 플래그를 사용하여 GC에 참여해야하는 스레드에 대해 더 적은 수를 지정할 수 있습니다. GC 중에이 수보다 많은 근로자가 활동중인 경우 일부 근로자는 GC 기간 동안 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="dff65f59491f27c9a1b1f59bb08671c0847e3677" translate="yes" xml:space="preserve">
          <source>By default, each hole fit shows the provenance information of its hole fit, i.e. where it was bound or defined, and what module it was originally defined in if it was imported. This can be toggled off using the reverse of this flag.</source>
          <target state="translated">기본적으로 각 구멍 맞춤은 구멍 맞춤의 출처 정보 (예 : 바인드 또는 정의 된 위치) 및 가져온 경우 원래 정의 된 모듈을 표시합니다. 이 플래그를 반대로 사용하여 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b07e5a3f0d5d2adc75edc52198eb4a7127369d" translate="yes" xml:space="preserve">
          <source>By default, if idle GC is enabled in the threaded runtime, a major GC will be performed every time the process goes idle for a sufficiently long duration (see &lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt;&lt;code&gt;-I ⟨seconds⟩&lt;/code&gt;&lt;/a&gt;). For large server processes accepting regular but infrequent requests (e.g., once per second), an expensive, major GC may run after every request. As an alternative to shutting off idle GC entirely (with &lt;code&gt;-I0&lt;/code&gt;), a minimum wait time between idle GCs can be specified with this flag. For example, &lt;code&gt;-Iw60&lt;/code&gt; will ensure that an idle GC runs at most once per minute.</source>
          <target state="translated">기본적으로 스레드 런타임에서 유휴 GC가 활성화되면 프로세스가 충분히 긴 기간 동안 유휴 상태가 될 때마다 주요 GC가 수행됩니다 ( &lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt; &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; &lt;/a&gt; 참조 ). 정기적이지만 드물게 요청을 수락하는 대규모 서버 프로세스의 경우 (예 : 초당 한 번) 값 비싼 주요 GC가 모든 요청 후에 실행될 수 있습니다. 유휴 GC를 완전히 차단하는 대신 ( &lt;code&gt;-I0&lt;/code&gt; ) 유휴 GC 간의 최소 대기 시간을이 플래그로 지정할 수 있습니다. 예를 들어 &lt;code&gt;-Iw60&lt;/code&gt; 은 유휴 GC가 분당 최대 한 번 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="00e1d7b164983ad889522ed53190607d61c4610f" translate="yes" xml:space="preserve">
          <source>By default, modules compiled with plugins are always recompiled even if the source file is unchanged. This most conservative option is taken due to the ability of plugins to perform arbitrary IO actions. In order to control the recompilation behaviour you can modify the &lt;code&gt;pluginRecompile&lt;/code&gt; field in &lt;code&gt;Plugin&lt;/code&gt;.</source>
          <target state="translated">기본적으로 플러그인으로 컴파일 된 모듈은 소스 파일이 변경되지 않은 경우에도 항상 다시 컴파일됩니다. 이 가장 보수적 인 옵션은 플러그인이 임의의 IO 작업을 수행 할 수 있기 때문에 수행됩니다. 재 컴파일 동작을 제어하기 위해 &lt;code&gt;Plugin&lt;/code&gt; 에서 &lt;code&gt;pluginRecompile&lt;/code&gt; 필드를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb82d4dffabcd57e78239ea2df207ce6d76727da" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if a set of patterns are overlapping, e.g.,</source>
          <target state="translated">기본적으로 컴파일러는 패턴 세트가 겹치는 경우 경고합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="069c263ac2190411cc9526082fc8f4fd76502131" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if types make a branch inaccessible. This generally requires GADTs or similar extensions.</source>
          <target state="translated">기본적으로 컴파일러는 유형이 분기에 액세스 할 수없는 경우 경고합니다. 일반적으로 GADT 또는 이와 유사한 확장이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="42ececaa43e2537fc3e254dd2078e6ca5e31deaf" translate="yes" xml:space="preserve">
          <source>By default, the entry points of all the object files will be exported from the DLL when using &lt;code&gt;-shared&lt;/code&gt;. Should you want to constrain this, you can specify the &lt;em&gt;module definition file&lt;/em&gt; to use on the command line as follows:</source>
          <target state="translated">기본적으로 &lt;code&gt;-shared&lt;/code&gt; 를 사용할 때 모든 오브젝트 파일의 진입 점이 DLL에서 내보내집니다 . 이를 제한 하려면 다음과 같이 명령 행에서 사용할 &lt;em&gt;모듈 정의 파일&lt;/em&gt; 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cda497389193e1649e303cab4fabec282743541" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overridden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overridden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">기본적으로 플래그는 동기화 시간이 지정된 시간을 초과 할 때 stderr로 경고를 내 보냅니다. :이 문제는 그러나, 오버라이드 (override) 할 수 있습니다 &lt;code&gt;longGCSync()&lt;/code&gt; 동기화 시간이 동기화 기간 동안 초과 될 때 후크가 호출되고 &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 끝에 후크. 이러한 후크는 모두 런타임이 &lt;code&gt;hs_init_ghc()&lt;/code&gt; 시작될 때 &lt;code&gt;RtsConfig&lt;/code&gt; 에서 재정의 될 수 있습니다 . 이러한 후크의 기본 구현 ( &lt;code&gt;LongGcSync()&lt;/code&gt; 및 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; stderr에 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9fe9a2f0fe153f620abcfa8682464add226d1fdb" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overriden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overriden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">기본적으로 플래그는 동기화 시간이 지정된 시간을 초과 할 때 stderr에 경고를 발생시킵니다. :이 문제는 그러나, 오버라이드 (override) 할 수 있습니다 &lt;code&gt;longGCSync()&lt;/code&gt; 동기화 시간이 동기화 기간 동안 초과 될 때 후크가 호출되고 &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 끝에 후크. 런타임이 &lt;code&gt;hs_init_ghc()&lt;/code&gt; 시작되면 &lt;code&gt;RtsConfig&lt;/code&gt; 에서 이러한 후크를 모두 대체 할 수 있습니다 . 이러한 후크 ( &lt;code&gt;LongGcSync()&lt;/code&gt; 및 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; ) 의 기본 구현은 stderr에 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7ddee701400360fbf24135d74284e1d2f92e56f8" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This flag toggles whether to show &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; instead of &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; in the where clause of the valid hole fit message.</source>
          <target state="translated">기본적으로 구멍 맞춤은이 구멍을 구멍의 유형에 맞게 만드는 데 필요한 유형 적용을 보여줍니다 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; 예 : 구멍 (_ :: &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; &amp;gt; [Int]) , mempty :: Monoid a =&amp;gt; a 는 구멍입니다 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; 와 맞습니다 . 이 플래그 는 유효한 hole fit 메시지의 where 절에 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; 대신 ~ ( Int- &amp;gt; [Int]) 를 표시할지 여부를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="d54e2c2c7ff09cca548a7181b38ba4eb543ff3ab" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This can be toggled off with the reverse of this flag.</source>
          <target state="translated">기본적으로 구멍 맞춤은이 구멍을 구멍 유형에 맞게 만드는 데 필요한 유형 응용 프로그램을 표시합니다 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; 예 : 구멍 (_ :: &lt;code&gt;mempty&lt;/code&gt; &amp;gt; [Int])) , mempty 는 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; . 이 플래그를 반대로 설정하면 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d5a2ec055ae5d603afdd7b0fe5afae1fc6be21" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type of the hole fit. This can be turned off by the reverse of this flag.</source>
          <target state="translated">기본적으로 구멍 맞춤은 구멍 맞춤 유형을 표시합니다. 이 플래그를 반대로하여 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a6c6abf4876ada1cf384346f6c09b294c533e7" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">기본적으로 유형 검사기는 부분 유형 서명의 각 구멍에 대해 오류 메시지를보고하여 프로그래머에게 추론 된 유형을 알립니다. 때 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; 의&lt;/a&gt; 확장이 가능하고, 형태 검사기 대신 오류 경고를 발생시키는 각 홀에 대한 추론 타입을 수락 할 것이다. 또한 이러한 경고는 &lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 음소거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f832c954f21105383f315f5795a3f1e4b92e9c8" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">기본적으로 형식 검사기는 부분 형식 서명의 각 구멍에 대한 오류 메시지를보고하여 프로그래머에게 유추 된 형식을 알려줍니다. 때 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; 의&lt;/a&gt; 확장이 가능하고, 형태 검사기 대신 오류 경고를 발생시키는 각 홀에 대한 추론 타입을 수락 할 것이다. 또한 이러한 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 침묵시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73c75d191039b62d5631ea3a5a9bfa7631f5b38e" translate="yes" xml:space="preserve">
          <source>By default, this means that everything from the module &lt;code&gt;Prelude&lt;/code&gt; is currently in scope. Should the prompt be set to &lt;code&gt;%s&amp;gt;&lt;/code&gt; in the &lt;code&gt;.ghci&lt;/code&gt; configuration file, we would be seeing &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; displayed. However, it is not the default mechanism due to the large space the prompt can take if more imports are done.</source>
          <target state="translated">기본적으로 이는 &lt;code&gt;Prelude&lt;/code&gt; 모듈의 모든 항목 이 현재 범위에 있음을 의미합니다 . &lt;code&gt;.ghci&lt;/code&gt; 구성 파일 에서 프롬프트를 &lt;code&gt;%s&amp;gt;&lt;/code&gt; 로 설정하면 &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; 가 표시됩니다. 그러나 더 많은 가져 오기가 수행되면 프롬프트가 차지할 수있는 공간이 크기 때문에 기본 메커니즘이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bbc06aef5e5a39593988fb4a13a30427cfe33d3b" translate="yes" xml:space="preserve">
          <source>By default, when a module is compiled with plugins, it will be marked as unsafe. With this flag passed, all plugins are treated as trustworthy and the safety inference will no longer be affected.</source>
          <target state="translated">기본적으로 모듈이 플러그인으로 컴파일되면 안전하지 않은 것으로 표시됩니다. 이 플래그가 전달되면 모든 플러그인이 신뢰할 수있는 것으로 취급되고 안전 추론이 더 이상 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="174e61791c2af8c07db7989b5f30fdc0a9f3888b" translate="yes" xml:space="preserve">
          <source>By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are:</source>
          <target state="translated">기본적으로 프로그램의 버그를 나타내는 표준 경고 세트가 표시됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="46283cfe9b92cf9ced3d37e5a425538fb2879a38" translate="yes" xml:space="preserve">
          <source>By feeding the ghc compiler driver the option &lt;code&gt;-shared&lt;/code&gt;, it will build a DLL rather than produce an executable. The DLL will consist of all the object files and archives given on the command line.</source>
          <target state="translated">ghc 컴파일러 드라이버에 옵션 &lt;code&gt;-shared&lt;/code&gt; 를 제공 하면 실행 파일이 아닌 DLL을 빌드합니다. DLL은 명령 행에 제공된 모든 오브젝트 파일과 아카이브로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8504674d3abb04bdd53121c5e1c8cc5547351f38" translate="yes" xml:space="preserve">
          <source>By including dependencies in a class declaration, we provide a mechanism for the programmer to specify each multiple parameter class more precisely. The compiler, on the other hand, is responsible for ensuring that the set of instances that are in scope at any given point in the program is consistent with any declared dependencies. For example, the following pair of instance declarations cannot appear together in the same scope because they violate the dependency for &lt;code&gt;D&lt;/code&gt;, even though either one on its own would be acceptable:</source>
          <target state="translated">클래스 선언에 의존성을 포함함으로써 프로그래머가 각 다중 파라미터 클래스를보다 정확하게 지정할 수있는 메커니즘을 제공합니다. 반면에 컴파일러는 프로그램의 특정 지점에서 범위 내에있는 인스턴스 세트가 선언 된 종속성과 일치하는지 확인해야합니다. 예를 들어, 다음 인스턴스 선언 쌍은 &lt;code&gt;D&lt;/code&gt; 에 대한 종속성을 위반하기 때문에 동일한 범위에서 함께 표시 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a31672cadecf688e7c40679abceb4f7169dc8697" translate="yes" xml:space="preserve">
          <source>By inspecting the example &lt;code&gt;plugin&lt;/code&gt; defined above, we can see that it is pure. This means that if the two modules have the same fingerprint then the plugin will always return the same result. Declaring a plugin as pure means that the plugin will never cause a module to be recompiled.</source>
          <target state="translated">위에서 정의한 예제 &lt;code&gt;plugin&lt;/code&gt; 을 살펴보면 플러그인 이 순수함을 알 수 있습니다. 즉, 두 모듈에 동일한 지문이 있으면 플러그인은 항상 동일한 결과를 반환합니다. 플러그인을 순수로 선언하면 플러그인으로 인해 모듈이 다시 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85fd7daebedfdd6804e24888c9b0949a47ff5308" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in O(1) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">이것을 클래스의 멤버로 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; 세미 그룹과 모노 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; 각각 stimes = stimesIdempotent 또는 stimes = stimesIdempotentMonoid 를 선택하여 O (1)에서 실행하도록 업그레이드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="280d0ae1e53ec0807b301a1828edbb266fb95f7c" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in \(\mathcal{O}(1)\) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">이것을 클래스의 구성원으로 만들면 멱등 세미 그룹과 모노 이드는 각각 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; 를 선택하여 \ (\ mathcal {O} (1) \)에서 실행되도록 업그레이드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60b0706ea95c7ca522f1b094a7d6011fac8bf09b" translate="yes" xml:space="preserve">
          <source>By overriding the &lt;code&gt;renamedResultAction&lt;/code&gt; field we can modify each &lt;code&gt;HsGroup&lt;/code&gt; after it has been renamed. A source file is separated into groups depending on the location of template haskell splices so the contents of these groups may not be intuitive. In order to save the entire renamed AST for inspection at the end of typechecking you can set &lt;code&gt;renamedResultAction&lt;/code&gt; to &lt;code&gt;keepRenamedSource&lt;/code&gt; which is provided by the &lt;code&gt;Plugins&lt;/code&gt; module. This is important because some parts of the renamed syntax tree (for example, imports) are not found in the typechecked one.</source>
          <target state="translated">&lt;code&gt;renamedResultAction&lt;/code&gt; 필드 를 재정 의하여 이름을 바꾼 후 각 &lt;code&gt;HsGroup&lt;/code&gt; 을 수정할 수 있습니다 . 소스 파일은 템플릿 haskell 스플 라이스의 위치에 따라 그룹으로 구분되므로 이러한 그룹의 내용이 직관적이지 않을 수 있습니다. 유형 검사가 끝날 때 검사를 위해 이름이 바뀐 AST 전체를 저장하기 위해 &lt;code&gt;Plugins&lt;/code&gt; 모듈에서 제공하는 &lt;code&gt;renamedResultAction&lt;/code&gt; 로 &lt;code&gt;keepRenamedSource&lt;/code&gt; 을 설정할 수 있습니다 . 이름이 바뀐 구문 트리의 일부 (예 : 가져 오기)는 유형 검사 된 구문 트리에서 찾을 수 없으므로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="96c953756e6001b89332797e663898838e62a7c0" translate="yes" xml:space="preserve">
          <source>By replacing &lt;code&gt;Str.hs&lt;/code&gt; with a signature &lt;code&gt;Str.hsig&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; (and any other modules in this package) are now parametrized by a string implementation:</source>
          <target state="translated">바꾸어 &lt;code&gt;Str.hs&lt;/code&gt; 를 서명으로 &lt;code&gt;Str.hsig&lt;/code&gt; , 지금 스트링 구현 의해 매개 변수화된다 (이 패키지의 다른 모듈) &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4177c241d143fa0a5ca33741ceb19186757ef74e" translate="yes" xml:space="preserve">
          <source>By using qualified names, one can set breakpoints on all functions (top-level and nested) in every loaded and interpreted module:</source>
          <target state="translated">정규화 된 이름을 사용하여로드되고 해석되는 모든 모듈의 모든 함수 (최상위 및 중첩)에 중단 점을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd2c213b8e4781cce6dcf36530ac2526d2c7bb34" translate="yes" xml:space="preserve">
          <source>By using them, you are telling GHC that you are willing to suffer longer compilation times for better-quality code.</source>
          <target state="translated">그것들을 사용함으로써 GHC에게 더 좋은 품질의 코드를 위해 더 긴 컴파일 시간을 겪을 것이라고 말하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6baee463471fde1ecec97642f1d1ca74590180" translate="yes" xml:space="preserve">
          <source>Byte ordering.</source>
          <target state="translated">바이트 순서.</target>
        </trans-unit>
        <trans-unit id="a2e0dbd8b1ab09bde4319780f72a4d81435a048c" translate="yes" xml:space="preserve">
          <source>Byte swapping</source>
          <target state="translated">바이트 스와핑</target>
        </trans-unit>
        <trans-unit id="67ce106b074a2dd010e2ed6cebb15426f65787d3" translate="yes" xml:space="preserve">
          <source>ByteArray#</source>
          <target state="translated">ByteArray#</target>
        </trans-unit>
        <trans-unit id="b2ba0861bb06ea1a63c71749689a7beb9ea6b729" translate="yes" xml:space="preserve">
          <source>ByteCount</source>
          <target state="translated">ByteCount</target>
        </trans-unit>
        <trans-unit id="53bc4f0faf53dfa905efcd2b3b1d6b5236b29f9b" translate="yes" xml:space="preserve">
          <source>ByteOffset</source>
          <target state="translated">ByteOffset</target>
        </trans-unit>
        <trans-unit id="8a45cdc61d443f1d99e6a8e08a1a5cac63e13810" translate="yes" xml:space="preserve">
          <source>ByteOrder</source>
          <target state="translated">ByteOrder</target>
        </trans-unit>
        <trans-unit id="c237250b1379824c1dbf827faf23519fe09b6f29" translate="yes" xml:space="preserve">
          <source>ByteString</source>
          <target state="translated">ByteString</target>
        </trans-unit>
        <trans-unit id="f4fdba4ce7955a359ebc54c3d8b75dced1a5bcb3" translate="yes" xml:space="preserve">
          <source>ByteString I/O uses binary mode, without any character decoding or newline conversion. The fact that it does not respect the Handle newline mode is considered a flaw and may be changed in a future version.</source>
          <target state="translated">ByteString I / O는 문자 디코딩이나 줄 바꾸기 변환없이 이진 모드를 사용합니다. 핸들 줄 바꾸기 모드를 준수하지 않는다는 사실은 결함으로 간주되며 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="141ecf8c9b6b748576d6f030e689b5ac01081c26" translate="yes" xml:space="preserve">
          <source>ByteStrings</source>
          <target state="translated">ByteStrings</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="f8cd96f16d9102cf1ed4d9be9ee1b34e6dca04ee" translate="yes" xml:space="preserve">
          <source>C compiler (opt.)</source>
          <target state="translated">C 컴파일러 (옵션)</target>
        </trans-unit>
        <trans-unit id="f4f28ebdbc8eb0a109bc7de54e138a24cbdfbe50" translate="yes" xml:space="preserve">
          <source>C file</source>
          <target state="translated">C 파일</target>
        </trans-unit>
        <trans-unit id="8db42ba5780c0869ea2cc63ca7f695f38e31b373" translate="yes" xml:space="preserve">
          <source>C functions are normally declared using prototypes in a C header file. Earlier versions of GHC (6.8.3 and earlier) &lt;code&gt;#include&lt;/code&gt;d the header file in the C source file generated from the Haskell code, and the C compiler could therefore check that the C function being called via the FFI was being called at the right type.</source>
          <target state="translated">C 함수는 일반적으로 C 헤더 파일에서 프로토 타입을 사용하여 선언됩니다. 이전 버전의 GHC (6.8.3 이하) &lt;code&gt;#include&lt;/code&gt; Haskell 코드에서 생성 된 C 소스 파일에 헤더 파일을 포함 시키므로 C 컴파일러는 FFI를 통해 호출 된 C 함수가 오른쪽에서 호출되고 있는지 확인할 수 있습니다. 유형.</target>
        </trans-unit>
        <trans-unit id="f30e8dc9993cbcb352b6de3b6f306c76123830fc" translate="yes" xml:space="preserve">
          <source>C header</source>
          <target state="translated">C 헤더</target>
        </trans-unit>
        <trans-unit id="e0a32b6cde92a02c4d0079b04d003ea26b8c8425" translate="yes" xml:space="preserve">
          <source>C pre-processor (opt.)</source>
          <target state="translated">C 전 처리기 (옵션)</target>
        </trans-unit>
        <trans-unit id="05da97e8f671dc8e81bb497ab7d0b559bb48f35f" translate="yes" xml:space="preserve">
          <source>C strings</source>
          <target state="translated">C 문자열</target>
        </trans-unit>
        <trans-unit id="a19e3f51c16c6cf9751d0517111b9e9046598db1" translate="yes" xml:space="preserve">
          <source>C strings with a configurable encoding</source>
          <target state="translated">구성 가능한 인코딩을 사용하는 C 문자열</target>
        </trans-unit>
        <trans-unit id="2a2bdbc5a70792af2d724997593731718b21fae4" translate="yes" xml:space="preserve">
          <source>C wide strings</source>
          <target state="translated">C 와이드 스트링</target>
        </trans-unit>
        <trans-unit id="9389a51d4da82d4389a58627b6e1618412013bd7" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s command-line flags say to trust &lt;code&gt;P&lt;/code&gt; regardless of what is recorded in the package database.</source>
          <target state="translated">C의 명령 행 플래그 는 패키지 데이터베이스에 기록 된 내용에 관계없이 &lt;code&gt;P&lt;/code&gt; 를 신뢰한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="be8c54d411949b31b40add83f394cd96144642ba" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s package database records that &lt;code&gt;P&lt;/code&gt; is trusted (and no command-line arguments override this)</source>
          <target state="translated">C의 패키지 데이터베이스는 &lt;code&gt;P&lt;/code&gt; 가 신뢰할 수 있음을 기록합니다 (그리고 이것을 무시하는 명령 행 인수는 없습니다)</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2db6df68dc5acc80ecf8fc1e995baa397dbbfd10" translate="yes" xml:space="preserve">
          <source>C-- representation</source>
          <target state="translated">C-- 표현</target>
        </trans-unit>
        <trans-unit id="4c91c2588a480fcaf1c89f77c993a5b28cde7c85" translate="yes" xml:space="preserve">
          <source>C-\- pass sanity checking</source>
          <target state="translated">C-\-패스 위생 검사</target>
        </trans-unit>
        <trans-unit id="53224a3fe23d089d17e25bc63ef74d76f7140e70" translate="yes" xml:space="preserve">
          <source>C-\- representation</source>
          <target state="translated">C-\-표현</target>
        </trans-unit>
        <trans-unit id="31a8186414085b899b97c056b647bb5d6f3812d1" translate="yes" xml:space="preserve">
          <source>C-specific Marshalling support: Handling of C &quot;errno&quot; error codes.</source>
          <target state="translated">C 특정 마샬링 지원 : C &quot;errno&quot;오류 코드 처리.</target>
        </trans-unit>
        <trans-unit id="28c27031fe7162d732a1c2e209a40bbfcb5fef90" translate="yes" xml:space="preserve">
          <source>C1</source>
          <target state="translated">C1</target>
        </trans-unit>
        <trans-unit id="6c0a03c4460fb3c0c00906dce789ea44d2c84225" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;0 :: BigNat&lt;/code&gt;</source>
          <target state="translated">값 &lt;code&gt;0 :: BigNat&lt;/code&gt; 나타내는 CAF :: BigNat</target>
        </trans-unit>
        <trans-unit id="5d21200844f499d2358206dede07cd8324f4fd8d" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;1 :: BigNat&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;1 :: BigNat&lt;/code&gt; 나타내는 CAF :: BigNat</target>
        </trans-unit>
        <trans-unit id="3398da44f9b46eb47c2133df1dbc8f8ae4577ac5" translate="yes" xml:space="preserve">
          <source>CApi</source>
          <target state="translated">CApi</target>
        </trans-unit>
        <trans-unit id="121fd037efff290f65a5321e272862e0f357c01b" translate="yes" xml:space="preserve">
          <source>CApiFFI</source>
          <target state="translated">CApiFFI</target>
        </trans-unit>
        <trans-unit id="14db2db50b91a19fe259904927c84450dabfbabc" translate="yes" xml:space="preserve">
          <source>CBlkCnt</source>
          <target state="translated">CBlkCnt</target>
        </trans-unit>
        <trans-unit id="d700620d461bc690688d590b78ff1f6451076bc9" translate="yes" xml:space="preserve">
          <source>CBlkSize</source>
          <target state="translated">CBlkSize</target>
        </trans-unit>
        <trans-unit id="b7c2df6676202033e6f4b96ba59aff64b6a29f29" translate="yes" xml:space="preserve">
          <source>CBool</source>
          <target state="translated">CBool</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="893cefd4dd78167c7a5a4ac0d06beb7f83dd928c" translate="yes" xml:space="preserve">
          <source>CCFlags</source>
          <target state="translated">CCFlags</target>
        </trans-unit>
        <trans-unit id="6042f4ccd2b35f8dec9caec98fc66b65acdc25f3" translate="yes" xml:space="preserve">
          <source>CCall</source>
          <target state="translated">CCall</target>
        </trans-unit>
        <trans-unit id="66f04a168f55eebf1080c6abb4c6b95b7048c658" translate="yes" xml:space="preserve">
          <source>CCc</source>
          <target state="translated">CCc</target>
        </trans-unit>
        <trans-unit id="0eaec9bae149e37a5ce9a0a7cb18d3a0521a4365" translate="yes" xml:space="preserve">
          <source>CChar</source>
          <target state="translated">CChar</target>
        </trans-unit>
        <trans-unit id="b922d01dfb7fbf4c7d572d9c0a302d24875c9465" translate="yes" xml:space="preserve">
          <source>CClock</source>
          <target state="translated">CClock</target>
        </trans-unit>
        <trans-unit id="00ffad0ad9d13dcd921b4ce8556a4127a2a6d9dd" translate="yes" xml:space="preserve">
          <source>CClockId</source>
          <target state="translated">CClockId</target>
        </trans-unit>
        <trans-unit id="058ca29cc6039cd32a619c31a884582dd9b365d7" translate="yes" xml:space="preserve">
          <source>CDev</source>
          <target state="translated">CDev</target>
        </trans-unit>
        <trans-unit id="a33f47bafc89a737517d547138493e904caede4a" translate="yes" xml:space="preserve">
          <source>CDouble</source>
          <target state="translated">CDouble</target>
        </trans-unit>
        <trans-unit id="a13df1b410bce84da0245d90f1b68f47e714bb5d" translate="yes" xml:space="preserve">
          <source>CFile</source>
          <target state="translated">CFile</target>
        </trans-unit>
        <trans-unit id="7207a00980deab52aac4c426e769595a330ba71f" translate="yes" xml:space="preserve">
          <source>CFloat</source>
          <target state="translated">CFloat</target>
        </trans-unit>
        <trans-unit id="f87722cf9f18251ddb2f5f220f7d782de8cb027d" translate="yes" xml:space="preserve">
          <source>CFpos</source>
          <target state="translated">CFpos</target>
        </trans-unit>
        <trans-unit id="3245250fcffb641fa52b5fc6b60ab78d806ce5a2" translate="yes" xml:space="preserve">
          <source>CFsBlkCnt</source>
          <target state="translated">CFsBlkCnt</target>
        </trans-unit>
        <trans-unit id="668bc46de7dfe8a5a87b82b4a14b2a9b3c2c4f39" translate="yes" xml:space="preserve">
          <source>CFsFilCnt</source>
          <target state="translated">CFsFilCnt</target>
        </trans-unit>
        <trans-unit id="9008ca0ab2fa0b88a1f9335f80a8e41eaf69719f" translate="yes" xml:space="preserve">
          <source>CGid</source>
          <target state="translated">CGid</target>
        </trans-unit>
        <trans-unit id="976337a037dec864a10c701cda46660bf59430a9" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS</source>
          <target state="translated">CHANGEATTRS</target>
        </trans-unit>
        <trans-unit id="9573cfe4003d4063018bfabe8baccabc5dec5643" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS is a more expressive alternative to ADDATTRS</source>
          <target state="translated">CHANGEATTRS는 ADDATTRS에 대한보다 표현력있는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="4ddd94dd247fbf76059144dff88c2354f6004d0e" translate="yes" xml:space="preserve">
          <source>CId</source>
          <target state="translated">CId</target>
        </trans-unit>
        <trans-unit id="e7be63b330aaa816ff99dddf52aa901f13c3fabc" translate="yes" xml:space="preserve">
          <source>CIno</source>
          <target state="translated">CIno</target>
        </trans-unit>
        <trans-unit id="a00ab8ccad7bd52aaf161686d6fb6af78b9d90cb" translate="yes" xml:space="preserve">
          <source>CInt</source>
          <target state="translated">CInt</target>
        </trans-unit>
        <trans-unit id="afbea4a00e3b8d5fbee852694e9f0dbcb7b1e070" translate="yes" xml:space="preserve">
          <source>CIntMax</source>
          <target state="translated">CIntMax</target>
        </trans-unit>
        <trans-unit id="47afa26f3dfaeef25e893b6e001325c1745aac45" translate="yes" xml:space="preserve">
          <source>CIntPtr</source>
          <target state="translated">CIntPtr</target>
        </trans-unit>
        <trans-unit id="ac426a11e5deca23d2c52eb810c979f96bbedb83" translate="yes" xml:space="preserve">
          <source>CJmpBuf</source>
          <target state="translated">CJmpBuf</target>
        </trans-unit>
        <trans-unit id="3ed41ed1d90695511c38d0a153baab3b0aab617d" translate="yes" xml:space="preserve">
          <source>CKey</source>
          <target state="translated">CKey</target>
        </trans-unit>
        <trans-unit id="1966141ca85782abdda851368b2a0b7057d80562" translate="yes" xml:space="preserve">
          <source>CLLong</source>
          <target state="translated">CLLong</target>
        </trans-unit>
        <trans-unit id="a354353db32e9f98dfeeb3d33b8aaf84b8a163c2" translate="yes" xml:space="preserve">
          <source>CLong</source>
          <target state="translated">CLong</target>
        </trans-unit>
        <trans-unit id="689f2f5b3b386fc3317fb8b3163fa80d82e58f86" translate="yes" xml:space="preserve">
          <source>CMode</source>
          <target state="translated">CMode</target>
        </trans-unit>
        <trans-unit id="c0b6232c6ae7abd7cbb0bae2c172830f28afe3d7" translate="yes" xml:space="preserve">
          <source>CNlink</source>
          <target state="translated">CNlink</target>
        </trans-unit>
        <trans-unit id="2da5c4d5231433ed47b22851a4f34135c562f535" translate="yes" xml:space="preserve">
          <source>CONSOLE_SCREEN_BUFFER_INFO</source>
          <target state="translated">CONSOLE_SCREEN_BUFFER_INFO</target>
        </trans-unit>
        <trans-unit id="f3139171b06d99e21e1e6c0b43a55ca7d2c6d843" translate="yes" xml:space="preserve">
          <source>COORD</source>
          <target state="translated">COORD</target>
        </trans-unit>
        <trans-unit id="49131fde8c7035d6dfd1fe50ce9178a13516766e" translate="yes" xml:space="preserve">
          <source>COff</source>
          <target state="translated">COff</target>
        </trans-unit>
        <trans-unit id="bb1b5dc31671aeff27893044e2275fa0f92d166f" translate="yes" xml:space="preserve">
          <source>CPid</source>
          <target state="translated">CPid</target>
        </trans-unit>
        <trans-unit id="885b63c2b62001411024f3d2c731364c5cee99eb" translate="yes" xml:space="preserve">
          <source>CPtrdiff</source>
          <target state="translated">CPtrdiff</target>
        </trans-unit>
        <trans-unit id="1e7cf4b3318228689b092ee37835b9eb42f41fcc" translate="yes" xml:space="preserve">
          <source>CRLF</source>
          <target state="translated">CRLF</target>
        </trans-unit>
        <trans-unit id="546a33567885515078f7a87477637b76336d1419" translate="yes" xml:space="preserve">
          <source>CRLim</source>
          <target state="translated">CRLim</target>
        </trans-unit>
        <trans-unit id="a28d95e9ceb07c9c8e7449a2375eb3ec11044c2f" translate="yes" xml:space="preserve">
          <source>CSChar</source>
          <target state="translated">CSChar</target>
        </trans-unit>
        <trans-unit id="75d3d4d8267acfcf111594d3887d3a5dd6134eae" translate="yes" xml:space="preserve">
          <source>CSUSeconds</source>
          <target state="translated">CSUSeconds</target>
        </trans-unit>
        <trans-unit id="ac8f56e35ed11b15a2832f15b0cb2a46ae988850" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV는 문자 기반 표 표현입니다. 최대한의 모듈성을 위해 먼저 &lt;code&gt;Table&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 렌더링 한 다음 일부 유니 코드 문자 인코딩을 사용 하여이 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩 할 수 있습니다. 그러나 이것은 중간 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현이 만들어지고 바로 버려지기 때문에 성능을 희생합니다 . 문자 인코딩을 UTF-8로 수정하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;Table&lt;/code&gt; 을 lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 표시되는 UTF-8 인코딩 CSV 테이블로 직접 변환 하여이 중간 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e46e637d7bf291d892a2acd0c0be182fc2c433c5" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV는 문자 기반 테이블 표현입니다. 최대한의 모듈화를 위해 먼저 &lt;code&gt;Table&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 렌더링 한 다음 일부 유니 코드 문자 인코딩을 사용 하여이 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩 할 수 있습니다. 그러나 이것은 중간 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현이 구축되고 곧바로 버려 지므로 성능이 저하됩니다 . 문자 인코딩을 UTF-8로 고정하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;Table&lt;/code&gt; 을 lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 표시된 UTF-8 인코딩 CSV 테이블로 직접 변환 하여이 중간 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현을 제거합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="c147f801a4e20b0c854dee13ad8a1089c996075a" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSV는 표의 문자 기반 표현입니다. 최대한의 모듈화를 위해 먼저 &lt;code&gt;Table&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 렌더링 한 다음 일부 유니 코드 문자 인코딩을 사용 하여이 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩 할 수 있습니다. 그러나 이것은 중간 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현이 구축되고 곧바로 버려 지므로 성능이 저하됩니다 . 문자 인코딩을 UTF-8로 고정하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;Table&lt;/code&gt; 을 lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 표시되는 UTF-8 인코딩 CSV 테이블로 직접 변환 함으로써이 중간 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 표현을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="794f1cc6fcdf266910baaaaa86b4abed6174089f" translate="yes" xml:space="preserve">
          <source>CShort</source>
          <target state="translated">CShort</target>
        </trans-unit>
        <trans-unit id="27cb76e132d99689a39828e8481058f89da270b5" translate="yes" xml:space="preserve">
          <source>CSigAtomic</source>
          <target state="translated">CSigAtomic</target>
        </trans-unit>
        <trans-unit id="066363f762e399c732848700263a21650f470940" translate="yes" xml:space="preserve">
          <source>CSize</source>
          <target state="translated">CSize</target>
        </trans-unit>
        <trans-unit id="3646574cc19c0a235322672991f1d68d3e2b739a" translate="yes" xml:space="preserve">
          <source>CSpeed</source>
          <target state="translated">CSpeed</target>
        </trans-unit>
        <trans-unit id="f87d0c18f3d1185d116c56fd0a55a68efac638e7" translate="yes" xml:space="preserve">
          <source>CSsize</source>
          <target state="translated">CSsize</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="a23c591d96bc64ebb3bf49374a09dbdd388bf154" translate="yes" xml:space="preserve">
          <source>CStringLen</source>
          <target state="translated">CStringLen</target>
        </trans-unit>
        <trans-unit id="9b2eea83d1e0429c7833e421b94919e2cf388ec0" translate="yes" xml:space="preserve">
          <source>CTcflag</source>
          <target state="translated">CTcflag</target>
        </trans-unit>
        <trans-unit id="5f2bbbe0349a800c3f616f598f975d6fd04867c5" translate="yes" xml:space="preserve">
          <source>CTime</source>
          <target state="translated">CTime</target>
        </trans-unit>
        <trans-unit id="18430e50761b0e842a393b19db9ce285e6cc8054" translate="yes" xml:space="preserve">
          <source>CTimer</source>
          <target state="translated">CTimer</target>
        </trans-unit>
        <trans-unit id="dcb42bcafe594e90af67676c9e8c052fd5a939f5" translate="yes" xml:space="preserve">
          <source>CUChar</source>
          <target state="translated">CUChar</target>
        </trans-unit>
        <trans-unit id="d4a2582d6c16b4ba5d2c635b012416934740d9a4" translate="yes" xml:space="preserve">
          <source>CUInt</source>
          <target state="translated">CUInt</target>
        </trans-unit>
        <trans-unit id="bd076efc1995c3ed275a187edc0ef066f25ea188" translate="yes" xml:space="preserve">
          <source>CUIntMax</source>
          <target state="translated">CUIntMax</target>
        </trans-unit>
        <trans-unit id="e074910606a6a0a7045029bb34df02fd731ab117" translate="yes" xml:space="preserve">
          <source>CUIntPtr</source>
          <target state="translated">CUIntPtr</target>
        </trans-unit>
        <trans-unit id="5486c3338e80ad8846379dc8e8efd520cc4bb304" translate="yes" xml:space="preserve">
          <source>CULLong</source>
          <target state="translated">CULLong</target>
        </trans-unit>
        <trans-unit id="5a6a6d18d4f6db0b3cd3cb3ee6e11d2b638b36ea" translate="yes" xml:space="preserve">
          <source>CULong</source>
          <target state="translated">CULong</target>
        </trans-unit>
        <trans-unit id="14f5959d3f206903fe812b4714e3e8212c8b6cb1" translate="yes" xml:space="preserve">
          <source>CUSKs</source>
          <target state="translated">CUSKs</target>
        </trans-unit>
        <trans-unit id="897002c69b6a884ea8eefcb5421db84ebdef160d" translate="yes" xml:space="preserve">
          <source>CUSeconds</source>
          <target state="translated">CUSeconds</target>
        </trans-unit>
        <trans-unit id="5c8ed628cb7e45bc705eead76f1cbbebd239bed4" translate="yes" xml:space="preserve">
          <source>CUShort</source>
          <target state="translated">CUShort</target>
        </trans-unit>
        <trans-unit id="92c2830bba441303faf6bab856a7cb069b95ea73" translate="yes" xml:space="preserve">
          <source>CUid</source>
          <target state="translated">CUid</target>
        </trans-unit>
        <trans-unit id="418cbde1ba91d0f1d2a07615c5e0090662363499" translate="yes" xml:space="preserve">
          <source>CWString</source>
          <target state="translated">CWString</target>
        </trans-unit>
        <trans-unit id="8057975ee7505b53300ea225f8ab98d9c485a979" translate="yes" xml:space="preserve">
          <source>CWStringLen</source>
          <target state="translated">CWStringLen</target>
        </trans-unit>
        <trans-unit id="e1b7eb195fb8e47d10f92245d40ce0a83001bfc2" translate="yes" xml:space="preserve">
          <source>CWchar</source>
          <target state="translated">CWchar</target>
        </trans-unit>
        <trans-unit id="f28b182fd6c1e7864bf4df566f792efa2f287d19" translate="yes" xml:space="preserve">
          <source>Calculate the disjoint union of two sets.</source>
          <target state="translated">두 세트의 분리 된 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4f4058eb0d05059b00bf8670b35dee8225ccc810" translate="yes" xml:space="preserve">
          <source>Calculate the integer base 2 logarithm of an &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. The calculation is more efficient than for the general case, on platforms with 32- or 64-bit words much more efficient.</source>
          <target state="translated">의 정수 기본이 대수 계산 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; . 32 비트 또는 64 비트 단어가 훨씬 더 효율적인 플랫폼에서는 일반적인 경우보다 계산이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6b1934e0c8bea85b670349912e862bb717885de1" translate="yes" xml:space="preserve">
          <source>Calculate the integer logarithm for an arbitrary base.</source>
          <target state="translated">임의의 밑수에 대한 정수 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fb6671b4faab4d9f68221ca795a7d987f6a0b011" translate="yes" xml:space="preserve">
          <source>Calculate the power set of a set: the set of all its subsets.</source>
          <target state="translated">세트의 검정력 세트를 계산하십시오. 모든 서브 세트 세트.</target>
        </trans-unit>
        <trans-unit id="64d88731a775170b2c2441d20c5626fd611990f4" translate="yes" xml:space="preserve">
          <source>Calculating length of a list continuation-style:</source>
          <target state="translated">리스트 연속 스타일의 길이 계산 :</target>
        </trans-unit>
        <trans-unit id="d8643951a671cd22c32e5119288ea47182a9cfcf" translate="yes" xml:space="preserve">
          <source>Calendar Duration</source>
          <target state="translated">일정 기간</target>
        </trans-unit>
        <trans-unit id="17b81c9701f67a03dd57e8dd0dc487ffc9b431f1" translate="yes" xml:space="preserve">
          <source>CalendarDiffDays</source>
          <target state="translated">CalendarDiffDays</target>
        </trans-unit>
        <trans-unit id="7409b1c71c8750958b11afbc94ff9c16ede064de" translate="yes" xml:space="preserve">
          <source>CalendarDiffTime</source>
          <target state="translated">CalendarDiffTime</target>
        </trans-unit>
        <trans-unit id="eb7dce9cb4dc86ccc09e9d78fd32dae9732b4f0b" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible</source>
          <target state="translated">가능한 한 전체 개월이있는 금전적 차이</target>
        </trans-unit>
        <trans-unit id="7768352cae2cf4a9e8a3254eb24cd7bb701e58be" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">가능한 한 한 달 전체의 금전적 차이. 긍정적 인 기간 동안 &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c553a4bbbf5e7eabf268248210393cf922adb6b0" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">가능한 한 한 달 전체의 금전적 차이. 양의 기간 동안 &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f49baea1e6b905de58ea91679cca46b40b81f9d9" translate="yes" xml:space="preserve">
          <source>Call frame information (CFI) necessary for stack unwinding to produce a call stack trace.</source>
          <target state="translated">콜 스택 추적을 생성하기 위해 스택 해제에 필요한 콜 프레임 정보 (CFI).</target>
        </trans-unit>
        <trans-unit id="3812f07ff31cb5f1c7a312c2a62d7b06b2a82122" translate="yes" xml:space="preserve">
          <source>Call stacks</source>
          <target state="translated">콜 스택</target>
        </trans-unit>
        <trans-unit id="369931f908b5d62b0161c02a5b22a7cc6f5cac8f" translate="yes" xml:space="preserve">
          <source>CallCC</source>
          <target state="translated">CallCC</target>
        </trans-unit>
        <trans-unit id="c880ae2dae683608578f800194affe123789856b" translate="yes" xml:space="preserve">
          <source>CallStack</source>
          <target state="translated">CallStack</target>
        </trans-unit>
        <trans-unit id="0056e80c1c5d28940be39ffae2973568ce16898b" translate="yes" xml:space="preserve">
          <source>Callback invoked on I/O events.</source>
          <target state="translated">I / O 이벤트에서 콜백이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="daaca2c7f2ff8d9519d665fa41b06b2d69fccb29" translate="yes" xml:space="preserve">
          <source>Callback invoked on timeout events.</source>
          <target state="translated">시간 종료 이벤트에서 콜백이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="bab9ef2996e7c7cd612ef756aaf74e75bf66e857" translate="yes" xml:space="preserve">
          <source>Callconv</source>
          <target state="translated">Callconv</target>
        </trans-unit>
        <trans-unit id="f2709480559f8e1ebfe51f5f922070ee5a0b317e" translate="yes" xml:space="preserve">
          <source>Called when event logging is about to stop. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">이벤트 로깅이 중지 되려고 할 때 호출됩니다. &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e54dd6b0d6f06132a5ac9efba16065ebcb80fc" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_free_fun_ptr&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;hs_free_fun_ptr&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f93440ac09595da765dfd7fce3c043e1340ddc7c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_thread_done()&lt;/code&gt; is entirely optional. You can call it as often or as little as you like. It is safe to call it from a thread that has never called any Haskell functions, or one that never will. If you forget to call it, the worst that can happen is that some memory remains allocated until &lt;code&gt;hs_exit()&lt;/code&gt; is called. If you call it too often, the worst that can happen is that the next call to a Haskell function incurs some extra overhead.</source>
          <target state="translated">&lt;code&gt;hs_thread_done()&lt;/code&gt; 호출 은 전적으로 선택 사항입니다. 원하는만큼 자주 또는 적게 호출 할 수 있습니다. Haskell 함수를 호출 한 적이없는 스레드 또는 절대 호출하지 않는 스레드에서 호출하는 것이 안전합니다. 호출을 잊어 버린 경우 발생할 수있는 최악의 상황은 &lt;code&gt;hs_exit()&lt;/code&gt; 가 호출 될 때까지 일부 메모리가 할당 된 상태로 유지된다는 것입니다 . 너무 자주 호출하면 다음에 Haskell 함수를 호출하면 약간의 오버 헤드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8f8b83a7a11f59a3ed11ede1f3d1bacf0e929ec" translate="yes" xml:space="preserve">
          <source>Calling a foreign export has a lot of overhead: it creates a complete new Haskell thread, for example.</source>
          <target state="translated">외국 수출을 호출하면 많은 오버 헤드가 있습니다. 예를 들어 완전히 새로운 Haskell 스레드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff08cba20a67e3d5df6255f93d1d83290d3ee9d5" translate="yes" xml:space="preserve">
          <source>Calling any FFI function that deals with the stable pointer table except for arbitrarily many calls to &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; and the final call to &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;.</source>
          <target state="translated">에 임의의 많은 호출을 제외하고 안정적인 포인터 테이블과 거래하는 것이 어떤 FFI 기능을 호출 &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; 최종 호출 할 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="9df609505c881df29223a688771547c8554de6d3" translate="yes" xml:space="preserve">
          <source>Calling any Haskell function, whether or not that function manipulates stable pointers.</source>
          <target state="translated">해당 함수가 안정적인 포인터를 조작하는지 여부에 관계없이 하스켈 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ed557244b4a9e349a3c322cb0a77503f0c82e38a" translate="yes" xml:space="preserve">
          <source>Calling it as a function and using the result exactly once in the same fashion.</source>
          <target state="translated">함수로 호출하고 동일한 방식으로 정확히 한 번 결과를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e7c37f4b93e87283ca9f6dfdb888042f1b6baeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">전화 &lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b8a9e246fa76764839ff44eb2f103e773afd472" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate an unknown format letter for a given type.</source>
          <target state="translated">주어진 유형에 대해 알 수없는 형식 문자를 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bbeabbfe431946986773f5b91e4e429276bde50e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that the format string ended early.</source>
          <target state="translated">형식 문자열이 일찍 종료되었음을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d4d742c7c0092a147431c7f726520a71e74c9a5c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a missing argument in the argument list.</source>
          <target state="translated">인수 목록에 누락 된 인수가 있음을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8f43ec8fc4303b258e938941fa0c2345e526a41e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a type error or similar in the given argument.</source>
          <target state="translated">주어진 인수에 유형 오류가 있거나 유사한 것을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="070d4130edcaf66aaea470ab76abbaddcd88f8ef" translate="yes" xml:space="preserve">
          <source>Calls to wrapper stubs like &lt;code&gt;mkCompare&lt;/code&gt; allocate storage, which should be released with &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">&lt;code&gt;mkCompare&lt;/code&gt; 와 같은 래퍼 스텁에 대한 호출은 스토리지를 할당하며, 더 이상 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; 로 해제해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f880e789e2f3915fa404c71994dee3260cf66e4f" translate="yes" xml:space="preserve">
          <source>Can be combined by allowing the first function to fail:</source>
          <target state="translated">첫 번째 기능이 실패하도록 허용하여 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a5398c4ef4368084de9b377c7ea4fe19382c35" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; 를 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d3a970cf23a4db5acc2dcd82f2ea1d2d3114348" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; 를 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77df886f88f5ac11d91e40af1a385d5cf0c476b4" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; 를 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfff1eba5fd5e0ee04fd5ffa74f4d0a27cee0119" translate="yes" xml:space="preserve">
          <source>Cancel and clean up the user interaction session. Does not block on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 상호 작용 세션을 취소하고 정리하십시오. &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 에 대한 기존 호출을 차단하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="79fd1355be5e5c3a2d4b8536cbbd16e2b9043764" translate="yes" xml:space="preserve">
          <source>Capability</source>
          <target state="translated">Capability</target>
        </trans-unit>
        <trans-unit id="54d8a47a1e0d806a4cdef71377794d92327dfe08" translate="yes" xml:space="preserve">
          <source>Capability set</source>
          <target state="translated">기능 세트</target>
        </trans-unit>
        <trans-unit id="47decb03a85edffa821a50bbfb0d437fdc807e88" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type. &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; evaluates to &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and evaluates to &lt;code&gt;y&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 유형에 대한 사례 분석 . &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; 가 평가 &lt;code&gt;x&lt;/code&gt; 때 &lt;code&gt;p&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 으로하고, 평가하여 &lt;code&gt;y&lt;/code&gt; 때 &lt;code&gt;p&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd61e6da694c7005c3bf09a8d6c6175a2aa43e8f" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형에 대한 사례 분석 . 값이되면 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; , 제 기능을 적용 &lt;code&gt;a&lt;/code&gt; ; 이 경우 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; , 상기 제 기능을 적용 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c9b70590f3abe192e52616a49d1ce1c95797d5" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형에 대한 사례 분석 . 값이되면 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; , 제 기능을 적용 &lt;code&gt;a&lt;/code&gt; ; 이 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; , 상기 제 기능을 적용 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="475bc2fca6cb658692cd146b77f3134683e44d4e" translate="yes" xml:space="preserve">
          <source>Case conversion</source>
          <target state="translated">사례 변환</target>
        </trans-unit>
        <trans-unit id="c384f0bd4de15126a4e648ecdb43ed85f0f9788d" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt; 위로 캐스트</target>
        </trans-unit>
        <trans-unit id="9b0c1cec3779c67b5a4198434044b6479333cc3b" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt; 위로 캐스트</target>
        </trans-unit>
        <trans-unit id="418d5136974671468558a366b7adf4e1745babd1" translate="yes" xml:space="preserve">
          <source>Casting &lt;code&gt;Any&lt;/code&gt; back to the real type</source>
          <target state="translated">주조 &lt;code&gt;Any&lt;/code&gt; 실제 유형에 다시</target>
        </trans-unit>
        <trans-unit id="14eaff82dc32a3dd06fbb2120fb55390d7aff2b7" translate="yes" xml:space="preserve">
          <source>Casting an unboxed type to another unboxed type of the same size. (Casting between floating-point and integral types does not work. See the &lt;code&gt;GHC.Float&lt;/code&gt; module for functions to do work.)</source>
          <target state="translated">상자가없는 유형을 같은 크기의 다른 상자가없는 유형으로 캐스팅합니다. (부동 소수점과 정수 유형 사이의 캐스팅은 작동하지 않습니다. 작동 하는 기능에 대해서는 &lt;code&gt;GHC.Float&lt;/code&gt; 모듈을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a77a280b66f17718ca45f364c2549ea59ee231d5" translate="yes" xml:space="preserve">
          <source>Casting any lifted type to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">어떤 해제 유형을 주조 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8239393d85a3d2b20d80ac50aa2077b6cb2bbff9" translate="yes" xml:space="preserve">
          <source>Casting between two types that have the same runtime representation. One case is when the two types differ only in &quot;phantom&quot; type parameters, for example &lt;code&gt;Ptr Int&lt;/code&gt; to &lt;code&gt;Ptr Float&lt;/code&gt;, or &lt;code&gt;[Int]&lt;/code&gt; to &lt;code&gt;[Float]&lt;/code&gt; when the list is known to be empty. Also, a &lt;code&gt;newtype&lt;/code&gt; of a type &lt;code&gt;T&lt;/code&gt; has the same representation at runtime as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">런타임 표현이 동일한 두 유형간에 캐스트 한 가지 경우는 두 유형이 &quot;팬텀&quot;유형 매개 변수에서만 다른 경우입니다 (예 : &lt;code&gt;Ptr Int&lt;/code&gt; - &lt;code&gt;Ptr Float&lt;/code&gt; ) 또는 목록이 비어있는 것으로 알려진 경우 &lt;code&gt;[Int]&lt;/code&gt; - &lt;code&gt;[Float]&lt;/code&gt; . 또한, &lt;code&gt;newtype&lt;/code&gt; 은 형식의 &lt;code&gt;T&lt;/code&gt; 는 같은 런타임 동일한 표현 갖는 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="817c5fda8cf761e409f0573537fe831f98dcc235" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">캐스트 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 다른 유형의를.</target>
        </trans-unit>
        <trans-unit id="3b87674433c2d83df21e90e5d30bb6ad8b8917b3" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 로 캐스팅 합니다 .</target>
        </trans-unit>
        <trans-unit id="a333b32a76b5f0846b0b562e4e374f98aa285d13" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="95e8d467482a948856e848cedf6d867c0805e0eb" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">캐스트 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 다른 유형의를.</target>
        </trans-unit>
        <trans-unit id="b06ed4465a78c5cb3d6a85f1cc01b4e8f6b31063" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 로 캐스팅 합니다 .</target>
        </trans-unit>
        <trans-unit id="19d6f9a00c0c2cabff3ad4bdfb625dab782fe4d7" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="c2924698e10e606808fa245512e94c5f68ae0c26" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">한 요소 유형 의 &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; 를 다른 요소 유형 의 IOUArray 로 캐스트합니다 . 결과 배열의 모든 요소는 정의되지 않습니다 (무엇을하고 있는지 알지 못하는 한 ...).</target>
        </trans-unit>
        <trans-unit id="a08750b8b38605ce21952c72bb767d5301c2b939" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">한 요소 유형 의 &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; 를 다른 요소 유형 의 STUArray 로 캐스트합니다 . 결과 배열의 모든 요소는 정의되지 않습니다 (무엇을하고 있는지 알지 못하는 한 ...).</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="55968d8a1379a4b67fddecc8e9883f837526266e" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt; ) 예외를 포착합니다 . 여전히 다소 일반적이지만 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; 을 사용하는 것보다 낫습니다 . &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt; 의 조건 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; 기반으로 특정 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 잡는 쉬운 방법은 catchIf 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b0491a3ba40c7aae2ac43311b82cc5e386de0f0" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt; ) 예외를 포착합니다 . 여전히 다소 일반적이지만 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; 을 사용하는 것보다 낫습니다 . &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt; 의 조건 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; 기반으로 특정 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 잡는 쉬운 방법은 catchIf 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be3e0797dab02a979f34001bfab69a509009b77c" translate="yes" xml:space="preserve">
          <source>Catch an exception in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 예외를 잡아라 .</target>
        </trans-unit>
        <trans-unit id="dd822d9ac25676eae90dbd5e34d62a0eba9fb936" translate="yes" xml:space="preserve">
          <source>Catch and handle an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 유형의 예외를 포착하고 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0396fc2c6cc0de592c078776391d5b4c38fa9d0" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 모든 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 유형을 포착합니다.</target>
        </trans-unit>
        <trans-unit id="bb4abdda83b18367b6738ca6670fbc64a522dd00" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">어떤 캐치 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 입력 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 모나드를.</target>
        </trans-unit>
        <trans-unit id="e8a05dab529be35078b57b35e09c9396125ad8d1" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 모든 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 유형을 포착합니다.</target>
        </trans-unit>
        <trans-unit id="85fb57b50b7c396aea28d0563de6686ac25936f8" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">계산에서 발생 하는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 잡아서 수정 된 버전을 던집니다.</target>
        </trans-unit>
        <trans-unit id="3e8b90383da6530dd9f0567fb4058dd0c3408fd5" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">계산에서 발생 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 잡아서 수정 된 버전을 던집니다.</target>
        </trans-unit>
        <trans-unit id="e00ca112629f0bbeddd0eaf128d45287b724c7a1" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">일부 술어를 전달하는 경우에만 예외를 포착하십시오. 종종 &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값 을 테스트하기위한 술어와 함께 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cc1d9a1fb694c15418a8f0478bbfd7cc9e0ccce4" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">일부 술어를 전달하는 경우에만 예외를 포착하십시오. 종종 &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값 을 테스트하기위한 술어와 함께 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="27e1a543d61fbc5ef22c14a662c04bfa3f8494dd" translate="yes" xml:space="preserve">
          <source>CatchT</source>
          <target state="translated">CatchT</target>
        </trans-unit>
        <trans-unit id="4faa50ac1aedb089ef7ad23c0ec14c4788d3fa93" translate="yes" xml:space="preserve">
          <source>Catchable failure</source>
          <target state="translated">캐치 가능한 실패</target>
        </trans-unit>
        <trans-unit id="3ad467bb02d631ca180aaff8b3eb2bb11449bd34" translate="yes" xml:space="preserve">
          <source>Catches all exceptions, and somewhat defeats the purpose of the extensible exception system. Use sparingly.</source>
          <target state="translated">모든 예외를 포착하고 확장 가능한 예외 시스템의 목적을 다소 어긋나게합니다. 아껴서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab50d7d0a8e10c25d0254d43e62f4208eacd6ea8" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">다양한 종류의 예외를 포착합니다. &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f142aa11175cc4bb725dba420c092ca4007c7b66" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">다양한 종류의 예외를 포착합니다. &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db9f1e35bd8bc054c14a57bda1390e0ea6c3de74" translate="yes" xml:space="preserve">
          <source>Catches exceptions from the base monad.</source>
          <target state="translated">기본 모나드에서 예외를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="cbf0eb43a0f74729b670cb70ee447e8dafe2ae8e" translate="yes" xml:space="preserve">
          <source>Catching Exceptions</source>
          <target state="translated">예외 잡기</target>
        </trans-unit>
        <trans-unit id="7c24a071f68091fc4b6c70d3a203d55c0991236d" translate="yes" xml:space="preserve">
          <source>Catching all exceptions</source>
          <target state="translated">모든 예외 잡기</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="24116b77a8f36e799ebb282f0b37aa98b99674d4" translate="yes" xml:space="preserve">
          <source>Cause GHC to spew a long usage message to standard output and then exit.</source>
          <target state="translated">GHC가 긴 사용법 메시지를 표준 출력에 뿌린 후 종료합니다.</target>
        </trans-unit>
        <trans-unit id="cd4f2174d5c74263e2692df318af63043a136f0a" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to ignore missing dependencies, directories and libraries when registering a package, and just go ahead and add it anyway. This might be useful if your package installation system needs to add the package to GHC before building and installing the files.</source>
          <target state="translated">원인 &lt;code&gt;ghc-pkg&lt;/code&gt; 패키지를 등록 할 때없는 종속 디렉토리와 라이브러리를 무시하고 그것을 계속해서 추가 할 수 있습니다. 이는 파일을 빌드하고 설치하기 전에 패키지 설치 시스템이 GHC에 패키지를 추가해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d690ac870a757a43255d7f87f9ba95fdebc250" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed package IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">원인 &lt;code&gt;ghc-pkg&lt;/code&gt; 설치 패키지 ID가 같은 인수를 해석하는 (예를 들어, 같은 식별자 &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; ). 이는 패키지 이름과 버전 만 제공하는 것이 모호한 경우에 유용합니다 (이전 버전의 GHC에서는 고유 한 것으로 보장되었지만이 불변 값이 더 이상 유지되지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="6668ddc9a0b8030af8f071d3c72c96b34a4f1919" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed unit IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">원인 &lt;code&gt;ghc-pkg&lt;/code&gt; 설치 단위 ID와 같은 인수의 해석 (예를 들면, 같은 식별자 &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; ). 이는 패키지 이름과 버전 만 제공하는 것이 모호한 경우에 유용합니다 (이전 버전의 GHC에서는 고유 한 것이 보장되었지만이 불변성은 더 이상 유지되지 않음).</target>
        </trans-unit>
        <trans-unit id="6c8b9bf99ddcbd146b3c845f7be476ec85530046" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as unit IDs (e.g., an identifier like &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt;). Package keys are used to prefix symbol names GHC produces (e.g., &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt;), so if you need to figure out what package a symbol belongs to, use &lt;code&gt;ghc-pkg&lt;/code&gt; with this flag.</source>
          <target state="translated">원인 &lt;code&gt;ghc-pkg&lt;/code&gt; 단위 ID와 같은 인수의 해석 (예를 들면, 같은 식별자 &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt; ). 패키지 키는 GHC가 생성하는 심볼 이름 (예 : &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt; ) 을 접두어로 사용 하므로 심볼이 속한 패키지를 알아 내려면 &lt;code&gt;ghc-pkg&lt;/code&gt; 를이 플래그와 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00ace62f72694d4200557c472f90977b55426b58" translate="yes" xml:space="preserve">
          <source>Causes GHC to continue the compilation if a module has an error. Any reverse dependencies are pruned immediately and the whole compilation is still flagged as an error. This option has no effect if parallel compilation (&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;) is in use.</source>
          <target state="translated">모듈에 오류가있는 경우 GHC에서 컴파일을 계속합니다. 역 종속성은 즉시 제거되고 전체 컴파일은 여전히 ​​오류로 플래그가 지정됩니다. 병렬 컴파일 ( &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt; 옵션은 효과가 없습니다 . )이 사용중인 .</target>
        </trans-unit>
        <trans-unit id="8e4e5c6ceb6d8c45565db992a2558a62eccda222" translate="yes" xml:space="preserve">
          <source>Causes GHC to display error messages with colors. To do this, the terminal must have support for ANSI color codes, or else garbled text will appear. The default value is &lt;code&gt;auto&lt;/code&gt;, which means GHC will make an attempt to detect whether terminal supports colors and choose accordingly.</source>
          <target state="translated">GHC가 색상과 함께 오류 메시지를 표시하도록합니다. 이렇게하려면 터미널에서 ANSI 색상 코드를 지원해야합니다. 그렇지 않으면 텍스트가 깨져서 나타납니다. 기본값은 &lt;code&gt;auto&lt;/code&gt; 입니다. 즉, GHC는 터미널이 색상을 지원하는지 여부를 감지하고 그에 따라 선택합니다.</target>
        </trans-unit>
        <trans-unit id="20d2d68914c6346c2e95cbf24b6ec67960b9eecf" translate="yes" xml:space="preserve">
          <source>Causes GHC to emit the full source span of the syntactic entity relating to an error message. Normally, GHC emits the source location of the start of the syntactic entity only.</source>
          <target state="translated">GHC가 오류 메시지와 관련된 구문 엔티티의 전체 소스 범위를 방출하도록합니다. 일반적으로 GHC는 구문 엔티티 시작의 소스 위치 만 방출합니다.</target>
        </trans-unit>
        <trans-unit id="d576e350cd2aa7e7096854355ee66b60b92ba0b0" translate="yes" xml:space="preserve">
          <source>Causes GHC to group diagnostic messages by severity and output them after other messages when building a multi-module Haskell program. This flag can make diagnostic messages more visible when used in conjunction with &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;. Otherwise, it can be hard to find the relevant errors or likely to ignore the warnings when they are mixed with many other messages.</source>
          <target state="translated">GHC가 심각도별로 진단 메시지를 그룹화하고 다중 모듈 Haskell 프로그램을 빌드 할 때 다른 메시지 뒤에 출력하도록합니다. 이 플래그는 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt; 와 함께 사용하면 진단 메시지를 더 잘 볼 수 있습니다 . . 그렇지 않으면 관련 오류를 찾기가 어렵거나 다른 많은 메시지와 혼합 될 때 경고를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70d25285a51eb0c30b7f813f53d107d40395ccf" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;exts/assert#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">GHC가 소스 코드에서 &lt;code&gt;Exception.assert&lt;/code&gt; 함수의 사용을 무시하도록합니다 (즉, &lt;code&gt;Exception.assert p e&lt;/code&gt; 를 &lt;code&gt;e&lt;/code&gt; 로 다시 작성 ( &lt;a href=&quot;exts/assert#assertions&quot;&gt;Assertions&lt;/a&gt; 참조 )).</target>
        </trans-unit>
        <trans-unit id="acca7ff63d9b6e41e528844003c34ddbdde2ee3a" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;glasgow_exts#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">GHC가 소스 코드에서 &lt;code&gt;Exception.assert&lt;/code&gt; 함수 사용을 무시하도록합니다 (즉, &lt;code&gt;Exception.assert p e&lt;/code&gt; 를 &lt;code&gt;e&lt;/code&gt; 로 다시 작성 ( &lt;a href=&quot;glasgow_exts#assertions&quot;&gt;어설 션&lt;/a&gt; 참조 )).</target>
        </trans-unit>
        <trans-unit id="a5c37beba2bad256ebd9f62113525cc50cf13289" translate="yes" xml:space="preserve">
          <source>Causes GHC to output errors in reverse line-number order, so that the errors and warnings that originate later in the file are displayed first.</source>
          <target state="translated">GHC가 라인 번호 순서로 오류를 출력하도록하여 파일에서 나중에 발생하는 오류 및 경고가 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c74c8c8a50a946a1eb069af532c3b41c65914fde" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt; breaks on only those exceptions which would otherwise be uncaught.</source>
          <target state="translated">예외가 발생하면 GHCi가 평가를 중단하고 대화식 프롬프트로 돌아갑니다. &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt; 는 그렇지 않으면 포착되지 않는 예외에서만 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="09fceabf67429fb54f490834d66c90cb5b2d87e7" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; breaks on all exceptions.</source>
          <target state="translated">예외가 발생하면 GHCi가 평가를 중단하고 대화식 프롬프트로 돌아갑니다. &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt; 은 모든 예외에서 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e4317b2c3f6f72a82cfdcbcf16addd4832d7ce" translate="yes" xml:space="preserve">
          <source>Causes a specific warning to be treated as normal warning, not fatal error.</source>
          <target state="translated">특정 경고가 치명적인 오류가 아니라 정상적인 경고로 취급되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9013a7a5dd4b02050c445d6c8d02f8c9a5659e8f" translate="yes" xml:space="preserve">
          <source>Causes a the finalizer associated with a weak pointer to be run immediately.</source>
          <target state="translated">약한 포인터와 관련된 종료자가 즉시 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d660793220cce4be870d303d08ede77e598c4e8a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign declarations that use unsupported calling conventions. In particular, if the &lt;code&gt;stdcall&lt;/code&gt; calling convention is used on an architecture other than i386 then it will be treated as &lt;code&gt;ccall&lt;/code&gt;.</source>
          <target state="translated">지원되지 않는 호출 규칙을 사용하는 외부 선언에 대해 경고가 발생합니다. 특히 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙이 i386 이외의 아키텍처에서 사용되는 경우 &lt;code&gt;ccall&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9231b916d8fb538801ceb6978b5f7d56d89c46a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign imports of the following form:</source>
          <target state="translated">다음 형식의 해외 ​​수입에 대해 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e98a3a30d7733ed9dedcbabc936490c757372801" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if a literal will overflow, e.g. &lt;code&gt;300 :: Word8&lt;/code&gt;.</source>
          <target state="translated">리터럴이 오버플로되면 경고가 발생합니다 (예 : &lt;code&gt;300 :: Word8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd1c01a0d1fd759549d7f5a255d840e89eea8c9" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if an enumeration is empty, e.g. &lt;code&gt;[5 .. 3]&lt;/code&gt;.</source>
          <target state="translated">열거가 비어 있으면 경고가 발생합니다 (예 : &lt;code&gt;[5 .. 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b03d60a421fef989bdabe6f59af3aafb863a3a2" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted in the following cases:</source>
          <target state="translated">다음과 같은 경우 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54a2ce2dcdf3de95961e4a84c06a6eb991218b3a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a datatype &lt;code&gt;T&lt;/code&gt; is exported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but is it just a type synonym.</source>
          <target state="translated">데이터 유형 &lt;code&gt;T&lt;/code&gt; 를 모든 생성자 (예 : &lt;code&gt;T(..)&lt;/code&gt; 와 함께 내보낼 때 경고가 발생 하지만 이는 유형 동의어 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5850209be2276082816894ad46c9d27f472d8244" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a deprecated command-line flag is used.</source>
          <target state="translated">더 이상 사용되지 않는 명령 행 플래그가 사용될 때 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1559b656d4f4ada2377537a03c55fbff0cb2ceb8" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 가 있는 모듈, 함수 또는 유형이 사용되면 경고 가 발생합니다. &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;pragma에&lt;/a&gt; 대한 자세한 내용 은 WARNING 및 DEPRECATED pragma 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8a0d32c9e37c86534bf9a681300a1caae49d88d" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 가 있는 모듈, 함수 또는 유형이 사용되면 경고 가 발생합니다. &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;pragma에&lt;/a&gt; 대한 자세한 내용 은 WARNING 및 DEPRECATED pragma 를 참조하십시오. &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="b17effd9a3e5c7c9e87b6669a7b23b62923d60da" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 가 있는 모듈, 기능 또는 유형을 사용하면 경고 가 발생합니다. &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;pragma에&lt;/a&gt; 대한 자세한 내용 은 WARNING 및 DEPRECATED pragma 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae2b17da3f31748cf6562bc1e9f9fc0eea07082f" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; 또는 &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 가 있는 모듈, 기능 또는 유형을 사용하면 경고 가 발생합니다. &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;pragma에&lt;/a&gt; 대한 자세한 내용 은 WARNING 및 DEPRECATED pragma 를 참조하십시오. &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="98e20c4585a176d469e30cd83022bf0c8a9dc06c" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a pragma that GHC doesn&amp;rsquo;t recognise is used. As well as pragmas that GHC itself uses, GHC also recognises pragmas known to be used by other tools, e.g. &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; and &lt;code&gt;DERIVE&lt;/code&gt;.</source>
          <target state="translated">GHC가 인식하지 못하는 pragma가 사용될 때 경고가 발생합니다. GHC 자체가 사용하는 pragma뿐만 아니라 GHC는 &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; 및 &lt;code&gt;DERIVE&lt;/code&gt; 와 같은 다른 도구에서 사용되는 것으로 알려진 pragma도 인식합니다 .</target>
        </trans-unit>
        <trans-unit id="a825494d23788ab82b5c459198f152d6a42195e6" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">유형 오류가 런타임까지 지연 될 때 경고가보고되도록합니다. &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;런타임에 유형 오류 연기를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="79d06a9df074ba808cc5468d12706017603b0286" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">런타임까지 유형 오류가 지연 될 때 경고가보고됩니다. &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임에 유형 오류 연기를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a66456e97d3e5c82a2e7e50ed6cce45f40a3e24" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">&lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 이 모두 사용 가능하고 명시 적 파생 전략이 사용되지 않는 경우 경고를 발생 시킵니다 . 예를 들어 다음과 같은 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cd293507c41778581d65d30e7291dca340df36ce" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 모두 경고를 발생 시킵니다. 이 모두 사용 가능하고 명시 적 파생 전략이 사용되지 않는 . 예를 들어 다음과 같은 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b795c3c145457a6b91186e97358df9a2b6dccc0" translate="yes" xml:space="preserve">
          <source>Causes all files following this option on the command line to be processed as if they had the suffix ⟨suffix⟩. For example, to compile a Haskell module in the file &lt;code&gt;M.my-hs&lt;/code&gt;, use &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt;.</source>
          <target state="translated">명령 행에서이 옵션 뒤에 오는 모든 파일이 접미사 ⟨접미사를 갖는 것처럼 처리되도록합니다. 예를 들어, &lt;code&gt;M.my-hs&lt;/code&gt; 파일에서 Haskell 모듈을 컴파일 하려면 &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8292d38b8a6403c2a334f06412c37889687b00ef" translate="yes" xml:space="preserve">
          <source>Causes the compiler to behave as if package ⟨pkg⟩, and any packages that depend on ⟨pkg⟩, are not installed at all.</source>
          <target state="translated">컴파일러가 패키지 ⟨pkg⟩ 및 ⟨pkg⟩에 종속 된 패키지가 전혀 설치되지 않은 것처럼 작동하도록합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
