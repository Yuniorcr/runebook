<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 켜져 있을 때 GHC는 선언에 대해 가장 일반적인 종류를 유추하려고합니다. 많은 경우 (예 : 데이터 유형 선언에서) 정의에는 종류 유추를 알리는 오른쪽이 있습니다. 그러나 항상 그런 것은 아닙니다. 치다</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">일반적으로 동일한 모듈에 정의 된 함수에 대해서만 &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; pragma를 제공 할 수 있습니다 . 그러나 함수 &lt;code&gt;f&lt;/code&gt; 에 정의 사이트에서 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; pragma 가 제공되면 모듈을 가져 와서 특수화 할 수 있습니다 ( &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt; 참조 ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">캡처 가능한 이름을 생성하십시오. 이러한 이름의 발생은 발생 사이트의 Haskell 범위 지정 규칙에 따라 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">캡처 할 수없는 새 이름을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; 도구의 입력에 적합한 형식으로 패키지 종속성의 그래프를 생성하십시오 . 예를 들어, 종속성 그래프의 PDF를 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">공유 라이브러리 생성 (실행 파일이 아닌)</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">실행 파일이 아닌 독립형 정적 라이브러리를 생성하십시오. 크로스 컴파일 할 때 유용합니다. 라이브러리는 모든 종속성과 함께 연결할 수있는 단일 정적 라이브러리로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">바이트 코드 생성</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체 코드 대신 바이트 코드를 생성하십시오. 이것이 GHCi의 기본값입니다. 바이트 코드는 현재 대화식 인터프리터에서만 사용할 수 있으며 디스크에는 저장되지 않습니다. 이 옵션은 &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; 효과를 되돌릴 때만 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">위치 독립적 실행 파일 (사용 가능한 경우)에 대한 코드 생성</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">동적 라이브러리와의 링크를위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위치 독립적 실행 파일에 링크 할 수있는 방식으로 코드 생성 현재 Linux x86 및 x86-64에서 작동합니다. Windows에서는 위치 독립적 인 코드가 사용되지 않으므로 플래그는 해당 플랫폼에서 작동하지 않습니다. 최종 실행 파일을 연결하려면 &lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">컬러 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">LaTeX 문서에 포함하기에 적합한 캡슐화 된 PostScript를 생성하십시오. 일반적으로 PostScript 그래프는 가로 9 인치 x 세로 6 인치 영역에서 가로 모드로 그려지며 &lt;code&gt;hp2ps&lt;/code&gt; 는이 영역이 대략 a4 용지 한 가운데에 정렬 되도록 합니다. 이 형식은 그래프를 자세히 연구하는 데 편리하지만 LaTeX 문서에 포함하기에는 적합하지 않습니다. &lt;code&gt;-e&lt;/code&gt; 옵션은 플로트 인치, 밀리미터 또는 포인트 (기본값)의 폭을 지정하여 세로 모드에서 그릴 수있는 그래프를 야기한다. 결과 PostScript 파일은 EPS (Encapsulated PostScript) 규칙을 준수하며 Rokicki의 dvi-to-PostScript 변환기 &lt;code&gt;dvips&lt;/code&gt; 를 사용하여 LaTeX 문서에 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">객체 코드 생성</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">객체 코드를 생성하십시오. 이것은 GHCi 외부의 기본값이며 GHCi와 함께 사용하여 바이트 코드보다 우선적으로 객체 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">위치 독립적 인 코드 (공유 라이브러리에 넣을 수있는 코드)를 생성하십시오. 이것은 현재 Linux x86 및 x86-64에서 작동합니다. Windows에서는 위치 독립적 인 코드가 사용되지 않으므로 플래그는 해당 플랫폼에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">위치 독립적 인 코드 생성 (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="translated">Generate warnings for Template Haskell splices</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">원래 소스의 소스 라인 번호를 전달하기 위해 전처리기에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">Vi 스타일 편집기 ( &lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt; ) 또는 Emacs 스타일 편집기 ( &lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt; ) 의 &quot;태그&quot;파일을 생성합니다 . 파일 이름을 지정하지 않으면 기본 &lt;code&gt;tags&lt;/code&gt; 또는 &lt;code&gt;TAGS&lt;/code&gt; 가 각각 사용됩니다. 현재로드 된 모듈의 모든 함수, 생성자 및 유형에 대한 태그가 생성됩니다. 이 명령이 작동하려면 모든 모듈을 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;prog.hp&lt;/code&gt; 파일에서 기본 힙 프로파일을 생성합니다 . 힙 프로파일 그래프를 생성하려면 &lt;strong&gt;hp2ps를&lt;/strong&gt; 사용 하십시오 ( &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; 힙 스크립트를 포스트 스크립트로 렌더링&lt;/a&gt; 참조 ). 기본 힙 프로파일은 다른 유형의 클로저 (함수, 썽크 등)가 광범위한 카테고리 (예 : &lt;code&gt;FUN&lt;/code&gt; , &lt;code&gt;THUNK&lt;/code&gt; ) 로 그룹화 된 데이터 생성자에 의해 분류됩니다 . 보다 자세한 프로파일을 얻으려면 전체 프로파일 링 지원 ( &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt; )을 사용하십시오. &lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; 로 단축 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">단일 GHC 실행에서 동적 및 정적 오브젝트 파일을 모두 생성합니다. 이 옵션은 기능적으로 GHC를 두 번 실행하는 것과 동일하며, 두 번째로 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">다음 인스턴스를 생성합니다</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">ByteString 생성 및 펼치기</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">생성 및 전개</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">일반 생성자 클래스</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">일반 인스턴스</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gunfold&lt;/code&gt; 정의 된 일반 작업</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHC의 일반 프로그래밍 지원을 통해 인스턴스화시 사용자 지정이 필요없는 메소드로 클래스를 정의 할 수 있습니다. 메소드 본문은 GHC에 의해 자동으로 파생됩니다. 이것은 예를 들어 &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 와 같은 표준 클래스에서 발생하는 것과 유사 하지만 이제는 사용자 정의 클래스에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">일반 표현 유형</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">일반 표현 유형</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">일반 지원</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">제네릭 형식 클래스</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">NUL 바이트로 끝나는 게으른 ByteString을 가져옵니다. 리턴 된 문자열은 NUL 바이트를 포함하지 않습니다. NUL을 찾지 않고 입력의 끝에 도달하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH 변수에서 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 목록을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH 변수에서 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 목록을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">중단 점에서 자유 변수에 대한 참조 얻기</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">제공된 프로젝션 함수를 사용하여 상태의 특정 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">현재 실행 스택 상태의 문자열 표현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">현재 실행 스택 상태의 추적을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">모든 확장을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">환경 값 또는 기본값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">실행 스택을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">현재 런타임 시스템 통계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 모나드 에서 상태를 얻습니다 . 상태는 Template Haskell 표현식이 실행되는 Haskell 모듈에 국한됩니다.</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 를 a의 머리에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 주어진 값과 연관된합니다.</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 를 a의 머리에 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 주어진 값과 연관된합니다.</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">특정 자오선에서 현지 시간의 UT1 시간을 가져옵니다 (도, 양수는 동쪽).</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">시간대에서 현지 시간의 UTC 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">확장자 나 경로없이 기본 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 환경 변수 의 내용을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">시스템 시계에서 현재 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">시스템 시계에서 현재 POSIX 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">현재 줄 입력 기록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">현재 시간대를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">현재 스레드에서 &lt;code&gt;errno&lt;/code&gt; 의 현재 값을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">터미널의 기본 크기를 가져옵니다. 크기 조정 가능한 터미널 (예 : &lt;code&gt;xterm&lt;/code&gt; )의 경우 실제 크기와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">디렉토리 이름을 가져 와서 한 단계 위로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">파일 경로에서 드라이브를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">터미널에 연결된 핸들의 에코 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">파일의 확장자를 가져오고 확장자가 없으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;.ext&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">다른 문자열에서 하위 문자열의 첫 번째 색인을 가져 오거나 문자열을 찾을 수 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다. &lt;code&gt;findSubstring p s&lt;/code&gt; 는 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">주어진 시간에 자정 이후의 하루의 일부를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">창의 제목을 사용하여 현재 콘솔 창의 핸들을 가져옵니다. 참조 : &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">현재 콘솔 창의 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">주어진 키의 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 레이블을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 레이블을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">특정 자오선에서 UT1 시간의 현지 시간을 가져옵니다 (도, 양은 동쪽).</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">시간대에서 UTC 시간의 현지 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">주어진 시간 동안 현지 시간대를 가져옵니다 (여름 시간 조정에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 모듈을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">&lt;code&gt;TBQueue&lt;/code&gt; 에서 제거하지 않고 다음 값을 가져 와서 채널이 비어 있으면 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">&lt;code&gt;TChan&lt;/code&gt; 에서 다음 값을 제거하지 말고 채널이 비어 있는지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">채널을 비우면 다시 시도 하여 &lt;code&gt;TQueue&lt;/code&gt; 에서 제거하지 않고 다음 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; 의 피코 초 수를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">해당 연도의 요일과 요일을 구하십시오. 첫 번째 월요일 주 1의 첫 번째 날, 올해 이전의 모든 일 주 0입니다 (같은 &lt;code&gt;%W&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ). 월요일 일요일 (로 7, 1 &lt;code&gt;%u&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">연도의 요일과 요일의 수를 구하십시오. 첫 번째 일요일은 주 1의 첫 번째 요일이며, 그 이전의 모든 요일은 주 0입니다 ( &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;%U&lt;/code&gt; 로 ). 일요일 토요일 (로 6이며, 0 &lt;code&gt;%w&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">파일 또는 디렉토리의 권한을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">고정도 값의 우선 순위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">나머지 바이트를 게으른 ByteString으로 가져옵니다. 이 기능은 모든 입력을 읽고 문자열을 메모리에 유지해야하므로 값 비싼 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 에서 초를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 소스 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 의 소스 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">객체에 연결된 스택 추적을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">주어진 형식 지정자에 해당하는 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">시스템 시간 (1970 UTC 시작, 윤초 무시)을 얻습니다. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 은 일반적으로 &lt;code&gt;getCurrentTime&lt;/code&gt; 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 의 꼬리를 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 의 꼬리를 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">자정 이후 시간이 주어진 시간을 가져옵니다. 24 시간 이상의 시간은 윤초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">자정 이후 하루 중 일부만 주어진 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">하루 중 자정부터 시간을받습니다.</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">이 시점까지 읽은 총 바이트 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">사용자 이름을 가져옵니다. 참조 : &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt; , &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">전경 창 가져 오기 / 설정.</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">주어진 OS 핸들 또는 POSIX fd에서 GHC 핸들 파일 설명을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">제공된 투영 함수를 사용하여 상태의 특정 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">인덱스의 생성자를 가져옵니다 (대수 데이터 유형 만 해당)</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">대수 데이터 유형의 생성자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">생성자의 데이터 유형을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">생성자의 필드 레이블을 가져옵니다. 레이블 목록은 원래 생성자 선언에 제공된 순서와 동일한 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">생성자의 고정도를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">생성자의 색인을 가져옵니다 (대수 데이터 유형 만 해당)</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">대수 데이터 유형의 최대 생성자 색인을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">형식 생성자의 모듈을 가져옵니다. 이름 앞에 *. *. * ...를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">데이터 유형의 공개 프리젠 테이션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">생성자의 공개 프리젠 테이션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">생성자에 대한 문자열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">모듈을 포함한 형식 생성자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">규정되지 않은 유형 생성자를 가져옵니다. 이름 앞에 drop *. *. * ...</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그인 모듈에 인수를 제공하십시오. 모듈은 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">플러그인 모듈에 인수를 제공하십시오. &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 으로 모듈을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">명시적인 유형 서명을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">압축과 블록 중 하나의 주소가 주어지면 다음 블록과 크기, 또는 인수가 압축의 마지막 블록 인 경우 #nullAddr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">경로 세그먼트 목록이 제공되면을 확장하십시오 &lt;code&gt;.&lt;/code&gt; 와 &lt;code&gt;..&lt;/code&gt; . . 경로 세그먼트에는 경로 구분 기호가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">문자열 목록이 제공되면 특정 문자를 이스케이프하고 각 문자열 사이에 줄 바꿈을 추가하여 단일 문자열로 연결하십시오. 이스케이프는 공백, 작은 따옴표, 큰 따옴표 또는 백 슬래시 문자 앞에 단일 백 슬래시 문자를 추가하여 수행되므로이 ​​이스케이프 문자를 제거해야합니다. 이스케이프 처리되지 않은 공백 (이 경우 줄 바꾸기)은이 &quot;전송&quot;형식의 일부로 이전 문자열의 끝과 새 문자열의 시작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">구조의 요소를 목록에 매핑하는 수단이 주어지면 모든 목록의 연결을 순서대로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">이름 또는 경로가 지정되면 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; 을 조회에 추가하고 지정된 검색 디렉토리 목록에서 실행 파일을 검색하고 모든 발생을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">다음과 같은 형식의 병렬 이해가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">양식의 패턴 동의어 정의가 주어짐</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">감안할 때 프로그램 &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; 와 인수 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 에 붙여 넣는 캐릭터에 적합한 반환 &lt;code&gt;/bin/sh&lt;/code&gt; (유닉스 시스템) 또는 &lt;code&gt;CMD.EXE&lt;/code&gt; (Windows에서)를.</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 소스와 대상이 동일한 배열 인 경우 소스와 대상 영역이 겹칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 두 어레이는 서로 다른 상태에서 동일한 어레이가 아니어야하지만이 역시 점검되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋, 대상 배열, 대상 배열에 대한 오프셋 및 복사 할 요소가 여러 개인 경우, 소스 배열에서 대상 배열로 요소를 복사하십시오. 소스 및 대상 배열은 동일한 배열을 참조 할 수 있습니다. 두 배열 모두 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다. 동일한 배열이 소스와 대상으로 모두 제공되는 경우에만 가능하지만 영역은 겹칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">소스 배열, 소스 배열에 대한 오프셋 및 복사 할 여러 요소가 주어지면 소스 배열의 요소로 새 배열을 만듭니다. 제공된 배열은 지정된 범위를 완전히 포함해야하지만 이것은 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">연결된 문자열 문자열이 제공되면 특정 문자 의 &lt;em&gt;인용&lt;/em&gt; 및 / 또는 &lt;em&gt;이스케이프&lt;/em&gt; 레이어를 제거하여 각각을 분리하십시오 .</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Right a&lt;/code&gt; 유형의 값이 주어지면 GHC는 &lt;code&gt;Right b&lt;/code&gt; 유형의 값을 생성해야합니다 . &lt;code&gt;Right&lt;/code&gt; 생성자에 대한 인수 는 &lt;code&gt;Either Int a&lt;/code&gt; 유형 을 가지므로, 코드는 &lt;code&gt;fmap&lt;/code&gt; 을 재귀 적으로 호출 하여 &lt;code&gt;Either Int b&lt;/code&gt; 유형의 값을 생성합니다.이 유형 은 결국 &lt;code&gt;Right b&lt;/code&gt; 유형의 최종 값을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">1 년 동안 정통 기독교 전통에 따라 부활절을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">1 년 동안 그레고리오 방식에 따라 부활절을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">1 년 동안 정통 기독교 전통에 따라 파스칼 보름달을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">1 년 동안 그레고리오 방식에 따라 파스카 보름달 찾기</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">임의의 주소와 정렬 제약 조건이 주어지면 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 은 정렬 제약 조건을 충족시키는 다음으로 높은 주소를 생성합니다. 정렬 제약 조건 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 로 나눌 수있는 모든 주소에 의해 충족됩니다 . 이 작업은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">임의의 주소와 정렬 제약 조건이 주어지면 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 은 정렬 제약 조건을 충족시키는 다음으로 높은 주소를 생성합니다. 정렬 제약 조건 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 로 나눌 수있는 모든 주소에 의해 충족됩니다 . 이 작업은 dem 등원입니다.</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Int 단위의 배열과 오프셋이 주어지면 요소를 읽으십시오. 인덱스는 범위 내에있는 것으로 가정합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Int 단위의 배열과 오프셋이 주어지면 요소를 작성하십시오. 인덱스는 범위 내에있는 것으로 가정합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열, Int 단위의 오프셋, 예상 이전 값 및 새 값이 주어지면 원자 비교를 수행하고 현재 값이 제공된 이전 값과 일치하면 새 값을 씁니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋, AND에 대한 값, 원자에 대한 AND의 값이 요소에 제공됩니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋과 NAND에 대한 값이 주어지면 원자 적으로 값을 요소에 NAND합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋, OR에 대한 값, 원자에 대한 OR 값 또는 요소에 대한 값이 제공됩니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋과 XOR에 대한 값이 주어지면 원자 적으로 값을 요소에 XOR합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋 및 추가 할 값이 주어지면 원소에 값을 원자 적으로 추가합니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">배열과 Int 단위의 오프셋 및 빼기 값이 주어지면 원소에 대해 값을 원자 적으로 빼냅니다. 작업 전 요소의 값을 반환합니다. 전체 메모리 장벽을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">점을 감안 &lt;code&gt;Int#&lt;/code&gt; 의 종류되지 &lt;code&gt;Type&lt;/code&gt; , 그 다음은 그 다음 &lt;code&gt;Maybe Int#&lt;/code&gt; 허용되지 않습니다. 입력 변수는 경향이 있기 때문에 유사 종류이어야 &lt;code&gt;Type&lt;/code&gt; (예를 들면, &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; , 모든 입력 변수는 종류가 &lt;code&gt;Type&lt;/code&gt; ) 다형성은 기본 유형에 비해 작동하지 않는 경향이 있습니다. 물러서서 다형성 함수가 데이터에 대한 포인터를 조작해야하고 대부분의 기본 유형은 개봉되어 있지 않기 때문에이 방법은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">Given that &lt;code&gt;Int#&lt;/code&gt; &amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt; , it then it follows that &lt;code&gt;Maybe Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; , all the type variables have kind &lt;code&gt;Type&lt;/code&gt; ), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 에서 작동한다고 가정하면 0 이하의 반복을 요청하면 실패 할 수 있으며 기본 정의는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 에서 작동한다고 가정하면 0 이하의 반복을 요청하면 실패 할 수 있으며 기본 정의는 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;Collects&lt;/code&gt; 에 대한 종속성 정보를 고려할 때 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 동일한 첫 번째 매개 변수 &lt;code&gt;c&lt;/code&gt; 를 가진 &lt;code&gt;Collects&lt;/code&gt; 제약 조건 에서 두 번째 매개 변수로 나타나기 때문에 동일해야한다고 추론 할 수 있습니다 . 따라서 &lt;code&gt;f&lt;/code&gt; 에 대해 더 짧고 정확한 유형을 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 예제가 주어진 경우 : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 예제가 주어진 경우 : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">GADT (Generalized Algebraic Data Types)에서 제공하는 기능을 고려할 때 위와 같은 정의가 실현 가능한 것처럼 보일 수 있습니다. 그러나 GADT와 달리 유형 패밀리는 &lt;em&gt;개방&lt;/em&gt; 되어 &lt;em&gt;있습니다. &lt;/em&gt;즉, 다른 모듈에서 새 인스턴스를 항상 추가 할 수 있습니다. 여러 데이터 인스턴스에서 패턴 일치를 지원하려면 확장 가능한 사례 구조 형식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">필요한 최대 크기와 ByteString의 내용을 만드는 함수가 주어지면 createAndTrim이 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 실제 최종 크기 (&amp;lt;= 최대 크기)를 반환하려면 생성 함수가 필요하며 결과 바이트 배열이이 크기로 재 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">실행 파일의 이름 또는 경로가 주어지면 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 은 일반적으로 &lt;code&gt;PATH&lt;/code&gt; 등을 포함하는 시스템 정의 위치 목록에서 해당 파일을 검색합니다 . 발견되면 실행 파일의 전체 경로가 리턴됩니다. 예를 들어, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; 는 일반적으로 GHC에 대한 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">컴팩트의 첫 번째 블록에 대한 포인터와 이전 주소 공간에있는 루트 객체의 주소가 주어지면 메모리에 직렬화되었을 때와 다른 메모리 위치를 설명하도록 컴팩트 내부의 내부 포인터를 수정하십시오. 이 메소드는 직렬화 된 압축 파일을 가져온 후 정확히 한 번 호출되어야하며 새로운 압축 및 새로운 조정 된 루트 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">이 선언에 따라 다음은 올바른 형식과 잘못된 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">주기 &lt;code&gt;+RTS -?&lt;/code&gt; RTS 옵션 옵션은 프로그램에서 실제로 사용할 수있는 RTS 옵션을 인쇄합니다 (컴파일 방법에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">클래스 메소드에 규칙을 부여하는 것은 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskell은 변화하는 시스템이므로 반드시 버그가있을 것입니다. 하나를 찾으면 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;이 위키 페이지&lt;/a&gt; 를보고하는 방법에 대한 정보 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">TH AST 외부에 묶인 전역 이름 : 원래 이름 (결합 만 아님), 네임 스페이스도 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC 홈페이지로&lt;/a&gt; 이동 하여 &quot;다운로드&quot;링크를 따라 해당 플랫폼에 맞는 GHC를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">넘어 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; (참조 &lt;a href=&quot;#disambiguate-fields&quot;&gt;기록 필드 동음&lt;/a&gt; )의 &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 의&lt;/a&gt; 확장은 여러 데이터 유형이 단일 모듈에서 같은 필드 이름을 사용하여 선언 할 수 있습니다. 예를 들어 다음을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">GHC가 함수 전개를 허용 할 최대 크기를 제어합니다. (펼치기에는 콜 사이트에서 펼쳐지는 확장 (일명 인라인)의 &quot;코드 팽창&quot;이라는 관점에서 비용을 반영하는 &quot;크기&quot;가 있습니다. 더 큰 기능에는 더 큰 비용이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">그래프 알고리즘</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">그래프 구성</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">그래프 속성</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">그래프 변환</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">그레고리 언 달력</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">그룹에 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">그룹에 읽기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">그룹에 읽기, 쓰기 및 실행 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">그룹에 쓰기 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">그룹 명령문 ( &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">음수 결과 값으로부터 보호</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">널 포인터로부터 보호</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">Guard는 &lt;code&gt;guard&lt;/code&gt; 기능 으로 변환되며 &lt;code&gt;MonadPlus&lt;/code&gt; 인스턴스 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">실패 할 수있는 IO 작업을위한 보호</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch, Daniel Ferizovic 및 Yihan Sun, &quot; &lt;em&gt;병렬 주문 세트에 합류&lt;/em&gt; &quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">해커 지역. 해커 지역. (경고를 받았습니다)</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">그러나 이것은 일반적으로 원하는 것이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPC는 요약 통계가 포함 된 텍스트 보고서 ( &lt;code&gt;hpc report&lt;/code&gt; )와 색상 표시가있는 소스 ( &lt;code&gt;hpc markup&lt;/code&gt; )의 두 가지 기본 방식으로 두 가지 정보를 모두 표시합니다 . 부울 범위의 경우 각 가드, ​​조건 또는 한정자에 대해 네 가지 가능한 결과가 있습니다. True 및 False 값이 모두 발생합니다. 오직 True; 오직 거짓; 평가되지 않았습니다. hpc-markup 출력에서 ​​배경이 노란색으로 강조 표시되면 평가되지 않은 프로그램의 일부가 나타납니다. 녹색 배경은 항상 참 표현을 나타내고 빨간색 배경은 항상 거짓 표현을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPC는 &lt;code&gt;.tix&lt;/code&gt; 파일 을 잠그려고 시도하지 않으므로 동일한 디렉토리에서 동시에 실행중인 여러 바이너리가 경쟁 조건을 나타냅니다. 컴파일 타임에는 생성 된 &lt;code&gt;.tix&lt;/code&gt; 파일 의 이름을 변경할 방법이 없습니다 . 실행시에, 상기 생성 된 이름 &lt;code&gt;.tix&lt;/code&gt; 의 파일을 사용하여 변경 될 수 &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; 을&lt;/a&gt; ; 바이너리 이름을 바꾸면 &lt;code&gt;.tix&lt;/code&gt; 파일 의 이름 도 변경됩니다. HPC는 GHCi에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 HPC 인스 트루먼 테이션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML은 HTML 태그에 올바르게 넣을 수있는 클래스입니다. 따라서 이것은 하나 이상의 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 요소 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , for example.</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">오류를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">예외를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">파일 디스크립터 (FD)로 구현 된 조작 처리</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">핸들 속성</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">읽을 핸들</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stderr&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stdin&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 에 사용할 핸들 (Nothing =&amp;gt; 기존 &lt;code&gt;stdout&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">쓸 핸들</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">예외가 발생하면 호출 할 핸들러</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">유형별 수정 자 처리</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">Win32 API를 사용하여 하드 링크 처리 [NTFS 만 해당]</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">신호 처리</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">Win32 API를 사용하여 심볼릭 링크 처리 [나중의 Vista 및 데스크톱 앱에만 해당]</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 신호 처리</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이벤트 로그 기록기를 이벤트 로그 데이터에 버퍼링합니다. 사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 에&lt;/a&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">하드 링크 이름</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">하드 링크</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">HasCallStack 호출 스택</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">해시 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . 실제로는 아니지만 두 개의 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 가 동일한 값으로 해시 될 수 있습니다. 반환 된 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 좋은 해시 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">Haskeline에는 두 가지 방법으로 사용자와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010 및 Haskell 98을 사용하면 정수 리터럴을 10 진수, 8 진수 ( &lt;code&gt;0o&lt;/code&gt; 또는 &lt;code&gt;0O&lt;/code&gt; 접두사 ) 또는 16 진 표기법 ( &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 접두사) 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010 및 Haskell 98은 &lt;code&gt;1.2e6&lt;/code&gt; 구문으로 부동 리터럴을 정의합니다 . 이 리터럴은 &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">하스켈 2010 기능</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98은 프로그래머가&amp;ldquo; &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; &amp;rdquo;를 데이터 유형 선언에 추가하여 &lt;code&gt;deriving&lt;/code&gt; 절에 지정된 클래스에 대한 표준 인스턴스 선언을 생성 할 수 있습니다 . Haskell 98에서 &lt;code&gt;deriving&lt;/code&gt; 항목에 나타날 수있는 유일한 클래스 는 표준 클래스 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98을 사용하면 프로그래머는 데이터 클래스 선언에 파생 절을 추가하여 지정된 클래스에 대한 표준 인스턴스 선언을 생성 할 수 있습니다. GHC는이 메커니즘을 여러 축을 따라 확장합니다.</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98을 사용하면 클래스를 선언 할 때 기본 구현을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98은 클래스 메소드 유형이 클래스 유형 변수에 대한 제한 조건을 언급하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98은이 네 가지를 모두 모호한 것으로 간주하지만 &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 확장을 통해 GHC는 이전 두 가지를 허용합니다. 규칙은 Haskell 98의 인스턴스 선언과 정확히 동일합니다. 여기서 인스턴스 선언에서 메소드 바인딩의 왼쪽에있는 메소드 이름은 해당 클래스의 메소드를 명확하게 참조합니다 (범위 내에있는 경우). 범위 내에 동일한 이름을 가진 다른 변수가있는 경우에도 마찬가지입니다. 이는 동일한 필드 이름을 사용하는 다른 모듈에서 두 개의 레코드를 가져올 때 규정 된 이름의 혼란을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 C printf가 사용하는 기본 &quot;6 자리&quot;정밀도를 절대 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 무료로 더하기 부호없이 가능한 최소 자릿수로 전자 형식 숫자의 지수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 소수점 이하 자릿수를 나타내는 것으로 &quot;정밀도&quot;지정자를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 가능하면 소수점 다음에 0을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Haskell은 데이터 타입에 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">하스켈 컴파일러</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskell은 &lt;code&gt;Handle&lt;/code&gt; 유형의 값으로 표시되는 파일에서 문자를 읽고 쓰는 작업을 정의합니다 . 이 유형의 각 값은 &lt;em&gt;핸들입니다&lt;/em&gt; . 파일 시스템 오브젝트로 I / O 를 &lt;em&gt;관리&lt;/em&gt; 하기 &lt;em&gt;위해&lt;/em&gt; Haskell 런타임 시스템에서 사용하는 레코드 입니다. 핸들에는 최소한 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">프롬프트에서 Haskell 표현식을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">하스켈 파일</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">하스켈 식별자 (예 : &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;Baz&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskell은 각 유형 변수의 종류를 유추합니다. 함수에 대한 타입 시그니처를 제공하는 것이 좋 듯이 명시 적으로 (기계 검사 된) 문서로 종류를 제공하는 것이 좋습니다. 어떤 경우에는 그렇게하는 것이 필수적입니다. 예를 들어, 논문 &quot;하스켈의 제한된 데이터 유형&quot;(Haskell Workshop 1999)에서 John Hughes는 데이터 유형을 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Haskell lexer : lexeme이 아닌 lexed 문자열을 반환</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">하스켈 도서관 저자가 선택할 수 있습니다. 대부분은 안전한 추론을 사용해야합니다. 언어의 안전하지 않은 기능을 피한다고 가정하면 모듈이 안전으로 표시됩니다. 유추 된 것과 명시적인 것에는 다음과 같은 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskell은 &lt;code&gt;IO&lt;/code&gt; 모나드를 통해 강력한 유형 시스템과 순수하고 효과적인 기능을 분리 합니다. 그러나 타입 시스템에는 몇 개의 루프 홀이 있으며, 가장 확실한 것은 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; 함수입니다. Safe Haskell의 안전한 언어 방언은 그러한 기능의 사용을 허용하지 않습니다. Haskell 코드를보다 쉽게 ​​분석하고 추론 할 수있게하므로 유용한 제한 사항이 될 수 있습니다. 또한 하스켈 커뮤니티의 기존 문화가 꼭 필요한 경우가 아니라면 안전하지 않은 기능을 피하려고 노력하고 있음을 체계화합니다. 따라서 &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 통해 안전한 언어를 사용하는 것은 &lt;code&gt;-Wall&lt;/code&gt; 기능과 유사한 좋은 스타일을 적용하는 방법으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskell은 색인 가능한 &lt;em&gt;배열을&lt;/em&gt; 제공 하는데, 이는 도메인이 정수의 연속적인 부분 집합에 대해 동형 인 함수로 생각할 수 있습니다. 이러한 방식으로 제한된 기능은 효율적으로 구현 될 수 있습니다. 특히, 프로그래머는 구성 요소에 대한 빠른 액세스를 합리적으로 기대할 수 있습니다. 이러한 구현의 가능성을 보장하기 위해 배열은 일반적인 기능이 아닌 데이터로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 값에 대한 Haskell 표현 . 사용자가 자신의 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 값 정의를 추가 할 수 있도록 구현이 의도적으로 노출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 값 의 하스켈 표현</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Haskell 소스 파일은 명령 행에서 이름이 지정 될 수 있으며 대화식 모드에서와 같이 정확하게로드됩니다. 로드 된 모듈의 컨텍스트에서 표현식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskell은 모듈 &lt;code&gt;M&lt;/code&gt; 을 컴파일 할 때 &amp;ldquo;아래&amp;rdquo; &lt;code&gt;M&lt;/code&gt; 의 모든 모듈에서 인스턴스 선언을 볼 수 있도록 지정합니다. (모듈 &lt;code&gt;A&lt;/code&gt; 는 &quot;아래&quot;입니다 &lt;code&gt;M&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 는 직접 가져 &lt;code&gt;M&lt;/code&gt; , 또는 경우에 &lt;code&gt;A&lt;/code&gt; 는 모듈 아래에있게 &lt;code&gt;M&lt;/code&gt; 의 직접 수입.) 원칙적으로는, GHC 그러므로 아래의 모든 모듈의 인터페이스 파일을 읽을 수 있어야합니다 &lt;code&gt;M&lt;/code&gt; 을 가 포함 된 단지의 경우, 에 중요한 인스턴스 선언 &lt;code&gt;M&lt;/code&gt; . 이것은 실제로 재앙 일 것이므로 GHC는 영리하려고 노력합니다.</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">하스켈 기호 (예 : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">하스켈 스레드 및 운영 체제 스레드</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Haskell 스레드는 동기화 된 가변 변수 인 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 통해 통신 할 수 있습니다 ( &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 로부터 몇 가지 공통된 동시성 추상화를 구축 할 수 있으며 &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 라이브러리에서 제공 합니다. GHC에서 스레드는 예외를 통해 통신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;bool&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;char&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;clock_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;double&lt;/code&gt; 유형을 나타내는 하스켈 유형 .</target>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;float&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;fpos_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;int&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;jmp_buf&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long long&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;ptrdiff_t&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;short&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;sig_atomic_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;signed char&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;size_t&lt;/code&gt; 타입을 나타내는 하스켈 타입 .</target>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;suseconds_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;time_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;unsigned char&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">는 C 대표 하스켈 타입 &lt;code&gt;unsigned int&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned long long&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned long&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;unsigned short&lt;/code&gt; 유형을 나타내는 Haskell 유형 .</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;useconds_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;wchar_t&lt;/code&gt; 타입을 나타내는 Haskell 타입 .</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">하스켈 타입 시그니처는 암시 적으로 정량화됩니다. 언어 옵션 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 이 사용될 때, &lt;code&gt;forall&lt;/code&gt; 키워드를 사용하면 이것이 의미하는 바를 정확하게 말할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">Haskell 's &lt;code&gt;Maybe&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; (목록), &lt;code&gt;ST&lt;/code&gt; (엄격하고 게으른 버전 모두), &lt;code&gt;IO&lt;/code&gt; 및 기타 여러 모나드에는 &lt;code&gt;MonadFix&lt;/code&gt; 인스턴스가 있습니다. 부정적인 측면에서 서명 &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; a- &amp;gt; r)-&amp;gt; r 과 함께 연속 모나드 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">Haskell의 기본 메커니즘 ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, 섹션 4.3.4&lt;/a&gt; )은 &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt; 가 지정 될 때 문자열 리터럴을 포함하도록 확장 됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Haskell의 독점 제한 ( Haskell 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;섹션 4.5.5&lt;/a&gt; 참조 )은 &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt; 으로 완전히 끌 수 있습니다 . GHC 7.8.1부터 GHCi의 대화식 옵션에서 단일형 제한이 기본적으로 해제되어 있습니다 ( &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Haskell의 오버로드 (유형 클래스 사용)는 우아하고 깔끔한 등입니다. 그러나 내부 루프에 남아 있으면 성능이 저하됩니다. 어떻게 스쿼시 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">memcpy 및 memmove에 대한 Haskellish 인터페이스</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">내보내기 목록의 중복 항목에 대해 컴파일러가 경고하도록하십시오. 이는 큰 반출 목록을 유지하고 반출 목록에서 멘션을 삭제 한 후 정의를 계속 반출하지 않으려는 경우에 유용한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오. 특히:</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">컴파일러가 형식 서명의 중복 제약 조건에 대해 경고하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="translated">Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</target>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Prelude를 내재적으로 가져 오는 경우 컴파일러에 경고를 표시하십시오. 이는 Prelude 모듈을 &lt;code&gt;import ... Prelude ...&lt;/code&gt; 행을 사용하여 명시 적으로 가져 오거나 내재 된 가져 오기를 사용하지 않는 경우 ( &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma에 의해)가 아닌 한 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import ... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</target>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">소스 파일에 탭이 있으면 컴파일러에 경고를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">컴파일러가 소스에서 Haskell Monomorphism Restriction이 적용되는 위치를 경고 / 알리도록합니다. MR을 자동으로 적용하면 예상치 못한 동작이 발생할 수 있으므로 적용 중임을 명시 적으로 경고하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">컴파일러가 소스에서 Haskell 기본 설정 메커니즘이 시작되는 위치를 경고 / 알림으로 알려주십시오. 이는 하나의 기본값을 다른 것으로 가정하는 컨텍스트의 코드를 변환 할 때 유용한 정보입니다 (예 : Haskell 1.4의 '기본 기본값') 그렇지 않으면 제약이없는 값 &lt;code&gt;1&lt;/code&gt; 에 유형 &lt;code&gt;Int&lt;/code&gt; 가 부여되고 Haskell 98 이상에서는 기본값이 &lt;code&gt;Integer&lt;/code&gt; 가 됩니다. 이것은 성능과 동작의 차이로 이어질 수 있으므로 이것에 대해 침묵하지 않는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">프로파일 링을 위해 프로그램을 컴파일 한 후에는 프로파일을 생성하기 위해 프로그램을 실행해야합니다. 예를 들어, &lt;code&gt;+RTS -p&lt;/code&gt; ( &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 참조 )로 프로그램을 실행하여 간단한 시간 프로파일을 생성 할 수 있습니다. 이 파일은 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; 라는 파일을 생성합니다. 여기서 ⟨prog⟩는 프로그램 이름 ( &lt;code&gt;.exe&lt;/code&gt; 확장자 없이 ) Windows에있는 경우).</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">프로그램을 실행 한 후, 텍스트 범위의 요약을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">우리는 그런 말을 한 &lt;em&gt;수&lt;/em&gt; 당신이 정말로 사용해야 할 경우 그래서, GHC는 부동 소수점 상태에 대한 수행을 정확히 문서화 &lt;code&gt;fenv.h&lt;/code&gt; 다음 함정의 전체 지식을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">부분 문자열에서 끊어진 끈의 머리와 꼬리</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">힙 조각화</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; 를 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 을 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 구현 으로 사용하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 완전히 평가하는 도우미</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">&lt;code&gt;RealFloat&lt;/code&gt; 유형 클래스 작업을 위한 도우미</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">&quot;래퍼&quot;기능 정의를위한 헬퍼</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">따라서 원래 표현식에는 &lt;code&gt;Show&lt;/code&gt; 클래스 의 인스턴스 인 유형이 있어야합니다 . 그렇지 않으면 GHCi가 다음과 같이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">여기 수입 &lt;code&gt;B&lt;/code&gt; 만, &lt;code&gt;B&lt;/code&gt; 의 수입 A의 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 순환 종속성 나누기 프라그. 모듈 임포트 그래프의 모든 루프는 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 임포트로 끊어야합니다. 또는 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 가져 오기가 무시되는 경우 모듈 가져 오기 그래프는 비순환이어야합니다 . &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;D&lt;/code&gt; 의 정의에서 모호 하지만 나중에 유형 응용 프로그램을 사용하여 &lt;code&gt;Int&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 는 클래스 매개 변수이지만 유형은 세 번째 매개 변수 &lt;code&gt;x&lt;/code&gt; 에서도 색인됩니다 .</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 은 패턴 동의어를 사용하지 않습니다. 숫자 패턴과 일치하도록 &lt;code&gt;42&lt;/code&gt; &lt;em&gt;필요&lt;/em&gt; 제약을 만족시키기 위해 발신자 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 가 나타나지 않도록 &lt;code&gt;f1&lt;/code&gt; 의 유형. &lt;code&gt;show&lt;/code&gt; 호출 은 &lt;code&gt;(Show b)&lt;/code&gt; 제약 조건을 생성합니다 . 여기서 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;MkT&lt;/code&gt; 의 패턴 일치에 의해 바인딩되는 존재 유형 변수 입니다. 그러나 동일한 패턴 일치는 제약 조건 &lt;code&gt;(Show b)&lt;/code&gt; ( &lt;code&gt;MkT&lt;/code&gt; 유형 참조 ) 도 &lt;em&gt;제공&lt;/em&gt; 하므로 모든 것이 잘됩니다.</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 은 패턴 동의어를 사용하지 않습니다. 숫자 패턴과 일치하도록 &lt;code&gt;42&lt;/code&gt; &lt;em&gt;필요&lt;/em&gt; 제약을 만족시키기 위해 발신자 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 가 나타나지 않도록 &lt;code&gt;f1&lt;/code&gt; 의 유형. &lt;code&gt;show&lt;/code&gt; 를 호출 하면 &lt;code&gt;(Show b)&lt;/code&gt; 제약 조건이 생성됩니다. 여기서 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;MkT&lt;/code&gt; 의 패턴 일치에 의해 바인딩 된 실존 적 유형 변수 입니다. 그러나 동일한 패턴 일치 가 제약 조건 &lt;code&gt;(Show b)&lt;/code&gt; 도 &lt;em&gt;제공&lt;/em&gt; 하므로 ( &lt;code&gt;MkT&lt;/code&gt; 유형 참조 ) 모든 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">여기서 &lt;code&gt;f&lt;/code&gt; 는 자유 변수가 없기 때문에 일반화됩니다. 이의 결합기는 단일 형성 제한에 영향을받지 않으며; 따라서 &lt;code&gt;f&lt;/code&gt; 가 닫힙니다. 하나의 닫힌 자유 변수, 즉 &lt;code&gt;f&lt;/code&gt; 가 있다는 점을 제외하고 는 동일한 추론이 &lt;code&gt;g&lt;/code&gt; 에 적용됩니다 . 마찬가지로 &lt;code&gt;h&lt;/code&gt; 폐쇄 &lt;em&gt;가 최상위에 결합되지 않은 경우에도&lt;/em&gt; 그 유일한 자유 변수 때문에, &lt;code&gt;f&lt;/code&gt; 폐쇄된다. 그러나 &lt;code&gt;k&lt;/code&gt; 는 닫히지 않습니다. 왜냐하면 닫히지 않은 &lt;code&gt;x&lt;/code&gt; 를 언급 했기 때문입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">여기서 &lt;code&gt;f&lt;/code&gt; 업데이트해야 &lt;code&gt;T&lt;/code&gt; 를 도 있기 때문에 &lt;code&gt;S&lt;/code&gt; 나 &lt;code&gt;U&lt;/code&gt; 가 두 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">여기에서 &lt;code&gt;h&lt;/code&gt; 의 유형은 &lt;code&gt;b&lt;/code&gt; 에서 모호해 보이지만 여기에는 합법적 인 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">여기서 &lt;code&gt;h&lt;/code&gt; 의 유형은 &lt;code&gt;b&lt;/code&gt; 에서 모호해 보이지만 다음 은 법적 호출입니다.</target>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">여기서 &lt;code&gt;strange&lt;/code&gt; 유형은 모호하지만 &lt;code&gt;foo&lt;/code&gt; 호출 은 &lt;code&gt;(D Bool b)&lt;/code&gt; 인스턴스에 의해 용해되는 제약 조건 &lt;code&gt;(D Bool beta)&lt;/code&gt; 을 발생시키기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">여기서 &lt;code&gt;strange&lt;/code&gt; 유형은 모호하지만 &lt;code&gt;foo&lt;/code&gt; 의 호출 은 &lt;code&gt;(D Bool b)&lt;/code&gt; 인스턴스 에서 사용할 수있는 제약 조건 &lt;code&gt;(D Bool beta)&lt;/code&gt; 을 발생시키기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">여기서 &lt;code&gt;tag&lt;/code&gt; 는 올바른 유형의 선택기 함수 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; 가있는 공개 필드 입니다. &lt;code&gt;self&lt;/code&gt; 유형은 외부에서 숨겨져; 함수로 &lt;code&gt;_this&lt;/code&gt; , &lt;code&gt;_inc&lt;/code&gt; 또는 &lt;code&gt;_display&lt;/code&gt; 를 적용하려고 하면 컴파일 타임 오류가 발생합니다. 즉, &lt;em&gt;GHC는 유형이 실질적으로 정량화 된 변수를 언급하지 않는 필드에 대해서만 레코드 선택기 함수를 정의합니다&lt;/em&gt; . (이 예제는 레코드 선택기가 정의되지 않는 필드에서 밑줄을 사용했지만 프로그래밍 스타일 일 뿐이며 GHC는이를 무시합니다.)</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 와 패턴 바인딩 &lt;code&gt;(y,z)&lt;/code&gt; 은 게으르게 유지됩니다. 이유 : 처음 사용할 때까지 강제로 할 수있는 좋은 순간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">여기서 GHC는 그 표현을</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">여기서 gHC는 최상위 &lt;code&gt;g&lt;/code&gt; 인스턴스에서 제한 조건 &lt;code&gt;(C c Int)&lt;/code&gt; 을 해결하지 않습니다. g 의 특정 호출이 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 를 모두 같은 유형으로 인스턴스화 할 수 있으므로 제한 조건이 다른 방식으로 해결 될 수 있기 때문입니다. 후자의 제한은 원칙적으로 구속 조건 해석기를 완료하는 것입니다. (관심있는 사람들은 &lt;code&gt;TcInteract&lt;/code&gt; 에서 &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; 지정된 오버랩] 을 읽을 수 있습니다.) 피하기 쉽습니다. 형식 서명에서 최상위 인스턴스와 일치하는 제약 조건을 피하십시오. &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; 플래그 는 그러한 서명에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">다음은 &lt;code&gt;filepath&lt;/code&gt; 함수를 함께 사용하는 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">다음은 허용 및 불법 유형 인스턴스의 예입니다.</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">다음은이 번역이 작동하는 방법에 대한 몇 가지 예입니다. 각 서열의 첫 번째 발현은 하스켈 공급원입니다. 다음은 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">다음은 상기 표현을 사용하는 몇 가지 예입니다. 다음 과 같이 인코딩 된 몇 가지 유형의 &lt;code&gt;Type&lt;/code&gt; 유니버스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">속성을 보여주는 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">내보내기 목록과 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">재귀 표기법을 사용할 때의 다른 중요한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; 와 &lt;code&gt;Foldable&lt;/code&gt; 에 대해 생성 된 코드의 차이점은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">각 확장에서 생성 된 코드의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;GHC.Exts&lt;/code&gt; 에서 제공되는 주요 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">두드러진 특징은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">다음은 속성을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">다음은이 파일의 구문에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">재귀 적 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">다음은 거의 모든 메타 정보가 제거 된 &lt;code&gt;Tree&lt;/code&gt; 의 축소 표현 입니다. 이제 가장 중요한 측면 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">다음은 간단한 (생각되었지만) 예입니다.</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">간단한 비재 귀적 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">다음은 예제 &lt;code&gt;mdo&lt;/code&gt; -expression 과 &lt;code&gt;rec&lt;/code&gt; 블록으로 의 변환입니다 .</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="translated">다음은 제한된 종류의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">다음은 몇 가지 SCC가있는 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Lift&lt;/code&gt; 를 파생시키는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">다음은 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">다음은 유형 수준의 숫자 리터럴을 사용하여 하위 수준 함수에 안전한 인터페이스를 제공하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">간단한 레코드 작업을 시뮬레이션하기 위해 형식 수준 문자열 리터럴을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 및 catchError 예외 메커니즘 과 함께 사용자 정의 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 데이터 유형을 사용하는 방법을 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 입니다. 사용자가 빈 문자열 또는 5자를 초과하는 문자열을 입력하면 예제에서 예외가 발생합니다. 그렇지 않으면 문자열의 길이를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 및 catchError 예외 메커니즘 과 함께 사용자 정의 오류 데이터 유형을 사용하는 방법을 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 입니다. 사용자가 빈 문자열 또는 5자를 초과하는 문자열을 입력하면 예제에서 예외가 발생합니다. 그렇지 않으면 문자열의 길이를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">오버로드 된 레이블을 레코드 선택기로 사용하는 방법을 보여주는 &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; 의 레코드 액세스 예제 확장은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">이 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">여기서, &lt;code&gt;Eq [a]&lt;/code&gt; 의 최상위 인스턴스 서명에 중첩 &lt;code&gt;Eq [a]&lt;/code&gt; . GHC는 전자를 사용하기 위해 몇 가지 노력을 기울이지 만, 후자를 사용해야한다면 불용성 &lt;code&gt;Eq a&lt;/code&gt; 제약 이있을 것이다 . 대신 다음과 같이 작성하면 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">여기서 &lt;code&gt;(==)&lt;/code&gt; 를 호출 하면 GHC는 &lt;code&gt;(Eq a)&lt;/code&gt; 제약 조건이 필요 하다고 생각 하므로 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">유형 변수 &lt;code&gt;t&lt;/code&gt; 는 유형 계열 응용 프로그램에서만 나타나므로 모호 하기 때문에 여기서 &lt;code&gt;id&lt;/code&gt; 의 정의는 거부 됩니다. 그러나이 코드는 GHC에 &lt;code&gt;Id&lt;/code&gt; 가 주입 형 이라고 말하면 받아 들여질 것 입니다. 즉 , 인수 유형에서 콜 사이트에서 &lt;code&gt;t&lt;/code&gt; 를 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">여기서 인스턴스 선언의 서명은 인스턴스화 된 클래스 메소드에 필요한 것보다 다형성입니다.</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">여기서 슈퍼 클래스주기는 종료되지만 완전히 이해되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">여기서 식의 형식 서명을 안쪽으로 밀어 f에 대한 형식 서명을 제공 할 수 있습니다. 마찬가지로 더 일반적으로 함수 자체에 대한 형식 서명을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">여기서 형식 변수 &lt;code&gt;a&lt;/code&gt; 는 생성자의 결과 형식에 나타나지 않습니다. 생성자의 유형으로 보편적으로 수량화되지만 이러한 유형 변수를 종종 &quot;존재&quot;라고합니다. 실제로, 위 선언은 정확히 같은 유형을 선언합니다. &lt;code&gt;data Foo&lt;/code&gt; 에서 &lt;a href=&quot;#existential-quantification&quot;&gt;실존 데이터 생성자를 정량화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="translated">여기서 범용 유형 변수 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 정의를 범위로 지정 하지만 실존 적 &lt;code&gt;b&lt;/code&gt; 는 그렇지 않습니다. (참조 # 14998에 대한 토론.)</target>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">여기서 범용 타입 변수 는 &lt;code&gt;P&lt;/code&gt; 의 정의에 &lt;code&gt;a&lt;/code&gt; 범위입니다 만 존재하는 &lt;code&gt;b&lt;/code&gt; 는 그렇지 않습니다. (Trac # 14998에 대한 논의 참조)</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">여기서는 인스턴스를 파생시킬 수 없습니다</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">여기서 생성자 인수이므로 &lt;code&gt;w&lt;/code&gt; 에 타입 서명을 줄 필요가 없습니다. &lt;code&gt;T1&lt;/code&gt; GHC에게 알아야 할 모든 것을 알려 .</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">여기에 두 개의 데이터 인스턴스 선언이 있습니다. 하나는 마지막 매개 변수가 &lt;code&gt;[v]&lt;/code&gt; 이고 다른 하나는 &lt;code&gt;Int&lt;/code&gt; 입니다. &lt;code&gt;(GMap Flob ...)&lt;/code&gt; 에 대한 &lt;em&gt;후속&lt;/em&gt; 인스턴스를 제공 할 수 없으므로이 기능은 무료 색인 매개 변수가 유한 한 수의 대안이있는 유형 인 경우에 가장 유용합니다 ( &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">여기서는 런타임 시스템의 &lt;code&gt;-V0&lt;/code&gt; 옵션을 사용하여 디버깅 세션을 방해 할 수있는 RTS의주기 타이머를 비활성화했습니다. 프로그램에 침입하면 &lt;code&gt;gdb&lt;/code&gt; 는 현재 실행 지점에 해당하는 소스 프로그램의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">여기에서 우리는 &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; 인스턴스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">여기서 우리는 스택 트레이스의 첫 번째 비트가 주소 &lt;code&gt;0x006eb0c0&lt;/code&gt; 에 식별되지 않은 많은 스택 프레임을 가지고 있음을 알 수 있습니다. 우리가 묻는다면 &lt;code&gt;gdb&lt;/code&gt; 에이 위치에 대해 하면이 프레임은 실제로 STG 업데이트 클로저이며</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">여기에 &lt;code&gt;calculateLength&lt;/code&gt; 를 사용 하여 결과를 &lt;code&gt;print&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">여기에서는 &lt;a href=&quot;#class-default-signatures&quot;&gt;기본 서명&lt;/a&gt; 을 사용 하여 인스턴스화 할 형식 의 &lt;code&gt;Generic&lt;/code&gt; 인스턴스 가있는 한 사용자가 &lt;code&gt;put&lt;/code&gt; 구현을 제공 할 필요가 없도록 지정합니다 . 예를 들어 &lt;code&gt;UserTree&lt;/code&gt; 유형의 경우 사용자는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">여기서는 &lt;code&gt;-g&lt;/code&gt; 옵션을 사용 하여 생성 된 바이너리에 디버깅 정보를 추가해야한다는 것을 GHC에 알 렸습니다. 이 디버깅 출력의 세 가지 수준입니다 &lt;code&gt;-g0&lt;/code&gt; (NO 디버깅 정보, 기본값) &lt;code&gt;-g1&lt;/code&gt; (기본 역 추적에 충분), &lt;code&gt;-g2&lt;/code&gt; (또는 &lt;code&gt;-g&lt;/code&gt; 짧게는 -g , GHC가 알고있는 모든 것을 방출 . 이 디버깅 정보는 GHC가 수행하는 최적화에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 인수를 취하는 명령의 예입니다. &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; 를&lt;/a&gt; 다시 구현 한 것입니다 . .</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">사용할 catch 스타일 함수를 결정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">여기서 &lt;code&gt;(!:)&lt;/code&gt; 는 &lt;code&gt;Arr e&lt;/code&gt; 유형의 배열을 색인화하는 재귀 함수입니다 . &lt;code&gt;(Int,Int)&lt;/code&gt; 유형의 ( &lt;code&gt;(!:)&lt;/code&gt; 호출을 고려하십시오 . 두 번째 전문화가 시작되고 특수 기능이 인라인됩니다. 그것은 두 통화를 갖고 &lt;code&gt;(!:)&lt;/code&gt; , 유형에 모두 &lt;code&gt;Int&lt;/code&gt; 있습니다. 이 두 가지 부름은 첫 번째 전문 분야를 시작하며, 그의 전문 분야도 인라인됩니다. 결과는 인덱싱 함수의 유형 기반 언 롤링입니다.</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">여기에서 &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; 는 정수를 &lt;code&gt;Bool&lt;/code&gt; 에 매핑하는 함수 &lt;code&gt;even&lt;/code&gt; 하여 정수를 패키지합니다 . 및 &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; 호환 기능을 가진 캐릭터를 패키지. 이 두 가지 유형은 각각 &lt;code&gt;Foo&lt;/code&gt; 유형입니다. 이며 목록에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">여기서 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; 은 연결된 값이없는 유형 수준 프록시입니다.</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">여기서 &lt;code&gt;Adder&lt;/code&gt; 는 모듈 트리에있는 루트 모듈의 이름입니다 (위에서 언급 한 것처럼 단일 루트 모듈이 있어야하므로 DLL에 단일 모듈 트리가 있어야 함). 모든 것을 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">여기서 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;D&lt;/code&gt; 의 수퍼 클래스 이지만 &lt;code&gt;C&lt;/code&gt; 의 클래스 연산 &lt;code&gt;op&lt;/code&gt; 가 &lt;code&gt;D&lt;/code&gt; 를 언급 해도 괜찮습니다 . ( &lt;code&gt;D&lt;/code&gt; 가 &lt;code&gt;C&lt;/code&gt; 의 수퍼 클래스 가되는 것은 좋지 않습니다. .)</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 가져오고 &lt;code&gt;c&lt;/code&gt; 는 최상위 레벨에 바인딩되므로&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo; 의 확장에 기여하지 않습니다 . 여기서의 동기는 독자가&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;이 무엇으로 확장 되는지 쉽게 알아낼 수 있어야한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">여기서 &lt;code&gt;f1&lt;/code&gt; 과 &lt;code&gt;g1&lt;/code&gt; 은 순위 -1 유형이며 표준 Haskell로 작성 될 수 있습니다 (예 : &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ). &lt;code&gt;forall&lt;/code&gt; 암시 적으로 하스켈에 의해 추가 명시 적으로 보편적 인 정량화한다.</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;f2&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 에서는 엄격 하지만 &lt;code&gt;y&lt;/code&gt; 에서는 엄격 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">여기서 &lt;code&gt;f3&lt;/code&gt; 과 &lt;code&gt;f4&lt;/code&gt; 는 동일합니다. 어쨌든 평가를 강제하는 패턴 앞에 뱅을 두는 것은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;g&lt;/code&gt; 는 모호한 유형을 가지며 거부되지만 &lt;code&gt;f&lt;/code&gt; 는 좋습니다. &lt;code&gt;f&lt;/code&gt; 의 호출 사이트 에서 &lt;code&gt;?x&lt;/code&gt; 에 대한 바인딩 은 매우 명확하며 &lt;code&gt;a&lt;/code&gt; 유형을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;g&lt;/code&gt; 는 모호한 유형이며 거부되지만 &lt;code&gt;f&lt;/code&gt; 는 괜찮습니다. &lt;code&gt;f&lt;/code&gt; 의 호출 사이트 에서 &lt;code&gt;?x&lt;/code&gt; 에 대한 바인딩 은 매우 명확하며 유형 &lt;code&gt;a&lt;/code&gt; 를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt; 의해 범위로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">여기서 &lt;code&gt;lookup&lt;/code&gt; 는 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; 로 선언 되지만 해당 유형이 아직 없기 때문에 정의 사이트에서 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 특수화 할 수 없습니다 . 대신 클라이언트 모듈은 &lt;code&gt;T&lt;/code&gt; 를 정의한 다음 해당 유형에 대한 &lt;code&gt;lookup&lt;/code&gt; 를 전문화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;m x&lt;/code&gt; 는 첫 번째 명령문에서 생성 된 &lt;code&gt;x&lt;/code&gt; 의 값에 따라 달라 지므로 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 을 사용하여 표현식을 변환 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">여기서 &lt;code&gt;NumInst a&lt;/code&gt; 유형의 값은 명시 적 &lt;code&gt;(Num a)&lt;/code&gt; 사전과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">여기서 GHC는 &lt;code&gt;foldl&lt;/code&gt; 의 본문을 콜 사이트로 인라인 한 후 루프 본문의 인수에서 &lt;code&gt;SPEC&lt;/code&gt; 를 사용하기 때문에 &lt;code&gt;foldl_loop&lt;/code&gt; 에서 콜 패턴 전문화를 매우 적극적으로 수행합니다 . &lt;code&gt;SPEC&lt;/code&gt; 에서 &lt;code&gt;GHC.Types&lt;/code&gt; 은 특히 컴파일러에 의해 인식된다.</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">여기서 오른쪽 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 은 왼쪽에서 발생하지 않는 종류 변수 &lt;code&gt;a&lt;/code&gt; 를 언급하지만 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 종류 패턴에 의해 &lt;em&gt;암시 적으로&lt;/em&gt; 바인딩 되므로 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="translated">여기서 오른쪽 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 은 왼쪽에서 발생하지 않는 종류 변수 &lt;code&gt;a&lt;/code&gt; 를 언급하지만 , &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 종류 패턴에 &lt;em&gt;암시 적으로&lt;/em&gt; 묶여 있기 때문에 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">여기서 &lt;code&gt;T Loop&lt;/code&gt; 타입을 사용하려고 시도하면 그 정의가 끝없이 반복 되므로 타입 체커를 무한 루프로 던질 것입니다. 다른 경우 에는 생성 된 코드가 유형 검사기를 루프에 넣지 않아도 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 를 활성화해야 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">여기서 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Orphan&lt;/code&gt; 모듈에서 선언 되지 않습니다 . 이러한 모듈을 &quot;고아 모듈&quot;이라고합니다. GHC는 고아 모듈을 식별하고 컴파일중인 모듈 아래에있는 모든 고아 모듈의 인터페이스 파일을 방문합니다. 이것은 일반적으로 낭비되는 작업이지만 피할 수는 없습니다. 따라서 가능한 한 적은 수의 고아 모듈을 갖도록 최선을 다해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">여기서 &lt;code&gt;b&lt;/code&gt; 만이 다형성 다형성입니다. levity-polymorphic 유형의 변수는 없습니다. 그리고 코드 생성기는 이것에 아무런 문제가 없습니다. 실제로 이것은 GHC의 &lt;code&gt;$&lt;/code&gt; 연산자 의 실제 유형이며 Haskell 98 버전보다 약간 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="translated">여기에서 종류 서명은 &lt;code&gt;'Just&lt;/code&gt; 안에 숨겨져 있으며 가장 바깥 쪽 종류 서명은 없습니다. 가장 바깥 쪽 종류의 서명을 제공하여이 예제를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">여기서 &lt;code&gt;ys&lt;/code&gt; 와 &lt;code&gt;zs&lt;/code&gt; 의 패턴 서명 은 문제가 없지만, &lt;code&gt;b&lt;/code&gt; 의 범위 가 아니기 때문에 &lt;code&gt;v&lt;/code&gt; 의 서명 은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">여기서, 패턴 타입 시그니처 &lt;code&gt;[t::a]&lt;/code&gt; 는 아직 범위 내에 있지 않은 어휘 타입 변수를 언급합니다. 실제로 패턴 일치에 의해 바인딩되므로 범위 내에 &lt;em&gt;있지 않아야합니다&lt;/em&gt; . 그 효과는 범위가 존재하여 존재 바인딩 유형 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">여기에서 모두에 대한 정량화 된 제약 &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; 는 로컬 인스턴스 선언과 약간 유사하게 작동하며 인스턴스를 입력 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">여기서 데이터 인스턴스의 오른쪽 에는 왼쪽에없는 유형 변수 &lt;code&gt;d&lt;/code&gt; 가 있습니다. 이러한 데이터 인스턴스는 형식 안전성을 손상시킬 수 있으므로 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;f1&lt;/code&gt; 의 결과 이므로 &lt;code&gt;MkFoo&lt;/code&gt; 에 의해 바인딩 된 유형은 &quot;이스케이프&quot; 됩니다. 이것이 왜 잘못된 지 확인하는 한 가지 방법은 &lt;code&gt;f1&lt;/code&gt; 유형 이 무엇인지 묻는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">여기에서 모든 유형의 서명이 &lt;code&gt;forall s. ST s Bool&lt;/code&gt; 은 어노테이션이있는 표현식 &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; 에서 유형 변수 &lt;code&gt;s&lt;/code&gt; 를 범위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 의 16 진 인코딩 .</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 의 16 진수 인코딩 .</target>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">16 진수</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">숨겨진 패키지 ( &lt;code&gt;exposed&lt;/code&gt; 플래그가 &lt;code&gt;False&lt;/code&gt; 인 패키지)는 패키지 목록에서 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">기본적으로 모든 패키지 숨기기</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">플러그인의 모든 패키지를 기본적으로 숨기십시오</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">패키지 숨기기</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 생성자에 대해 최고 허용 연산자 우선 순위 (답 : 9)</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 생성자에 대해 최고 허용 연산자 우선 순위 (답 : 9)</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">역사적으로 &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 관용구에 대한 안전한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">역사적으로 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 관용구에 대한 안전한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">반면에 &lt;code&gt;Weak ThreadId&lt;/code&gt; 유지 하면 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 를 수신하지 못하게됩니다 . &lt;code&gt;Weak ThreadId&lt;/code&gt; 에 예외를 던질 수는 있지만 호출자는 스레드가 여전히 존재하는지 여부를 판별하기 위해 먼저 &lt;code&gt;deRefWeak&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="translated">Hole-fit 플러그인은 typed-hole 오류 메시지가 생성 될 때 호출되는 플러그인으로, 컴파일 타임에 typed-hole에 대한 정보에 액세스 할 수 있으며 유효한 구멍 맞춤 제안을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">홈 디렉토리 (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">호스트 엔디안, 정렬되지 않은 디코딩</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">호스트 엔디안, 정렬되지 않은 쓰기</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">호스트 별 이진 인코딩</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">12시</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">제로 시간</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">힙 프로파일 러가보고 한 힙 상주가 프로그램을 실행할 때 실제 메모리 상주와 어떤 관련이 있습니까? 힙 프로파일 러에서보고 한 상주와 시스템의 도구 (예 : Unix에서 &lt;code&gt;ps&lt;/code&gt; 또는 &lt;code&gt;top&lt;/code&gt; , Windows의 작업 관리자)에 의해보고 된 상주간에 큰 차이가있을 수 있습니다 . 이에 대한 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">컴파일러가 사전을 인라인하기 위해 얼마나 간절해야합니까?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">컴파일러가 함수를 인라인하기 위해 얼마나 간절해야합니까?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">프로그램이 실행 된 시간 (CPU 시간 및 경과 된 벽시계 시간)</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">이 가비지 콜렉션에 소요 된 시간 (CPU 시간 및 경과 된 벽시계 시간)</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">현재 사용중인 바이트 수</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">이 비용 센터 내부에서 프로그램이 몇 바이트를 할당 했습니까? 하위 비용 센터에있는 동안에는 할당이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">읽을 바이트 수</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">이 가비지 수집을 할당 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">이 가비지 수집을 복사 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">프로그램이 시작된 기능 수 (예 : &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션 사용) &lt;code&gt;setNumCapabilities&lt;/code&gt; 함수 로 인해 실행 중에 기능 수가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">마지막 가비지 수집이 끝난 후 발생한 페이지 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">이 가비지 콜렉션이 발생한 페이지 결함 수입니다.</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">프로그램 실행 과정에서 경과 된 프로파일 러 &quot;틱&quot;수.</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt; 의 스택 프레임 수</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">이 비용 센터 내에서 프로그램의 실행 횟수는 몇 번입니까? 아동 비용 센터는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">이 비용 센터는 몇 번이나 입력 되었습니까?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">프로파일 러 틱 사이의 시간</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">stderr를 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">표준 입력을 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">표준 출력을 결정하는 방법</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">숫자 필드의 부호를 처리하는 방법. &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; 가 우선적 으로 상호 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">그러나 당신이 사용하는 경우 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; 의 이름 범위에 무엇이든 다음 GHC 대신 사용 &lt;code&gt;toList&lt;/code&gt; , &lt;code&gt;fromList&lt;/code&gt; 및 &lt;code&gt;fromListN&lt;/code&gt; 을 . 즉, 이러한 기능은 리 바인드 가능합니다. cf 리 &lt;a href=&quot;#rebindable-syntax&quot;&gt;바인딩 가능한 구문 및 암시 적 Prelude 가져 오기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">그러나 GHCi의 오버랩 규칙에 대한 &lt;a href=&quot;ghci#ghci-decls&quot;&gt;유형, 클래스 및 기타 선언&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">그러나 생성 된 정의가 여전히 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 의 입력에 있는지주의하십시오 . 유형 확인 입력을 필터링하지 않으면 공구 동작이 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">그러나 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">그러나 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">그러나 Debug.Trace.trace는 &lt;code&gt;stderr&lt;/code&gt; 대신 Windows 디버깅 출력 지원을 사용하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;바운드&lt;/em&gt; 스레드를 작성하는데 , OpenGL과 같은 스레드 로컬 상태를 사용하는 외부 (Haskell이 아닌) 라이브러리를 호출해야하는 경우에 필요합니다 ( &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">그러나 let / where 패턴 바인딩의 &lt;em&gt;중첩 된&lt;/em&gt; 뱅은 다른 모든 형태의 패턴 일치와 균일하게 동작합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">그러나 이러한 제한 외에도 완전히 평가되지 않은 표현을 포함하여 많은 것들이 허용됩니다! 주석 표현식은 Template Haskell 스플 라이스와 마찬가지로 컴파일러에서 평가합니다. 따라서이 주석은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">그러나 GHC는 형식의 일부가 생략 될 때 형식을 &lt;em&gt;유추&lt;/em&gt; 해야하므로 다형성 재귀를 사용할 수 없습니다. 형식 서명이 완전히 생략 된 경우에도 동일한 제한이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">그러나 Haskell의 타입 클래스 시스템에 대한 간단한 확장으로 동적 바인딩을 지원할 수 있습니다. 기본적으로 동적 바인딩 된 변수를 형식의 제약 조건으로 사용합니다. 이러한 제약 조건은 &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; 형식으로 이어 지며 ,이 함수는&amp;ldquo;이 함수는 동적으로 바인딩 된 변수 &lt;code&gt;?x&lt;/code&gt; 유형 &lt;code&gt;t'&lt;/code&gt; 을 사용 합니다. 예를 들어, 다음은 &lt;code&gt;cmp&lt;/code&gt; 라는 비교 함수에 의해 암시 적으로 매개 변수화 된 정렬 함수의 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">그러나 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">그러나 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장을 활성화하면 모듈을 컴파일 할 수 있습니다. 다음을 포함하여 다양한 확장에서 유사한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">그러나 GADT의 경우 다음과 같은 추가 제약 조건이 있습니다. 필드 &lt;code&gt;f&lt;/code&gt; 가있는 모든 생성자 는 동일한 결과 유형 (모듈로 알파 변환)을 가져야합니다. 따라서 위 예에서 &lt;code&gt;num&lt;/code&gt; 및 &lt;code&gt;arg&lt;/code&gt; 필드를 단일 이름으로 병합 할 수 없습니다 . 필드 유형은 모두 &lt;code&gt;Term Int&lt;/code&gt; 이지만 선택기 기능은 실제로 다른 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">그러나 대부분의 응용 프로그램에서는 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; 플래그 만 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">그러나 &lt;code&gt;CProv&lt;/code&gt; 이 비어있는 동안, &lt;code&gt;CReq&lt;/code&gt; 가 있습니다에 대한 위의 패턴 유형 서명 &lt;code&gt;P&lt;/code&gt; 는 로 지정해야</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">그러나 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 가 구분 기호로 끝나는 경우 기본 데이터베이스 (예 : 사용자 및 전역 패키지 데이터베이스)가 경로에 추가됩니다. 예를 들어, 자신의 데이터베이스로 일반적인 패키지 세트를 보강하려면 (유닉스에서) 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신이 당신의 프로그램이 운영 체제에서 제공하는 스레드 패키지를 사용 할 것으로 예상 외국 도서관과 상호 작용하려는 경우, 당신은 사용하여 수행 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">그러나, 모든 패턴에서 &lt;em&gt;다른&lt;/em&gt; 패턴 바인딩보다 범위에없는 타입의 변수를 말할 수있는 패턴 유형 서명; 이 경우 &lt;em&gt;서명은 해당 유형 변수를 scope로 가져옵니다&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">그러나 줄 끝에 공백을 추가하면 &lt;code&gt;cpp&lt;/code&gt; (적어도 GNU &lt;code&gt;cpp&lt;/code&gt; 및 다른 &lt;code&gt;cpp&lt;/code&gt; )가 백 슬래시 공백 쌍을 그대로두고 문자열 간격이 예상대로 작동하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">그러나 약간의 &quot;뒤로&quot;평가를 수행 할 수 있습니다. 예를 들어, 다음은 유형 수준에서 GHC가 임의의 로그를 계산하도록하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">그러나 사용자가 유형을 지정해야하는 것은 번거로운 일이므로 GHCi는 다음과 같이 Haskell의 유형 기본 규칙 (Haskell 2010 보고서의 4.3.4 단원)을 확장합니다. 표준 규칙 은 각 유형 변수 &lt;code&gt;a&lt;/code&gt; 에 대한 각 제약 조건 그룹 &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; 을 취하고 기본 유형 변수 인 경우</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">그러나 모든 것이 손실되는 것은 아닙니다. 우리는 여전히 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">그러나 &lt;code&gt;foo.hs&lt;/code&gt; 라는 파일에 &lt;code&gt;Main&lt;/code&gt; 모듈을 사용하는 것이 합리적 이지만 GHC는 모듈 &lt;code&gt;Main&lt;/code&gt; 에 대한 인터페이스를 검색 할 필요가 없기 때문에 작동합니다 ( 가져 오기 가 수행되지 않기 때문). 따라서 동일한 디렉토리에있는 별도의 소스 파일에 여러 개의 &lt;code&gt;Main&lt;/code&gt; 모듈 이있을 수 있으며 GHC는 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">그러나 플래그 설정에 관계없이 수량자는 다음과 같은 상황에서 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">그러나 버전 8.4 이후 이러한 일이 더 이상 가능하지 않습니다 : GHC는 &lt;strong&gt;보장&lt;/strong&gt; 이 가비지 컬렉션이 중에 발생하지 않습니다 &lt;code&gt;unsafe&lt;/code&gt; 경우에도 바이트 코드 인터프리터, 전화, 그리고 더 보장 &lt;code&gt;unsafe&lt;/code&gt; 호출이 호출 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">그러나 때로는 그러한 호출이 없으므로 pragma가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">그러나 독립형 파생은 여러 가지 중요한 측면에서 &lt;code&gt;deriving&lt;/code&gt; 조항 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">그러나 &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; 부터 기본 구현은 보다 정확한 자동 파생 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 인스턴스를 허용 하는 &lt;code&gt;DefaultSignatures&lt;/code&gt; 를 기반으로 합니다. 이전에 사용 된 정확한 기본 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 메소드 구현 시맨틱 이 필요한 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">그러나 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 및 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 축은 모두 원하는 구속 조건 &lt;code&gt;C a&lt;/code&gt; 와 일치합니다 . 이러한 중복 로컬 공리를 처리하기위한 몇 가지 가능한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">그러나 인스턴스 선언은 여전히 &lt;a href=&quot;#instance-termination&quot;&gt;인스턴스 종료 규칙을 따라야&lt;/a&gt; 합니다 ( 인스턴스 종료 규칙 참조) .</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">그러나 실제 구현에서는 memcmp를 사용하여 문자열의 끝만 비교하며 반대 순서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">그러나 정의되지 않은 연산자가 있으면 두 번째 법을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">그러나 두 용어는 확실히 관련이 있습니다. 여러 CPU를 사용하면 동시 스레드를 병렬로 실행할 수 있으며 이것이 바로 GHC의 SMP 병렬 처리 지원과 동일합니다. 그러나 동시성을 사용하지 않는 프로그램에서 병렬 처리를 통해 성능을 향상시킬 수도 있습니다. 이 섹션에서는 GHC를 사용하여 병렬 프로그램을 컴파일하고 실행하는 방법을 설명하고, &lt;a href=&quot;parallel#lang-parallel&quot;&gt;동시 및 병렬 Haskell&lt;/a&gt; 에서는 병렬 처리에 영향을주는 언어 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">그러나 임의 모듈이이 모듈을 사용하여 자신을 신뢰할 수있는 것으로 표시 할 수 있기 때문에 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 의 무제한 사용은 문제가되지만 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 와 달리 모듈에 대한 보증을 제공하지 않습니다 . 신뢰할 수있는 모듈의 사용을 제어하려면 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하는 것이 좋습니다 . 이 플래그는 신뢰할 수있는 모듈에 대한 신뢰 검사에 추가 요구 사항을 추가합니다. 신뢰할 수있는 모듈을 신뢰할 수있는 것으로 간주하고 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있어야합니다.코드를 컴파일하는 클라이언트 C는 코드를 컴파일하는 클라이언트 C가 신뢰할 수있는 모듈이있는 패키지를 신뢰한다고 GHC에 알려야합니다. 이것은 본질적으로 C가 말하는 방법이며,이 패키지에는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 신뢰할 수없는 모듈이 사용할 수있는 신뢰할 수있는 모듈이 들어 있습니다 , 나는이 패키지의 저자를 신뢰하고 모듈이 안전한 API만을 노출 시킨다고 믿는다. 패키지의 신뢰는 언제든지 변경 될 수 있으므로 패키지에서 취약점이 발견되면 C는 패키지에 대한 향후 컴파일이 실패하도록 패키지를 신뢰할 수 없음으로 선언 할 수 있습니다. 이 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;#safe-trust&quot;&gt;신뢰 및 안전 하스켈 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">그러나이 방법에는 몇 가지 문제점이 있습니다. 첫 번째는 두 개의 예외 핸들러를 갖는 것이 비효율적이라는 것입니다. 그러나 더 심각한 문제는 두 번째 예외 핸들러가 첫 번째 예외 (예 : 위의 예)에서 예외를 포착한다는 것입니다. &lt;code&gt;handleArith&lt;/code&gt; 가 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시키면 두 번째 예외 핸들러가 예외를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 만드는 함수가 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 에서 항상 안전하게 호출 할 수있는 트랜잭션 변수를 작성하는 기능이 있습니다 . 참조 : &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">그러나 이것은 유닉스 이외의 일부 OS에서는 구현하기가 어렵 기 때문에 최대한의 이식성을 위해 호출 된대로 프로그램의 리프 이름 만 반환합니다. 그럼에도 플랫폼간에 약간의 차이가 있습니다. 예를 들어, Windows에서 foo로 호출 된 프로그램은 실제로 &lt;code&gt;FOO.EXE&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">그러나 이것은 유닉스 이외의 일부 OS에서는 구현하기가 어렵 기 때문에 최대한의 이식성을 위해 호출 된대로 프로그램의 리프 이름 만 반환합니다. 그럼에도 플랫폼간에 약간의 차이가 있습니다. 예를 들어, Windows에서 foo로 호출 된 프로그램은 실제로 &lt;code&gt;FOO.EXE&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 이 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">그러나 레이아웃 대신 명시 적 세미콜론을 사용하여 완전한 정의를 한 줄에 제공해야하므로 여러 절 또는 상호 재귀 함수 그룹을 사용하여 함수를 정의 할 때 빠르게 지루합니다.</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="translated">그러나이 제한은 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 를 활성화하여 완화 할 수 있습니다 . 해제되지 않은 새로운 유형 &lt;a href=&quot;#unlifted-newtypes&quot;&gt;에&lt;/a&gt; 대한 섹션에서는 이러한 유형의 동작을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">그러나 &lt;code&gt;x&lt;/code&gt; 가 모호 하기 때문에 이것은 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">그러나 데이터 패밀리 인스턴스의 유형 클래스 인스턴스는 다른 데이터 유형과 매우 유사하게 정의 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">그러나 데이터 유형을 결정하기 위해 인수의 유형을 유추하거나 제약 조건 솔버에 대한 선택을 연기하는 방법이 없습니다. 따라서 다음은 모호합니다.</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">그러나 &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 다음과 같이 정제 구멍 맞춤 목록을 추가로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">HTML 약어</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">HTML 색상</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="translated">나는 사용할 수 없다</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">프로그래머가 정의한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">인수 중 하나가 이미 존재하여 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">인수 중 하나가 존재하지 않아 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">인수 중 하나가 이미 사용중인 단일 사용 자원이므로 조작이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">장치가 가득 차서 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">파일 끝에 도달하여 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">사용자에게 해당 작업을 수행 할 충분한 운영 체제 권한이 없기 때문에 작업이 실패한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">작업이 불가능한 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">I / O 오류</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">I / O 작업은 구현에 필요한 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">I / O와 &lt;code&gt;ByteString&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">핸들이있는 I / O</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">그룹의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">소유자의 ID</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">이 파일이있는 장치의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">직렬화를위한 IO 함수</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">IO 관련 예외 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="translated">ISO 8601 서수 날짜 형식</target>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="translated">ISO 8601 주일 형식</target>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 2.3.3. 하이픈과 콜론을 생략하십시오. &quot;기본 형식은 일반 텍스트로 피해야합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 2.3.4. 하이픈과 콜론을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.2</target>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.3 (a)</target>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.3 (b)</target>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.3 (c)</target>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.4 (a)</target>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.4 (b)</target>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.4 (c)</target>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.2.4 (d)</target>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.3.2</target>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.3.3</target>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.4.2</target>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.1.4.3</target>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.2.2, 4.2.2.4 (a)</target>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.2.3 (a), 4.2.2.4 (b)</target>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.2.3 (b), 4.2.2.4 (c)</target>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.2.5</target>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.4</target>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.5.1</target>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.2.5.2</target>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.3.2</target>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.3.3</target>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.4.3.2</target>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.4.3.3</target>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.4.4.1</target>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="translated">ISO 8601 : 2004 (E) 초 4.5</target>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="translated">ISO / IEC 8859-1 (Char8)</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이상적으로이 유형은 전혀 존재하지 않으며 우리는 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 인스턴스 만 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="translated">와 동일 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; , 반환 값은 정점에 키를 매핑하는 기능을 포함하지 않는 것을 제외하고. 이 버전의 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; 는 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">신원 기능.</target>
        </trans-unit>
        <trans-unit id="45ddee8d84b61e8e7c17a3d7431270c5b54e7630" translate="yes" xml:space="preserve">
          <source>Identity functor and monad. (a non-strict monad)</source>
          <target state="translated">정체성 functor와 모나드. (엄격하지 않은 모나드)</target>
        </trans-unit>
        <trans-unit id="d40415a7e74878f91a4dde01d55fe29e70b542f1" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="d7ecdcc9a073254188d013838ea2cd05cfb232fd" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="ff5736ff9442788a1bd6a07a6f1942f21ee0e0ff" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="7460eb65d03a49632f7e5ea228f3d10021c309c4" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="036d1bdfa0b3334e329d5335dac94c3cade01124" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="e9a8044f8b5708bc7d69f87f32e2d6115a58e170" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 정체성</target>
        </trans-unit>
        <trans-unit id="de31daa9296519446ec20ea71e05cfd2b2ffa509" translate="yes" xml:space="preserve">
          <source>IdentityT</source>
          <target state="translated">IdentityT</target>
        </trans-unit>
        <trans-unit id="d55cb59cae5c6bdaf9dd412febcf10b5197dca0f" translate="yes" xml:space="preserve">
          <source>Ids with special behaviour</source>
          <target state="translated">특별한 행동을하는 ID</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7165d0bd8b8d1acf3a7959ac10d5a5fbeb953852" translate="yes" xml:space="preserve">
          <source>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</source>
          <target state="translated">(D)가 존재하지 않으면 (A)와 (C)는 여전히 일치하지만 가장 구체적인 것은 없습니다. 이 경우 &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; 를 사용하도록 설정 하지 않으면 프로그램이 거부되고,이 경우 프로그램이 수락되고 (A) 또는 (C)가 임의로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="ddb8e98916bf04f77cda2ecb54ffffb8aeaffeca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어 입력 / 종류의 변수는 명시 적으로 바인딩 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da9178d1cdaa41cf10a914fbfe9e3f1cc2e99f91" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 오버로드 된 라벨은 무엇이든 사용 desugared됩니다 &lt;code&gt;fromLabel&lt;/code&gt; 를 사용하여 항상 기능 범위에보다는 &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e7f41696d0e1b366335f05f546f0074d2d8f5534" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt;&lt;code&gt;-fprint-bind-result&lt;/code&gt;&lt;/a&gt; is set then GHCi will print the result of a statement if and only if:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt; &lt;code&gt;-fprint-bind-result&lt;/code&gt; &lt;/a&gt; 가 설정 되면 GHCi 는 다음과 같은 경우에만 명령문 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a12298741a44a56544916fcc3d1eeb39ec79ce67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; 가 정규 있어야 정의된다 (즉, &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="37d0b772579ed80acd95d06e7921caed2a9f0731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</source>
          <target state="translated">경우 &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; 가 지정되고, 그 객체 파일 이름 ⟨dir⟩ / ⟨mod⟩.⟨osuf⟩, ⟨mod⟩ 슬래시 교체 도트 모듈 이름이고이다. GHC는 directorydir⟩ 아래에 필요한 디렉토리 구조를 자동으로 작성합니다 (없는 경우).</target>
        </trans-unit>
        <trans-unit id="6bec439461a8c0d2127d1c99af2a5820ee3a9cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;getInputLine&lt;/code&gt; 에 의해 리턴 된 공백이 아닌 각 행 이 자동으로 히스토리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d72c7fde1442e5a18545f8980ce1eaec5905c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; are both &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then so is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; 모두 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 다음 그렇다 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94e59d7cf4d9cb8563c18691722ce11c38c079d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is uninhabited then any &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; that holds only values of type &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is holding no values.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 다음 어떤 무인된다 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 타입의 값을 보유 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 어떤 값을 유지하지 않습니다를.</target>
        </trans-unit>
        <trans-unit id="326c4fe588e95cc1235b78af1086ddc7bd85c512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; were not lazy, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; would look strict in &lt;code&gt;y&lt;/code&gt; which would defeat the whole purpose of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 게으른 아니었다 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 엄격한 보일 것이다 &lt;code&gt;y&lt;/code&gt; 의 전체 목적을 물리 칠 것 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="610f1b238432a44cf8ce8bbb88c3bf824a5dd237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is used wrongly, then it may be that computations whose result that would otherwise be shared are re-evaluated every time they are used. Otherwise, the use of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is safe.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; 을 잘못 사용 하면 공유 할 결과를 계산할 때마다 계산이 재평가 될 수 있습니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="7c58158c9223c0688808fab7017305ac888c0083" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; 의 만남이 파일의 끝 지점에서 다른 행으로 판독하면서, 그것은 광고 종료로 간주하고 (부분) 행이 반환된다.</target>
        </trans-unit>
        <trans-unit id="21b4b2460fe3194b5c1e8e3d5532ed22dd7586f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; 의 만남이 파일의 끝 지점에서 다른 행으로 판독하면서, 그것은 광고 종료로 간주하고 (부분) 행이 반환된다.</target>
        </trans-unit>
        <trans-unit id="e320f20c42c7605270530cbc8962daed664fbb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 및 라인 입력 (즉, 모든 공간이 아닌) 공백이 아닌, 그것은 자동으로 역사에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2cf8b46ce5b4adfb311cafcd49d769949e020c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; 의 만남이 파일의 끝 지점에서 다른 행으로 판독하면서, 그것은 광고 종료로 간주하고 (부분) 행이 반환된다.</target>
        </trans-unit>
        <trans-unit id="54c8bbd7c753a8e36c3603f2de4d4cd2a62cd77c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; is a power of 2, the result will be exact. In other cases (e.g. for &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt;), the result &lt;em&gt;may&lt;/em&gt; be 1 digit too large sometimes.</source>
          <target state="translated">경우 &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; 2의 힘, 결과는 정확합니다. 다른 경우 (예 : &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt; ) 결과 &lt;em&gt;가&lt;/em&gt; 때때로 1 자리가 너무 클 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a13e850c195084652095c4cca81184cca1bc111" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; imports multiple modules, then there will be multiple lines with &lt;code&gt;M.o&lt;/code&gt; as the target.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 이 여러 모듈을 가져 오는 경우 &lt;code&gt;M.o&lt;/code&gt; 가 대상으로 여러 줄이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1c19c1db68e46617d35c0326dd5168514a0df2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then read its contents without modifying the MVar, without possibility of intervention from other threads.</source>
          <target state="translated">경우 &lt;code&gt;MVar#&lt;/code&gt; 비어 블록이 가득 찰 때까지. 그런 다음 다른 스레드의 개입없이 MVar를 수정하지 않고 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="83f91e64cabad1b57cc078065479e2f730107802" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="translated">경우 &lt;code&gt;MVar#&lt;/code&gt; 비어 블록이 가득 찰 때까지. 그런 다음 내용을 제거하고 반환하고 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="00f25de3697afd87eb6d27164088e4e76d5903b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;, and set &lt;code&gt;MVar#&lt;/code&gt; empty.</source>
          <target state="translated">경우 &lt;code&gt;MVar#&lt;/code&gt; 비어 즉시 정의되지 않은 정수 0 값으로 돌아갑니다. 그렇지 않으면 정수 1과 &lt;code&gt;MVar#&lt;/code&gt; 내용으로 리턴 하고 &lt;code&gt;MVar#&lt;/code&gt; 비워 두십시오 .</target>
        </trans-unit>
        <trans-unit id="ebfef89b340df038e270ba036f34b0519cbc0ac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;MVar#&lt;/code&gt; 비어 즉시 정의되지 않은 정수 0 값으로 돌아갑니다. 그렇지 않으면 정수 1과 &lt;code&gt;MVar#&lt;/code&gt; 내용으로 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="de738ce23865dd45047c99b18298df90a9c1de7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, block until it becomes empty. Then store value arg as its new contents.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; 이 가득 찬 경우 비워 질 때까지 차단하십시오. 그런 다음 값 arg를 새 컨텐츠로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="f0ea9c86d00bfb75f1a61c6b64453776a80bc752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;MVar#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="translated">경우 &lt;code&gt;MVar#&lt;/code&gt; 가득, 즉시로 그렇지 않으면 정수 0, 저장 값 인수와 반환 &lt;code&gt;MVar#&lt;/code&gt; 새로운 내용의, 그리고 한 정수로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="2b9bf43f23f5bb273c3cc1f6ac0c3d420ae5cb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06453765ecd11a2317b668a85556dad5d95cee4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c87e13d090df879361d15dfa79e405cd9085828" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206bdce74c7401df8dd34a4eb0c73875661f2142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c2aadabafad2cf8c71f374eecfaa7c9542d06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83d5752a7d1aceda6754825ba636c32044c8b3bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; 이 플랫폼에 정의되지 않은, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; 으로 감소 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5275bc4d51e6899e6fad22c83eb521ad2006efe4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">경우 &lt;code&gt;blk&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;WNOHANG&lt;/code&gt; 가 에 대한 옵션으로 설정되어 &lt;code&gt;waitpid&lt;/code&gt; 를 , 그렇지 않으면 없습니다. 경우 &lt;code&gt;stopped&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;WUNTRACED&lt;/code&gt; 는 대한 옵션에서 설정 &lt;code&gt;waitpid&lt;/code&gt; 를 , 그렇지 않으면 없습니다.</target>
        </trans-unit>
        <trans-unit id="947ea7c1dfd7ce4b41e18914f4032b10928d1f59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">경우 &lt;code&gt;blk&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;WNOHANG&lt;/code&gt; 가 에 대한 옵션으로 설정되어 &lt;code&gt;waitpid&lt;/code&gt; 를 , 그렇지 않으면 없습니다. 경우 &lt;code&gt;stopped&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;WUNTRACED&lt;/code&gt; 는 대한 옵션에서 설정 &lt;code&gt;waitpid&lt;/code&gt; 를 , 그렇지 않으면 없습니다.</target>
        </trans-unit>
        <trans-unit id="a08b722470ddafe8fb8c09c93deed2c332b705cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 또한 인 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , 그것은 만족해야</target>
        </trans-unit>
        <trans-unit id="c98343bbca185d60c1ee11e55600855a284be984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 또한 인 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , 그것은 만족해야</target>
        </trans-unit>
        <trans-unit id="a539250d2be5c33120a88a56e298e7c403b47812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 또한 인 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , 그것은 만족해야</target>
        </trans-unit>
        <trans-unit id="5eac9f125314dfa3f7885b5b45714df2e1cf5559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is both &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; then by the time you factor in the laws of each of those classes, it can't actually use its argument in any meaningful capacity.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; 둘 다인 경우 각 클래스의 법칙을 고려할 때 실제로 의미있는 용량으로 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f7d12845339fe8cd3cb3ac36c2fb96a946b74fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것입니다 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931888dcad242b41a99c52e3454ca1021c558949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906096b1295440d05beb1594c0fb7469bf723e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것입니다 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="805ac8206a6b088f57d9c958aae524c515330e81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b40996ba5b36b066518d58ee4318ccc60ee6eaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것입니다 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd33339e864a1994b487c054b99bec9522d7f84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb76c568526f84f6e23c00ea7ec6b9359af0d64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것입니다 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f6815c2e1b653f81af4e4ff845f99b11b6b06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 는 (예를 기록 선택, 또는 매우 저렴 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; 보다 더 빨리 될 것 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9adf0f8908e10c9f90956ffd3ed4fc92f31eb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; 가 정의 된 경우 정식이어야합니다 (예 : &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15cf615fdb6b04b2196b63a29a9332d038e92d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">경우 &lt;code&gt;hdl&lt;/code&gt; 블록 - 또는 라인 버퍼이며, 먼저 출력 버퍼에있는 모든 항목 일으키는 장치에 기록 될 것이다 현재 버퍼에없는 위치하고자 후 입력 버퍼가 삭제되도록. 일부 핸들은 검색 할 수 없거나 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; 참조 ) 가능한 위치 지정 작업의 하위 세트 만 지원합니다 (예 : 테이프의 끝 또는 시작 또는 현재 위치에서 양의 오프셋 만 찾을 수 있음). ). 음의 I / O 위치 또는 실제 파일의 경우 현재 파일 끝을 초과하는 I / O 위치를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c8a6eee3327c93a8398e06086b0787394abd668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">경우 &lt;code&gt;hdl&lt;/code&gt; 블록 - 또는 라인 버퍼이며, 먼저 출력 버퍼에있는 모든 항목 일으키는 장치에 기록 될 것이다 현재 버퍼에없는 위치하고자 후 입력 버퍼가 삭제되도록. 일부 핸들은 검색 할 수 없거나 ( &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; 참조 ) 가능한 위치 지정 작업의 하위 세트 만 지원합니다 (예 : 테이프의 끝 또는 시작 또는 현재 위치에서 양의 오프셋 만 찾을 수 있음). ). 음의 I / O 위치 또는 실제 파일의 경우 현재 파일 끝을 초과하는 I / O 위치를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ef3f214074b587d958bb04dc92f38b70020c8f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;./.ghci&lt;/code&gt; files will be ignored (sourcing untrusted local scripts is a security risk). The default is &lt;code&gt;source&lt;/code&gt;. Set this directive in your user &lt;code&gt;.ghci&lt;/code&gt; script, i.e. before the local script would be sourced.</source>
          <target state="translated">경우 &lt;code&gt;ignore&lt;/code&gt; , &lt;code&gt;./.ghci&lt;/code&gt; 파일이 무시됩니다 (신뢰할 수없는 로컬 스크립트를 소싱하는 것은 보안 상 위험). 기본값은 &lt;code&gt;source&lt;/code&gt; 입니다. 이 지시문을 사용자 &lt;code&gt;.ghci&lt;/code&gt; 스크립트 에 설정하십시오 . 즉, 로컬 스크립트가 소싱되기 전에 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0345953305b2b9f4ea94ff39c9fed5b790ac50f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mappend&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;mappend&lt;/code&gt; 가 정의 된 경우 정식이어야합니다 (예 : &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb896d3d56035749898d473a3ff0398ee85a2441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 원인 것 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대리 쌍 내부에서 시작, 접미사의 시작은 하나의 추가에 의해 진행됩니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 유효성을 유지하는 장치.</target>
        </trans-unit>
        <trans-unit id="860162bde8907826a2c5a3fcdedbfb920738c4b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 원인 것 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대리 쌍 내부의 끝을, 접두사의 끝이 하나의 추가에 의해 고급 것 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 의 유효성을 유지하는 장치.</target>
        </trans-unit>
        <trans-unit id="226e4123ccd5bdaffb4ec80558af633a764b0837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nel&lt;/code&gt; is not defined, this may be built out of other capabilities.</source>
          <target state="translated">&lt;code&gt;nel&lt;/code&gt; 이 정의되지 않은 경우 다른 기능으로 구축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d4d1d892b2f78b4eac4a90be4fe3562658fe6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 실패하고 일부 입력을 소비, 그렇게 &lt;code&gt;lookAhead&lt;/code&gt; . 이것이 바람직하지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="3537d71db5bdf66b5e84e584bddb563361f13d18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 실패하고 일부 입력을 소비, 그렇게 &lt;code&gt;lookAhead&lt;/code&gt; . 이것이 바람직하지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="13ee3fdf69deef0295af859365ce7e178691bbfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;return = pure&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 이 정의 된 경우 정식이어야합니다 (예 : &lt;code&gt;return = pure&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df692bac65da2783906b8b3e140d687e86cb3e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sn1 :: StableName&lt;/code&gt; and &lt;code&gt;sn2 :: StableName&lt;/code&gt; and &lt;code&gt;sn1 == sn2&lt;/code&gt; then &lt;code&gt;sn1&lt;/code&gt; and &lt;code&gt;sn2&lt;/code&gt; were created by calls to &lt;code&gt;makeStableName&lt;/code&gt; on the same object.</source>
          <target state="translated">경우 &lt;code&gt;sn1 :: StableName&lt;/code&gt; 과 &lt;code&gt;sn2 :: StableName&lt;/code&gt; 및 &lt;code&gt;sn1 == sn2&lt;/code&gt; 다음 &lt;code&gt;sn1&lt;/code&gt; 과 &lt;code&gt;sn2&lt;/code&gt; 에 대한 호출에 의해 생성 된 &lt;code&gt;makeStableName&lt;/code&gt; 동일한 개체에.</target>
        </trans-unit>
        <trans-unit id="e2ad7372f58041f5b2d3a204387a830ce9ae4dd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; is less than zero, then &lt;code&gt;hWaitForInput&lt;/code&gt; waits indefinitely.</source>
          <target state="translated">경우 &lt;code&gt;t&lt;/code&gt; 가 0보다 작은, 다음 &lt;code&gt;hWaitForInput&lt;/code&gt; 는 무한정 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6557dd6d42d307abdecff79045e463256f2df340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uid&lt;/code&gt; or &lt;code&gt;gid&lt;/code&gt; is specified as -1, then that ID is not changed.</source>
          <target state="translated">경우 &lt;code&gt;uid&lt;/code&gt; 또는 &lt;code&gt;gid&lt;/code&gt; -1로 지정하면 ID가 변경되지 않도록.</target>
        </trans-unit>
        <trans-unit id="8c23a4167afefd24de1f72d0b1f0f0c9e3f11603" translate="yes" xml:space="preserve">
          <source>If Ctrl-C is pressed during the given action, throw an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">주어진 동작 중에 Ctrl-C를 누르면 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 유형 예외를 발생 시킵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="821902f7f945f9df9b4c26649b68c4f807408798" translate="yes" xml:space="preserve">
          <source>If GHC didn&amp;rsquo;t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC&amp;rsquo;s code generator. Consider</source>
          <target state="translated">만약 GHC가 현실 세계에서 실행되는 프로그램을 컴파일 할 필요가 없다면, 그것은 이야기의 끝이 될 것입니다. 그러나 표현 다형성은 GHC의 코드 생성기에 약간의 문제를 일으킬 수 있습니다. 치다</target>
        </trans-unit>
        <trans-unit id="20ef5d466c86ecef8e8961310c403330cf2b508d" translate="yes" xml:space="preserve">
          <source>If GHC persists in being a bad memory citizen, please report it as a bug.</source>
          <target state="translated">GHC가 계속 나쁜 메모리 시민이되는 경우 버그로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="220d5b83850f635db8c322690e19f967385f577b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; references a file descriptor, attempt to lock contents of the underlying file in appropriate mode. If the file is already locked in incompatible mode, this function blocks until the lock is established. The lock is automatically released upon closing a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 파일 설명자를 참조하는 경우 기본 모드 파일의 내용을 적절한 모드로 잠그십시오. 파일이 이미 호환되지 않는 모드로 잠겨 있으면이 기능은 잠금이 설정 될 때까지 차단됩니다. &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫으면 잠금이 자동으로 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="378447cdb747f861c2af8b9d9aa5411c32ef8aca" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 가 GADT 구문 생성자를 둘러싼 후 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화 할 &lt;em&gt;모든&lt;/em&gt; 생성자 사용 형 변수. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc4cc18d4c1e7b851b50db0a714da14e3509176a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 가 생성자를 바닐라 구문으로 둘러싼 경우 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;존재&lt;/em&gt; 유형 변수 만 수량화 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="044539454a09356f28e0ae13ed4c626569d75f51" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 가 GADT 구문 생성자를 둘러싼 후 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화 할 &lt;em&gt;모든&lt;/em&gt; 생성자 사용 형 변수. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="722ab6109c5e8f9f7714e4e2a9d91f17d7a90602" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 가 생성자를 바닐라 구문으로 둘러싼 경우 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;존재&lt;/em&gt; 유형 변수 만 수량화 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b34d5c83b4ecf116da3871cc1a290a189d5d74ad" translate="yes" xml:space="preserve">
          <source>If a C function prototype has &lt;code&gt;t&lt;/code&gt; as an argument or result type, the use of &lt;code&gt;CT&lt;/code&gt; in the corresponding position in a foreign declaration permits the Haskell program to access the full range of values encoded by the C type; and conversely, any Haskell value for &lt;code&gt;CT&lt;/code&gt; has a valid representation in C.</source>
          <target state="translated">C 함수 프로토 타입 에 인수 또는 결과 유형으로 &lt;code&gt;t&lt;/code&gt; 가없는 경우 , 외부 선언에서 해당 위치에 &lt;code&gt;CT&lt;/code&gt; 를 사용 하면 Haskell 프로그램이 C 유형으로 인코딩 된 전체 값 범위에 액세스 할 수 있습니다. 반대로 &lt;code&gt;CT&lt;/code&gt; 에 대한 하스켈 값 은 C로 유효한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f2c29459b71d15ab93a1c9fd6e056294e61bdf3d" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family.</source>
          <target state="translated">인젝 티브로 선언 된 LHS 타입 변수가 RHS GHC의 인젝 티브 위치에 언급되지 않은 경우 타입 패밀리가 인젝 티브하지 않다고보고합니다. 주입 위치는 유형 생성자에 대한 인수 또는 유형 패밀리에 대한 주입 인수를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b02289337799e172c6434a2959c4692b153f59ab" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt;; GHC suggests enabling the flag when it is necessary.</source>
          <target state="translated">주입 형으로 선언 된 LHS 유형 변수가 RHS GHC의 주입 형 위치에 언급되지 않은 경우 해당 유형 패밀리가 주입 형이 아니라고보고합니다. 주입 적 위치는 유형 생성자에 대한 인수 또는 유형 패밀리에 대한 주입 적 인수를 의미합니다. 유형 추론은 RHS에서 주입 유형 패밀리를 살펴볼 때 잠재적으로 반복 될 수 있으므로 &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 가 필요합니다 . GHC는 필요할 때 플래그를 활성화 할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="df1c26c5e5d7b0e6a433e2ce679bce2faf2ee71c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</source>
          <target state="translated">유형 패밀리 방정식의 RHS가 베어 유형 변수 인 경우 모든 LHS 변수 (암시 적 종류 변수 포함)도 베어 여야합니다. 다시 말해, 이것은 해당 유형 군의 유일한 방정식이어야하며 가능한 모든 패턴을 포함해야합니다. 패턴이 GHC를 덮지 않는 경우 유형 패밀리가 주 입성이 아니라고보고합니다.</target>
        </trans-unit>
        <trans-unit id="aae1bcb9b1cecea16f3e3634cf7f4ebbfdfb031c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</source>
          <target state="translated">유형 패밀리 방정식의 RHS가 유형 패밀리 응용 프로그램 인 경우 GHC는 유형 패밀리가 주입 적이 지 않다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="db25b8f3188747af958388f20acf6bd09afc1781" translate="yes" xml:space="preserve">
          <source>If a call is annotated as &lt;code&gt;interruptible&lt;/code&gt; and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See &lt;a href=&quot;#ffi-interruptible&quot;&gt;Interruptible foreign calls&lt;/a&gt; for more details.</source>
          <target state="translated">호출에 &lt;code&gt;interruptible&lt;/code&gt; 으로 주석이 달고 프로그램이 다중 스레드 인 경우 Haskell 스레드가 예외를 수신하면 호출이 중단 될 수 있습니다. 인터럽트가 발생하는 메커니즘은 플랫폼에 따라 다르지만 차단 된 시스템 호출이 중단 된 오류 코드와 함께 즉시 반환되도록하기위한 것입니다. 기본 운영 체제 스레드는 손상되지 않습니다. 자세한 내용은 &lt;a href=&quot;#ffi-interruptible&quot;&gt;긴급 통화&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c05c3def7562a739048b872d41b6d6eb05d7a90" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 에 대한 호출 이 위치 &lt;code&gt;p&lt;/code&gt; 를 리턴하면 , 계산 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;hdl&lt;/code&gt; 의 위치를 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; 에 대한 호출시 보유한 위치로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ba018d0d62ee53ce6b9db280035b85aedadefa2f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 에 대한 호출 이 위치 &lt;code&gt;p&lt;/code&gt; 를 리턴하면 , 계산 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;hdl&lt;/code&gt; 의 위치를 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; 에 대한 호출시 보유한 위치로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b6f98223cfb0eee3633d62b814584044de61b78c" translate="yes" xml:space="preserve">
          <source>If a constructor has no arguments, then &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; is used as its representation. For example the representation of &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; is</source>
          <target state="translated">생성자가 인수가 없으면 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; 이 해당 표현으로 사용됩니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 의 표현 은</target>
        </trans-unit>
        <trans-unit id="a9f3d133e06321809c86bac4a4d58b06416b36bf" translate="yes" xml:space="preserve">
          <source>If a declaration occurs in multiple inherited signatures, they will be &lt;em&gt;merged&lt;/em&gt; together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</source>
          <target state="translated">상속 된 여러 서명에서 선언이 발생하면 함께 &lt;em&gt;병합&lt;/em&gt; 됩니다. 값의 경우 두 시그니처의 유형이 정확히 일치해야합니다. 그러나 다른 선언은 더 흥미로운 방식으로 병합 될 수 있습니다. 이러한 경우 병합 작업을 수행하면 이전 이름의 모든 항목을 텍스트로 새로 병합 된 선언에 대한 참조로 대체하는 효과가 있습니다. 예를 들어 다음과 같은 두 가지 서명이있는 경우</target>
        </trans-unit>
        <trans-unit id="8cb4f4cbaa3cf83a5c5f2e268c4fafffea33710e" translate="yes" xml:space="preserve">
          <source>If a field has a higher-rank or existential type, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</source>
          <target state="translated">필드의 순위가 높거나 &lt;code&gt;HasField&lt;/code&gt; 유형 인 경우 해당 HasField 제약 조건은 위에서 설명한 것처럼 자동으로 해결되지 않지만 단순성을 위해 사용자가 자신의 인스턴스를 정의 할 수도 없습니다. 필드가 범위 내에 있지 않으면 다운 스트림 모듈에서 충돌을 피하기 위해 해당 인스턴스가 여전히 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="a8eaf7aebcd40fba7a5385d613e9ae5cec1a85c4" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="translated">종료자가 예외를 throw하면 실행이 완료된 후 큐에 대기 한 후속 종료자가 실행되지 않습니다. 이 동작은 다음 릴리스에서 변경 될 수 있습니다. 이슈 트래커의 이슈 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; 을 참조하십시오 . 예외를 발생시키는 종료자를 작성하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e1b752cff9e74d6e08fc8898cd07eefb082da1bf" translate="yes" xml:space="preserve">
          <source>If a module was then to import &lt;code&gt;MyNum&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt;, it would also import the pattern synonym &lt;code&gt;Zero&lt;/code&gt;.</source>
          <target state="translated">모듈이 수입에 다음 인 경우 &lt;code&gt;MyNum&lt;/code&gt; 에서 &lt;code&gt;Example&lt;/code&gt; , 그것은 또한 패턴 동의어 가져올 것 &lt;code&gt;Zero&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="893611b3da8b13dca82bbde8d7e30b09c03ec327" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">명령 앞에 숫자가 제공되면 지정된 중단 점 (만)에 도달하면 명령이 실행됩니다. 예를 들어 &lt;code&gt;:set stop 1 :continue&lt;/code&gt; 중단 될 때마다 &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; 를 실행하여 중단 점 1을 효과적으로 비활성화합니다 (GHCi는 여전히 중단 점에 도달했다는 메시지를 표시하지만). 또한 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt; 를 교대로 사용 하면 &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; 을 사용하여 조건부 중단 점을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7c3aca378dedbdc91ecccb72c921e9d9ef55af4" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit In this case GHCi will still emit a message to say the breakpoint was hit. If you don&amp;rsquo;t want such a message, you can use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command. What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">명령 앞에 숫자가 주어지면 지정된 중단 점 (만)에 도달 할 때 명령이 실행됩니다. 이것은 매우 유용 할 수 있습니다. 예를 들어, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; 가 적중 될 때마다 실행함으로써 중단 점 1을 효과적으로 비활성화합니다 . 이러한 메시지를 원하지 않으면 &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 . 또한 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt; 를 교묘하게 사용 하면 &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; 을 사용하여 조건부 중단 점을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1469d9b993c79ed9fd15d1a5a0d6060aaa153a72" translate="yes" xml:space="preserve">
          <source>If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved. For example,</source>
          <target state="translated">레코드 필드 유형에 존재하는 변수가 이스케이프되어 선택기 함수가없는 경우 해당 &lt;code&gt;HasField&lt;/code&gt; 제한 조건이 해결되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="164c3702f74e30bae3bcb4e2249a8dd0868593c2" translate="yes" xml:space="preserve">
          <source>If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved, because doing so would violate the functional dependency on &lt;code&gt;HasField&lt;/code&gt; and/or require impredicativity. For example,</source>
          <target state="translated">레코드 필드에 다형성 유형이 있고 (따라서 선택기 함수가 더 높은 순위 인 경우) 해당 &lt;code&gt;HasField&lt;/code&gt; 제한 조건은 해결되지 않습니다. 그렇게하면 &lt;code&gt;HasField&lt;/code&gt; 에 대한 기능적 종속성을 위반 하거나 불확실성이 필요하기 때문입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="afc8e267ccbb00ce682890bda99554fbfc2f7a86" translate="yes" xml:space="preserve">
          <source>If a record type has an old-fashioned datatype context, the &lt;code&gt;HasField&lt;/code&gt; constraint will be reduced to solving the constraints from the context. For example,</source>
          <target state="translated">레코드 유형에 구식 데이터 유형 컨텍스트가있는 경우 &lt;code&gt;HasField&lt;/code&gt; 제한 조건이 컨텍스트에서 제한 조건을 해결하도록 축소됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="608bb4b5a475db6a4953e34347efc01b12ab3dbd" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="translated">스레드가 외래 전화를 걸면 (그리고 전화가 &lt;code&gt;unsafe&lt;/code&gt; 않은 것으로 표시되지 않은 경우 ) 외래 전화가 진행되는 동안 프로그램의 다른 Haskell 스레드가 계속 실행됩니다. 또한 &lt;code&gt;foreign export&lt;/code&gt; 스레드 Haskell 함수를 여러 OS 스레드에서 동시에 호출 할 수 있습니다. &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;멀티 스레딩 및 FFI를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9afb526f4bf8bfbbfbd29f142d6a0d74ef8a8864" translate="yes" xml:space="preserve">
          <source>If a type variable &lt;code&gt;a&lt;/code&gt; in a datatype, class, or type family declaration depends on another such variable &lt;code&gt;k&lt;/code&gt; in the same declaration, two properties must hold:</source>
          <target state="translated">데이터 유형, 클래스 또는 유형 패밀리 선언 의 유형 변수 &lt;code&gt;a&lt;/code&gt; 가 동일한 선언의 다른 변수 &lt;code&gt;k&lt;/code&gt; 에 종속되는 경우 두 개의 특성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1fa7a794644c3b1936544c749803bfa930ad77e9" translate="yes" xml:space="preserve">
          <source>If a user does not provide a manual implementation for &lt;code&gt;sPpr&lt;/code&gt;, then it will default to &lt;code&gt;show&lt;/code&gt;. Now we can leverage the &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension to easily implement a &lt;code&gt;SPretty&lt;/code&gt; instance for a new data type:</source>
          <target state="translated">사용자가 &lt;code&gt;sPpr&lt;/code&gt; 에 대한 수동 구현을 제공하지 않으면 기본적으로 &lt;code&gt;show&lt;/code&gt; 됩니다. 이제 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 확장을 활용하여 새 데이터 유형에 대한 &lt;code&gt;SPretty&lt;/code&gt; 인스턴스 를 쉽게 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae7120c3db21432a6f1b3610362bef769bc13113" translate="yes" xml:space="preserve">
          <source>If a weak pointer (object) refers to an &lt;em&gt;unreachable&lt;/em&gt; key, it may be finalized.</source>
          <target state="translated">약한 포인터 (객체)가 &lt;em&gt;연결할 수없는&lt;/em&gt; 키 를 나타내는 경우 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102c2b7d4713d61cdf925ffde90969e0cf8621ec" translate="yes" xml:space="preserve">
          <source>If a worker has that many arguments, none will be unpacked anymore.</source>
          <target state="translated">만약 노동자가 그와 같은 많은 주장을한다면, 더 이상 풀리지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b93932446c468ada97c37e6d1c9ba23f662e6eb7" translate="yes" xml:space="preserve">
          <source>If all else fails, then you need to resort to &lt;code&gt;Foreign.malloc&lt;/code&gt; and &lt;code&gt;Foreign.free&lt;/code&gt;. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform&amp;rsquo;s C library. We usually find &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; to be significantly slower than the other forms of allocation above.</source>
          <target state="translated">다른 모든 방법이 실패하면 &lt;code&gt;Foreign.malloc&lt;/code&gt; 및 &lt;code&gt;Foreign.free&lt;/code&gt; 에 의지해야합니다 . 이것들은 같은 이름의 C 함수를 감싸는 래퍼이며 효율성은 궁극적으로 플랫폼의 C 라이브러리에서 이러한 함수의 구현에 달려 있습니다. 우리는 일반적으로 찾을 수 &lt;code&gt;malloc&lt;/code&gt; 하고 &lt;code&gt;free&lt;/code&gt; 위의 할당의 다른 형태보다 훨씬 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a9c3c0b52a8eea92099f68faa2621ba66a2174" translate="yes" xml:space="preserve">
          <source>If all the matches against the &lt;code&gt;pi&lt;/code&gt; succeed, the match succeeds, binding the variables bound by the &lt;code&gt;pi&lt;/code&gt; . (The &lt;code&gt;xi&lt;/code&gt; are not bound; they remain local to the pattern synonym declaration.)</source>
          <target state="translated">&lt;code&gt;pi&lt;/code&gt; 에 대한 모든 일치가 성공하면 &lt;code&gt;pi&lt;/code&gt; 에 의해 바인딩 된 변수를 바인딩하여 일치합니다 . ( &lt;code&gt;xi&lt;/code&gt; 는 바인딩되지 않으며 패턴 동의어 선언에 로컬로 유지됩니다.)</target>
        </trans-unit>
        <trans-unit id="eed9f549e1682b63a8806713ee685fb3c9adfb3a" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</source>
          <target state="translated">나머지 후보가 모두 일치하지 않으면 검색이 성공하여 임의의 생존 후보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb88aceb390c3de7d3ec513d599b8826a7a3104e" translate="yes" xml:space="preserve">
          <source>If all values stored in all maps in the arguments are in WHNF, then all values stored in all maps in the results will be in WHNF once those maps are evaluated.</source>
          <target state="translated">인수의 모든 맵에 저장된 모든 값이 WHNF에있는 경우 해당 맵이 평가되면 결과의 모든 맵에 저장된 모든 값은 WHNF에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f53d1f0ff24c6a37e378e5ebd89c1567f62d05" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callCommand&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callCommand&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callCommand&lt;/code&gt; 를 실행하는 스레드에 비동기 예외가 발생 하면 분기 된 프로세스가 종료되고 &lt;code&gt;callCommand&lt;/code&gt; 는 프로세스가 종료 될 때까지 대기 (차단)합니다.</target>
        </trans-unit>
        <trans-unit id="fa75dc761964532aaa328fd35153a5453bcd7b2e" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callProcess&lt;/code&gt; 를 실행하는 스레드에 비동기 예외가 발생 하면 분기 된 프로세스가 종료되고 &lt;code&gt;callProcess&lt;/code&gt; 는 프로세스가 종료 될 때까지 대기 (차단)합니다.</target>
        </trans-unit>
        <trans-unit id="d1293622c4845776f0f7f46e69be43df4b5fb632" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;readProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;readProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;readProcess&lt;/code&gt; 를 실행하는 스레드에 비동기 예외가 발생 하면 분기 된 프로세스가 종료되고 프로세스가 종료 될 때까지 &lt;code&gt;readProcess&lt;/code&gt; 가 대기 (차단)됩니다.</target>
        </trans-unit>
        <trans-unit id="ac09f8306bc4c40a9a80bb592e856f9697dfc58b" translate="yes" xml:space="preserve">
          <source>If an entry within the directory vanishes while &lt;code&gt;removePathForcibly&lt;/code&gt; is running, it is silently ignored.</source>
          <target state="translated">&lt;code&gt;removePathForcibly&lt;/code&gt; 가 실행되는 동안 디렉토리 내의 항목이 사라지면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1f47696dc0606508335264b40a8a2bc81264cf0b" translate="yes" xml:space="preserve">
          <source>If an environment entry does not contain an &lt;code&gt;'='&lt;/code&gt; character, the &lt;code&gt;key&lt;/code&gt; is the whole entry and the &lt;code&gt;value&lt;/code&gt; is the empty string.</source>
          <target state="translated">환경 항목에 &lt;code&gt;'='&lt;/code&gt; 문자가 포함되지 않은 경우 &lt;code&gt;key&lt;/code&gt; 는 전체 항목이며 &lt;code&gt;value&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="588c20098b5c4c736fc7038d90ea284118f71b07" translate="yes" xml:space="preserve">
          <source>If an exception occurs while removing an entry, &lt;code&gt;removePathForcibly&lt;/code&gt; will still try to remove as many entries as it can before failing with an exception. The first exception that it encountered is re-thrown.</source>
          <target state="translated">항목을 제거하는 동안 예외가 발생하면 &lt;code&gt;removePathForcibly&lt;/code&gt; 는 예외로 실패하기 전에 가능한 한 많은 항목을 제거하려고 시도합니다. 처음 발생한 예외는 다시 발생하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f43e9ffc752b9a35ea582ecc7ec760456f3ea2c" translate="yes" xml:space="preserve">
          <source>If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</source>
          <target state="translated">명시적인 파생 전략이 제공되지 않으면 여러 전략이 적용될 수 있습니다. 이 경우 GHC는 다음과 같이 전략을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ff8ac1961b2d3e86583dd04eda895ba3b29064e6" translate="yes" xml:space="preserve">
          <source>If an identifier&amp;rsquo;s type has a &lt;code&gt;forall&lt;/code&gt;, then the order of type variables as written in the &lt;code&gt;forall&lt;/code&gt; is retained.</source>
          <target state="translated">식별자의 형태가있는 경우 &lt;code&gt;forall&lt;/code&gt; 다음에서 작성된 입력 변수의 순서 &lt;code&gt;forall&lt;/code&gt; 유지된다.</target>
        </trans-unit>
        <trans-unit id="6f039989be66fcac53da059edc720fe7f2a41936" translate="yes" xml:space="preserve">
          <source>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</source>
          <target state="translated">선택적 패키지 식별자 ⟨P⟩가 제공되면 해당 식별자와 일치하는 패키지 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9480ee90d261f8569a157de91547e584915aaf32" translate="yes" xml:space="preserve">
          <source>If any of the allocation functions fails, an exception is thrown. In some cases, memory exhaustion may mean the process is terminated. If &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is applied to a memory area that has been allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, the behaviour is undefined. Any further access to memory areas allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, after the computation that was passed to the allocation function has terminated, leads to undefined behaviour. Any further access to the memory area referenced by a pointer passed to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; entails undefined behaviour.</source>
          <target state="translated">할당 기능 중 하나라도 실패하면 예외가 발생합니다. 경우에 따라 메모리 소진은 프로세스가 종료되었음을 의미 할 수 있습니다. 경우 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 가 할당 된 메모리 영역에 적용되는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; 함수 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; , 행동은 정의되지 않는다. 할당 함수에 전달 된 계산이 종료 된 후 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; 로 할당 된 메모리 영역에 대한 추가 액세스 는 정의되지 않은 동작으로 이어집니다. &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 로 전달 된 포인터가 참조하는 메모리 영역에 대한 추가 액세스 는 정의되지 않은 동작을 수반합니다.</target>
        </trans-unit>
        <trans-unit id="0e7fd42d0300203e3af493856477c90e7ae13199" translate="yes" xml:space="preserve">
          <source>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</source>
          <target state="translated">정량화 된 유형 변수 중 하나에 종류 변수를 언급하는 종류가있는 경우</target>
        </trans-unit>
        <trans-unit id="73e0a573c5bd37919b95c361fc7a30bc02d831c3" translate="yes" xml:space="preserve">
          <source>If any of the variables depend on other variables (that is, if some of the variables are &lt;em&gt;kind&lt;/em&gt; variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</source>
          <target state="translated">변수 중 하나가 다른 변수에 의존하는 경우 (즉, 일부 변수가 &lt;em&gt;종류&lt;/em&gt; 변수 인 경우) 변수는 순서대로 정렬되어 종류 변수가 유형 변수 앞에 오도록하여 왼쪽에서 오른쪽 순서를 최대한 유지합니다. 즉, GHC는 변수에 대해 안정적인 위상 정렬을 수행합니다. 예:</target>
        </trans-unit>
        <trans-unit id="f0557de3fe76952756c65625bbfb3066796d428b" translate="yes" xml:space="preserve">
          <source>If both of these conditions are met, GHC will generate this instance:</source>
          <target state="translated">이 두 조건이 모두 충족되면 GHC는 다음 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7ce69b4f84d82a5182cf85076110c0eb025eac55" translate="yes" xml:space="preserve">
          <source>If both rules apply to a deriving clause, then &lt;code&gt;anyclass&lt;/code&gt; is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</source>
          <target state="translated">두 규칙이 파생 조항에 적용되는 경우 모든 &lt;code&gt;anyclass&lt;/code&gt; 가 사용되며 사용자에게 모호성에 대한 경고가 표시됩니다. 원하는 파생 전략을 명시 적으로 지정하면 경고를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fa898721e2cf3e2c6fc02511763040c586b29a5" translate="yes" xml:space="preserve">
          <source>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; is required, the presence of the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; macro needs to be ensured before it is called, e.g.:</source>
          <target state="translated">&lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; 을 정의하지 않은 Haskell 컴파일러 (버전 7.10.1 이전의 GHC 포함)와의 호환성 이 필요한 경우 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; 매크로가 호출되기 전에이를 확인해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="08f60c7543719f4b0441de2debed7ccff9b057ee" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the access time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; 이전 의 &lt;code&gt;unix&lt;/code&gt; 버전에 대해 컴파일 된 경우 , 함수는 1 초 미만의 해상도로 타임 스탬프를 설정할 수 없습니다. 이 경우 액세스 시간의 정밀도 손실도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ca0ce3ddba01a79e74af5c98436169275d83f0d" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the modification time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; 이전 의 &lt;code&gt;unix&lt;/code&gt; 버전에 대해 컴파일 된 경우 , 함수는 1 초 미만의 해상도로 타임 스탬프를 설정할 수 없습니다. 이 경우 수정 시간에 정밀도 손실도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76a5f02902c36d5e634fb160347312d3187dcbaf" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-O2&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-O2&lt;/code&gt; 가 활성화 된 상태에서 컴파일 된 경우 필드에는 각각 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b6e9b0f077c5045ff320f1e46e64bdc9093838" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-XStrictData&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-XStrictData&lt;/code&gt; 가 사용 가능한 상태로 컴파일 된 경우 필드에는 각각 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="894b0f94836181331c4facb44019c7354d1c68db" translate="yes" xml:space="preserve">
          <source>If compiled without optimization or other language extensions, then the fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">최적화 또는 다른 언어 확장을 사용하지 않고 컴파일하면, 다음의 분야 &lt;code&gt;ExampleConstructor&lt;/code&gt; 는 것 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; 을 각각.</target>
        </trans-unit>
        <trans-unit id="94f0a56741935b56d9657b26b078c93129516f82" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">정의 된 경우 &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; 가 방정식의 최소 해가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="702c4c7f59fbddacdb90bd27f31c03920aeed35e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">정의 된 경우 &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; 가 방정식의 최소 해가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="13447cdcf1a935f05011fe0f50982abf26334ad9" translate="yes" xml:space="preserve">
          <source>If divisor is zero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; is returned</source>
          <target state="translated">제수가 0이면 &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="079e039a9d9a2492d984ad6955aa2d617c670ae6" translate="yes" xml:space="preserve">
          <source>If given an explicit &amp;lt;mask&amp;gt;, the &amp;lt;mask&amp;gt; is interpreted as a bitmap that indicates the NUMA nodes on which to run the program. For example, &lt;code&gt;--numa=3&lt;/code&gt; would run the program on NUMA nodes 0 and 1.</source>
          <target state="translated">명시 적 &amp;lt;mask&amp;gt;가 제공되면 &amp;lt;mask&amp;gt;는 프로그램을 실행할 NUMA 노드를 나타내는 비트 맵으로 해석됩니다. 예를 들어 &lt;code&gt;--numa=3&lt;/code&gt; 은 NUMA 노드 0과 1에서 프로그램을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="5fc002cc69c30cbd42ee3fdd97604037215dd998" translate="yes" xml:space="preserve">
          <source>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</source>
          <target state="translated">유효하지 않은 입력이 주어진 경우, 함수 또는 연속이 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="560a8ee2e174396c52afe392206d8b4e1b326878" translate="yes" xml:space="preserve">
          <source>If given, uses &lt;code&gt;MADV_DONTNEED&lt;/code&gt; instead of &lt;code&gt;MADV_FREE&lt;/code&gt; on platforms where this results in more accurate resident memory usage of the program as shown in memory usage reporting tools (e.g. the &lt;code&gt;RSS&lt;/code&gt; column in &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;htop&lt;/code&gt;).</source>
          <target state="translated">주어진 경우, 플랫폼에서 &lt;code&gt;MADV_DONTNEED&lt;/code&gt; 대신 &lt;code&gt;MADV_FREE&lt;/code&gt; 를 사용합니다.이 경우 메모리 사용량보고 도구 (예 : &lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;htop&lt;/code&gt; 의 &lt;code&gt;RSS&lt;/code&gt; 열)에 표시된대로 프로그램의 상주 메모리 사용량이 더 정확 해 집니다.</target>
        </trans-unit>
        <trans-unit id="6b94f294f89264115630dd884435117d7704777a" translate="yes" xml:space="preserve">
          <source>If hs-boot files are considered distinct from their parent source files, and if a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command &lt;code&gt;ghc -M&lt;/code&gt; will report an error if a cycle is found.</source>
          <target state="translated">hs-boot 파일이 상위 소스 파일과 다른 것으로 간주되고 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 가져 오기가 hs-boot 파일을 참조하는 것으로 간주되면 모듈 가져 오기 그래프에주기가 없어야합니다. 사이클이 발견되면 &lt;code&gt;ghc -M&lt;/code&gt; 명령 이 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="cd1bdd645b7861dcf3835e2124b49ce612dfa503" translate="yes" xml:space="preserve">
          <source>If in doubt, don't use this function.</source>
          <target state="translated">의심스러운 경우이 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d098bda271cdeda0c89226b1f9334177dda1ff17" translate="yes" xml:space="preserve">
          <source>If in doubt, return non-zero, but do make an effort to create the correct answer for small args, since otherwise the performance of &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; will be poor.</source>
          <target state="translated">확실하지 않은 경우 0이 아닌 값을 반환하지만 작은 인수에 대한 정답을 만들려고 노력하십시오. 그렇지 않으면 &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; 의 성능 이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="901bbb7f5d809f3c6e6b017688b99e54b9c8c79f" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 터미널을 열 수 없으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="49674ddcca37568931ac6e297642bf137c06f0fb" translate="yes" xml:space="preserve">
          <source>If it is heavily used on lists with &lt;code&gt;Widget&lt;/code&gt; keys, you could specialise it as follows:</source>
          <target state="translated">&lt;code&gt;Widget&lt;/code&gt; 키가있는 목록에서 많이 사용되는 경우 다음과 같이 특수화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0edddfba80ac6a09b6665c39b1ef9f0ebf6fbab" translate="yes" xml:space="preserve">
          <source>If it says you&amp;rsquo;re using more than 20% of total time in garbage collecting, then more memory might help: use the &lt;code&gt;-H⟨size⟩&lt;/code&gt; (see &lt;code&gt;-H [⟨size⟩]&lt;/code&gt;) option. Increasing the default allocation area size used by the compiler&amp;rsquo;s RTS might also help: use the &lt;code&gt;+RTS -A⟨size⟩
-RTS&lt;/code&gt; option (see &lt;code&gt;-A ⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">가비지 수집에 총 시간의 20 % 이상을 사용한다고 표시되면 더 많은 메모리가 도움이 될 수 있습니다. &lt;code&gt;-H⟨size⟩&lt;/code&gt; ( &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 참조 ) 옵션을 사용하십시오. 컴파일러의 RTS가 사용하는 기본 할당 영역 크기를 늘리면 &lt;code&gt;+RTS -A⟨size⟩ -RTS&lt;/code&gt; 옵션을 사용하는 데 도움이 될 수 있습니다 ( &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="205fa22c0cf21d40cd9db8045e7c70a4db4f3ae2" translate="yes" xml:space="preserve">
          <source>If it uses terminal-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; will be read from the user's &lt;code&gt;~/.haskeline&lt;/code&gt; file (if present). If it uses file-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; are not relevant and will not be read.</source>
          <target state="translated">터미널 스타일 상호 작용을 사용하는 경우 사용자의 &lt;code&gt;~/.haskeline&lt;/code&gt; 파일 (있는 경우) 에서 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 를 읽습니다 . 파일 스타일 상호 작용을 사용하는 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 는 관련이 없으며 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48a69ac0f3095acb072ddfcfb9a6bdffd564f050" translate="yes" xml:space="preserve">
          <source>If more than one non-incoherent candidate remains, the search fails.</source>
          <target state="translated">일치하지 않는 후보가 둘 이상 남아 있으면 검색이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="092903c3946d9ebf1026389c3dca1af41e4be180" translate="yes" xml:space="preserve">
          <source>If more than one rule matches a call, GHC will choose one arbitrarily to apply.</source>
          <target state="translated">둘 이상의 규칙이 통화와 일치하는 경우 GHC는 임의로 적용 할 규칙을 하나 선택합니다.</target>
        </trans-unit>
        <trans-unit id="46c551abf7dfa66ea7e6819fd50f9537ead8ac62" translate="yes" xml:space="preserve">
          <source>If multiple CodingProgress returns are possible, OutputUnderflow must be preferred to InvalidSequence. This allows GHC's IO library to assume that if we observe InvalidSequence there is at least a single element available in the output buffer.</source>
          <target state="translated">여러 CodingProgress 리턴이 가능한 경우, OutputUnderflow가 InvalidSequence보다 선호되어야합니다. 이를 통해 GHC의 IO 라이브러리는 InvalidSequence를 관찰하면 출력 버퍼에 최소한 하나의 요소가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7c993cec0b4151ad1b0f5562c270a5895e49c59e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for datatypes where each constructor has just zero or one field, in particular for enumeration types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 인스턴스가 제공 되지 않으면 함수는 각 생성자가 0 또는 하나의 필드, 특히 열거 유형에 대한 데이터 유형에 여전히 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="777411d8c4bf9b9216adcc59bd1260d805fb12f9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for empty datatypes or datatypes that have a single constructor, but will fail on datatypes with more than one constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 인스턴스가 제공 되지 않은 경우 함수는 여전히 단일 생성자가있는 빈 데이터 유형 또는 데이터 유형에 대해 작동하지만 둘 이상의 생성자가있는 데이터 유형에서는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="076b26677e1e9d94d1e31f006635bd3641fcc733" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for enumeration types, where no constructor has any fields.</source>
          <target state="translated">어떤 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 인스턴스가 주어지지 함수는 여전히 생성자는 어떤 분야가 없습니다 열거 유형을 위해 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db076b7e62e1c825a47aaaf3a5ab3a6b5fbdafa9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype where each constructor has at least one field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; 인스턴스가 제공 되지 않은 경우 각 생성자가 하나 이상의 필드를 갖는 모든 데이터 유형에 대해 함수가 계속 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1606eb80e1c8dfc4c88130f2d2acd1efbbfc995e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype that is not empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 인스턴스가 제공 되지 않으면 이 함수는 비어 있지 않은 데이터 유형에 대해 여전히 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b3a7948164a4bece210a1698cfedabc51fc766" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">어떤 경우 &lt;code&gt;MINIMAL&lt;/code&gt; 프라그가 클래스 선언에 지정되지 않은, 그냥 것처럼 인 프라그 &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; 주어진는 어디 &lt;code&gt;opi&lt;/code&gt; 의 기본 방법이 부족 방법은 클래스 선언 (cf &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wmissing-methods&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6558b92d136aeb7b89c5f372133e67b42639edb6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;default&lt;/code&gt; declaration is given, then it is just as if the module contained the declaration &lt;code&gt;default( Integer, Double, String)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 선언이 없으면 모듈에 &lt;code&gt;default( Integer, Double, String)&lt;/code&gt; 선언이 포함 된 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="784b5f99e839f7b12ec2093256b70c6cad4b74c2" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search failes</source>
          <target state="translated">후보가 남아 있지 않으면 검색이 실패합니다</target>
        </trans-unit>
        <trans-unit id="9192657645342fee69fd524510551ad47221178f" translate="yes" xml:space="preserve">
          <source>If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</source>
          <target state="translated">서명에 대한 내보내기 목록이 제공되지 않은 경우 서명 내보내기는 모든 정의 된 엔터티가 상속 된 모든 서명 내보내기와 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ff16fc0e935cafc45afe04c519a876483f5dcb" translate="yes" xml:space="preserve">
          <source>If no inlining takes place, the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; function expands to the identity function in Phase zero, so its use imposes no overhead.</source>
          <target state="translated">더 인라인가 발생하지 않으면, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; 함수는 오버 헤드의 사용을 강요하며, 그래서 단계 제로의 ID 기능으로 확장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09340baa4f1fe5048c9542d16a391d2e3eb6f959" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">모드 플래그가 없으면 명령 행에 Haskell 소스 파일이 있으면 GHC는 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 ( &lt;a href=&quot;#make-mode&quot;&gt;ghc &amp;ndash;make 사용)로&lt;/a&gt; 들어가 거나 명령 행에 이름 지정된 오브젝트를 링크하여 실행 파일을 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="2c70bd69294b761a98eab2c97c782c7a594740e3" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">모드 플래그가 없으면 GHC는 명령 줄에 지정된 Haskell 소스 파일이 있으면 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 ( &lt;a href=&quot;#make-mode&quot;&gt;ghc --make 사용)로&lt;/a&gt; 들어가 거나, 그렇지 않으면 명령 줄에 명명 된 객체를 연결하여 실행 가능.</target>
        </trans-unit>
        <trans-unit id="545b39aee7ff9dd8868144c774e3a1c54c9f14dd" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt; and &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="translated">수량화 된 제약 조건이 일치하지 않으면 &lt;a href=&quot;#instance-resolution&quot;&gt;인스턴스 확인&lt;/a&gt; 및 &lt;a href=&quot;#instance-overlap&quot;&gt;겹치는 인스턴스에&lt;/a&gt; 설명 된대로 글로벌 인스턴스를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="8910a1e7567042e5831890a8c1459a75e51e378b" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="translated">그렇지 않은 경우 사용 가능한 모든 수량화 된 제약 조건을 확인하십시오. 정확히 하나가 &lt;code&gt;C t&lt;/code&gt; 와 일치 하면 선택하십시오. 둘 이상의 일치하는 경우 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="0c47246abbeffab64ebd4d936953fd4c7c077f74" translate="yes" xml:space="preserve">
          <source>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</source>
          <target state="translated">생략하면 ⟨n⟩ 및 ⟨m⟩의 기본값은 사용 가능한 첫 번째 또는 마지막 완료 후보입니다. range 인수를 통해 요청 된 것보다 적은 후보가있는 경우 ⟨n⟩ 및 ⟨m⟩은 암시 적으로 사용 가능한 완료 후보 수에 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="43110c483674fe00877c4157e9200eb8ff216c7b" translate="yes" xml:space="preserve">
          <source>If one input list is short, excess elements of the longer list are discarded:</source>
          <target state="translated">하나의 입력 목록이 짧은 경우 더 긴 목록의 초과 요소는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bae8b4e0fe43800691134bf9658ff55ae4812650" translate="yes" xml:space="preserve">
          <source>If one were to attempt to derive a Generic instance for a datatype with an unlifted argument (for example, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;), one might expect the occurrence of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; argument to be marked with &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;. This won't work, though, since &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; is of an unlifted kind, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; expects a type of kind &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">리프팅되지 않은 인수 (예 : &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; )가 있는 데이터 유형에 대한 Generic 인스턴스를 파생하려고 하면 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 인수가 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 로 표시 될 것으로 예상 할 수 있습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 은 리프팅 되지 않은 유형 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;*&lt;/code&gt; 유형이 필요하기 때문에 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ff1ad15ce25abb2710fa65ecce3a62a8bb2f9029" translate="yes" xml:space="preserve">
          <source>If platform does not provide &lt;code&gt;posix_fadvise(2)&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; becomes a no-op.</source>
          <target state="translated">플랫폼에서 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; 제공하지 않으면 Advise 가 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2fd0fc4ca5ca1f4279bebce52029854ce0a49ff" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="translated">가능한 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 가 직접 사용됩니다 (즉 , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 를 새로 할당 된 것으로 복제 &lt;em&gt;하지 않고&lt;/em&gt; 공유 )</target>
        </trans-unit>
        <trans-unit id="a02a08bcb120a182f93778d549b78999be975134" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, &amp;hellip;</source>
          <target state="translated">프로파일 링이 특정 기능을 가리켰다면 핵심 코드를 살펴보십시오. &lt;code&gt;lets&lt;/code&gt; , 나쁜 &lt;code&gt;cases&lt;/code&gt; 좋은 사전 (이다 &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; 나쁜, 중첩 된 람다 나쁜 있습니다) 또는 아무것도 과부하 틱, 명시 적 데이터 생성자가 좋은, 기본 작업 (예, 있습니다 &lt;code&gt;eqInt#&lt;/code&gt; 입니다) 좋은, &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="52cc4cf0d03d5edea947b7488d65fce86a4331f7" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, ...</source>
          <target state="translated">프로파일 링이 특정 기능을 손가락으로 가리키면 핵심 코드를 확인하십시오. &lt;code&gt;lets&lt;/code&gt; , 나쁜 &lt;code&gt;cases&lt;/code&gt; 좋은 사전 (이다 &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; 나쁜, 중첩 된 람다 나쁜 있습니다) 또는 아무것도 과부하 틱, 명시 적 데이터 생성자가 좋은, 기본 작업 (예, 있습니다 &lt;code&gt;eqInt#&lt;/code&gt; 입니다) 좋은, ...</target>
        </trans-unit>
        <trans-unit id="a9f317cd94e7a84b9481c4cd3410991be028a616" translate="yes" xml:space="preserve">
          <source>If recursive bindings are required for a monad, then that monad must be declared an instance of the &lt;code&gt;MonadFix&lt;/code&gt; class.</source>
          <target state="translated">모나드에 재귀 바인딩이 필요한 경우 해당 모나드는 &lt;code&gt;MonadFix&lt;/code&gt; 클래스 의 인스턴스로 선언되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="65bff50aaf133e46c4c389202fbe2fead3ced4d7" translate="yes" xml:space="preserve">
          <source>If right-to-left evaluation is required, the input list should be reversed.</source>
          <target state="translated">오른쪽에서 왼쪽으로 평가해야하는 경우 입력 목록을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="edfe3ca7d56d7c40b077f20b07320acbb2603c62" translate="yes" xml:space="preserve">
          <source>If some of the rows are shorter than the following rows, their elements are skipped:</source>
          <target state="translated">일부 행이 다음 행보다 짧은 경우 해당 요소를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a471137408c37fe4b26bd411d1c9b91c60232b56" translate="yes" xml:space="preserve">
          <source>If such a package environment is found, it is equivalent to passing these command line arguments to &lt;code&gt;ghc&lt;/code&gt;:</source>
          <target state="translated">이러한 패키지 환경이 발견되면 다음 명령 행 인수를 &lt;code&gt;ghc&lt;/code&gt; 에 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="100bc4626b0efab2c2dfa95a3d57f85130c6e4b0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;a href=&quot;#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">는 IF &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;이벤트 로그&lt;/a&gt; (으로 활성화 &lt;a href=&quot;#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 런타임 시스템 플래그) 힙 샘플 추가적으로 GHC 이벤트 로그에 출사한다 (참조 &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;힙 프로파일 이벤트 로그 출력&lt;/a&gt; 이벤트 포맷에 대한 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="4364a4035c9b8cd510cf366346a071ecc7512c6e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">는 IF &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;이벤트 로그&lt;/a&gt; (으로 활성화 &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; 런타임 시스템 플래그) 힙 샘플 추가적으로 GHC 이벤트 로그에 출사한다 (참조 &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;힙 프로파일 이벤트 로그 출력&lt;/a&gt; 이벤트 포맷에 대한 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="984396ef6b346f6f5a141f1b3cc9c98c57b40449" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="translated">는 IF &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt; &lt;code&gt;-Wunused-foralls&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어 사용자가 명시 적으로 형태 변수를 쓸 때 경고가 방출됩니다 &lt;code&gt;forall&lt;/code&gt; 그렇지 않으면 사용되지 않는 문. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="67067af8a67e4c0ac00744d32ff51787c4c23ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;*&lt;/code&gt; symbol is placed before the module name, then &lt;em&gt;all&lt;/em&gt; the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 기호가 모듈 이름 앞에 배치 되면 ⟨module⟩ 범위 내 &lt;em&gt;모든&lt;/em&gt; 식별자 (내보내기 만)가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7426ed03e0cc31e14922c9ce2a60b1c4a4d18a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-rtsopts&lt;/code&gt; flag is set to something other than &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;ignoreAll&lt;/code&gt; when linking, RTS options are also taken from the environment variable &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt;. For example, to set the maximum heap size to 2G for all GHC-compiled programs (using an &lt;code&gt;sh&lt;/code&gt;-like shell):</source>
          <target state="translated">경우 &lt;code&gt;-rtsopts&lt;/code&gt; 플래그가 아닌 다른 값으로 설정되어 &lt;code&gt;none&lt;/code&gt; 또는 &lt;code&gt;ignoreAll&lt;/code&gt; 링크 할 때, RTS 옵션도 환경 변수에서 가져옵니다 &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; . 예를 들어, &lt;code&gt;sh&lt;/code&gt; 와 같은 쉘을 사용하여 모든 GHC 컴파일 프로그램에 대해 최대 힙 크기를 2G로 설정하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee47e204ad25ad75b90f894519d743cd373d5ec1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; is not found returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 는 반환 발견되지 &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eecdf1765fe1b5c7a149e43f46aee92b76c9e9d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is a relative path, then for every search directory &lt;code&gt;dir&lt;/code&gt;, the function checks whether &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; exists and satisfies the predicate. If so, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; is returned as one of the results. In other words, the returned paths can be either relative or absolute depending on the search directories were used. If there are no search directories, no results are ever returned.</source>
          <target state="translated">는 IF &lt;code&gt;name&lt;/code&gt; 모든 검색 디렉토리에 대한 다음 상대 경로 &lt;code&gt;dir&lt;/code&gt; , 기능 검사 여부를 &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; 존재하고 만족 술어를. 그렇다면 &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; 이 결과 중 하나로 리턴됩니다. 즉, 리턴 된 경로는 사용 된 검색 디렉토리에 따라 상대적이거나 절대적 일 수 있습니다. 검색 디렉토리가 없으면 결과가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e66c7a66ac7c32b8ef7f9ce828408309a2951cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is an absolute path, then the function will return a single result if the file exists and satisfies the predicate and no results otherwise. This is irrespective of what search directories were given.</source>
          <target state="translated">는 IF &lt;code&gt;name&lt;/code&gt; 절대 경로는 파일이 존재하지 만족 술어를하고 그렇지 않으면 결과가 있다면, 함수는 하나의 결과를 반환합니다. 검색 디렉토리가 무엇이든 관계 없습니다.</target>
        </trans-unit>
        <trans-unit id="95e84cba36edfb057e05285c58d1b651c2f290d8" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 로 랩핑 된 I / O 계산이 부작용을 수행하는 경우 해당 부작용이 발생하는 상대적 순서 (주 I / O 트렁크 또는 기타 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 호출 )가 결정되지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 부작용 을 일으키는 경우 부작용 을 예상 한만큼 여러 번 수행하도록 다음 예방 조치를 취해야합니다. 이러한주의 사항은 GHC에 필요하지만 충분하지 않을 수 있으며 다른 컴파일러에서는 다른주의 사항이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95557e9796ad5018f234723793eebbd659062bdd" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 로 랩핑 된 I / O 계산이 부작용을 수행하는 경우 해당 부작용이 발생하는 상대적 순서 (주 I / O 트렁크 또는 기타 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 호출 )가 결정되지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 부작용 을 일으키는 경우 부작용 을 예상 한만큼 여러 번 수행하도록 다음 예방 조치를 취해야합니다. 이러한주의 사항은 GHC에 필요하지만 충분하지 않을 수 있으며 다른 컴파일러에서는 다른주의 사항이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f37fb4ee444bede274c669b4d448a3acdb65fb55" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 로 랩핑 된 I / O 계산이 부작용을 수행하는 경우 해당 부작용이 발생하는 상대적 순서 (주 I / O 트렁크 또는 기타 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 호출 )가 결정되지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하여 부작용 을 일으키는 경우 부작용 을 예상 한만큼 여러 번 수행하도록 다음 예방 조치를 취해야합니다. 이러한주의 사항은 GHC에 필요하지만 충분하지 않을 수 있으며 다른 컴파일러에서는 다른주의 사항이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="916aaf70159a57842ced3963dcd6e37575d65a6b" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 에 대한 인수 가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="c74b7c9262440ab8eb34e0a6d3d1e23753614271" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">버퍼 모드가 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 으로 변경 되면</target>
        </trans-unit>
        <trans-unit id="eb44311b2b43303ecd2e4401810f83b01105af2e" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">버퍼 모드가 &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 으로 변경 되면</target>
        </trans-unit>
        <trans-unit id="340506b1fc7cfecd1cc706b1ed0b444cb860cf41" translate="yes" xml:space="preserve">
          <source>If the computation is to modify the stored information, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">계산이 저장된 정보를 수정하는 경우 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c240367cda084253143432ddcf60bf0b03fa3e5" translate="yes" xml:space="preserve">
          <source>If the constraint solver encounters a constraint &lt;code&gt;HasField x r a&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is a concrete datatype with a field &lt;code&gt;x&lt;/code&gt; in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying &lt;code&gt;a&lt;/code&gt; with the type of the field if necessary. This happens irrespective of which extensions are enabled.</source>
          <target state="translated">구속 조건 솔버가 구속 조건 &lt;code&gt;HasField x r a&lt;/code&gt; 여기서 &lt;code&gt;r&lt;/code&gt; 이 범위에 필드 &lt;code&gt;x&lt;/code&gt; 가있는 콘크리트 데이터 유형 인 경우 필드 선택기를 사전으로 사용하여 구속 조건을 자동으로 해결하여 필요한 경우 필드 유형과 &lt;code&gt;a&lt;/code&gt; 를 통합 합니다. 어떤 확장이 활성화되어 있는지에 관계없이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ac5d0fe1d7acda30fb0ec5a56697651c36a28ef" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 는 생성자의 중위 애플리케이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bc73951c5c10ca78ae5366f259e7017f69544b8f" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 는 생성자의 중위 애플리케이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9a11dfd9c83245d6ba417f9310e69a934f255b67" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 는 생성자의 중위 애플리케이션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7340551eb65b17d80f26730fb4f3289da8692a48" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 접두사 양식이 아닌 생성자의 중위 애플리케이션 만 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a7834f177091806c3787fe742b48954a28d269ce" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 접두사 양식이 아닌 생성자의 중위 애플리케이션 만 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="fff881ab5c74b90094d3fe1033075847bf7fe644" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">생성자가 중위 연산자로 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 인스턴스는 접두사 양식이 아닌 생성자의 중위 애플리케이션 만 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a24a3dfbd521f865d8c41e8577fde1211e1662ee" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 는 레코드 구문 형식 만 구문 분석하며 필드는 원래 선언과 동일한 순서로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d9cae460cd107a842e94f70119834c39ecbdb71b" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 는 레코드 구문 형식 만 구문 분석하며 필드는 원래 선언과 동일한 순서로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b45481ebece8ce7cdca4efa8d7e24867db92404c" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 파생 된 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 는 레코드 구문 형식 만 구문 분석하며 필드는 원래 선언과 동일한 순서로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7dfb1a85a710e73bec4ed69a3c877abb78023f39" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 는 원래 선언과 동일한 순서로 제공된 필드와 함께 레코드 구문 양식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b1a05487843b471ffa877f4ad69c2c7e4d703688" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 는 원래 선언과 동일한 순서로 제공된 필드와 함께 레코드 구문 양식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0b96127742ffe03893d0e4f936b677e699812df7" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">생성자가 레코드 구문을 사용하여 정의 된 경우 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 는 원래 선언과 동일한 순서로 제공된 필드와 함께 레코드 구문 양식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="915369447c441596818ea47cd1848a5ce0c1bbc6" translate="yes" xml:space="preserve">
          <source>If the derived instance were allowed, what would the type of its method &lt;code&gt;bad&lt;/code&gt; be? It would seem to be &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt;, which is equivalent to &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt;, according to the type family &lt;code&gt;Inspect&lt;/code&gt;. Yet, if we simply adapt the implementation from the instance for &lt;code&gt;Int&lt;/code&gt;, the implementation for &lt;code&gt;bad&lt;/code&gt; produces a &lt;code&gt;Bool&lt;/code&gt;, and we have trouble.</source>
          <target state="translated">파생 인스턴스가 허용 된 경우, 그 방법의 종류 어떤 것이 &lt;code&gt;bad&lt;/code&gt; 일? 유형 패밀리 &lt;code&gt;Inspect&lt;/code&gt; 에 따르면 &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt; 인 것으로 보입니다 . 이는 &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt; 와 같습니다 . 그러나 &lt;code&gt;Int&lt;/code&gt; 인스턴스에서 구현을 간단히 적용하면 &lt;code&gt;bad&lt;/code&gt; 구현 으로 &lt;code&gt;Bool&lt;/code&gt; 이 생성 되고 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99dd79a68e6ace7bc36818530a36dff1b61996fd" translate="yes" xml:space="preserve">
          <source>If the elements are ordered, a linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">요소가 정렬 된 경우 성능은 &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; 와 동일한 선형 시간 구현이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ffe9c900b23c1f743c980afb39a54b09a15873e" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is set, and its value does not end in a separator (&lt;code&gt;:&lt;/code&gt; on Unix, &lt;code&gt;;&lt;/code&gt; on Windows), then the last database is considered to be the global database, and will be modified by default by &lt;code&gt;ghc-pkg&lt;/code&gt;. The intention here is that &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;.</source>
          <target state="translated">환경 변수의 경우 &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 가&lt;/a&gt; 설정되고, 그 값이 분리 끝나지 않는 ( &lt;code&gt;:&lt;/code&gt; 유닉스에서 &lt;code&gt;;&lt;/code&gt; Windows의 경우), 다음 마지막으로 데이터베이스는 글로벌 데이터베이스로 간주됩니다,에 의해 기본적으로 수정됩니다 &lt;code&gt;ghc-pkg&lt;/code&gt; . 여기서는 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 를 사용하여 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 이외의 설정없이 Cabal 패키지를 설치할 수있는 가상 패키지 환경을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55d64c16a458e52bfe82101c17b8bb95dd2a0fb1" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 내부에서 예외가 발생하지 않으면 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 다시 발생 하고 전체 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="0f96e8b63db707eb0457ade29de32d3c2df84734" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 내부에서 예외가 발생하지 않으면 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 다시 발생 하고 전체 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="c2dff9269612b6f615c400bd3a6c96cd41d71ec5" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 내부에서 예외가 발생하지 않으면 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 다시 발생 하고 전체 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="1b31e706b20ca1dd226c814726e8413042889a0f" translate="yes" xml:space="preserve">
          <source>If the expression was instead of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;it&lt;/code&gt; will be bound to the result of the &lt;code&gt;IO&lt;/code&gt; computation, which is of type &lt;code&gt;a&lt;/code&gt;. eg.:</source>
          <target state="translated">식 대신 타입이라면 &lt;code&gt;IO a&lt;/code&gt; 일부 후 &lt;code&gt;it&lt;/code&gt; 의 결과에 바인딩 될 &lt;code&gt;IO&lt;/code&gt; 의 유형이다 계산, . 예 : &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="557b536a62aea491508b3f277f7c66ebafe8f737" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">파일이 존재하지 않고 출력을 위해 열린 경우 새 파일로 작성해야합니다. 경우 &lt;code&gt;mode&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 및 파일이 이미 존재, 그것은 제로 길이로 절단되어야한다. 일부 운영 체제는 그래서 파일이 다음과 같은 존재 것이라는 보장이없는 빈 파일을 삭제 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 이 후 성공적으로 기록되지 않는가. &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; 인 경우 핸들은 파일의 끝에 위치하고 그렇지 않으면 시작 (내부 위치는 0)에 있습니다. 초기 버퍼 모드는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8bdafef8b919def741e21f11e5c61515c31e3d40" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">파일이 존재하지 않고 출력을 위해 열린 경우 새 파일로 작성해야합니다. 경우 &lt;code&gt;mode&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 및 파일이 이미 존재, 그것은 제로 길이로 절단되어야한다. 일부 운영 체제는 그래서 파일이 다음과 같은 존재 것이라는 보장이없는 빈 파일을 삭제 &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 이 후 성공적으로 기록되지 않는가. &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; 인 경우 핸들은 파일의 끝에 위치하고 그렇지 않으면 시작 (내부 위치는 0)에 있습니다. 초기 버퍼 모드는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8848ff01b8a32afcddff36cec08d4b6728717d85" translate="yes" xml:space="preserve">
          <source>If the final statement is not of one of these forms, GHC falls back to standard &lt;code&gt;do&lt;/code&gt; desugaring, and the expression will require a &lt;code&gt;Monad&lt;/code&gt; constraint.</source>
          <target state="translated">마지막 문이없는 이러한 형태 중 하나 인 경우, GHC 표준에 다시 떨어질 &lt;code&gt;do&lt;/code&gt; desugaring 및 표현은 필요합니다 &lt;code&gt;Monad&lt;/code&gt; 제약 조건을.</target>
        </trans-unit>
        <trans-unit id="99750cf8581988661447b877b8a2ef2af75d98f8" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">다시 시도하지 않고 첫 번째 조치가 완료되면 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 의 결과가 됩니다 . 그렇지 않으면 첫 번째 조치가 재 시도되면 두 번째 조치가 대신 시도됩니다. 두 조치가 모두 재 시도되면 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 는 전체 재 시도입니다.</target>
        </trans-unit>
        <trans-unit id="c3b9d8e821fceed6649d1fb75df70e0b3ecb6ca6" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">다시 시도하지 않고 첫 번째 조치가 완료되면 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 의 결과가 됩니다 . 그렇지 않으면 첫 번째 조치가 재 시도되면 두 번째 조치가 대신 시도됩니다. 두 조치가 모두 재 시도되면 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 는 전체 재 시도입니다.</target>
        </trans-unit>
        <trans-unit id="29e53de7a23bc55e53e1793d6fcc64937e975381" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">다시 시도하지 않고 첫 번째 조치가 완료되면 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 의 결과가 됩니다 . 그렇지 않으면 첫 번째 조치가 재 시도되면 두 번째 조치가 대신 시도됩니다. 두 조치가 모두 재 시도되면 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; 는 전체 재 시도입니다.</target>
        </trans-unit>
        <trans-unit id="0a17c36982066985bf53c44ca7e61aeacd02ae41" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 로 평가 되면 결과는 두 번째 인수입니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 의 예외는 포함 제기되는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 에 대한 호출의 소스 파일과 줄 번호와 &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feb4f24ce87f487be05ef1c288b600a60dcbf5bb" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수가 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 로 평가 되면 결과는 두 번째 인수입니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 의 예외는 포함 제기되는 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 에 대한 호출의 소스 파일과 줄 번호와 &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0054b769e95e245513b766b41dc0a78a5fa0e67" translate="yes" xml:space="preserve">
          <source>If the first completer produces no suggestions, fallback to the second completer's output.</source>
          <target state="translated">첫 번째 완성자가 제안을하지 않으면 두 번째 완성 자의 출력으로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="7d227d6371173673bc113bcadb48246870a816fc" translate="yes" xml:space="preserve">
          <source>If the first list contains duplicates, so will the result.</source>
          <target state="translated">첫 번째 목록에 중복 항목이 있으면 결과도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8f303f44f15d67e9e20a0ff01c05b8e471995e19" translate="yes" xml:space="preserve">
          <source>If the first list is not finite, the result is the first list.</source>
          <target state="translated">첫 번째 목록이 유한하지 않은 경우 결과는 첫 번째 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fabb69bed587314beb9edec19efed156d82f6d0c" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 가 둘 이상의 매개 변수를 사용하는 경우 형식 변수 &lt;code&gt;b&lt;/code&gt; 는 ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 조합기에 추가 파서 &lt;code&gt;p&lt;/code&gt; 와 잘 결합 된 기능 형식으로 인스턴스화됩니다 . 이로 인해 순열 구문 분석기가 결합 함수 &lt;code&gt;f&lt;/code&gt; 로 시작하고 구문 분석기가 시작되는 양식화 된 코드가 생성됩니다 . 함수 &lt;code&gt;f&lt;/code&gt; 는 파서가 지정된 순서대로 매개 변수를 가져 오지만 실제 입력은 임의의 순서로 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5eb94185e7818eb4718538187db5c7b4cbfd254a" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 가 둘 이상의 매개 변수를 사용하는 경우 형식 변수 &lt;code&gt;b&lt;/code&gt; 는 ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 조합기에 추가 파서 &lt;code&gt;p&lt;/code&gt; 와 잘 결합 된 기능 형식으로 인스턴스화됩니다 . 이로 인해 순열 구문 분석기가 결합 함수 &lt;code&gt;f&lt;/code&gt; 로 시작하고 구문 분석기가 시작되는 양식화 된 코드가 생성됩니다 . 함수 &lt;code&gt;f&lt;/code&gt; 는 파서가 지정된 순서대로 매개 변수를 가져 오지만 실제 입력은 임의의 순서로 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c0bf34eec193f2a121ba6f174b48d6e08e32c420" translate="yes" xml:space="preserve">
          <source>If the function isn&amp;rsquo;t exported, just compile with the extra flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;; next to the signature for any binder, it will print the self-same pragmatic information as would be put in an interface file. (Besides, Core syntax is fun to look at!)</source>
          <target state="translated">함수가 내보내지지 않으면 여분의 플래그 &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; 로&lt;/a&gt; 컴파일하십시오 . 바인더의 서명 옆에 인터페이스 파일에 넣는 것과 동일한 실제 정보가 인쇄됩니다. (핵심 구문은 재미있게 볼 수 있습니다!)</target>
        </trans-unit>
        <trans-unit id="79369b89e6cd5dd14719075c040fa3bcd79b2c7d" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="96d21b1729033749751e04b2041b55e92dac94b3" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="733eefc07bf9e51bd55cbb49b0874fcb5f17d31b" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 는 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="75a38fbd33678c8e1ac4ad25b0d95cd894290536" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫힌 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="eb6e0e76a190f2043a8bd3777daebaebf1def2ab" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 는 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="ac14468e0ab875750716201383acedb0f1aa59a2" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫힌 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="4758d777c012362f6479362e01995e935a7b09ed" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="43a808de4e438b2cac191975ec1178b82376b0eb" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 는 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="695c3d916d62f2ea55cdb779edc67a44a1f3c788" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 는 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="c9752d59da062f75442fd0c45b415851963415b0" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="c2f82e3a8d0be8d48a4f40713cb2d9fb06f2e221" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">핸들이 파이프 또는 소켓이고 쓰기 끝이 닫히면 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; 은 EOF에 도달 한 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="2eb52b41e41c616d22190f5e23f9b5d53c5c8fa6" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="translated">핸들러가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 로 랩핑 된 값을 리턴하면 해당 값이 출력에서 ​​유효하지 않은 입력을 대체하는 데 사용됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환 하면 출력에 값이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe922e3d119fe0f1cc74a44c92d349bcf461e892" translate="yes" xml:space="preserve">
          <source>If the initial buffer is too small to hold all data, subsequent buffers will be the default buffer size.</source>
          <target state="translated">초기 버퍼가 너무 작아 모든 데이터를 보유 할 수없는 경우 후속 버퍼가 기본 버퍼 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="1a8e4480bef91d631c461344a2de2236d4cfee75" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 UTF-8 데이터가 포함 된 경우 순수한 코드에서 포착 할 수없는 예외가 발생합니다 (이 함수 또는 연속으로). 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd132895bcb29067d5281e312732641ade69617a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 UTF-8 데이터가 포함 된 경우 순수한 코드에서 포착 할 수없는 예외가 발생합니다. 유효하지 않은 데이터 처리에 대한 제어를 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; 하려면 decodeUtf8 ' 또는 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6f85b42e97d38521695bc5719fab602af715f74" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 UTF-8 데이터가 포함 된 경우 순수한 코드에서 포착 할 수없는 예외가 발생합니다. 유효하지 않은 데이터 처리에 대한 제어를 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; 하려면 decodeUtf8 ' 또는 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09b23031b09a6ace4ba4f6ac224b740e40f02c57" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</source>
          <target state="translated">입력에 유효하지 않은 UTF-8 데이터가 포함 된 경우 관련 예외가 리턴되고 그렇지 않으면 디코딩 된 텍스트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="754415b1a59c2ab620f6ecdfc36468a832eed47d" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 big endian UTF-16 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="24a4190d0c5a617251a227f4e4ffc0dc4c3ec80e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 big endian UTF-16 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a938f8cb41602c2e37ba21b2b1d159bacbe79e60" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 big endian UTF-32 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 강력하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0a0fd29f327678893fbe7d2c540d1bfc2f81f6e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 big endian UTF-32 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 강력하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="64bf7ac928bb9d8d34aaf3441fc5265800b5a9d5" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 리틀 엔디 언 UTF-16 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="de1b7df55ab6d8158aa8cf994eaac1e0b9224b7e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 리틀 엔디 언 UTF-16 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="70c2f670f171baeb0231536712051cb1c8aaf33a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 리틀 엔디 언 UTF-32 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26edc2ab81f9a20a2fa34e0b70f9dd71e74d9ab" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입력에 유효하지 않은 리틀 엔디 언 UTF-32 데이터가 포함 된 경우 예외가 발생합니다. 유효하지 않은 데이터 처리를보다 세밀하게 제어하려면 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d43fcf632f6993095dae2aeab0f213b43767b8e" translate="yes" xml:space="preserve">
          <source>If the key exists in the map, this function is lazy in &lt;code&gt;value&lt;/code&gt; but strict in the result of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">키가 맵에 존재하면이 함수는 &lt;code&gt;value&lt;/code&gt; 이 게으르지 만 &lt;code&gt;f&lt;/code&gt; 결과에서는 엄격합니다 .</target>
        </trans-unit>
        <trans-unit id="625b4beded575a88ac5daec835ba706a687d2bcb" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록의 키를 주문하면 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; 와 동일한 성능으로 선형 시간 구현이 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="b1448f4c78b74e05628456296d2ae49ddecc501e" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록의 키가 정렬 된 경우 성능은 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; 와 동일한 선형 시간 구현이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="749dbe9f6d5460db51b381f2ed3cc45b62922708" translate="yes" xml:space="preserve">
          <source>If the linker complains about not finding &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt;, then something is inconsistent: you probably didn&amp;rsquo;t compile modules in the proper dependency order.</source>
          <target state="translated">링커가 &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt; 를 찾지 못한다고 불평하면 무언가가 일치하지 않습니다. 아마도 적절한 종속성 순서로 모듈을 컴파일하지 않았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="17ce2aaa6f885fafff129a1f5c7f288b0246cde9" translate="yes" xml:space="preserve">
          <source>If the module is omitted, then the most recently-loaded module is used.</source>
          <target state="translated">모듈을 생략하면 가장 최근에로드 된 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06465b1683dc6997624e8cf98f88a5ffebfed678" translate="yes" xml:space="preserve">
          <source>If the object becomes unreachable right before the program exits, then GC may not be performed. Finalizers run during GC, so finalizers associated with the object do not run if GC does not happen.</source>
          <target state="translated">프로그램이 종료되기 직전에 객체에 도달 할 수 없게되면 GC가 수행되지 않을 수 있습니다. GC 중에 파이널 라이저가 실행되므로 GC가 발생하지 않으면 객체와 관련된 파이널 라이저가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1118a0190298be9b79dcb8130235e2ed75e7ad6d" translate="yes" xml:space="preserve">
          <source>If the operations needed are available in &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;, it's recommended to avoid importing this module and use &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; instead for now.</source>
          <target state="translated">필요한 조작이 &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; 에서 사용 가능한 경우이 모듈을 가져 &lt;a href=&quot;ghc-list&quot;&gt;오지&lt;/a&gt; 않고 GHC.List를 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d002b03429965487a13f5d84e867b7a6ca60210f" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="translated">&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; 옵션이 이 컴파일러에 전달되면 위의 제한 사항이 적용되지 않으며 형식 유추 중에 형식 패밀리 정규화가 종료되도록 프로그래머에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a071a26aa48a39d43d14f16a87c253716cb792f4" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--simple-output&lt;/code&gt; is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of &lt;code&gt;ghc-pkg list&lt;/code&gt; using a script.</source>
          <target state="translated">&lt;code&gt;--simple-output&lt;/code&gt; 옵션 이 제공되면 패키지는 공백으로 구분 된 한 줄에 나열되며 데이터베이스 이름은 포함되지 않습니다. 이것은 스크립트를 사용하여 &lt;code&gt;ghc-pkg list&lt;/code&gt; 의 출력을보다 쉽게 ​​구문 분석 할 수 있도록하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a2972ccb36c0dde44e00d9bbf8a450ab2fdf58ed" translate="yes" xml:space="preserve">
          <source>If the package contains profiling libraries, then the interface files for those library modules should have the suffix &lt;code&gt;.p_hi&lt;/code&gt;. So the package can contain both normal and profiling versions of the same library without conflict (see also &lt;code&gt;library_dirs&lt;/code&gt; below).</source>
          <target state="translated">패키지에 프로파일 링 라이브러리가 포함 된 경우 해당 라이브러리 모듈의 인터페이스 파일에는 접미사 &lt;code&gt;.p_hi&lt;/code&gt; 가 있어야합니다 . 따라서 패키지는 충돌없이 동일한 라이브러리의 일반 및 프로파일 링 버전을 모두 포함 할 수 있습니다 ( 아래의 &lt;code&gt;library_dirs&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="8ccd8f5434504821c2b94076a11f8715fe0b84ba" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;a&lt;/code&gt; appears underneath a composition of other type constructors, then the representation involves composition, too:</source>
          <target state="translated">매개 변수 &lt;code&gt;a&lt;/code&gt; 가 다른 유형 생성자의 컴포지션 아래 표시 컴포지션도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="32cab9cb10b6c38303476943187addc7db896eb0" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경로가 이미 절대적이면 작업이 실패하지 않습니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 와 동일한 예외로 작업이 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b17cb9d8e7bb5e296d3da780f46cf2d367124c" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may throw exceptions.</source>
          <target state="translated">경로가 이미 절대적이면 작업이 실패하지 않습니다. 그렇지 않으면 작업에서 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd818a895dd0680e5558fe6703f03edd2d2230d" translate="yes" xml:space="preserve">
          <source>If the path points to an existing file or directory, then the output path shall also point to the same file or directory, subject to the condition that the relevant parts of the file system do not change while the function is still running. In other words, the function is definitively not atomic. The results can be utterly wrong if the portions of the path change while this function is running.</source>
          <target state="translated">경로가 기존 파일 또는 디렉토리를 가리키는 경우, 출력 경로는 기능이 계속 실행되는 동안 파일 시스템의 관련 부분이 변경되지 않는 조건에 따라 동일한 파일 또는 디렉토리를 가리켜 야합니다. 다시 말해서, 함수는 확실히 원자가 아닙니다. 이 기능이 실행되는 동안 경로 부분이 변경되면 결과가 완전히 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17dcdf1f1aa0a2191303abce0bb5187d7f7a9885" translate="yes" xml:space="preserve">
          <source>If the pattern is a constructor pattern &lt;code&gt;(P p1 ... pn)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern synonym defined by &lt;code&gt;P x1 ... xn = p&lt;/code&gt; or &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt;, then:</source>
          <target state="translated">패턴이 생성자 패턴 &lt;code&gt;(P p1 ... pn)&lt;/code&gt; 인 경우 &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;P x1 ... xn = p&lt;/code&gt; 또는 &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt; -p에 의해 정의 된 패턴 동의어입니다. 인 경우 :</target>
        </trans-unit>
        <trans-unit id="3ba484df09e44ad6151f620767b5567f42c57031" translate="yes" xml:space="preserve">
          <source>If the pattern matches multiple packages, the description for each package is emitted, separated by the string &lt;code&gt;---&lt;/code&gt; on a line by itself.</source>
          <target state="translated">패턴이 여러 패키지와 일치하는 경우 각 패키지에 대한 설명이 문자열 &lt;code&gt;---&lt;/code&gt; 로 구분 되어 자체적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eddedbc84892409431bb5cd9dff6d864c792acc8" translate="yes" xml:space="preserve">
          <source>If the plugin cannot make any progress, it should return &lt;code&gt;TcPluginOk [] []&lt;/code&gt;. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</source>
          <target state="translated">플러그인이 진행할 수 없으면 &lt;code&gt;TcPluginOk [] []&lt;/code&gt; 반환해야합니다 . . 그렇지 않으면 새로운 제약 조건이있는 경우 기본 제약 조건 솔버를 다시 호출하여 단순화 한 다음 플러그인을 다시 호출합니다. 플러그인은이 프로세스가 결국 종료되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f4dd01b74a08371cbefaa339741c2f2bf732cc33" translate="yes" xml:space="preserve">
          <source>If the pointer argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;. If the requested size is 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 에 대한 포인터 인수 가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 같이 작동 합니다. 요청 된 크기가 0이면 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 처럼 동작합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="94a8bff9ac670099a84c99ae99166a8b13917470" translate="yes" xml:space="preserve">
          <source>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</source>
          <target state="translated">프로그램을 추가 객체 (예 : 일부 보조 C 코드)와 연결해야하는 경우 명령 줄에 객체 파일을 제공 할 수 있으며 GHC는 실행 파일을 연결할 때 해당 파일을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cf0e55f0ed3aeca48a639cdc97cfce430926d732" translate="yes" xml:space="preserve">
          <source>If the program&amp;rsquo;s heap exceeds the value set by &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;, the RTS throws an exception to the program, and the program gets an additional quota of allocation before the exception is raised again, the idea being so that the program can execute its exception handlers. &lt;code&gt;-Mgrace=&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">프로그램의 힙이 &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 값을 초과하면 RTS는 프로그램에 예외를 던지고 프로그램은 예외가 다시 발생하기 전에 추가 할당량을 얻습니다. 예외 처리기. &lt;code&gt;-Mgrace=&lt;/code&gt; 는이 추가 할당량의 크기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a05bad59c9ffd07726909b6b71df24cb1faeae56" translate="yes" xml:space="preserve">
          <source>If the quotes are left off in the above command, &lt;code&gt;ghci&lt;/code&gt; will interpret the filename as two, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt;.</source>
          <target state="translated">위 명령에서 인용 부호를 생략하면 &lt;code&gt;ghci&lt;/code&gt; 는 파일 이름을 &lt;code&gt;c:\\\\Program&lt;/code&gt; 및 &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt; 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="2999a971417548d37995328ba747557f94ced1e4" translate="yes" xml:space="preserve">
          <source>If the specifics of the data format is not important to you, for example, you are more interested in serializing and deserializing values than in which format will be used, it is possible to derive &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; instances using the generic support. See &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 데이터 형식의 세부 사항이 중요하지 않은 경우 사용되는 형식보다 값을 직렬화 및 역 직렬화하는 데 더 관심이있는 경우 일반 지원을 사용하여 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 인스턴스 를 파생시킬 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bff18fc6fb06d1186c47eea05dc08be6efd2b10" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열에 공통 접두사가 없거나이 중 하나가 비어 있으면이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a96483a865258b93f60fbe9c7b1b6209ab588de4" translate="yes" xml:space="preserve">
          <source>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for &lt;code&gt;EINTR&lt;/code&gt; always, but on Windows it is not typically necessary to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">시스템 호출이 성공적으로 중단되면 Haskell로 돌아가서 예외가 발생할 수 있습니다. 외부 함수의 호출자가 호출이 중단 된 결과를 처리 할 수 ​​있도록 &lt;code&gt;interruptible&lt;/code&gt; 을 사용할 때 특히주의하십시오 . 유닉스에서는 항상 &lt;code&gt;EINTR&lt;/code&gt; 을 확인하는 것이 좋지만 Windows에서는 일반적으로 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; 를 처리 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b0ea0825d60f59ed95619566d152ac3af5d1dc48" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상이 호출 스레드 인 경우 예외가 비동기 예외로 처리된다는 점을 제외 하면 동작은 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 즉, 현재 IO 작업이 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에있는 경우 순수한 순수 계산이있는 경우 해당 계산은 예외로 영구적으로 대체되지 않지만 비동기 예외를 수신 한 것처럼 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="ef565fe58fa8cc5e2adb616fefe14b2fe53e3eb9" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상이 호출 스레드 인 경우 예외가 비동기 예외로 처리된다는 점을 제외 하면 동작은 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 즉, 현재 IO 작업이 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에있는 경우 순수한 순수 계산이있는 경우 해당 계산은 예외로 영구적으로 대체되지 않지만 비동기 예외를 수신 한 것처럼 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="29ed533e57740cc52561c9e0778a3939079b1869" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상이 호출 스레드 인 경우 예외가 비동기 예외로 처리된다는 점을 제외 하면 동작은 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 즉, 현재 IO 작업이 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에있는 경우 순수한 순수 계산이있는 경우 해당 계산은 예외로 영구적으로 대체되지 않지만 비동기 예외를 수신 한 것처럼 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="3b5423771ba3f07d0d121d4047b87be07039385d" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상이 호출 스레드 인 경우 예외가 비동기 예외로 처리된다는 점을 제외 하면 동작은 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 즉, 현재 IO 작업이 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에있는 경우 순수한 순수 계산이있는 경우 해당 계산은 예외로 영구적으로 대체되지 않지만 비동기 예외를 수신 한 것처럼 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="f635604a794f0509d229ca0450224e3801f13960" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">대상 스레드가 현재 외래 호출을하는 경우 호출이 완료 될 때까지 예외가 발생하지 않으며 따라서 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않습니다. 이것은 호출이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에 있는지 여부에 관계없이 적용 됩니다. 그러나 GHC에서 외래 호출은 &lt;code&gt;interruptible&lt;/code&gt; 가능으로 주석을 달 수 있으며 ,이 경우 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 RTS가 호출을 다시 시도하게합니다. 자세한 내용은 GHC 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cb32a1414cef013e5d3c55de2b52fcec36dfcc67" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">대상 스레드가 현재 외래 호출을하는 경우 호출이 완료 될 때까지 예외가 발생하지 않으며 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않습니다. 이것은 호출이 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에 있는지 여부에 관계없이 적용 됩니다. 그러나 GHC에서 외래 호출은 &lt;code&gt;interruptible&lt;/code&gt; 가능으로 주석을 달 수 있으며 ,이 경우 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 RTS가 호출을 다시 시도하게합니다. 자세한 내용은 GHC 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="410b774382afae43c015c978d6a4c05a23286a81" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">대상 스레드가 현재 외래 호출을하는 경우 호출이 완료 될 때까지 예외가 발생하지 않으며 따라서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않습니다. 이것은 호출이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에 있는지 여부에 관계없이 적용 됩니다. 그러나 GHC에서 외래 호출은 &lt;code&gt;interruptible&lt;/code&gt; 가능으로 주석을 달 수 있으며 ,이 경우 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 RTS가 호출을 다시 시도하게합니다. 자세한 내용은 GHC 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6aae4a4891882f9616442e3ab4e703d074ae744f" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">대상 스레드가 현재 외래 호출을하는 경우 호출이 완료 될 때까지 예외가 발생하지 않으며 따라서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않습니다. 이것은 호출이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에 있는지 여부에 관계없이 적용 됩니다. 그러나 GHC에서 외래 호출은 &lt;code&gt;interruptible&lt;/code&gt; 가능으로 주석을 달 수 있으며 ,이 경우 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 RTS가 호출을 다시 시도하게합니다. 자세한 내용은 GHC 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0efe330fe5a7f319c74a83698c2016b7024d2870" translate="yes" xml:space="preserve">
          <source>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</source>
          <target state="translated">틱 카운트가 만료되면 GHC는 수행 한 단순화 단계를 요약합니다. &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; 를 사용하여 훨씬 더 자세한 목록을 생성 할 수 있습니다 . 일부 숫자가 매우 크기 때문에 일반적으로 루프를 매우 정확하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f834f3278901f9fdfc11689ba5008e3d53a52f10" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy:</source>
          <target state="translated">유형이 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 인스턴스 인 경우 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="27c720209a65937fe0295731a0ddd0e77cf4c007" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">유형도 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 인 경우</target>
        </trans-unit>
        <trans-unit id="c31cbe33b88501dc1cab64cc221110f7cc955564" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">유형도 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 인 경우</target>
        </trans-unit>
        <trans-unit id="b1a3cb38f79f019c8eefd564552c10ef09d46fb9" translate="yes" xml:space="preserve">
          <source>If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</source>
          <target state="translated">유형 시그니처에 다양한 종류의 주석 (변수 바인더 또는 유형에 대한 주석)이 포함 된 경우, 유형 주석에 사용 된 모든 변수는 유형 주석에 사용 된 변수보다 우선합니다. 이 규칙은 재귀 적이 지 않습니다. 주석 내에 주석이있는 경우 여기에 사용 된 변수는 동일한 기초에 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8c4ea0e44780d77e1880898106ce1bbf9df2c555" translate="yes" xml:space="preserve">
          <source>If the types of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;q&lt;/code&gt; 의 타입이 박스형이 아닌 경우, 결과적인 바인딩은 다른 Haskell 패턴 바인딩과 같이 게으르다. 위의 예는 다음과 같이 설탕을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b6f18250f43f2740e1195441a25da60c594f32dd" translate="yes" xml:space="preserve">
          <source>If the underlying encoding is not itself roundtrippable, this mechanism can fail. Roundtrippable encodings are those which have an injective mapping into Unicode. Almost all encodings meet this criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain several different encodings of the same Unicode codepoint.</source>
          <target state="translated">기본 인코딩 자체가 왕복 할 수없는 경우이 메커니즘이 실패 할 수 있습니다. 왕복 가능한 인코딩은 유니 코드에 인젝 티브 매핑이있는 인코딩입니다. 거의 모든 인코딩이이 기준을 충족하지만 일부는 그렇지 않습니다. 특히 Shift-JIS (CP932) 및 Big5에는 동일한 유니 코드 코드 포인트의 여러 가지 인코딩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18d7f0b53d60c67a0f0044ea31055a7a2c5370e" translate="yes" xml:space="preserve">
          <source>If the user has supplied a type signature, as in &lt;code&gt;f&lt;/code&gt;, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in &lt;code&gt;f&lt;/code&gt; will be &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;f&lt;/code&gt; 와 같이 타입 서명을 제공했다면, 이것은 쉽다 : 우리는 타입 서명으로부터 순서를 취하고, 왼쪽에서 오른쪽으로 가고, 변수의 첫 번째 발생을 사용하여 순서 내에서 위치를 선택한다. 따라서,의 변수 &lt;code&gt;f&lt;/code&gt; 것이다 &lt;code&gt;b&lt;/code&gt; 다음 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="153127ffa367d83e2cf43ec8214e9672b8320af2" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">사용자가 &quot;lexical&quot;을 작성하면 구문 분석기가 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; 실패 하고 &quot;let&quot;에 't'가 필요 합니다. 실제로 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 첫 번째 대안이 입력을 소비하지 않은 경우에만 대안을 시도하기 때문에 &lt;code&gt;identifier&lt;/code&gt; 구문 분석기는 시도되지 않습니다 ( &lt;code&gt;string &quot;let&quot;&lt;/code&gt; 구문 분석기 의 &quot;le&quot;접두어 가 이미 사용 되었기 때문에). &lt;code&gt;try&lt;/code&gt; 조합기 를 추가하면 올바른 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="077149390f83f66f25123eacbd59fbfc008ad8c0" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">사용자가 &quot;lexical&quot;을 작성하면 구문 분석기가 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; 실패 하고 &quot;let&quot;에 't'가 필요 합니다. 실제로 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 첫 번째 대안이 입력을 소비하지 않은 경우에만 대안을 시도하기 때문에 &lt;code&gt;identifier&lt;/code&gt; 구문 분석기는 시도되지 않습니다 ( &lt;code&gt;string &quot;let&quot;&lt;/code&gt; 구문 분석기 의 &quot;le&quot;접두어 가 이미 사용 되었기 때문에). &lt;code&gt;try&lt;/code&gt; 조합기 를 추가하면 올바른 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="627396045def6a2b30cfb67918ea7b827134e0dc" translate="yes" xml:space="preserve">
          <source>If the value of the error is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">오류 값이 필요하지 않은 경우 &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; 의 변형을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cbcf45c8589b25e6b77fbe3fd739a89f107ae36" translate="yes" xml:space="preserve">
          <source>If the value of the exception is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">예외 값이 필요하지 않은 경우 &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; 의 변형을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9596c4f417cd0a2eeda3532c57a9759b3148d2e2" translate="yes" xml:space="preserve">
          <source>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</source>
          <target state="translated">노출 된 패키지 버전이 여러 개인 경우 GHC는 최신 버전을 선호합니다. 또한 일부 패키지가 손상되었을 수 있습니다. 즉, 패키지 데이터베이스에서 누락되었거나 종속성 중 하나가 손상되었습니다. 이 경우 이러한 패키지는 기본 패키지 세트에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="2744f509c20d0d226472161d7c5e0d680881c742" translate="yes" xml:space="preserve">
          <source>If there are no other threads to run, the runtime system will check for runnable finalizers before declaring the system to be deadlocked.</source>
          <target state="translated">실행할 다른 스레드가없는 경우 런타임 시스템은 시스템 교착 상태를 선언하기 전에 실행 가능한 종료자를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2754d33a517265ae953ce70490f5a33b97494617" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이있는 경우 ( 즉, 엔 클로징 함수에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건 이있는 경우) GHC는 기존 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 새 콜 사이트를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f4b72501bc991c36ff4bffdeb5e90240c549826c" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이있는 경우 ( 즉, 엔 클로징 함수에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건 이있는 경우) GHC는 기존 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 새 콜 사이트를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="786b9b7efbfcf460816260b5fc3891ba66319ff4" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이있는 경우 ( 즉, 엔 클로징 함수에 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건 이있는 경우) GHC는 기존 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 새 콜 사이트를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fdb2173b7203347d640f077ccdf8f741ab650cd9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;CallStack&lt;/code&gt; in scope &amp;ndash; i.e. the enclosing definition has a &lt;code&gt;HasCallStack&lt;/code&gt; constraint &amp;ndash; GHC will push the new call-site onto the existing &lt;code&gt;CallStack&lt;/code&gt;.</source>
          <target state="translated">범위에 &lt;code&gt;CallStack&lt;/code&gt; 이있는 경우 ( 즉, 엔 클로징 정의에 &lt;code&gt;HasCallStack&lt;/code&gt; 제한 조건 이있는 경우) GHC는 새 Call-site를 기존 &lt;code&gt;CallStack&lt;/code&gt; 으로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="9751e595298ec0b63212d3d3e3da71e206e9047f" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;-odir&lt;/code&gt; option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</source>
          <target state="translated">&lt;code&gt;-odir&lt;/code&gt; 옵션 (기본값) 이 없으면 접미사를 ⟨osuf⟩로 바꾸어 소스 파일 이름 (모듈 이름 무시)에서 객체 파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0459b16b546d66c267a51da320d328d26755c8cb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없는 경우 ( 예 : 위의 GHCi 세션) 엔 클로징 정의에 명시 적 유형 서명이없는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 클로징 정의에 대한 HasCallStack 제약 조건을 유추합니다 ( 단일 제한에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="51b3dd98e9cfee97be33be76a5f1ce7dc9f8f5e6" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없고 엔 클로징 정의에 명시적인 유형 서명이있는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 현재 콜 사이트 만 포함하는 싱글 톤 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 대한 HasCallStack 제약 조건을.</target>
        </trans-unit>
        <trans-unit id="1471f8828c2379e165ca2717ec8725b325f74acd" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없는 경우범위에 예 : 위의 GHCi 세션) 엔 클로징 정의에 명시 적 유형 서명이없는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 클로징 정의에 대한 HasCallStack 제약 조건을 유추합니다 ( 단일 제한에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="af5dadc898713c4d1ac69f3e2c4c1c3cd662c85a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없고 엔 클로징 정의에 명시 적 유형 서명이있는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 을 해결합니다 . 현재 콜 사이트 만 포함 하는 싱글 톤 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 대한 제약 조건을 .</target>
        </trans-unit>
        <trans-unit id="c0a2154090a11c56205c916716db23e3aaf5e97a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없는 경우범위에 예 : 위의 GHCi 세션) 엔 클로징 정의에 명시 적 유형 서명이없는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 클로징 정의에 대한 HasCallStack 제약 조건을 유추합니다 ( 단일 제한에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="ebb76c92af062244a4e188e2b7f8ad3c706df8fb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">범위에 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 이없고 엔 클로징 정의에 명시 적 유형 서명이있는 경우 GHC는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 을 해결합니다 . 현재 콜 사이트 만 포함 하는 싱글 톤 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 대한 제약 조건을 .</target>
        </trans-unit>
        <trans-unit id="c41b4ceb40ee7df7d2779d08c19440a00fd4dee9" translate="yes" xml:space="preserve">
          <source>If these instances can be defined, defining instances of the base classes is mechanical:</source>
          <target state="translated">이러한 인스턴스를 정의 할 수있는 경우 기본 클래스의 인스턴스를 정의하는 것은 기계적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a9d1a25b60758f4043441274ee9783e99a3d47e" translate="yes" xml:space="preserve">
          <source>If this flag is on, call-pattern specialisation will specialise a call &lt;code&gt;(f (Just x))&lt;/code&gt; with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</source>
          <target state="translated">이 플래그가 켜져 있으면 통화 패턴 전문화가 통화를 전문화합니다 &lt;code&gt;(f (Just x))&lt;/code&gt; 인수가 함수 본문에서 자세히 조사되지 않더라도 명시적인 생성자 인수 (f (Just x)) 을 합니다. 이것은 때때로 유익하다; 예를 들어, 인수 자체가 전문화 될 수있는 다른 함수에 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="615c1d104b752d5fbf04f2f7bfaa64a63695c34b" translate="yes" xml:space="preserve">
          <source>If true, create the semaphore if it does not yet exist.</source>
          <target state="translated">true 인 경우 세마포어가 없으면 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5726894dc0e940e30aa84621008b693bdc032ec8" translate="yes" xml:space="preserve">
          <source>If true, create the shm object if it does not exist.</source>
          <target state="translated">true 인 경우 shm 오브젝트가 없으면 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="61a6257ede23921542c050cc42cf5a60299cc751" translate="yes" xml:space="preserve">
          <source>If true, open the shm object read-write rather than read-only.</source>
          <target state="translated">참이면 shm 객체를 읽기 전용이 아니라 읽기 / 쓰기로여십시오.</target>
        </trans-unit>
        <trans-unit id="4c1c0f18f18624f27614c4ffe42965205a397757" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the semaphore already exists.</source>
          <target state="translated">true 인 경우 세마포어가 이미 존재하면 예외를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="fa803c6c609db6b79b17d1491838007497e1d827" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the shm object already exists.</source>
          <target state="translated">true 인 경우 shm 오브젝트가 이미 존재하면 예외를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="ed093df6f14d931fa3c4c256a6b87b3891dc67ba" translate="yes" xml:space="preserve">
          <source>If true, wipe the contents of the shm object after opening it.</source>
          <target state="translated">true 인 경우 shm 객체를 연 후 내용물을 닦아냅니다.</target>
        </trans-unit>
        <trans-unit id="aa3d7aa2ca27566724560024376f27197b54c353" translate="yes" xml:space="preserve">
          <source>If used in conjunction with &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;, writes dump output from main C-- pipeline stages to files (each stage per file).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 기본 C-- 파이프 라인 단계의 덤프 출력을 파일 에 기록합니다 (파일 당 각 단계).</target>
        </trans-unit>
        <trans-unit id="b399c89393340f06d26617e02a5d2db971dcd55d" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;v&lt;/code&gt; at the cursor is depended on by any earlier variable &lt;code&gt;w&lt;/code&gt;, move &lt;code&gt;v&lt;/code&gt; immediately before the leftmost such &lt;code&gt;w&lt;/code&gt;.</source>
          <target state="translated">커서의 변수 &lt;code&gt;v&lt;/code&gt; 가 이전 변수 &lt;code&gt;w&lt;/code&gt; 에 의존하는 경우 , 가장 왼쪽의 &lt;code&gt;w&lt;/code&gt; 바로 직전에 &lt;code&gt;v&lt;/code&gt; 를 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="05f59d5d88acf30508b2934ebb596d83dcf81d86" translate="yes" xml:space="preserve">
          <source>If we aren&amp;rsquo;t concerned about preserving the evaluatedness of a variable, we can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; command behaves exactly like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, except that it forces the evaluation of any thunks it encounters:</source>
          <target state="translated">변수의 평가를 보존하는 데 관심이 없다면 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; 명령은 정확히처럼 동작 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 그것이 발생하는 모든 썽크의 평가를 강제하는 것을 제외 :</target>
        </trans-unit>
        <trans-unit id="46aacca2dc2b515359c3629f8b545b4072e9cb10" translate="yes" xml:space="preserve">
          <source>If we expanded the superclasses of &lt;code&gt;C Id&lt;/code&gt; we&amp;rsquo;d get first &lt;code&gt;Id (C Id)&lt;/code&gt; and thence &lt;code&gt;C Id&lt;/code&gt; again.</source>
          <target state="translated">&lt;code&gt;C Id&lt;/code&gt; 의 수퍼 클래스를 확장하면 첫 번째 &lt;code&gt;Id (C Id)&lt;/code&gt; 를 얻은 다음 &lt;code&gt;C Id&lt;/code&gt; 를 다시 얻게 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab06f8bed3c50d147e0f34ef14e2a2bfe485f229" translate="yes" xml:space="preserve">
          <source>If we map the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; constructor, the entire list should be returned:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 생성자를 매핑하면 전체 목록이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7cadd59d96946a92a3e4e327a5bdc6e946f758a" translate="yes" xml:space="preserve">
          <source>If we need to combine multiple values we can use the &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; function to do so. We need to ensure however that we have at least one value to operate on, since otherwise our result would be undefined. It is for this reason that &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; uses &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; - a list that can never be empty:</source>
          <target state="translated">여러 값을 결합해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 그렇게 할 수 있습니다. 그러나 결과를 정의 할 수 없으므로 최소한 하나 이상의 값을 사용해야합니다. 이러한 이유로 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; 은 절대로 절대로 비어있을 수없는 목록 인 &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3467969828fd41de06ba2ada1d51483a9746f64f" translate="yes" xml:space="preserve">
          <source>If we now load a file into GHCi, the prompt will change:</source>
          <target state="translated">이제 파일을 GHCi에로드하면 프롬프트가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="63f9b336b3695cb29c6493fac4402515a8e4d030" translate="yes" xml:space="preserve">
          <source>If we now modify the source of &lt;code&gt;D&lt;/code&gt; (or pretend to: using the Unix command &lt;code&gt;touch&lt;/code&gt; on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</source>
          <target state="translated">이제 &lt;code&gt;D&lt;/code&gt; 의 소스를 수정 하거나 소스 파일 에서 Unix 명령 &lt;code&gt;touch&lt;/code&gt; 를 사용하는 것이 가장 편리하다고 가정하면 컴파일러는 더 이상 객체 파일을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="56aef672862bfcd7939d7f244a055f2611b773c3" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like</source>
          <target state="translated">예 (기본값) 인 경우 RTS는 다음과 같은 것을 포착하기 위해 신호 처리기를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="b556699afcea8a3861c7bd49d57539e01604beee" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like &lt;code&gt;Ctrl-C&lt;/code&gt;. This option is primarily useful for when you are using the Haskell code as a DLL, and want to set your own signal handlers.</source>
          <target state="translated">예인 경우 (기본값) RTS는 &lt;code&gt;Ctrl-C&lt;/code&gt; 와 같은 것을 포착하기 위해 신호 처리기를 설치합니다. . 이 옵션은 Haskell 코드를 DLL로 사용하고 자체 신호 처리기를 설정하려는 경우 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1824a09e94a9e0974a32536579d942e06a534b49" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on errors such as segfaults.</source>
          <target state="translated">예 (기본값) 인 경우 Windows의 RTS는 Windows 예외 처리 메커니즘을 사용하여 처리되지 않은 예외를 포착하기 위해 예외 처리기를 설치합니다. 이 옵션은 주로 Haskell 코드를 DLL로 사용하고 segfault와 같은 오류가 발생했을 때 RTS가 응용 프로그램을 비정상적으로 종료하지 않도록하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f47cebe51b03f623c16d891f461a3756b2773fce" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on erros such as segfaults.</source>
          <target state="translated">예인 경우 (기본값) Windows의 RTS는 예외 처리기를 설치하여 Windows 예외 처리 메커니즘을 사용하여 처리되지 않은 예외를 포착합니다. 이 옵션은 주로 Haskell 코드를 DLL로 사용하고 RTS가 segfaults와 같은 오류로 인해 응용 프로그램을 부적절하게 종료하지 않기를 원할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="862def3a23c265087b17b9a922955600a2924ede" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">예인 경우 (기본값) Windows의 RTS는 충돌시 코어 덤프를 생성합니다. 이러한 덤프는 WinDBG와 같은 디버거를 사용하여 검사 할 수 있습니다. 덤프는 충돌시 모든 코드, 레지스터 및 스레딩 정보를 기록합니다. 이것은 &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt; 를 의미 합니다. .</target>
        </trans-unit>
        <trans-unit id="3e635d9c8063789e49ab24dcfcbdf9f3659eb237" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">예 (기본값) 인 경우 Windows의 RTS는 충돌시 코어 덤프를 생성합니다. 이러한 덤프는 WinDBG와 같은 디버거를 사용하여 검사 할 수 있습니다. 덤프는 충돌 당시 모든 코드, 레지스터 및 스레딩 정보를 기록합니다. 이것은 &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="babf43c52d9b937cdcace43cdc2f276acdb87956" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a stack trace on crashes if exception handling are enabled. In order to get more information in compiled executables, C code or DLLs symbols need to be available.</source>
          <target state="translated">예인 경우 (기본값) 예외 처리가 활성화 된 경우 Windows의 RTS는 충돌시 스택 추적을 생성합니다. 컴파일 된 실행 파일에 대한 자세한 정보를 얻으려면 C 코드 또는 DLL 기호를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="75dc4a8f44681567411c7cc8c3553fb7e90b3d1c" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt;.</source>
          <target state="translated">명령 행의 나머지 모든 옵션이 프로그램으로 이동하고 RTS가 아닌 프로그램으로 이동하려면 &lt;code&gt;--RTS&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eb60052601f4a3531e65c7d5067016decf78928" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="translated">&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 도 사용하는 경우 하는 경우 형식 동의어로 unboxed 튜플을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="705b934efdf6451c14bd14b83d658533f8914cf9" translate="yes" xml:space="preserve">
          <source>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it&amp;rsquo;s important that the program it compiles produces results whose representations are identical to those of the compiler itself.</source>
          <target state="translated">소스에서 GHC를 빌드하는 경우 템플릿 Haskell 스플 라이스 및 준 따옴표를 실행하려면 적어도 2 단계 부트 스트랩 컴파일러가 필요합니다. 1 단계 컴파일러는 Haskell의 정규 인용 만 허용합니다. 이유 : TH 스플 라이스 및 준 따옴표는 프로그램을 컴파일하고 실행 한 다음 결과를 봅니다. 따라서 컴파일하는 프로그램이 컴파일러 자체의 표현과 동일한 표현을 갖는 결과를 생성하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="969473549eb7eda775de0bbd5b7e1c35fe2a3fe0" translate="yes" xml:space="preserve">
          <source>If you are down to your last-compile-before-a-bug-report, we would recommend that you add a &lt;code&gt;-dcore-lint&lt;/code&gt; option (for extra checking) to your compilation options.</source>
          <target state="translated">마지막으로 컴파일 전 버그 리포트를보고있는 경우 컴파일 옵션에 &lt;code&gt;-dcore-lint&lt;/code&gt; 옵션 (추가 검사 용)을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8db781218acb5f2994b23e09a56675a86f2ceeb8" translate="yes" xml:space="preserve">
          <source>If you are hit by this, you may want to compile the affected module with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fno-omit-yields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;). This flag ensures that yield points are inserted at every function entrypoint (at the expense of a bit of performance).</source>
          <target state="translated">이 문제가 발생하면 영향을받는 모듈을 &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fno-omit-yields&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다 ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : 플랫폼 독립적 플래그 참조&lt;/a&gt; ). 이 플래그는 모든 기능 진입 점에 약간의 성능을 희생하면서 항복점이 삽입되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ee2cd5fd786322ce97e57aaf58e15a0f10e358b1" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="translated">여러 Haskell 스레드에서 외래 전화를 걸고 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 호출하는 외래 코드가 스레드로부터 안전해야합니다. 특히 일부 GUI 라이브러리는 스레드로부터 안전하지 않으므로 호출자는 단일 스레드에서만 GUI 메소드를 호출해야합니다. 이 경우 GUI 작업을 단일 Haskell 스레드로 제한하고 바운드 스레드를 사용해야 할 수도 있습니다 ( &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;Haskell 스레드와 OS 스레드 간의 관계&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a3cb86bb37d550f99fb107d358e09f2ff4997d45" translate="yes" xml:space="preserve">
          <source>If you are setting language options in your &lt;code&gt;.ghci&lt;/code&gt; file, it is good practice to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, unless you really do want them to apply to all modules you load in GHCi.</source>
          <target state="translated">&lt;code&gt;.ghci&lt;/code&gt; 파일 에서 언어 옵션을 설정하는 경우 GHCi에 로드하는 모든 모듈에 실제로 적용하지 않으려면 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2780984904c2d880871374ff9ccab143b480b0b2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 키를, 당신이 사용하는 대부분의 작업을위한 더 나은 성능을 얻을 것이다 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b97f8aaadda196835b4af2ea1886f79e9ad8ac0e" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 키를, 당신이 사용하는 대부분의 작업을위한 더 나은 성능을 얻을 것이다 &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1f508d47e724e488b898fb6b5424ab4c2ea295" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 키를, 당신이 사용하는 대부분의 작업을위한 더 나은 성능을 얻을 것이다 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14f369071627bc2e08352734351733171bc0451" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 키를, 당신이 사용하는 대부분의 작업을위한 더 나은 성능을 얻을 것이다 &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f294dc39561bb7510ab182cdc6070d0d208bd977" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;make&lt;/code&gt;, GHC can automatically generate the dependencies required in order to make sure that every module &lt;em&gt;is&lt;/em&gt; up-to-date with respect to its imported interfaces. Please see &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;make&lt;/code&gt; , GHC는 자동으로 모든 모듈이 있는지 확인하기 위해 필요한 종속성을 생성 할 수 &lt;em&gt;있습니다&lt;/em&gt; 수입 된 인터페이스에 대한 최신 상태를. &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;종속성 생성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64df0960b34991e4d85de84eb1668ccd834d0e6f" translate="yes" xml:space="preserve">
          <source>If you are using a Haskell &amp;ldquo;package&amp;rdquo; (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;), don&amp;rsquo;t forget to add the relevant &lt;code&gt;-package&lt;/code&gt; option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the &lt;code&gt;-package&lt;/code&gt; option will likely result in several pages of link errors.</source>
          <target state="translated">당신이 하스켈 &quot;패키지&quot;(참조 사용하는 경우 &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; ) 관련 추가하는 것을 잊지 마세요 &lt;code&gt;-package&lt;/code&gt; 도 프로그램을 연결 옵션을 : 그것은 적절한 라이브러리가 프로그램에 연결되게합니다. &lt;code&gt;-package&lt;/code&gt; 옵션을 잊어 버리면 여러 페이지의 링크 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b7cc346da82320cb12d47cf0a63adf255287f4d" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkdtemp glibc function (supported in glibc &amp;gt; 2.1.91) then this function uses mktemp and so shouldn't be considered safe.</source>
          <target state="translated">mkdtemp glibc 기능을 지원하지 않는 시스템으로 사용하는 경우 (glibc&amp;gt; 2.1.91에서 지원)이 기능은 mktemp를 사용하므로 안전하지 않은 것으로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="755c446ad00dee715ae6a725a7e54ef9a2b3bb98" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkstemps glibc function (supported in glibc &amp;gt; 2.11) then this function simply throws an error.</source>
          <target state="translated">mkstemps glibc 기능 (glibc&amp;gt; 2.11에서 지원)을 지원하지 않는 시스템으로 사용하는 경우이 기능은 단순히 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="40ce0801a711815e8a0985a07d3d4a08fee712a7" translate="yes" xml:space="preserve">
          <source>If you are using external packages with &lt;strong&gt;cabal&lt;/strong&gt;, you may need to reinstall these packages with profiling support; typically this is done with &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;cabal&lt;/strong&gt; 과 함께 외부 패키지를 사용하는 경우 프로파일 링 지원으로 이러한 패키지를 다시 설치해야 할 수 있습니다. 일반적으로 &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt; 로 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="449e0cceb9882f742ae4ba71b581c42c65c1bc09" translate="yes" xml:space="preserve">
          <source>If you aren't using GHC or Hugs then this function simply wraps mktemp and so shouldn't be considered safe.</source>
          <target state="translated">GHC 또는 Hugs를 사용하지 않는 경우이 함수는 단순히 mktemp를 래핑하므로 안전하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c57e71626bccca627c9de3e0d23513402fbfad64" translate="yes" xml:space="preserve">
          <source>If you can't be bothered with the above, then you can build simple tables with simpleTable. Just provide the attributes for the whole table, attributes for the cells (same for every cell), and a list of lists of cell contents, and this function will build the table for you. It does presume that all the lists are non-empty, and there is at least one list.</source>
          <target state="translated">위와 같이 귀찮게 할 수 없다면 simpleTable로 간단한 테이블을 만들 수 있습니다. 전체 테이블에 대한 속성, 셀에 대한 속성 (모든 셀에 동일) 및 셀 내용 목록을 제공하면이 기능이 테이블을 생성합니다. 모든 목록이 비어 있지 않고 하나 이상의 목록이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7c1274d2d2a7e0ba4a2c783c4ef67e9c677accd2" translate="yes" xml:space="preserve">
          <source>If you do not have an explicit export list in a module, GHC must assume that everything in that module will be exported. This has various pessimising effects. For example, if a bit of code is actually &lt;em&gt;unused&lt;/em&gt; (perhaps because of unfolding effects), GHC will not be able to throw it away, because it is exported and some other module may be relying on its existence.</source>
          <target state="translated">모듈에 명시 적 내보내기 목록이없는 경우 GHC는 해당 모듈의 모든 항목을 내보내는 것으로 가정해야합니다. 여기에는 다양한 비관 효과가 있습니다. 예를 들어, 약간의 코드가 실제로 &lt;em&gt;사용되지 않는 경우&lt;/em&gt; (아마도 펼치기 효과로 인해) GHC는 코드를 내 보내지 않고 다른 모듈이 그 존재에 의존하기 때문에 버릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a1ecd7c0b5ed67d9ee213cf7d0666e703994546" translate="yes" xml:space="preserve">
          <source>If you do not need the offset parameter then you do should be using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">오프셋 매개 변수가 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; 를 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dacf0556d43b3d2afe433d11b8b9c360f1380a6b" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="translated">생성자를 작성하지 않으면 GHC에 유형 변수의 종류 ( &quot;*&quot;가 아닌 경우)를 알리기 위해 종류 주석 ( &lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt; ) 을 제공해야합니다 . (소스 파일에서는 생성자에서 type 변수가 사용되는 방식으로 해결됩니다.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4308cfa9bfacb8d98d2c6bb15e1dd09df45e6181" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default &lt;code&gt;*&lt;/code&gt;. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to &lt;a href=&quot;#runtime-rep&quot;&gt;run-time representation polymorphism&lt;/a&gt;), as in this example:</source>
          <target state="translated">당신이 생성자를 작성하지 않는 경우, 당신은 기본이 아닌 경우 형태 변수의 종류가 무엇인지 GHC을 알려주는 일종의 제공해야 할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 을 . 일반 데이터 유형 선언과는 달리, 추상적 인 데이터 선언의 반환 종류는 무엇이든 될 수있다 (아마 타입 동의어를 사용하여 구현 될 경우입니다.) 반대로이 (컴파일 시간 표현의 다형성을 허용 할 수 있습니다 &lt;a href=&quot;#runtime-rep&quot;&gt;런타임&lt;/a&gt; 이 예에서와 같이 표현 다형성 ) :</target>
        </trans-unit>
        <trans-unit id="00d8e4e35d4f313452afad0626c5a13b4457d20a" translate="yes" xml:space="preserve">
          <source>If you do want custom history behavior, you may need to disable the above default setting(s).</source>
          <target state="translated">사용자 지정 기록 동작을 원하는 경우 위의 기본 설정을 비활성화해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92f00276e7b4844202319651693a66141bcfc09" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it&amp;hellip; unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">당신이없는 경우 &lt;code&gt;cygpath&lt;/code&gt; 를 여러 플랫폼에 대해 하나 개의 빌드 프로세스를 쓰고 싶어하지 않는 한, 당신은 아마 ... 그것 때문에 아무런 문제가 Cygwin에서이 없어요. 다시 말하지만, 상대 경로는 친구이지만 절대 경로를 사용해야하고 다른 플랫폼에서 다른 도구를 사용하고 싶지 않다면 현재 디렉토리를 인쇄하는 짧은 Haskell 프로그램을 작성하기 만하면됩니다 (George Russell에게 감사드립니다). 아이디어) : GHC로 컴파일하면 GHC가 의존하는 파일 시스템에 대한보기를 제공합니다 (GHC가 cygwin의 gcc 또는 mingw의 gcc로 컴파일되었는지 또는 실제 Unix 시스템에서 컴파일되는지에 따라 다릅니다 ..)-그 작은 프로그램 경로에서 &lt;code&gt;\\&lt;/code&gt; 이스케이프 처리 할 수도 있습니다 . 배너 및 시작 시간 외에도 다음과 같은 작업도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dbfd1c6f422cd2cb2dbbb7fda57624d1324776cf" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it... unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">&lt;code&gt;cygpath&lt;/code&gt; 가 없다면 여러 플랫폼에 대해 하나의 빌드 프로세스를 작성하지 않는 한 cygwin이 없으므로 문제가 없을 것입니다. 다시 말하지만 상대 경로는 친구이지만 절대 경로를 사용해야하고 다른 플랫폼에서 다른 도구를 사용하지 않으려면 간단한 Haskell 프로그램을 작성하여 현재 디렉토리를 인쇄 할 수 있습니다 (George Russell에게 감사드립니다) idea) : GHC로 컴파일하면 GHC가 의존하는 파일 시스템을 볼 수 있습니다 (GHC가 cygwin의 gcc 또는 mingw의 gcc로 컴파일되었는지 또는 실제 유닉스 시스템에서 컴파일되는지에 따라 다릅니다). 경로에서 &lt;code&gt;\\&lt;/code&gt; 이스케이프 처리 할 수도 있습니다 . 배너 및 시작 시간 외에도 다음과 같은 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ca8436639b62f991d1a8bca7a44877f0eba7f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know what virtual memory, thrashing, and page faults are, or you don&amp;rsquo;t know the memory configuration of your machine, &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; try to be clever about memory use: you&amp;rsquo;ll just make your life a misery (and for other people, too, probably).</source>
          <target state="translated">가상 메모리, 스 래싱 및 페이지 오류가 무엇인지 모르거나 컴퓨터의 메모리 구성을 모르는 경우 메모리 사용에 대해 영리하려고 &lt;em&gt;하지 마십시오&lt;/em&gt; . 삶을 불행하게 만들 것입니다. (그리고 아마도 다른 사람들에게도).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
