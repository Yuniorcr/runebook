<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d84ebfc6fbaa58496dbe73b158b5610e0f005524" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="156fd7ebd73ad9d7d9ba6f146870be0be3263cef" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="4240c3ab8260bb583d13050ed2064bbaae7bc43b" translate="yes" xml:space="preserve">
          <source>Make the interface loader be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">인터페이스 로더 가 최신 상태에 대해 &lt;em&gt;실제&lt;/em&gt; 대화가되게하십시오.</target>
        </trans-unit>
        <trans-unit id="4358699704291b8174b75e1e492414b400dba246" translate="yes" xml:space="preserve">
          <source>Make the pattern match exhaustiveness checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">패턴 일치 철저 검사기 는 그것이 무엇인지에 대해 &lt;em&gt;진정한&lt;/em&gt; 대화가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="d42a1e2a4e6f039639430d0f8ec96b5efe794a51" translate="yes" xml:space="preserve">
          <source>Make the renamer be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">이름 바꾸기가 될 수 있도록 &lt;em&gt;실제&lt;/em&gt; 는 최대 무엇인지에 대해 수다.</target>
        </trans-unit>
        <trans-unit id="8cd12a9927ea510906e14322831e59cfe0a4baca" translate="yes" xml:space="preserve">
          <source>Make the type checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">타입 체커 는 그것이 무엇인지에 대해 &lt;em&gt;진정한&lt;/em&gt; 대화가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="15d9abd622590033f2c411d33953dd776c5be50c" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 개체에 대한 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 첫 번째 인수로 전달 된 객체는 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 에 의해 평가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c12968a0552ecdcf1b9de9b4f5c5bede7e5bbb53" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 개체에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 첫 번째 인수로 전달 된 객체는 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 에 의해 평가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aa32c2b4fd707872dac37cc6dbc8a7e855f28d02" translate="yes" xml:space="preserve">
          <source>Makes a binary Handle. This is for historical reasons; it should probably be a text Handle with the default encoding and newline translation instead.</source>
          <target state="translated">이진 핸들을 만듭니다. 이것은 역사적인 이유로 인한 것입니다. 대신 기본 인코딩 및 줄 바꿈 변환이 포함 된 텍스트 핸들이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e61217ddb45f4a69f77fed47cefb695ba63354" translate="yes" xml:space="preserve">
          <source>Makes a constructor for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 의 생성자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="675f8bacbe562ad639f450df630ba3e1d4142613" translate="yes" xml:space="preserve">
          <source>Makes a pointer to a field struct. It will have the type &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt;.</source>
          <target state="translated">필드 구조체에 대한 포인터를 만듭니다. 유형은 &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15d722c20f3a7b347acb5b13726b5fa9b1a3a525" translate="yes" xml:space="preserve">
          <source>Makes a specific warning into a fatal error. The warning will be enabled if it hasn&amp;rsquo;t been enabled yet. Can be reversed with &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">치명적인 오류로 특정 경고를 표시합니다. 아직 활성화되지 않은 경우 경고가 활성화됩니다. &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b11cc1ed06b4ae510e6c368934b3332b8443ad9c" translate="yes" xml:space="preserve">
          <source>Makes any warning into a fatal error. Useful so that you don&amp;rsquo;t miss warnings when doing batch compilation. To reverse &lt;code&gt;-Werror&lt;/code&gt; and stop treating any warnings as errors use &lt;code&gt;-Wwarn&lt;/code&gt;, or use &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; to stop treating specific warnings as errors.</source>
          <target state="translated">치명적인 오류로 경고합니다. 배치 컴파일을 수행 할 때 경고를 놓치지 않도록 유용합니다. &lt;code&gt;-Werror&lt;/code&gt; 를 되돌리고 오류로 경고 처리를 중지하려면 &lt;code&gt;-Wwarn&lt;/code&gt; 을 사용하거나 &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 를 사용하여 특정 경고를 오류로 처리하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="bbf1ed151ae759b693edba02d868a0ae08a8295e" translate="yes" xml:space="preserve">
          <source>Makes the second handle a duplicate of the first handle. The second handle will be closed first, if it is not already.</source>
          <target state="translated">두 번째 핸들을 첫 번째 핸들의 복제본으로 만듭니다. 두 번째 핸들이 아직 닫히면 먼저 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="610ca9a4f461051b57571e94ee46024ad1945482" translate="yes" xml:space="preserve">
          <source>Making functors whose elements are notionally in the reverse order from the original functor.</source>
          <target state="translated">원래 functor와 개념적으로 역순으로 요소가있는 functors 만들기.</target>
        </trans-unit>
        <trans-unit id="de10c11c39a04c2dd93935591757ad821f0de619" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스로 functors 만들기</target>
        </trans-unit>
        <trans-unit id="289b3ce3f004eadb698cbe23952c8692f75647d6" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스로 펑터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="316f89b1fd653898886f6125de784c38a5ec08fb" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스로 펑터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="155fd1571bb064a261bef3cb9235ad72ee317621" translate="yes" xml:space="preserve">
          <source>Malloc some data and return a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; to it</source>
          <target state="translated">Malloc 일부 데이터 및 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; 을 반환</target>
        </trans-unit>
        <trans-unit id="357e8ecf448ec27f6c58902a75153131236e9618" translate="yes" xml:space="preserve">
          <source>Manage separate memory pools for each node.</source>
          <target state="translated">각 노드에 대해 별도의 메모리 풀을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="27a837f8eed8146ea6300d174b2ba753bef518d3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">조작 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 사용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 작업을. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 과 동일한 속도로 실행될 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8d02698e3a7db40c93071ad0130d603170bdbf3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b134cb33755b44d8cb28b21abf1877659563685" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f6f1aebfb4c2d76356eff64760ef8d083e1ea9b" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;em&gt;lazy &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 과 동일한 속도로 실행될 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="0938573170c5ad64ab547628da8f4334a36723ce" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;em&gt;게으른 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="847ea03503ee75bf6cb87556d6d49608481050a3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;em&gt;게으른 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21b2945c3b95e9ba030912e565f7997d2afceb6a" translate="yes" xml:space="preserve">
          <source>Many codecs are not stateful, and in these case the state can be represented as &lt;code&gt;()&lt;/code&gt;. Other codecs maintain a state. For example, UTF-16 recognises a BOM (byte-order-mark) character at the beginning of the input, and remembers thereafter whether to use big-endian or little-endian mode. In this case, the state of the codec would include two pieces of information: whether we are at the beginning of the stream (the BOM only occurs at the beginning), and if not, whether to use the big or little-endian encoding.</source>
          <target state="translated">많은 코덱은 상태 저장이 아니며이 경우 상태는 &lt;code&gt;()&lt;/code&gt; 로 표현 될 수 있습니다 . 다른 코덱은 상태를 유지합니다. 예를 들어 UTF-16은 입력 시작시 BOM (바이트 순서 표시) 문자를 인식 한 후 빅 엔디안 모드 또는 리틀 엔디안 모드를 사용할지 기억합니다. 이 경우 코덱 상태에는 두 가지 정보가 포함됩니다. 즉, 스트림의 시작 위치에 있는지 (BOM은 시작 부분에만 발생), 그렇지 않은 경우에는 빅 엔디안 또는 리틀 엔디안 인코딩을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="24d0ab19e4e99147773dbcbe9263cdf0c945a575" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List의&lt;/a&gt; 함수와 이름이 같습니다 . 거의 모든 경우에 이러한 기능은 유사하게 작동합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 그 동일하게 시퀀스를 필터링 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 목록을 필터링합니다. 유일한 주요 예외는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 함수입니다.이 함수 는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 의 이름이 아니라 &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap의&lt;/a&gt; 해당 이름에 따른 함수를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c62b5fa473677017f2721ca5795d98e992c22e65" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List의&lt;/a&gt; 함수와 이름이 같습니다 . 거의 모든 경우에 이러한 기능은 유사하게 작동합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 와 똑같은 방식으로 시퀀스를 필터링합니다 . 필터 는 목록을 필터링합니다. 유일한 주요 예외는 &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; 의 이름이 아닌 &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap의&lt;/a&gt; 해당 이름의 함수를 기반으로 하는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="32ed30cfd1996dd6a729e9c45a8bc70a6cf0b6f3" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.15.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.15.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.15.0.0/data-list&quot;&gt;Data.List의&lt;/a&gt; 함수와 이름이 같습니다 . 거의 모든 경우에 이러한 기능은 유사하게 작동합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.15.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 와 똑같은 방식으로 시퀀스를 필터링합니다 . 필터 는 목록을 필터링합니다. 유일한 주요 예외는 &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 의 이름이 아닌 &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap의&lt;/a&gt; 해당 이름의 함수를 기반으로 하는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="e8f58e0bdebbef9653cf1bc7b5100f112ff0653f" translate="yes" xml:space="preserve">
          <source>Many instances of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; (e.g. the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; instance) are conditionally lazy, and use or don't use their second argument depending on the value of the first. These are used with the folds below, which terminate as early as possible, but otherwise generally keep going. Some instances (e.g. for List) are always strict, but the result is lazy in the tail of the output, so that &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; for a list of lists is in fact corecursive. These folds are defined in terms of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">많은 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 인스턴스 (예 : &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 인스턴스)는 조건부로 게으르고 첫 번째 값에 따라 두 번째 인수를 사용하거나 사용하지 않습니다. 이들은 가능한 한 빨리 종료되지만 일반적으로 계속 진행되는 아래의 폴드와 함께 사용됩니다. 일부 인스턴스 (예 : List)는 항상 엄격하지만 결과는 출력의 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 에서 게으 르기 때문에 목록 목록에 대한 asum은 실제로 핵심어입니다. 이러한 접기는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="a54ffbaf5c6091b870718ed3779391643593140a" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">많은 작업이 최악의 경우 O (min (n, W))의 복잡성을 갖습니다. 이는 최대 &lt;em&gt;W를&lt;/em&gt; 가진 요소 수에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수로 작업이 선형화 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="98a01da62d47f087f540e76f8d5b26b5e49b62ce" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">대부분의 작업은 최악의 경우 복잡성이 O (min (n, W))입니다. 이는 연산이 최대 &lt;em&gt;W&lt;/em&gt; 인 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수인 요소 수에서 선형이 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="9acf6964d94c05eea3598cac6c4c82a9ac869d16" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">많은 작업의 경우 최악의 복잡성이 O (min (n, W))입니다. 이는 연산이 최대 &lt;em&gt;W&lt;/em&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수) 인 요소 수에서 선형이 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="9eaadd708e5d269baf72848cf514c6218e594037" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;'\r\n'&lt;/code&gt; into &lt;code&gt;'\n'&lt;/code&gt; on input, and &lt;code&gt;'\n'&lt;/code&gt; to the native newline representation on output. This mode can be used on any platform, and works with text files using any newline convention. The downside is that &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; might yield a different file.</source>
          <target state="translated">입력시 &lt;code&gt;'\r\n'&lt;/code&gt; 을 &lt;code&gt;'\n'&lt;/code&gt; 에 매핑 하고 출력시 기본 줄 바꿈 표현에 &lt;code&gt;'\n'&lt;/code&gt; 을 매핑 합니다. 이 모드는 모든 플랫폼에서 사용할 수 있으며 모든 줄 바꿈 규칙을 사용하여 텍스트 파일과 함께 작동합니다. 단점은 &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; 이 다른 파일을 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b7b80f10f3a81cda5d3d90fed79ebb948d0265b" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;'\r\n'&lt;/code&gt; into &lt;code&gt;'\n'&lt;/code&gt; on input, and &lt;code&gt;'\n'&lt;/code&gt; to the native newline represetnation on output. This mode can be used on any platform, and works with text files using any newline convention. The downside is that &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; might yield a different file.</source>
          <target state="translated">지도 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 입력에, 그리고 &lt;code&gt;'\n'&lt;/code&gt; 출력의 기본 개행 represetnation에. 이 모드는 모든 플랫폼에서 사용할 수 있으며 모든 줄 바꿈 규칙을 사용하여 텍스트 파일과 함께 작동합니다. 단점은 &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; 이 다른 파일을 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d55454f009aa8f95f75c772db0fb5ae0e9a9272" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">지도 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d73f39524fe5ef1af56ec8e22806ecc515086be" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">지도 &lt;code&gt;m2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9983700cca6f292aa903742f89b52d541c8d933e" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; - safe 값에 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="18e38d5e5d89b044de0e37bb9b26db6369ce574d" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 안전 값에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="e654d2c2aeead91ee951837f20bb89e6b191fd36" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 안전 값에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="0766fa419be24fb2dc55e7497743d52826668e62" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="15035b59f86fdfce06c5503b47c04b11e811e80d" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="b46e7ebb5140a1447b3c89113a3d9ae22bb0b79b" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="6903ae5c580a3f2ab80be5d8534af3c46567f965" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="9f9558286be8174c824362eb946ace711872dbf8" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; stream.</source>
          <target state="translated">비 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 스트림에 함수를 맵핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="21fd99a4595253dffd079844b719d83735a7905f" translate="yes" xml:space="preserve">
          <source>Map a function over a list and concatenate the results.</source>
          <target state="translated">함수를 목록에 매핑하고 결과를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="9800e72be66dc6c45d2ad289e20ef1a9a51d98ad" translate="yes" xml:space="preserve">
          <source>Map a function over a stream that results in a stream and concatenate the results.</source>
          <target state="translated">스트림을 생성하는 함수를 스트림에 맵핑하고 결과를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="ad689681c3a3649d48f9aaad672101632605a134" translate="yes" xml:space="preserve">
          <source>Map a function over all the elements of a container and concatenate the resulting lists.</source>
          <target state="translated">컨테이너의 모든 요소에 함수를 맵핑하고 결과 목록을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="552e1bebb738ef9f96de04d70a982bb350a641c3" translate="yes" xml:space="preserve">
          <source>Map a function returning a list over a list and concatenate the results. &lt;code&gt;&lt;a href=&quot;ghc-list#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; can be seen as the composition of &lt;code&gt;&lt;a href=&quot;ghc-list#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록 위에 목록을 반환하는 함수를 매핑하고 결과를 연결합니다. &lt;code&gt;&lt;a href=&quot;ghc-list#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-list#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 의 구성으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06fff69e6935c5ce977d35f21f04166c5be20d3c" translate="yes" xml:space="preserve">
          <source>Map a function returning a list over a list and concatenate the results. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; can be seen as the composition of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">목록 위에 목록을 반환하는 함수를 매핑하고 결과를 연결합니다. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 의 구성으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a8247db8adfeefa619b1655afff9beae6787d09" translate="yes" xml:space="preserve">
          <source>Map a user interaction by modifying the base monad computation.</source>
          <target state="translated">기본 모나드 계산을 수정하여 사용자 상호 작용을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="7edbce9966aa6d05b4981154c3d88123653a0c5d" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 계산 사이를 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="712af23920428aa8ce829c6c9a926052d19c882a" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 계산 사이를 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="45e2cd283ebb4c611280d82cee74660fbe85bf94" translate="yes" xml:space="preserve">
          <source>Map both the return value and final state of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 반환 값과 계산의 최종 상태를 모두 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="4273e77ff1728ba48d1f840696e743d1da1ee755" translate="yes" xml:space="preserve">
          <source>Map both the return value and output of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 계산의 반환 값과 출력을 모두 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="803e1322fde156db8cc3128774fd2f8d4c99abec" translate="yes" xml:space="preserve">
          <source>Map capabilities to NUMA nodes. Capability C is mapped to NUMA node C mod N.</source>
          <target state="translated">기능을 NUMA 노드에 맵핑하십시오. 기능 C는 NUMA 노드 C mod N에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="21de922b618d81f2e317aafc9cbebc99176766bc" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="aa119e405295642a5bcf3b77b05b9cefc544c124" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="7245e811517b83cae4b9adf19d8a5924072530a7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="09e23d7bb6cd983f23a248d179ee216a8f59e394" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="2569c1d7ccbe6013b4e6c78fb8e786a9a6095e76" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt; 위에 반항적으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="a14103f7c1f26a2fcbb71bbe285a99bdcde54ff7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="a8eb552837e87415b9d4df127dcd174fef924114" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt;.</source>
          <target state="translated">이상 covariantly지도 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bcbb877a60019cf521e9ab67aa98b003657bfd" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt; 에 대해 공변량으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="b9d6ab9d11a41a76d9162b3143fae97f6b16f455" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="3f706796547b811fccb9bd7e5484d305853862eb" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="80246f23eba01c63a2b57d2f1b0b002711c39d9f" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="a5cd585d64a0c1fc4c937dd0ee8ee4b052b09370" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="ce99df6d5a6c7da2f980fb998d55fe0e027d1fd2" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="2de75aa8ae3777dc3c106e78b70228d497cabfb4" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="1414775fb27f647a11edd9afbabc9f1f96d002c5" translate="yes" xml:space="preserve">
          <source>Map covariantly over the first argument.</source>
          <target state="translated">첫 번째 인수에 대해 공변량으로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="d189acaf26502066081e31e150c1693816dae853" translate="yes" xml:space="preserve">
          <source>Map covariantly over the second argument.</source>
          <target state="translated">두 번째 인수에 대해 공변량으로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="66f098667a15e2db24bb8373340e33eb8b6f8853" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나드 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 수집합니다. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3b66d8ea2cb272c74911fcfbdc7cf4ca77953fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나 딕 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가 한 후 결과를 수집합니다. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9faa2d5ff3705c067b9b5226876c908059a5fa59" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나드 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 수집합니다. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02dfb7e92c38e4214d51e2b9595047ff1b8f9b31" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나 딕 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbfeb99bf3039f3b9bd94716be1697f7c672a217" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업에 매핑하고 이러한 작업을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e288a8969f8edd9a984979987138d0017375a217" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업에 매핑하고 이러한 작업을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29efd3765dfabc72142232cb82d864034ee72729" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 수집하십시오. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d22dd22b104dd621f77d9d5650ccd532318e02da" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 무시하십시오. 결과를 무시하지 않는 버전의 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43e6de6decbbed7c2a5b1c6751631f378ba334b2" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 작업에 매핑하고 이러한 작업을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4417d32b4f323c831d7b4ced61e67f600e01b3fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 무시하십시오. 결과를 무시하지 않는 버전의 경우 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c124d6dfa5bddefa553c4516b6211d2cf0661762" translate="yes" xml:space="preserve">
          <source>Map each element of a structure using one of two actions, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 동작 중 하나를 사용하여 구조의 각 요소를 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가 한 다음 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="539eacbc27d41b07bf8575009d83f8bccfbf1214" translate="yes" xml:space="preserve">
          <source>Map each element of the structure into a monoid, and combine the results with &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt;. This fold is right-associative and lazy in the accumulator. For strict left-associative folds consider &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead.</source>
          <target state="translated">구조의 각 요소를 모노 이드로 매핑하고 결과를 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 로 결합합니다 . 이 접기는 누산기에서 오른쪽 연관성이며 게으른 것입니다. 엄격한 왼쪽 연관 폴드의 경우 대신 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa8b74f971e12062a8ab201e009a282f51b7016" translate="yes" xml:space="preserve">
          <source>Map each element of the structure into a monoid, and combine the results with &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt;. This fold is right-associative and lazy in the accumulator. For strict left-associative folds consider &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead.</source>
          <target state="translated">구조의 각 요소를 모노 이드로 매핑하고 결과를 &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 로 결합합니다 . 이 접기는 누산기에서 오른쪽 연관성이며 게으른 것입니다. 엄격한 왼쪽 연관 폴드의 경우 대신 &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e14cd9471b9b06b4f5f3069e4de360f95948a3" translate="yes" xml:space="preserve">
          <source>Map each element of the structure to a monoid, and combine the results.</source>
          <target state="translated">구조의 각 요소를 단일체에 맵핑하고 결과를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="cb44df1644994b6e9bedbd4295f2ba757e01b134" translate="yes" xml:space="preserve">
          <source>Map leap-second values to the start of the following second. The resulting &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; will always be in the range 0 to 1E9-1.</source>
          <target state="translated">윤초 값을 다음 초의 시작 부분에 매핑합니다. 결과 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; 는 항상 0에서 1E9-1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="f67b9485e617340983ccecc0a0a8ab8a5398d3f1" translate="yes" xml:space="preserve">
          <source>Map over both arguments at the same time.</source>
          <target state="translated">두 인수를 동시에 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="820bfb2b876cadb7ba21577ea1191e745febb6e2" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="042a8e608fdbf1be1815be0ba68d9d8129c0d45e" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7446b734119c67e4a15eea3901f43f333f1d45b7" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f20f45f5901d5da69a8a8bd25afdefdf94fb0463" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="27b9407877fd74e4c60e5bb3f11429e5468cc32d" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="4972444ee92a42eeb10783a738cee55cc20ccb73" translate="yes" xml:space="preserve">
          <source>Map the inner computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 내부 계산을 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="f01bd56150a44e5c1e36c99b2ce32a4952f1afda" translate="yes" xml:space="preserve">
          <source>Map the return value, final state and output of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 반환 값, 최종 상태 및 계산 결과를 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="611b5e106ea059979f2f1779bbc5d5819342b37e" translate="yes" xml:space="preserve">
          <source>Map the unwrapped computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 래핑되지 않은 계산을 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="9a3aa11de5ca9a6bdbea1dfb4fae341156bcff0a" translate="yes" xml:space="preserve">
          <source>Map type</source>
          <target state="translated">지도 유형</target>
        </trans-unit>
        <trans-unit id="1810f098d7eac5bae7e2406903ecfc11787e8374" translate="yes" xml:space="preserve">
          <source>MapCRtoLF</source>
          <target state="translated">MapCRtoLF</target>
        </trans-unit>
        <trans-unit id="28b80a5d51a036d17e03dadde928449b953d85da" translate="yes" xml:space="preserve">
          <source>MapLFtoCR</source>
          <target state="translated">MapLFtoCR</target>
        </trans-unit>
        <trans-unit id="0f7287b611e3434635c4078dcc64979ba53c31bb" translate="yes" xml:space="preserve">
          <source>MapiFlag</source>
          <target state="translated">MapiFlag</target>
        </trans-unit>
        <trans-unit id="509e216767250bbf0cec7134cc87bd8db88ff863" translate="yes" xml:space="preserve">
          <source>MapiFreeBufferType</source>
          <target state="translated">MapiFreeBufferType</target>
        </trans-unit>
        <trans-unit id="f6693d804c9943e70a4a0323060d0df51aa65dfa" translate="yes" xml:space="preserve">
          <source>MapiFuncs</source>
          <target state="translated">MapiFuncs</target>
        </trans-unit>
        <trans-unit id="cd9c46f0be135a23d65b90dc10dbdb8e6bf7bb43" translate="yes" xml:space="preserve">
          <source>MapiLoaded</source>
          <target state="translated">MapiLoaded</target>
        </trans-unit>
        <trans-unit id="fa7f40372f1e4c545567caf67dc788efc58735dc" translate="yes" xml:space="preserve">
          <source>MapiLogoffType</source>
          <target state="translated">MapiLogoffType</target>
        </trans-unit>
        <trans-unit id="36cb3aec5c1c5fe73d8e8e0fc96d8a25e6742274" translate="yes" xml:space="preserve">
          <source>MapiLogonType</source>
          <target state="translated">MapiLogonType</target>
        </trans-unit>
        <trans-unit id="7a12682bc39d4a4b9b85256454d88deeb97151f5" translate="yes" xml:space="preserve">
          <source>MapiRecipDesc</source>
          <target state="translated">MapiRecipDesc</target>
        </trans-unit>
        <trans-unit id="dd6f6d1599d7119a2a1666a29fe8913e02817cc0" translate="yes" xml:space="preserve">
          <source>MapiResolveNameType</source>
          <target state="translated">MapiResolveNameType</target>
        </trans-unit>
        <trans-unit id="e806730edd68685562cf8c1233b6d49d37ab11ba" translate="yes" xml:space="preserve">
          <source>MapiSendMailType</source>
          <target state="translated">MapiSendMailType</target>
        </trans-unit>
        <trans-unit id="09e81b0440d9e7e7c46c283e70fc598be2643acd" translate="yes" xml:space="preserve">
          <source>Mapped object, from withMappedFile</source>
          <target state="translated">withMappedFile에서 매핑 된 객체</target>
        </trans-unit>
        <trans-unit id="782e4fafad5e3beb16ef35319d6126950de58292" translate="yes" xml:space="preserve">
          <source>MappedObject</source>
          <target state="translated">MappedObject</target>
        </trans-unit>
        <trans-unit id="6f8944015d37918b217a17f41aec65c11bca6197" translate="yes" xml:space="preserve">
          <source>Mapping of C types to corresponding Haskell types.</source>
          <target state="translated">C 유형을 해당 Haskell 유형에 매핑</target>
        </trans-unit>
        <trans-unit id="bfccc2a90a967ca2c9726fa59c31448b51ea07bc" translate="yes" xml:space="preserve">
          <source>Maps an old state to a new state inside a state monad. The old state is thrown away.</source>
          <target state="translated">상태 모나드 내에서 이전 상태를 새 상태로 매핑합니다. 오래된 상태는 버려집니다.</target>
        </trans-unit>
        <trans-unit id="0a1978af85dd59fcc87cee4e7808720188940a44" translate="yes" xml:space="preserve">
          <source>Maps area into memory.</source>
          <target state="translated">영역을 메모리에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="12d3f218c041a3e94409cd521a65703707ec7d30" translate="yes" xml:space="preserve">
          <source>Maps file fully and returns ForeignPtr and length of the mapped area. The mapped file is opened read-only and shared reading.</source>
          <target state="translated">파일을 완전히 매핑하고 ForeignPtr과 매핑 된 영역의 길이를 반환합니다. 매핑 된 파일은 읽기 전용 및 공유 읽기로 열립니다.</target>
        </trans-unit>
        <trans-unit id="3936cc3f677a76a2eedb9a68dae98afcd381cc69" translate="yes" xml:space="preserve">
          <source>Mark a module as unsafe so that it can&amp;rsquo;t be imported by code compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Also enable the Safe Import extension so that a module can require a dependency to be trusted.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 코드로 가져올 수 없도록 모듈을 안전하지 않은 것으로 표시하십시오 . 또한 안전 가져 오기 확장을 활성화하여 모듈의 신뢰를 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2469915cb8350f4b45d32b9fb09eae8014a2fd7" translate="yes" xml:space="preserve">
          <source>MarkParityErrors</source>
          <target state="translated">MarkParityErrors</target>
        </trans-unit>
        <trans-unit id="cf1e479bca0990aa370eb4cace42655c1749155a" translate="yes" xml:space="preserve">
          <source>Markers let us do this: we can annotate the program to emit a marker at an appropriate point during execution and then see that in a profile.</source>
          <target state="translated">마커를 통해이를 수행 할 수 있습니다. 프로그램에 주석을 달아 실행 중에 적절한 지점에 마커를 방출 한 다음 프로필에서이를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfae789a5691468edf927d3fcc545f317911943" translate="yes" xml:space="preserve">
          <source>Marks a capability flushing its local update remembered set accumulator.</source>
          <target state="translated">로컬 업데이트 기억 세트 누산기를 플러시하는 기능을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="749ef48ee39365b34972946cb74471d0eed9c084" translate="yes" xml:space="preserve">
          <source>Marks if the datatype is actually a newtype</source>
          <target state="translated">데이터 유형이 실제로 새로운 유형인지 표시</target>
        </trans-unit>
        <trans-unit id="2e31ff5a5bf802580a8893f8699ba55f6d3ac5b7" translate="yes" xml:space="preserve">
          <source>Marks if this constructor is a record</source>
          <target state="translated">이 생성자가 레코드인지 표시</target>
        </trans-unit>
        <trans-unit id="c3400456e0dc9b11aa991afcb8dd85aa615efa2c" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a heap profile sample.</source>
          <target state="translated">힙 프로필 샘플의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dfdb9356e7d55128f5fe9e41f811cbba7086dbb4" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a time profile.</source>
          <target state="translated">시간 프로필의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="11481cc8464a72c6d603970383a2b8035b849cba" translate="yes" xml:space="preserve">
          <source>Marks the beginning of marking by the concurrent collector.</source>
          <target state="translated">동시 수집기의 표시 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c5867d7dd9a19fc447a637c38b43c98746f7ab60" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">동시 가비지 수집기의 포스트 마크 동기화 단계의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7e14a218bcc85c7d4dcb33742d978559eff47dc5" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">동시 가비지 수집기의 스윕 단계의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="be5ce64099ae9eb2d5c99a4e160328562b3336ca" translate="yes" xml:space="preserve">
          <source>Marks the creation of a Haskell thread.</source>
          <target state="translated">Haskell 스레드의 생성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06e940d86df5e1c669573ec00f380d2004c19a2e" translate="yes" xml:space="preserve">
          <source>Marks the creation of a task.</source>
          <target state="translated">작업 생성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e3821a3cd57a76c02636f3ef5d01798bb2876d2d" translate="yes" xml:space="preserve">
          <source>Marks the end of a heap profile sample.</source>
          <target state="translated">힙 프로필 샘플의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e59b472cf539a835c888dd89568d8c7535aa244" translate="yes" xml:space="preserve">
          <source>Marks the end of concurrent scavenging.</source>
          <target state="translated">동시 청소의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="57bb2a224b54670e5e30b20bb4395fd09c0df40e" translate="yes" xml:space="preserve">
          <source>Marks the end of marking by the concurrent collector.</source>
          <target state="translated">동시 수집기의 표시 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="640deea39fa19db976a137734b54b69c77f77688" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">동시 가비지 수집기의 포스트 마크 동기화 단계의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ff67171565b14a0ac19b21e97b897585fbd8895f" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">동시 가비지 수집기의 스윕 단계의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="769d2819dbb6bff931272f20731d9d45442d5b36" translate="yes" xml:space="preserve">
          <source>Marks the migration of a task to a new capability.</source>
          <target state="translated">작업을 새 기능으로 마이그레이션하는 것을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2a1e650924ea24ab3b1b0f295ccf2fdea9b1307a" translate="yes" xml:space="preserve">
          <source>Marks the start of concurrent scavenging.</source>
          <target state="translated">동시 청소의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7e626c3e7759a64e59e9a89ccd39a484ef5b02cf" translate="yes" xml:space="preserve">
          <source>Marshal a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a C string encoded as UTF-8 in temporary storage, with explicit length information. The encoded string may contain NUL bytes, and is not followed by a trailing NUL byte.</source>
          <target state="translated">명시적인 길이 정보를 사용하여 임시 저장소에서 UTF-8로 인코딩 된 C 문자열로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 마샬링합니다 . 인코딩 된 문자열에는 NUL 바이트가 포함될 수 있으며 뒤에 NUL 바이트가 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e194c0bfa99200c6de46b0a0dae4f141264ffb6b" translate="yes" xml:space="preserve">
          <source>Marshal a C string with explicit length into a Haskell string.</source>
          <target state="translated">명시 적 길이의 C 문자열을 Haskell 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="50198af1318b58c7e70f40d2d8b8dc415ec720f2" translate="yes" xml:space="preserve">
          <source>Marshal a C wide string with explicit length into a Haskell string.</source>
          <target state="translated">명시적인 길이의 C 와이드 문자열을 Haskell 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="3c5b68516d82d4c37cb3d40678d4531758ba74e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information.</source>
          <target state="translated">명시 적 길이 정보를 사용하여 Haskell 문자열을 임시 저장소의 C 문자열 (예 : 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="062175c88aeda03668433b163d83cb6364af626e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) with explicit length information.</source>
          <target state="translated">Haskell 문자열을 명시적인 길이 정보를 사용하여 C 문자열 (즉, 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="912dd885ff9b0a2ea4a16995e74ae7cc0940d45e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">명시 적 길이 정보를 사용하여 임시 저장 공간에서 Haskell 문자열을 C 와이드 문자열 (예 : 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="f77c471f3c7f74d5609487ca9b39a6878b13f8dd" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (ie, wide character array) with explicit length information.</source>
          <target state="translated">Haskell 문자열을 명시 적 길이 정보를 사용하여 C 와이드 문자열 (즉, 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="c98ce6c5f02b8c9585848448e89dbd65dcaf47e3" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열을 NUL 종료 C 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="fdda91a4f111ed1a0fc6f2a8775b98e089fe921b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string.</source>
          <target state="translated">Haskell 문자열을 NUL 종료 C 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4a04b9cb2051b02b522faee9650a0d495e9ac7e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열을 NUL 종료 C 와이드 문자열에 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4054981272596d06fac239f84b099d399356e48b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string.</source>
          <target state="translated">Haskell 스트링을 NUL 종료 C 와이드 스트링에 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="09d48aea89cc33b11ec8033bc15b6483354cf103" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C string into a Haskell string.</source>
          <target state="translated">NUL로 종료 된 C 문자열을 Haskell 문자열로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="4311d7c39509b4fe039bef36ba55dfd320cecd73" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C wide string into a Haskell string.</source>
          <target state="translated">NUL 종료 C 와이드 문자열을 Haskell 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4c47a3a8839a6fd68ae9716c3fa1ce5197fbd8d4" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">더미 하스켈 문자열을 명시적인 길이 정보와 함께 임시 저장소의 C 와이드 문자열 (즉, 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="6d86041ec3d2e84d33ddd1dd6cfc24550f14836a" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">임시 스토리지를 사용하여 더미 Haskell 문자열을 NUL 종료 C 와이드 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="e0dade00c021cdaf9d0ee91f43d69115b6f80912" translate="yes" xml:space="preserve">
          <source>Marshal a list of Haskell strings into an array of NUL terminated C strings using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열 목록을 NUL 종료 C 문자열 배열에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cc6b108a5f57dc6b9a05c1b127e58f7eca9629cd" translate="yes" xml:space="preserve">
          <source>Marshalling</source>
          <target state="translated">Marshalling</target>
        </trans-unit>
        <trans-unit id="f0ad063d68044737957ed0f797a2cae2aa208116" translate="yes" xml:space="preserve">
          <source>Marshalling arrays</source>
          <target state="translated">마샬링 배열</target>
        </trans-unit>
        <trans-unit id="36c846ee62dfe999f6767389bfae195bd57e0465" translate="yes" xml:space="preserve">
          <source>Marshalling lists of storable objects</source>
          <target state="translated">저장 가능한 객체의 마샬링 목록</target>
        </trans-unit>
        <trans-unit id="0dba1cb48010c84cd2d29279809f66a88be05516" translate="yes" xml:space="preserve">
          <source>Marshalling of Boolean values (non-zero corresponds to &lt;code&gt;True&lt;/code&gt;)</source>
          <target state="translated">부울 값의 마샬링 (0이 아닌 값은 &lt;code&gt;True&lt;/code&gt; 에 해당 )</target>
        </trans-unit>
        <trans-unit id="ab71dfd4eb06d44348ff90d0b69db22a5328f47d" translate="yes" xml:space="preserve">
          <source>Marshalling of Maybe values</source>
          <target state="translated">아마도 가치의 마샬링</target>
        </trans-unit>
        <trans-unit id="239b1e2996122625ab9c3b095db2c1aaf212e151" translate="yes" xml:space="preserve">
          <source>Marshalling support</source>
          <target state="translated">마샬링 지원</target>
        </trans-unit>
        <trans-unit id="2768b4d93d7521d0bb9c22088cc6e109b9cb0751" translate="yes" xml:space="preserve">
          <source>Marshalling support. Unsafe API.</source>
          <target state="translated">마샬링 지원. 안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="2ac6f66636ae68e7acfa888a200b00a6c8d691d3" translate="yes" xml:space="preserve">
          <source>Marshalling support: routines allocating, storing, and retrieving Haskell lists that are represented as arrays in the foreign language</source>
          <target state="translated">마샬링 지원 : 외국어로 배열로 표시되는 Haskell 목록을 할당, 저장 및 검색하는 루틴</target>
        </trans-unit>
        <trans-unit id="2eec1eaadfce2f2343fb8a58e72120839ce594dd" translate="yes" xml:space="preserve">
          <source>Martin Escardo and Paulo Oliva. &quot;Selection functions, bar recursion and backward induction&quot;, &lt;em&gt;Mathematical Structures in Computer Science&lt;/em&gt; 20:2 (2010), pp. 127-168. &lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</source>
          <target state="translated">마틴 에스 카르 도와 파울로 올리바. &quot;선택 기능, 막대 재귀 및 역 귀납법&quot;, &lt;em&gt;컴퓨터 과학의 수학적 구조&lt;/em&gt; 20 : 2 (2010), 127-168 쪽. &lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8aadf1657da58cb6e5ae063fb1322736bf6002e4" translate="yes" xml:space="preserve">
          <source>Mask</source>
          <target state="translated">Mask</target>
        </trans-unit>
        <trans-unit id="30b6cc635afcf7d59efbff7d871b3f85ca41ffeb" translate="yes" xml:space="preserve">
          <source>MaskedInterruptible</source>
          <target state="translated">MaskedInterruptible</target>
        </trans-unit>
        <trans-unit id="f8a86f7a0ad149ff28451b56d2a010763bd9ea96" translate="yes" xml:space="preserve">
          <source>MaskedUninterruptible</source>
          <target state="translated">MaskedUninterruptible</target>
        </trans-unit>
        <trans-unit id="55a3d416a9f5e2d65bbae417b235dd396b7e87d1" translate="yes" xml:space="preserve">
          <source>MaskingState</source>
          <target state="translated">MaskingState</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="d8e65ef19404e901265ea66bdd78cf07c84d55f3" translate="yes" xml:space="preserve">
          <source>Match &lt;code&gt;v1&lt;/code&gt; against &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt; against &lt;code&gt;p2&lt;/code&gt; and so on. If any of these matches fail or diverge, so does the whole match.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; 과 &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; 와 &lt;code&gt;p2&lt;/code&gt; 등을 일치 시킵니다. 이러한 일치 중 하나라도 실패하거나 분기되면 전체 일치도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6ceb6ea323bd13a9e935c2eb466741cf2f979c72" translate="yes" xml:space="preserve">
          <source>Match and Clause</source>
          <target state="translated">경기와 조항</target>
        </trans-unit>
        <trans-unit id="dd7924a1ec8896d061a233f605e42f91781e1add" translate="yes" xml:space="preserve">
          <source>Match the value &lt;code&gt;v&lt;/code&gt; against &lt;code&gt;p&lt;/code&gt;. If this match fails or diverges, so does the whole (pattern synonym) match. Otherwise the match against &lt;code&gt;p&lt;/code&gt; must bind the variables &lt;code&gt;x1 ... xn&lt;/code&gt;; let them be bound to values &lt;code&gt;v1 ... vn&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;v&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt; 를 일치시킵니다 . 이 일치가 실패하거나 분기되면 전체 (패턴 동의어) 일치합니다. 그렇지 않으면 &lt;code&gt;p&lt;/code&gt; 에 대한 일치 는 변수 &lt;code&gt;x1 ... xn&lt;/code&gt; 바인딩해야합니다 . 값 &lt;code&gt;v1 ... vn&lt;/code&gt; 바인딩되도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="6763e6cca4e80df18fa4d5f912665ef97a375c19" translate="yes" xml:space="preserve">
          <source>MatchQ</source>
          <target state="translated">MatchQ</target>
        </trans-unit>
        <trans-unit id="4895b24f6bce36c2cd9b44590b52713fb09b4922" translate="yes" xml:space="preserve">
          <source>Matching an expression &lt;code&gt;e&lt;/code&gt; against a pattern &lt;code&gt;!p&lt;/code&gt; is done by first evaluating &lt;code&gt;e&lt;/code&gt; (to WHNF) and then matching the result against &lt;code&gt;p&lt;/code&gt;. Example:</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt; 를 패턴 &lt;code&gt;!p&lt;/code&gt; 와 일치시키는 것은 먼저 &lt;code&gt;e&lt;/code&gt; 를 평가하고 (WHNF로) 그 결과를 &lt;code&gt;p&lt;/code&gt; 와 일치시킴으로써 수행됩니다 . 예:</target>
        </trans-unit>
        <trans-unit id="70016ff14223778abe33ce54933e1dcebf537bde" translate="yes" xml:space="preserve">
          <source>Matching function for the token to parse.</source>
          <target state="translated">구문 분석 할 토큰의 일치 기능</target>
        </trans-unit>
        <trans-unit id="469df59ba37712c09add7e5bdd4e7279148a045b" translate="yes" xml:space="preserve">
          <source>Matching is carried out on GHC&amp;rsquo;s intermediate language, which includes type abstractions and applications. So a rule only matches if the types match too. See &lt;a href=&quot;#rule-spec&quot;&gt;Specialisation&lt;/a&gt; below.</source>
          <target state="translated">매칭은 타입 추상화와 응용을 포함하는 GHC의 중간 언어에서 수행됩니다. 따라서 규칙도 유형이 일치하는 경우에만 일치합니다. 아래 &lt;a href=&quot;#rule-spec&quot;&gt;전문화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78b96c127877ae96cfefda73d72a8baba84838aa" translate="yes" xml:space="preserve">
          <source>Matching on &lt;code&gt;App&lt;/code&gt; directly is both hard to read and error prone to write. And the situation is even worse when the matching is nested:</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 직접 일치하는 것은 읽기가 어렵고 오류가 발생하기 쉽습니다. 그리고 일치하는 것이 중첩되면 상황이 더욱 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="042bacca5d8f713d47eab01491aa815bdbd55203" translate="yes" xml:space="preserve">
          <source>Matching the pattern &lt;code&gt;!pat&lt;/code&gt; against a value &lt;code&gt;v&lt;/code&gt; behaves as follows:</source>
          <target state="translated">패턴 &lt;code&gt;!pat&lt;/code&gt; 를 값 &lt;code&gt;v&lt;/code&gt; 와 일치 시키면 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3d675806f239e11d4b41b67aa65a5606104824d2" translate="yes" xml:space="preserve">
          <source>Matching: To the equations in Section 3.17.3 of the &lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt;, add the following:</source>
          <target state="translated">매칭 : &lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt; 3.17.3 섹션의 방정식에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d87072f110a398a070f07e3107f06ad006b827b3" translate="yes" xml:space="preserve">
          <source>Matching: To the equations in Section 3.17.3 of the &lt;a href=&quot;https://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt;, add the following:</source>
          <target state="translated">매칭 : &lt;a href=&quot;https://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 보고서&lt;/a&gt; 3.17.3 절의 방정식에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e2376240265e2ddbf31297cb5bda027216f1ebd9" translate="yes" xml:space="preserve">
          <source>MathSymbol</source>
          <target state="translated">MathSymbol</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="c189943b0e68bf52ade04ebce38ce6c7c78d6eea" translate="yes" xml:space="preserve">
          <source>Maximum length of a line, in characters.</source>
          <target state="translated">한 줄의 최대 길이 (문자)</target>
        </trans-unit>
        <trans-unit id="144a9206977b57448e4faf5e1062274633d6193e" translate="yes" xml:space="preserve">
          <source>Maximum live data (including large objects + compact regions) in the heap. Updated after a major GC.</source>
          <target state="translated">힙의 최대 라이브 데이터 (큰 개체 + 컴팩트 영역 포함). 주요 GC 이후에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="159b778d9454be206f67d4893bca54a49e9b8c77" translate="yes" xml:space="preserve">
          <source>Maximum live data in compact regions</source>
          <target state="translated">컴팩트 한 지역에서 최대 라이브 데이터</target>
        </trans-unit>
        <trans-unit id="a16695344254fdba02129e66db3ad3e63cb1016e" translate="yes" xml:space="preserve">
          <source>Maximum live data in large objects</source>
          <target state="translated">큰 물체에서 최대 라이브 데이터</target>
        </trans-unit>
        <trans-unit id="240702bae0f29e273fb09ffdba7773ca8777719c" translate="yes" xml:space="preserve">
          <source>Maximum memory in use by the RTS</source>
          <target state="translated">RTS에서 사용중인 최대 메모리</target>
        </trans-unit>
        <trans-unit id="d8099e9d8479df145a140dbad71866cd985cafd7" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to read</source>
          <target state="translated">읽을 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="29145ea756091c42d8b8df72e4191a60b4a54c6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to write</source>
          <target state="translated">쓸 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="9e69850923d54429a417c753e43ca53a7ffd31d5" translate="yes" xml:space="preserve">
          <source>Maximum number of unmatched patterns to be shown in warnings generated by &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 경고에 표시되는 일치하지 않는 최대 패턴 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1f5b0947f46a97bb1ec7fe07a7eee8499d030c8e" translate="yes" xml:space="preserve">
          <source>Maximum of two size hints.</source>
          <target state="translated">최대 2 개의 힌트 크기.</target>
        </trans-unit>
        <trans-unit id="bdf18c00bb82701af0218115bcf257f5be6c13bb" translate="yes" xml:space="preserve">
          <source>Maximum slop</source>
          <target state="translated">최대 경사</target>
        </trans-unit>
        <trans-unit id="15683050ba4f95be274c22da707d4d37cc680acd" translate="yes" xml:space="preserve">
          <source>May be overlapped by more specific instances</source>
          <target state="translated">보다 구체적인 인스턴스와 겹칠 수 있음</target>
        </trans-unit>
        <trans-unit id="9d13a4f70e986c78366878d8a4b23da17275d3fb" translate="yes" xml:space="preserve">
          <source>May overlap a more general instance</source>
          <target state="translated">보다 일반적인 인스턴스와 겹칠 수 있음</target>
        </trans-unit>
        <trans-unit id="bc53972d25b2dda7267fd09725c8dd41aac97859" translate="yes" xml:space="preserve">
          <source>May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">이 설명이 잘못된 경우 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dd8d0bbe9dcb95403cd2c187064106af47af84" translate="yes" xml:space="preserve">
          <source>Maybe</source>
          <target state="translated">Maybe</target>
        </trans-unit>
        <trans-unit id="bef155b2a43310adf81b6d1bb8637732d86f34c0" translate="yes" xml:space="preserve">
          <source>Maybe include (or exclude) replacement locales?</source>
          <target state="translated">대체 로케일을 포함 (또는 제외) 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b92babb5409c0a6ec95584469ae7d91df0ca8969" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the leftmost non-Nothing value.</source>
          <target state="translated">가장 왼쪽이 아닌 값을 반환하는 monoid 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018b50df30620e3a51db9ef52260cf832edd1f4d" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the rightmost non-Nothing value.</source>
          <target state="translated">아마도 가장 오른쪽이 아닌 값을 반환하는 monoid 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0be6aa40a87f2c34d21604241fc126b3d008fc" translate="yes" xml:space="preserve">
          <source>Maybe type</source>
          <target state="translated">아마도 타입</target>
        </trans-unit>
        <trans-unit id="aa7807fd2f555e6dc07cae0194859e7c01ce8cb6" translate="yes" xml:space="preserve">
          <source>Maybe values</source>
          <target state="translated">아마도 가치</target>
        </trans-unit>
        <trans-unit id="e3265936ce333fe37c9404fe3bfe54fa2731aec4" translate="yes" xml:space="preserve">
          <source>MaybeT</source>
          <target state="translated">MaybeT</target>
        </trans-unit>
        <trans-unit id="3fbd96571113d60d1ec28c5fc4754c91f3088410" translate="yes" xml:space="preserve">
          <source>MbATOM</source>
          <target state="translated">MbATOM</target>
        </trans-unit>
        <trans-unit id="55d8534107e7b0b303e6aa4feb48079bd26d10e8" translate="yes" xml:space="preserve">
          <source>MbHANDLE</source>
          <target state="translated">MbHANDLE</target>
        </trans-unit>
        <trans-unit id="e5248b4829d90843e057bd4eca3e14ec6c01b898" translate="yes" xml:space="preserve">
          <source>MbHINSTANCE</source>
          <target state="translated">MbHINSTANCE</target>
        </trans-unit>
        <trans-unit id="863abdca342d4cbfd84104bbc0ff83f945b49e3b" translate="yes" xml:space="preserve">
          <source>MbHMODULE</source>
          <target state="translated">MbHMODULE</target>
        </trans-unit>
        <trans-unit id="3d9c03cdc0330cc84e5101070b081063867dbc28" translate="yes" xml:space="preserve">
          <source>MbINT</source>
          <target state="translated">MbINT</target>
        </trans-unit>
        <trans-unit id="ecea6b01153b85a30965344164775b06fbcb69a4" translate="yes" xml:space="preserve">
          <source>MbLPCSTR</source>
          <target state="translated">MbLPCSTR</target>
        </trans-unit>
        <trans-unit id="e5be102041dc49217c1540606dd21365b89afc4f" translate="yes" xml:space="preserve">
          <source>MbLPCTSTR</source>
          <target state="translated">MbLPCTSTR</target>
        </trans-unit>
        <trans-unit id="53d96f8a97cd2285858b07956c5ce9cae6040aba" translate="yes" xml:space="preserve">
          <source>MbLPOVERLAPPED</source>
          <target state="translated">MbLPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="1bab356846186170a8b4b1f5b81a7ad37bab46a7" translate="yes" xml:space="preserve">
          <source>MbLPSECURITY_ATTRIBUTES</source>
          <target state="translated">MbLPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="48504feb90b785c6491d7d2c1926298c2bd30054" translate="yes" xml:space="preserve">
          <source>MbLPVOID</source>
          <target state="translated">MbLPVOID</target>
        </trans-unit>
        <trans-unit id="96d0adb31743d4f3821a0e34427fd9d3c6b05a6e" translate="yes" xml:space="preserve">
          <source>MbPos</source>
          <target state="translated">MbPos</target>
        </trans-unit>
        <trans-unit id="e4fd24ce7545ffe7c595a6b3e7a83dba23199af3" translate="yes" xml:space="preserve">
          <source>MbString</source>
          <target state="translated">MbString</target>
        </trans-unit>
        <trans-unit id="ce9329746fe501a099093f13e3edca7c47f40a51" translate="yes" xml:space="preserve">
          <source>Mc: Mark, Spacing Combining</source>
          <target state="translated">맥 : 마크, 간격 결합</target>
        </trans-unit>
        <trans-unit id="e2c8f4a8900f070fa946c771890c8638e1827848" translate="yes" xml:space="preserve">
          <source>Me: Mark, Enclosing</source>
          <target state="translated">나 : 마크, 동봉</target>
        </trans-unit>
        <trans-unit id="5613874632be97c00f6099463fe7f3e041473ea8" translate="yes" xml:space="preserve">
          <source>Meanings of specific keywords:</source>
          <target state="translated">특정 키워드의 의미 :</target>
        </trans-unit>
        <trans-unit id="1aedf6c2f14dc3df6a343ae9b734d4a0213e9822" translate="yes" xml:space="preserve">
          <source>Means &amp;ldquo;turn off all optimisation&amp;rdquo;, reverting to the same settings as if no &lt;code&gt;-O&lt;/code&gt; options had been specified. Saying &lt;code&gt;-O0&lt;/code&gt; can be useful if e.g. &lt;code&gt;make&lt;/code&gt; has inserted a &lt;code&gt;-O&lt;/code&gt; on the command line already.</source>
          <target state="translated">&lt;code&gt;-O&lt;/code&gt; 옵션이 지정 되지 않은 것과 동일한 설정으로 되돌아가는 &quot;모든 최적화 해제&quot;를 의미 합니다. 예를 들어 &lt;code&gt;make&lt;/code&gt; 가 이미 명령 줄에 &lt;code&gt;-O&lt;/code&gt; 를 삽입 한 경우 &lt;code&gt;-O0&lt;/code&gt; 을 말하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4aa9a4c3b5df0d65ca9349e71ddf30cd0d7394" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Apply every non-dangerous optimisation, even if it means significantly longer compile times.&amp;rdquo;</source>
          <target state="translated">의미 : &quot;컴파일 시간이 상당히 길어 지더라도 모든 위험하지 않은 최적화를 적용하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="c3bbe6c8c39ed5248e3ca18003eb3d6900b1a45b" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Generate good-quality code without taking too long about it.&amp;rdquo; Thus, for example: &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</source>
          <target state="translated">의미 : &quot;너무 오래 걸리지 않고 양질의 코드를 생성하십시오.&quot; 따라서 예를 들면 다음과 같습니다. &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe31d4f25bb8cbbdafdbd4fc62d7fc6cf17c7656" translate="yes" xml:space="preserve">
          <source>Mediate types and binary type constructors.</source>
          <target state="translated">유형과 이진 유형 생성자를 중재합니다.</target>
        </trans-unit>
        <trans-unit id="517ef4fa125305a5305a3a02844f3bb72b3175b5" translate="yes" xml:space="preserve">
          <source>Mediate types and unary type constructors.</source>
          <target state="translated">유형과 단항 유형 생성자를 중재하십시오.</target>
        </trans-unit>
        <trans-unit id="e4fbd39576ea76f4b6886965b788cbf9b98faaa4" translate="yes" xml:space="preserve">
          <source>Memoisation happens because the built-in Haskell list &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; is represented as &lt;strong&gt;data&lt;/strong&gt;, either empty or a &lt;em&gt;cons-cell&lt;/em&gt; holding the first element and the tail of the list. The &lt;code&gt;Foldable&lt;/code&gt; class enables a variant representation of iterators as &lt;em&gt;functions&lt;/em&gt;, which take an operator and a starting accumulator and output a summary result.</source>
          <target state="translated">내장 목록 하스켈 때문에 메모이 제이션이 발생 &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; 가&lt;/strong&gt; 로 표시되는 &lt;strong&gt;데이터가&lt;/strong&gt; 비어 있거나 역시 &lt;em&gt;양론 셀&lt;/em&gt; 첫번째 요소 목록의 꼬리를 잡고. &lt;code&gt;Foldable&lt;/code&gt; 클래스는 반복자 변형 표현 가능 &lt;em&gt;함수&lt;/em&gt; 연산자 및 출발 누산기 출력을 요약 한 결과를 가지고.</target>
        </trans-unit>
        <trans-unit id="a1bf368dfa41af6966ac27794caf5006abecc398" translate="yes" xml:space="preserve">
          <source>Memory Model</source>
          <target state="translated">메모리 모델</target>
        </trans-unit>
        <trans-unit id="49364f57d947f17b4af9ef59269db84acaef977a" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">메모리 주소는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 유형의 값으로 표시되며 일부 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 에 대한 type 인수 는 FFI 코드에서 귀중한 유형 안전성을 제공하는 데 도움이되고 (명시 적 캐스트없이 다른 유형의 포인터를 혼합 할 수 없음) Haskell 유형 시스템이 주어진 포인터에 어떤 마샬링 방법이 필요한지 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ccc7c7227622171674639dfab2d7182af83111c" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">메모리 주소는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 유형의 값으로 표시되며 일부 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 에 대한 type 인수 는 FFI 코드에서 귀중한 유형 안전성을 제공하는 데 도움이되고 (명시 적 캐스트없이 다른 유형의 포인터를 혼합 할 수 없음) Haskell 유형 시스템이 주어진 포인터에 어떤 마샬링 방법이 필요한지 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="403b42e453dae36d100f182dddf88973e094f006" translate="yes" xml:space="preserve">
          <source>Memory containing the data to write</source>
          <target state="translated">쓸 데이터를 포함하는 메모리</target>
        </trans-unit>
        <trans-unit id="94713b6ce43e5b0b6c83500725c2f66aaf33bf20" translate="yes" xml:space="preserve">
          <source>Memory in which to put the data</source>
          <target state="translated">데이터를 넣을 메모리</target>
        </trans-unit>
        <trans-unit id="6dc9de36a01521f350aa26cecadb8b40753a93e7" translate="yes" xml:space="preserve">
          <source>Memory occupied by threads and their stacks is labelled as &amp;ldquo;TSO&amp;rdquo; and &amp;ldquo;STACK&amp;rdquo; respectively when displaying the profile by closure description or type description.</source>
          <target state="translated">스레드 및 해당 스택이 차지하는 메모리는 클로저 설명 또는 유형 설명으로 프로파일을 표시 할 때 각각 &quot;TSO&quot;및 &quot;STACK&quot;으로 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4c76fe9817202da64040fc649066dabc0e7eed8e" translate="yes" xml:space="preserve">
          <source>Memory overhead</source>
          <target state="translated">메모리 오버 헤드</target>
        </trans-unit>
        <trans-unit id="76cf8b1754b778b2d89d0e21d90207ed29dcf08d" translate="yes" xml:space="preserve">
          <source>Memory-related system things.</source>
          <target state="translated">메모리 관련 시스템 것들.</target>
        </trans-unit>
        <trans-unit id="d10533e6a3289c9df349dcd02b8d8d7f9c80176b" translate="yes" xml:space="preserve">
          <source>Merge immediately-nested case expressions that scrutinise the same variable. For example,</source>
          <target state="translated">동일한 변수를 면밀히 조사하는 즉시 중첩 된 대소 문자 표현을 병합합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5d3ef442f47f2ad90bddd19466398680ce25d8b8" translate="yes" xml:space="preserve">
          <source>Merge two maps.</source>
          <target state="translated">두 맵을 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="19c032c62dd34ab443e91cd122c550a6e77893b2" translate="yes" xml:space="preserve">
          <source>Merging the contribution of the current element with an accumulator value from a partial result is performed by an &lt;em&gt;operator&lt;/em&gt; function, either explicitly provided by the caller as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, implicit as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, or partly implicit as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; (where each element is mapped into a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, and the monoid's &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; operator performs the merge).</source>
          <target state="translated">일부 결과로부터 누산기 값과 현재 요소의 기여도를 병합하는 의해 수행되는 &lt;em&gt;운전자의&lt;/em&gt; 명시 적 같이 발신자에 의해 제공되는 기능 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 같이 암시, &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; , 또는 같은 부분적으로 암시 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 각 요소에 매핑된다 ( &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; , 상기 모노 이드의 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 의 운영자)는 병합을 수행한다.</target>
        </trans-unit>
        <trans-unit id="68f4145fee7dde76afceb910165924ad14cf0d00" translate="yes" xml:space="preserve">
          <source>Message</source>
          <target state="translated">Message</target>
        </trans-unit>
        <trans-unit id="024d721d7acc6f792bdb94402861b9353228512e" translate="yes" xml:space="preserve">
          <source>Messages sent back to GHC from GHCi.TH, to implement the methods of &lt;code&gt;Quasi&lt;/code&gt;. For an overview of how TH works with Remote GHCi, see Note [Remote Template Haskell] in GHCi.TH.</source>
          <target state="translated">메시지의 방법을 구현하기 위해, GHCi.TH에서 GHC로 다시 전송 &lt;code&gt;Quasi&lt;/code&gt; . TH가 Remote GHCi와 작동하는 방식에 대한 개요는 GHCi.TH의 참고 [Remote Template Haskell]을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="b4c38ae701ee7b9a08939eed835436caf60c6814" translate="yes" xml:space="preserve">
          <source>Meta information: &lt;code&gt;M1&lt;/code&gt;</source>
          <target state="translated">메타 정보 : &lt;code&gt;M1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbd5ac6aaff1e4e5e3680f3fcf71d0e95837cf76" translate="yes" xml:space="preserve">
          <source>Meta-information</source>
          <target state="translated">Meta-information</target>
        </trans-unit>
        <trans-unit id="1704ec077999acd78a98ea2ae7222e509894be96" translate="yes" xml:space="preserve">
          <source>Meta-information (constructor names, etc.)</source>
          <target state="translated">메타 정보 (생성자 이름 등)</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="1ce80809f59fb3e44fb71f48daaa5004423cdbcf" translate="yes" xml:space="preserve">
          <source>Methods for the RealFrac instances for &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, with specialised versions for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 전용 버전을 사용하여 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 용 RealFrac 인스턴스에 대한 메서드입니다 .</target>
        </trans-unit>
        <trans-unit id="056ba157b3837c9d7e53cf9a40b8f90212f59c28" translate="yes" xml:space="preserve">
          <source>Micro</source>
          <target state="translated">Micro</target>
        </trans-unit>
        <trans-unit id="064b3c6c13a563b40aaf45097d6cc83685cba7e9" translate="yes" xml:space="preserve">
          <source>Milan Straka 2014</source>
          <target state="translated">밀란 스트라 카 2014</target>
        </trans-unit>
        <trans-unit id="90b5d11de357d4d026169517972bc20fb4c73559" translate="yes" xml:space="preserve">
          <source>Milli</source>
          <target state="translated">Milli</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="2afa51042312a9e6905578605fd22a3a6cf486b0" translate="yes" xml:space="preserve">
          <source>Min/Max</source>
          <target state="translated">Min/Max</target>
        </trans-unit>
        <trans-unit id="e4a689975026b0f86f50d77f497034f70d01b4fa" translate="yes" xml:space="preserve">
          <source>Minimal complete definition</source>
          <target state="translated">최소의 완전한 정의</target>
        </trans-unit>
        <trans-unit id="ac6d77ddd397a6c5eefaab2dc1cbd2ec7a9c37eb" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최소한의 완전한 정의 : &lt;code&gt;&lt;a href=&quot;control-monad-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="665f3b3bb2b72327a6fd69442668299a386cb99c" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최소한의 완전한 정의 : &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab7e52c60d681dae189f8720979ee422a3d05064" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최소한의 완전한 정의 : &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd6feae02a9278c6dea240fd40b8aeb536aa561" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최소한의 완전한 정의 : 하나 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f44945409c6023d19bee5e3d0ed6a60092084206" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt;. Using &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; can be more efficient for complex types.</source>
          <target state="translated">최소한의 완전한 정의 : 하나 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; . 복잡한 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af209dc37f96b74f9773c4c4d607b8e40fe1baaf" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최소한의 완전한 정의 : 하나 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7953d2f2689ba6cdd1d813d83ee82da633d40079" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt;. Using &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; can be more efficient for complex types.</source>
          <target state="translated">최소한의 완전한 정의 : 하나 &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; . 복잡한 유형의 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8799ac72cc46a81952dd429d7c4af0260005305d" translate="yes" xml:space="preserve">
          <source>Minimal definition is either both of &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; or just &lt;code&gt;state&lt;/code&gt;</source>
          <target state="translated">최소 정의는 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 또는 just &lt;code&gt;state&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af4f6aa56d4f948a03f18d3a1d4d1605a2212012" translate="yes" xml:space="preserve">
          <source>Minimal size of next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 의 최소 ​​크기입니다 .</target>
        </trans-unit>
        <trans-unit id="36461254172845cccb18d0bf80dba5e9c41d913e" translate="yes" xml:space="preserve">
          <source>Minimal verbosity: print one line per compilation (this is the default when &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">최소 세부 정보 : 컴파일 당 한 줄을 인쇄합니다 ( &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt; 가 켜져있는 경우 기본값 임).</target>
        </trans-unit>
        <trans-unit id="13dd082aed431f232c24aac55d18467c2b663e2e" translate="yes" xml:space="preserve">
          <source>Minimum % ⟨n⟩ of heap which must be available for allocation.</source>
          <target state="translated">할당 할 수 있어야하는 힙의 최소 % % n⟩.</target>
        </trans-unit>
        <trans-unit id="b2c5225f522390e3a01cad15518a7fad4845c00b" translate="yes" xml:space="preserve">
          <source>Minimum of two size hints.</source>
          <target state="translated">최소 2 개의 힌트 크기.</target>
        </trans-unit>
        <trans-unit id="6375390ec9f90418a19031fe946ea7c8b08c7ed6" translate="yes" xml:space="preserve">
          <source>Minor utilities for the HPC tools.</source>
          <target state="translated">HPC 도구 용 보조 유틸리티</target>
        </trans-unit>
        <trans-unit id="0f40575a4f8fcd450cc8e24d023e408e6a539894" translate="yes" xml:space="preserve">
          <source>MiscFlags</source>
          <target state="translated">MiscFlags</target>
        </trans-unit>
        <trans-unit id="2aa593cd19b234155d3652986effbe2cabb181f4" translate="yes" xml:space="preserve">
          <source>Miscelaneous information available for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 사용 가능한 기타 정보.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="6b75dbc2d8c884fa76ebd1fab5321c113f5bdcc6" translate="yes" xml:space="preserve">
          <source>Miscellaneous GMP-provided operations</source>
          <target state="translated">기타 GMP 제공 작업</target>
        </trans-unit>
        <trans-unit id="5e68c0546c69483d4d1cb26b8fe241467b0b0496" translate="yes" xml:space="preserve">
          <source>Miscellaneous backend dumps</source>
          <target state="translated">기타 백엔드 덤프</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="766dde0dd177116968305ecf5af25276425044a7" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions on tactics</source>
          <target state="translated">전술에 대한 기타 기능</target>
        </trans-unit>
        <trans-unit id="fc807e2d7976d257c9171d114a6eb3efc8cab20a" translate="yes" xml:space="preserve">
          <source>Miscellaneous information about the system environment.</source>
          <target state="translated">시스템 환경에 대한 기타 정보</target>
        </trans-unit>
        <trans-unit id="bddea403651e35362ffdbaad6b7106a982b909aa" translate="yes" xml:space="preserve">
          <source>Miscellaneous information available for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 사용할 수있는 기타 정보입니다.</target>
        </trans-unit>
        <trans-unit id="142e1b72c08ab742f64274e6c7d575bbcc8429f4" translate="yes" xml:space="preserve">
          <source>Miscellaneous parameters</source>
          <target state="translated">기타 매개 변수</target>
        </trans-unit>
        <trans-unit id="75614093589ee1a6ed1d6b3a9a321b001454bfa9" translate="yes" xml:space="preserve">
          <source>Miscellaneous tactic functions</source>
          <target state="translated">기타 전술 기능</target>
        </trans-unit>
        <trans-unit id="120f9c9998409369934eaac96bbbad1e69990044" translate="yes" xml:space="preserve">
          <source>Mismatch between the argument types and the format string, as well as any other syntactic or semantic errors in the format string, will cause an exception to be thrown at runtime.</source>
          <target state="translated">인수 유형과 형식 문자열 간의 불일치뿐만 아니라 형식 문자열의 다른 구문 또는 의미 오류로 인해 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="a5446b7cafd6f64fa36d064009daafea44ba609c" translate="yes" xml:space="preserve">
          <source>Mix DataStructure</source>
          <target state="translated">혼합 데이터 구조</target>
        </trans-unit>
        <trans-unit id="832e98200646adcbff0ea6a3b2b8398b73caa5ed" translate="yes" xml:space="preserve">
          <source>MixEntry</source>
          <target state="translated">MixEntry</target>
        </trans-unit>
        <trans-unit id="517dcc2aab9ff981e3d03a30ce6935c8e5ebac7e" translate="yes" xml:space="preserve">
          <source>MixEntryDom</source>
          <target state="translated">MixEntryDom</target>
        </trans-unit>
        <trans-unit id="d6840928afb9e96dced0538038e4e1c1eac39e1f" translate="yes" xml:space="preserve">
          <source>MkSystemTime</source>
          <target state="translated">MkSystemTime</target>
        </trans-unit>
        <trans-unit id="30376c6ee888990666c554e49bebf998120a5703" translate="yes" xml:space="preserve">
          <source>Mn: Mark, Non-Spacing</source>
          <target state="translated">Mn : 비 간격 표시</target>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="f149e0b10681e7408d843a0239621f9345205680" translate="yes" xml:space="preserve">
          <source>ModJulianDate</source>
          <target state="translated">ModJulianDate</target>
        </trans-unit>
        <trans-unit id="7a6df6254eeab02c96836922ac0139d166dad965" translate="yes" xml:space="preserve">
          <source>ModName</source>
          <target state="translated">ModName</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="e6c089b7ef71ad84d0b5ea7857ddf7e884d95cec" translate="yes" xml:space="preserve">
          <source>Mode wrappers</source>
          <target state="translated">모드 래퍼</target>
        </trans-unit>
        <trans-unit id="6fd961190d330e230cb25033021abb41924a952f" translate="yes" xml:space="preserve">
          <source>Mode: A mode may be used on the command line only. You can pass only one mode flag. For example, &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt;. The available modes are listed in &lt;a href=&quot;#modes&quot;&gt;Modes of operation&lt;/a&gt;.</source>
          <target state="translated">모드 : 모드는 명령 행에서만 사용할 수 있습니다. 하나의 모드 플래그 만 전달할 수 있습니다. 예를 들어 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt; 입니다. 사용 가능한 모드는 &lt;a href=&quot;#modes&quot;&gt;작동&lt;/a&gt; 모드에 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0b30babf16ffbe6c525df9ecff6598de4eeedcf" translate="yes" xml:space="preserve">
          <source>ModifiedJulianDay</source>
          <target state="translated">ModifiedJulianDay</target>
        </trans-unit>
        <trans-unit id="ad8932265b6513f8f4632598479d16d811295a0e" translate="yes" xml:space="preserve">
          <source>ModifierLetter</source>
          <target state="translated">ModifierLetter</target>
        </trans-unit>
        <trans-unit id="06e78e77af950abb3de1917e6c715f81fbe8971c" translate="yes" xml:space="preserve">
          <source>ModifierParser</source>
          <target state="translated">ModifierParser</target>
        </trans-unit>
        <trans-unit id="a6384fc88bd1c896276b41e4e1213a85a46e0ff7" translate="yes" xml:space="preserve">
          <source>ModifierSymbol</source>
          <target state="translated">ModifierSymbol</target>
        </trans-unit>
        <trans-unit id="612cabf63b0ae37796ad667f19fbb51eec48245e" translate="yes" xml:space="preserve">
          <source>Modify the ambient monad used during code generation. For example, you can use &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; to handle a state effect: &lt;code&gt;
  handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a
  handleState = hoistCode (flip runState 0)
 &lt;/code&gt;</source>
          <target state="translated">코드 생성 중에 사용되는 주변 모나드를 수정합니다. 예를 들어, 상태 효과를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 : &lt;code&gt; handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a handleState = hoistCode (flip runState 0) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbb225bd76a44ecd21f3cad93b922d790b638f86" translate="yes" xml:space="preserve">
          <source>Modify the ambient monad used during code generation. For example, you can use &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; to handle a state effect: &lt;code&gt;
  handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a
  handleState = hoistCode (flip runState 0)
 &lt;/code&gt;</source>
          <target state="translated">코드 생성 중에 사용되는 주변 모나드를 수정합니다. 예를 들어, 상태 효과를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 : &lt;code&gt; handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a handleState = hoistCode (flip runState 0) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6320257ec347ce7461b6559133a0cc26667c4e6d" translate="yes" xml:space="preserve">
          <source>Modify the contents of a &lt;code&gt;MutVar#&lt;/code&gt;, returning the previous contents and the result of applying the given function to the previous contents.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 의 내용을 수정하여 이전 내용과 주어진 함수를 이전 내용에 적용한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0a2b227aefd779ece79d3f6ad8baef4e51ab448" translate="yes" xml:space="preserve">
          <source>Modify the contents of a &lt;code&gt;MutVar#&lt;/code&gt;, returning the previous contents and the result of applying the given function to the previous contents. Note that this isn't strictly speaking the correct type for this function; it should really be &lt;code&gt;MutVar# s a -&amp;gt; (a -&amp;gt; (a,b)) -&amp;gt; State# s -&amp;gt; (# State# s, a, (a, b) #)&lt;/code&gt;, but we don't know about pairs here.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 의 내용을 수정하여 이전 내용과 주어진 함수를 이전 내용에 적용한 결과를 반환합니다. 이것이이 함수에 올바른 타입을 말하는 것은 아닙니다. 실제로 &lt;code&gt;MutVar# s a -&amp;gt; (a -&amp;gt; (a,b)) -&amp;gt; State# s -&amp;gt; (# State# s, a, (a, b) #)&lt;/code&gt; 이어야 하지만 쌍에 대해서는 알지 못합니다. 여기.</target>
        </trans-unit>
        <trans-unit id="6ecabc24fa376f8bfdd5f9771659364d02446fee" translate="yes" xml:space="preserve">
          <source>Modify the depth of the evaluation history tracked by GHCi.</source>
          <target state="translated">GHCi가 추적 한 평가 히스토리의 깊이를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="18199c686f30decfd6449ba999c8002260a92575" translate="yes" xml:space="preserve">
          <source>Modify the value of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 값을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="34813144ec19f74db4ddda85d08e6849e3f1487f" translate="yes" xml:space="preserve">
          <source>Modifying the code slightly, however, produces code which will not compile:</source>
          <target state="translated">그러나 코드를 약간 수정하면 컴파일되지 않는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4c32fd82ceb8daf13a6616a1ab5a958038171a59" translate="yes" xml:space="preserve">
          <source>Modifying the user environment</source>
          <target state="translated">사용자 환경 수정</target>
        </trans-unit>
        <trans-unit id="e075617bae1ed6d213cacf5b4a1963cf2b558270" translate="yes" xml:space="preserve">
          <source>Modular arithmetic</source>
          <target state="translated">모듈 식 산술</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="40b31c77d57b0de63020f3b87cedcf39795f6b82" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; 는 저장 가능한 배열의 인터페이스를 제공합니다. 이들은 &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 포함).</target>
        </trans-unit>
        <trans-unit id="dfbffd6a6167f932043b8ceb3531f4ecd4669be4" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">모듈 &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; 는 저장 가능한 배열의 인터페이스를 제공합니다. &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 포함) 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="6b407bb0936075a0d89e6cf1e7e32901f003e72c" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; 는 저장 가능한 배열의 인터페이스를 제공합니다. &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 사용) 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="59fc78cc7268113b6d14c7ba3a0c68ede04edd9f" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Y&lt;/code&gt; exports all the entities defined in &lt;code&gt;Y&lt;/code&gt;, namely the data constructors &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt;, and &lt;em&gt;implicitly&lt;/em&gt; the data family &lt;code&gt;D&lt;/code&gt;, even though it&amp;rsquo;s defined in &lt;code&gt;X&lt;/code&gt;. This means you can write &lt;code&gt;import Y( D(D1,D2) )&lt;/code&gt;&lt;em&gt;without&lt;/em&gt; giving an explicit export list like this:</source>
          <target state="translated">모듈 &lt;code&gt;Y&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 에 정의되어 있어도 &lt;code&gt;Y&lt;/code&gt; 에 정의 된 모든 엔티티 , 즉 데이터 생성자 &lt;code&gt;D1&lt;/code&gt; 및 &lt;code&gt;D2&lt;/code&gt; 및 &lt;em&gt;암시 적&lt;/em&gt; 으로 데이터 패밀리 &lt;code&gt;D&lt;/code&gt; 를 내 보냅니다 . 이것은 다음과 같은 명시 적 내보내기 목록 &lt;em&gt;을&lt;/em&gt; 제공 &lt;em&gt;하지 않고 &lt;/em&gt; &lt;code&gt;import Y( D(D1,D2) )&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 작성할 수 있음을 의미합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ca5283a9401b368ad7082d2368aee85af976008" translate="yes" xml:space="preserve">
          <source>Module Data.Typeable re-exported for convenience</source>
          <target state="translated">모듈 데이터. 편의를 위해 입력 가능한 재수출</target>
        </trans-unit>
        <trans-unit id="ec22b40d47f573ceb3764447b0fd39403f6d6c2d" translate="yes" xml:space="preserve">
          <source>Module authors using the &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; language extension for a module &lt;code&gt;M&lt;/code&gt; should ensure that &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s public API (the symbols exposed by its export list) can&amp;rsquo;t be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.</source>
          <target state="translated">모듈 &lt;code&gt;M&lt;/code&gt; 에&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 언어 확장을 사용하는 모듈 작성자 는 &lt;code&gt;M&lt;/code&gt; 의 공개 API (내보내기 목록에 의해 노출 된 기호)를 안전하지 않은 방식으로 사용할 수 없도록해야합니다. 즉, 내 보낸 기호는 형식 안전 및 참조 투명성을 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="91ba4bca6673e09b576e66d35a05c3026f377972" translate="yes" xml:space="preserve">
          <source>Module authors using the &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; language extension for a module &lt;code&gt;M&lt;/code&gt; should ensure that &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s public API (the symbols exposed by its export list) can&amp;rsquo;t be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.</source>
          <target state="translated">모듈 &lt;code&gt;M&lt;/code&gt; 에 대해 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 언어 확장을 사용하는 모듈 작성자 는 &lt;code&gt;M&lt;/code&gt; 의 공개 API (내보내기 목록에 의해 노출되는 기호)가 안전하지 않은 방식으로 사용되지 않도록해야합니다. 이는 내 보낸 기호가 유형 안전성과 참조 투명성을 존중해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58b8208bcfdac835bd589f0a0f394caee9130541" translate="yes" xml:space="preserve">
          <source>Module names</source>
          <target state="translated">모듈 이름</target>
        </trans-unit>
        <trans-unit id="9ae357fac1f871ab051702ee0509a637ca73c454" translate="yes" xml:space="preserve">
          <source>Module over monad operator for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; 용 모나드 연산자를 통한 모듈</target>
        </trans-unit>
        <trans-unit id="eb27714f2a03885159601b0fa4f8b118e5c3a120" translate="yes" xml:space="preserve">
          <source>Module prefix of a name, if it exists.</source>
          <target state="translated">이름의 모듈 접두어 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="00d767e865b30777f85d5e023407cb4c65ee4110" translate="yes" xml:space="preserve">
          <source>Module signatures actually consist of two closely related features:</source>
          <target state="translated">모듈 서명은 실제로 두 가지 밀접한 관련 기능으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="80246c9711a49a29d3a5e03817c371dd6ae4cbfc" translate="yes" xml:space="preserve">
          <source>ModuleAnnotation</source>
          <target state="translated">ModuleAnnotation</target>
        </trans-unit>
        <trans-unit id="538831de95e10dc8de9dab5d4714b91d07aa6e76" translate="yes" xml:space="preserve">
          <source>ModuleInfo</source>
          <target state="translated">ModuleInfo</target>
        </trans-unit>
        <trans-unit id="17c49dd9a2601ed05a4293ce1094e4ae4f9be60b" translate="yes" xml:space="preserve">
          <source>Modules compiled with this option can be freely mixed with modules compiled without it; indeed, most libraries will typically be compiled without &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt;. When the program is run, coverage data will only be generated for those modules that were compiled with &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt;, and the &lt;strong&gt;hpc&lt;/strong&gt; tool will only show information about those modules.</source>
          <target state="translated">이 옵션으로 컴파일 된 모듈은이 옵션없이 컴파일 된 모듈과 자유롭게 혼합 될 수 있습니다. 실제로 대부분의 라이브러리는 일반적으로 &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt; 없이 컴파일됩니다 . 프로그램이 실행되면 &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 해당 모듈에 대해서만 적용 범위 데이터가 생성 되며 &lt;strong&gt;hpc&lt;/strong&gt; 도구는 해당 모듈에 대한 정보 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7f34a515a9849c6d1d6359aa243ee958639d54b5" translate="yes" xml:space="preserve">
          <source>Modules reexported by this package. This list takes the form of &lt;code&gt;pkg:OldName as NewName (A@orig-pkg-0.1-HASH)&lt;/code&gt;: the first portion of the string is the user-written reexport specification (possibly omitting the package qualifier and the renaming), while the parenthetical is the original package which exposed the module under are particular name. Reexported modules have a relaxed overlap constraint: it&amp;rsquo;s permissible for two packages to reexport the same module as the same name if the reexported moduleis identical.</source>
          <target state="translated">이 패키지에서 모듈을 다시 내보냈습니다. 이 목록은 &lt;code&gt;pkg:OldName as NewName (A@orig-pkg-0.1-HASH)&lt;/code&gt; 형식을 NewName (A@orig-pkg-0.1-HASH) 형식 으로 사용합니다. 문자열의 첫 번째 부분은 사용자 작성 다시 내보내기 사양 (패키지 한정자와 이름 바꾸기 생략)이며 괄호 특정 이름으로 모듈을 노출 한 원래 패키지입니다. 재수출 된 모듈은 완화 된 오버랩 제약 조건이 있습니다. 재수출 된 모듈이 동일한 경우 두 패키지가 동일한 이름으로 동일한 모듈을 재수출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44309d68cfcd4f5d92e2cc5899604b23cc2ee7ad" translate="yes" xml:space="preserve">
          <source>Modules using unboxed tuples or sums will automatically enable &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">박싱되지 않은 튜플 또는 합계를 사용하는 모듈은 자동으로 &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; 를&lt;/a&gt; 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="e3bc4d952ccd3346da0175b0abdc685fcb3a3272" translate="yes" xml:space="preserve">
          <source>Modulus of natural numbers. &lt;code&gt;Mod x 0&lt;/code&gt; is undefined (i.e., it cannot be reduced).</source>
          <target state="translated">자연수의 계수. &lt;code&gt;Mod x 0&lt;/code&gt; 은 정의되어 있지 않습니다 (즉, 줄일 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="11531c3c6a7c6d49562c188b9bdc843a54288d30" translate="yes" xml:space="preserve">
          <source>Monad</source>
          <target state="translated">Monad</target>
        </trans-unit>
        <trans-unit id="f117e306f3bfe1ed114c24f6bd68d2322d3b742f" translate="yes" xml:space="preserve">
          <source>Monad comprehensions generalise the list comprehension notation, including parallel comprehensions (&lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;) and transform comprehensions (&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) to work for any monad.</source>
          <target state="translated">모나드 이해는 병렬 이해 ( &lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel Comprehensions&lt;/a&gt; ) ( 병렬리스트 이해 ) 및 변형 이해 ( &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalized (SQL-like) List Comprehensions&lt;/a&gt; )를 포함하여 모나드에 대해 작동 하도록 목록 이해 표기법을 일반화합니다 .</target>
        </trans-unit>
        <trans-unit id="e9a1db2a2bc244dd09436f1dc6c3b604a440f9fe" translate="yes" xml:space="preserve">
          <source>Monad comprehensions generalise the list comprehension notation, including parallel comprehensions (&lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;) and transform comprehensions (&lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) to work for any monad.</source>
          <target state="translated">모나드 이해는 병렬 이해 ( &lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt; ) 및 변환 이해 ( &lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;일반화 (SQL 유사) List Comprehensions&lt;/a&gt; )를 포함하여 모든 모나드에서 작동 하도록 목록 이해 표기법을 일반화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b154b6a867643b57ffe3e50fb7555800ae79d0a" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support rebindable syntax (&lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;). Without rebindable syntax, the operators from the &amp;ldquo;standard binding&amp;rdquo; module are used; with rebindable syntax, the operators are looked up in the current lexical scope. For example, parallel comprehensions will be typechecked and desugared using whatever &amp;ldquo;&lt;code&gt;mzip&lt;/code&gt;&amp;rdquo; is in scope.</source>
          <target state="translated">Monad 이해는 리 바인드 가능한 구문 (리 &lt;a href=&quot;#rebindable-syntax&quot;&gt;바인드 가능한 구문 및 암시 적 Prelude import&lt;/a&gt; )을 지원합니다. 리 바인딩 가능한 구문이 없으면 &quot;표준 바인딩&quot;모듈의 연산자가 사용됩니다. 리 바인딩 가능한 구문으로 연산자는 현재 어휘 범위에서 조회됩니다. 예를 들어, 병렬 이해는 범위에있는 &quot; &lt;code&gt;mzip&lt;/code&gt; &quot;을 사용하여 유형 검사 및 설탕 제거를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="7cb902b1da8088200b68ff6ba9cddaada5c6c71a" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support rebindable syntax (&lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;). Without rebindable syntax, the operators from the &amp;ldquo;standard binding&amp;rdquo; module are used; with rebindable syntax, the operators are looked up in the current lexical scope. For example, parallel comprehensions will be typechecked and desugared using whatever &amp;ldquo;&lt;code&gt;mzip&lt;/code&gt;&amp;rdquo; is in scope.</source>
          <target state="translated">Monad Comprehensions는 rebindable 구문을 지원합니다 ( &lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable 구문 및 암시 적 Prelude 가져 오기&lt;/a&gt; ). 리 바인딩 가능한 구문이 없으면 &quot;표준 바인딩&quot;모듈의 연산자가 사용됩니다. 리 바인딩 가능한 구문을 사용하면 연산자가 현재 어휘 범위에서 조회됩니다. 예를 들어, 병렬 이해는 범위에있는 &quot; &lt;code&gt;mzip&lt;/code&gt; &quot;을 사용하여 typechecked 및 desugared 됩니다.</target>
        </trans-unit>
        <trans-unit id="9118814255c8cbff0f92707b31e2747bffbb4a14" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support:</source>
          <target state="translated">Monad 이해력 지원 :</target>
        </trans-unit>
        <trans-unit id="ccf5f31df2b47a5c8b3c7b4b8bec553c0e566b1a" translate="yes" xml:space="preserve">
          <source>Monad transformation</source>
          <target state="translated">모나드 변환</target>
        </trans-unit>
        <trans-unit id="1c0fd921dbc28d4c0620875213e77e22d440c417" translate="yes" xml:space="preserve">
          <source>Monad transformations</source>
          <target state="translated">모나드 변환</target>
        </trans-unit>
        <trans-unit id="b85021f1542ee4ad142b965dc1641cf10fd4260f" translate="yes" xml:space="preserve">
          <source>Monad values are functions from the environment to a value. The bound function is applied to the bound value, and both have access to the shared environment.</source>
          <target state="translated">모나드 값은 환경에서 값까지의 함수입니다. 바운드 함수는 바운드 값에 적용되며 둘 다 공유 환경에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a1aa98499a1d957e619f8fa4af2de6d1152500b" translate="yes" xml:space="preserve">
          <source>MonadComprehensions</source>
          <target state="translated">MonadComprehensions</target>
        </trans-unit>
        <trans-unit id="c6fb342904057550b8ef01f426ca92e465116ed4" translate="yes" xml:space="preserve">
          <source>MonadCont</source>
          <target state="translated">MonadCont</target>
        </trans-unit>
        <trans-unit id="89861c606303650c7e7f0d7c743da67de31d69c7" translate="yes" xml:space="preserve">
          <source>MonadCont class</source>
          <target state="translated">MonadCont 클래스</target>
        </trans-unit>
        <trans-unit id="39a661caab336fa22d832d7beffd7388def93e46" translate="yes" xml:space="preserve">
          <source>MonadError</source>
          <target state="translated">MonadError</target>
        </trans-unit>
        <trans-unit id="6971cd3387fcb89462309d104896a63aacd3ef19" translate="yes" xml:space="preserve">
          <source>MonadException</source>
          <target state="translated">MonadException</target>
        </trans-unit>
        <trans-unit id="16fc28da849b4c8c2a56c99fe357bebb2ee341a7" translate="yes" xml:space="preserve">
          <source>MonadFail</source>
          <target state="translated">MonadFail</target>
        </trans-unit>
        <trans-unit id="7fdd52d0e4c29c94ae163aa3e69f06596bf4ebd0" translate="yes" xml:space="preserve">
          <source>MonadFailDesugaring</source>
          <target state="translated">MonadFailDesugaring</target>
        </trans-unit>
        <trans-unit id="8cd3e027e126ef51355bf4e476d5b9c913c5824c" translate="yes" xml:space="preserve">
          <source>MonadFix</source>
          <target state="translated">MonadFix</target>
        </trans-unit>
        <trans-unit id="464a90d352252a57d56693a4858884c98810e3a1" translate="yes" xml:space="preserve">
          <source>MonadIO</source>
          <target state="translated">MonadIO</target>
        </trans-unit>
        <trans-unit id="741fdf5e9791ce30c278a5afdbd3129dd2c1ead9" translate="yes" xml:space="preserve">
          <source>MonadPlus</source>
          <target state="translated">MonadPlus</target>
        </trans-unit>
        <trans-unit id="e59b4d8e1e1b084ca225560b46a86c3f02b6c3c8" translate="yes" xml:space="preserve">
          <source>MonadReader</source>
          <target state="translated">MonadReader</target>
        </trans-unit>
        <trans-unit id="a68c00a3ea80c75e5ccf937dfcb38fee6f14dbc7" translate="yes" xml:space="preserve">
          <source>MonadReader class</source>
          <target state="translated">MonadReader 클래스</target>
        </trans-unit>
        <trans-unit id="4dbbde36c5c41657a758435796e76b6fee9c0240" translate="yes" xml:space="preserve">
          <source>MonadState</source>
          <target state="translated">MonadState</target>
        </trans-unit>
        <trans-unit id="f176c139b4727308ec824a9344e742f670f0aa3b" translate="yes" xml:space="preserve">
          <source>MonadState class</source>
          <target state="translated">MonadState 클래스</target>
        </trans-unit>
        <trans-unit id="a2e64d3be4f20e02142a613432a291ee3dae4677" translate="yes" xml:space="preserve">
          <source>MonadState class.</source>
          <target state="translated">MonadState 클래스.</target>
        </trans-unit>
        <trans-unit id="29e37501f89d2caf27053c9fb3f8913750d9897a" translate="yes" xml:space="preserve">
          <source>MonadTrans</source>
          <target state="translated">MonadTrans</target>
        </trans-unit>
        <trans-unit id="3f2f8d76eb3c2357f757275d57fffc9c8d4ee396" translate="yes" xml:space="preserve">
          <source>MonadTrans (&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; s u)</source>
          <target state="translated">MonadTrans ( &lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; su)</target>
        </trans-unit>
        <trans-unit id="60a504062889fae8b9e846460fc07b21f50fb371" translate="yes" xml:space="preserve">
          <source>MonadTrans (&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; s u)</source>
          <target state="translated">MonadTrans ( &lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; su)</target>
        </trans-unit>
        <trans-unit id="652f00fb36c1c38645bc9e90431a168567726128" translate="yes" xml:space="preserve">
          <source>MonadWriter</source>
          <target state="translated">MonadWriter</target>
        </trans-unit>
        <trans-unit id="f9be51da3714e0cf4aee03cf4cecccec8f06c1ad" translate="yes" xml:space="preserve">
          <source>MonadWriter class</source>
          <target state="translated">MonadWriter 클래스</target>
        </trans-unit>
        <trans-unit id="52dae74b8add8e5bac5ef90f8e6def33af0626f8" translate="yes" xml:space="preserve">
          <source>MonadZip</source>
          <target state="translated">MonadZip</target>
        </trans-unit>
        <trans-unit id="37921d15310812cb15bb950e0e8c69478968709e" translate="yes" xml:space="preserve">
          <source>Monadic actions</source>
          <target state="translated">수도원 활동</target>
        </trans-unit>
        <trans-unit id="be38a4e3e1a34b178a11a5fbcae21f0a5b3e86dc" translate="yes" xml:space="preserve">
          <source>Monadic fixpoints.</source>
          <target state="translated">모나 딕 픽스 포인트.</target>
        </trans-unit>
        <trans-unit id="79464d099a2a04a0be206b18bf0034c16bdc124c" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure, associating to the left, i.e. from left to right.</source>
          <target state="translated">왼쪽, 즉 왼쪽에서 오른쪽으로 연결된 구조의 요소를 모나드로 접습니다.</target>
        </trans-unit>
        <trans-unit id="0f4ba0ee1732f5a3212ba30683790be701be210c" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure, associating to the right, i.e. from right to left.</source>
          <target state="translated">오른쪽, 즉 오른쪽에서 왼쪽으로 연결된 구조의 요소를 모나드로 접습니다.</target>
        </trans-unit>
        <trans-unit id="ccb232023546e12a237e28f888ebb5702510f0c0" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure. This type of fold is left-associative in the monadic effects, and right-associative in the output value.</source>
          <target state="translated">구조의 요소를 모나 딕으로 접습니다. 이 유형의 접기는 모나드 효과에서 왼쪽 연결이고 출력 값에서 오른쪽 연결입니다.</target>
        </trans-unit>
        <trans-unit id="5c2c7207e0e94b1363bbea4d7345d4fdd0da8444" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure. This type of fold is right-associative in the monadic effects, and left-associative in the output value.</source>
          <target state="translated">구조의 요소를 모나 딕으로 접습니다. 이 유형의 접기는 모나드 효과에서 오른쪽 연결이고 출력 값에서 왼쪽 연결입니다.</target>
        </trans-unit>
        <trans-unit id="5595a6b57f768b1b94cd5faeef182cec9288c190" translate="yes" xml:space="preserve">
          <source>Monadic forest builder, in breadth-first order</source>
          <target state="translated">폭이 넓은 순서로 수도원 숲 건축업자</target>
        </trans-unit>
        <trans-unit id="8b5e9251f6a7731c5728c4734b226c8f0fb9eb58" translate="yes" xml:space="preserve">
          <source>Monadic forest builder, in depth-first order</source>
          <target state="translated">깊이 우선 순서의 수도원 포리스트 빌더</target>
        </trans-unit>
        <trans-unit id="92e8f6d8093ef19a3fbeb20205bdce42d7b88c0f" translate="yes" xml:space="preserve">
          <source>Monadic front-end to Text.PrettyPrint</source>
          <target state="translated">텍스트에 대한 모나드 프런트 엔드.</target>
        </trans-unit>
        <trans-unit id="4700a1dc5dbcbeb872e70164fe9a3ec9d66a7714" translate="yes" xml:space="preserve">
          <source>Monadic lifting operators</source>
          <target state="translated">모나 딕 리프팅 연산자</target>
        </trans-unit>
        <trans-unit id="cb3f1c0525f059418665af747bb13d9f2d7d0703" translate="yes" xml:space="preserve">
          <source>Monadic state transformer.</source>
          <target state="translated">수도원 상태 변압기.</target>
        </trans-unit>
        <trans-unit id="afd12b25574336c915d17d02eed63bdd6790c29d" translate="yes" xml:space="preserve">
          <source>Monadic tree builder, in breadth-first order.</source>
          <target state="translated">너비 우선의 모나 딕 트리 빌더.</target>
        </trans-unit>
        <trans-unit id="1c0844a453139b42e240b3dbd8899eb7e45afa2d" translate="yes" xml:space="preserve">
          <source>Monadic tree builder, in depth-first order.</source>
          <target state="translated">깊이 우선 순서의 모나 딕 트리 빌더.</target>
        </trans-unit>
        <trans-unit id="751701098af9ceab4eca10e3e9e72843e8819c96" translate="yes" xml:space="preserve">
          <source>Monadic variation on &lt;code&gt;&lt;a href=&quot;data-data#v:fromConstrB&quot;&gt;fromConstrB&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:fromConstrB&quot;&gt;fromConstrB&lt;/a&gt;&lt;/code&gt; 의 모나드 변형</target>
        </trans-unit>
        <trans-unit id="9159bd85753caa0996e8d4ad3b128a9014c50e05" translate="yes" xml:space="preserve">
          <source>Monadic zipping (used for monad comprehensions)</source>
          <target state="translated">모나드 압축 (모나드 이해에 사용)</target>
        </trans-unit>
        <trans-unit id="250083fc6df0956d1673cca1cb1611bfc11ab137" translate="yes" xml:space="preserve">
          <source>Monads and functors</source>
          <target state="translated">모나드 및 펑터</target>
        </trans-unit>
        <trans-unit id="9fade08cca7ae6ce3b29ed4f480ac77d554be713" translate="yes" xml:space="preserve">
          <source>Monads having fixed points with a 'knot-tying' semantics. Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fix#t:MonadFix&quot;&gt;MonadFix&lt;/a&gt;&lt;/code&gt; should satisfy the following laws:</source>
          <target state="translated">'매듭 묶기'시맨틱으로 고정 점을 갖는 모나드. &lt;code&gt;&lt;a href=&quot;control-monad-fix#t:MonadFix&quot;&gt;MonadFix&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ab257a5f129af1981f621c8ddf84b2fd68c88ba" translate="yes" xml:space="preserve">
          <source>Monads in which &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations may be embedded. Any monad built by applying a sequence of monad transformers to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad will be an instance of this class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 포함 할 수있는 모나드 . 일련의 모나드 변환기를 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에 적용하여 구축 된 모나드 가이 클래스의 인스턴스가됩니다.</target>
        </trans-unit>
        <trans-unit id="bec921c5487ea6eaf795a69781d0904af33f534a" translate="yes" xml:space="preserve">
          <source>Monads that also support choice and failure.</source>
          <target state="translated">선택과 실패를 지원하는 Monads.</target>
        </trans-unit>
        <trans-unit id="20f29bb326b4b655b5b0354aa1b0ff90343d0044" translate="yes" xml:space="preserve">
          <source>Monads with error handling</source>
          <target state="translated">오류 처리 기능이있는 모나드</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="36181aae20a5a2ae5ba1584c42b3b9779dffec5e" translate="yes" xml:space="preserve">
          <source>Monday-starting week number (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">(같은 주 번호 월요일 - 시작 &lt;code&gt;%W&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="b5307adf2da7c702cf60f2a0dad66c188a1c8b3b" translate="yes" xml:space="preserve">
          <source>MonoLocalBinds</source>
          <target state="translated">MonoLocalBinds</target>
        </trans-unit>
        <trans-unit id="db3026559eb3ab8db4d183918b45caef643c418f" translate="yes" xml:space="preserve">
          <source>MonoPatBinds</source>
          <target state="translated">MonoPatBinds</target>
        </trans-unit>
        <trans-unit id="9c5483b826379f2567e8ee89ca55b9c52e011529" translate="yes" xml:space="preserve">
          <source>Monoid</source>
          <target state="translated">Monoid</target>
        </trans-unit>
        <trans-unit id="0220c03411dbd64cddd0b0ccca5475f10ebe0331" translate="yes" xml:space="preserve">
          <source>Monoid functions</source>
          <target state="translated">모노 함수</target>
        </trans-unit>
        <trans-unit id="e0ac9d688b93e0a5de738795a1f225343db79584" translate="yes" xml:space="preserve">
          <source>Monoid operations</source>
          <target state="translated">모노 이드 연산</target>
        </trans-unit>
        <trans-unit id="3a1b4f214513abdcdf27e4ab6401c3d176d9757e" translate="yes" xml:space="preserve">
          <source>Monoid under &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 아래의 모노 이드 .</target>
        </trans-unit>
        <trans-unit id="8f6543d6abb3998d23fb62d545057fa1ab18548a" translate="yes" xml:space="preserve">
          <source>Monoid under addition.</source>
          <target state="translated">추가중인 모노 이드.</target>
        </trans-unit>
        <trans-unit id="7029b0947bbd5af2e213d2e9bb3c221593a86f9d" translate="yes" xml:space="preserve">
          <source>Monoid under multiplication.</source>
          <target state="translated">곱셈에서 모노 이드.</target>
        </trans-unit>
        <trans-unit id="3e61bbeed3f08fcc986f97d9c436530dd737834a" translate="yes" xml:space="preserve">
          <source>Monomorphic equality operators</source>
          <target state="translated">단항 평등 연산자</target>
        </trans-unit>
        <trans-unit id="129d16939021f97809d6e9d8b3a79a644e52d05b" translate="yes" xml:space="preserve">
          <source>MonomorphismRestriction</source>
          <target state="translated">MonomorphismRestriction</target>
        </trans-unit>
        <trans-unit id="b9bd340d94bbe1799fa2827ad776ca607d3614ba" translate="yes" xml:space="preserve">
          <source>Morally, builder primitives are like functions &lt;code&gt;a -&amp;gt; Builder&lt;/code&gt;, that is they take a value and encode it as a sequence of bytes, represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. Of course their implementation is a bit more specialised.</source>
          <target state="translated">도덕적으로 빌더 프리미티브는 a- &lt;code&gt;a -&amp;gt; Builder&lt;/code&gt; 함수와 같습니다 . 즉, 값을 가져 와서 일련의 바이트로 인코딩하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 로 나타냅니다 . 물론 그들의 구현은 조금 더 전문화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66f6edcbd906b2619c8ac8ef5055169fffaa86c" translate="yes" xml:space="preserve">
          <source>More concretely, if &lt;code&gt;nameAndLineCount&lt;/code&gt; counts the number of lines in a file, returning a pair with input filename and the line count, then traversal over a list of file names produces an IO action that evaluates to a list of &lt;strong&gt;&lt;code&gt;(fileName, lineCount)&lt;/code&gt;&lt;/strong&gt; pairs:</source>
          <target state="translated">보다 구체적으로, &lt;code&gt;nameAndLineCount&lt;/code&gt; 가 파일의 행 수를 계산하고 입력 파일 이름과 행 수와 함께 쌍을 반환하는 경우 파일 이름 목록을 순회하면 &lt;strong&gt; &lt;code&gt;(fileName, lineCount)&lt;/code&gt; &lt;/strong&gt; 쌍 목록으로 평가되는 IO 작업이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9713777f0ffc9301f9aa702f90a88fc96cd4daa" translate="yes" xml:space="preserve">
          <source>More concretely, the input to a command consists of a pair of an environment and a stack. Each value on the stack is paired with the remainder of the stack, with an empty stack being &lt;code&gt;()&lt;/code&gt;. So operators like &lt;code&gt;handleA&lt;/code&gt; that pass extra inputs to their subcommands can be designed for use with the notation by placing the values on the stack paired with the environment in this way. More precisely, the type of each argument of the operator (and its result) should have the form</source>
          <target state="translated">보다 구체적으로, 명령에 대한 입력은 한 쌍의 환경과 스택으로 구성됩니다. 스택의 각 값은 스택의 나머지와 쌍을 이루며 빈 스택은 &lt;code&gt;()&lt;/code&gt; 입니다. 따라서 추가 입력을 부속 명령에 전달하는 &lt;code&gt;handleA&lt;/code&gt; 와 같은 연산자 는 이러한 방식으로 환경과 쌍을 이루는 스택에 값을 배치하여 표기법과 함께 사용하도록 설계 할 수 있습니다. 더 정확하게 말하면 연산자의 각 인수 유형과 결과는 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8806e84b84beada4d40a025a8b169a5dd3603418" translate="yes" xml:space="preserve">
          <source>More crucially, we can also directly define the key building block for generative recursion:</source>
          <target state="translated">더 중요한 것은 생성 적 재귀를위한 주요 구성 요소를 직접 정의 할 수도 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31b13373cbfa12cceaf613513d103c95459cbf88" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;debugging#options-debugging&quot;&gt;Debugging the compiler&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;debugging#options-debugging&quot;&gt;컴파일러 디버깅에 대한&lt;/a&gt; 자세한 내용</target>
        </trans-unit>
        <trans-unit id="c0cecd44911066c36d923fdbe5a19b53168e3dcf" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;extending_ghc#compiler-plugins&quot;&gt;Compiler Plugins&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;extending_ghc#compiler-plugins&quot;&gt;컴파일러 플러그인에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="17420796ed603dd509d02e3a8d1da517181cd7d5" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;ghci#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-dot-files&quot;&gt;.ghci 및 .haskeline 파일&lt;/a&gt; 에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="37e9d2c958040b445e2912cfe73b6aa30dc6a6e6" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;packages#packages&quot;&gt;패키지에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="baf1294ef868c2abc05ce0421bd9b43c7f792cad" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#c-pre-processor&quot;&gt;C 전처리기에 영향을주는 옵션에 대한&lt;/a&gt; 자세한 내용</target>
        </trans-unit>
        <trans-unit id="51d1ab0e22b2ab0d231fb2c5972d2be780b12e73" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#forcing-options-through&quot;&gt;Forcing options to a particular phase&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#forcing-options-through&quot;&gt;옵션을 특정 단계&lt;/a&gt; 로 강제 적용에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="7983553fdee60c62d0851647dd220831bd52e4c8" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#options-codegen&quot;&gt;코드 생성에 영향을 미치는 옵션에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="a16863701609094692f0c3f835ccc3d878e7e100" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#options-linker&quot;&gt;연결에 영향을주는 옵션의&lt;/a&gt; 자세한 내용</target>
        </trans-unit>
        <trans-unit id="8adac53d0127ee0d97906718b6336057dbda2f90" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#replacing-phases&quot;&gt;Replacing the program for one or more phases&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#replacing-phases&quot;&gt;하나 이상의 단계에서 프로그램 교체에 대한&lt;/a&gt; 자세한 내용</target>
        </trans-unit>
        <trans-unit id="31663a68122cfc30712ddae060ef7c0c26fb2a9b" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;profiling#hpc&quot;&gt;Observing Code Coverage&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;profiling#hpc&quot;&gt;코드 범위 관찰에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="e2f3306e90d0fd9056b2e721c5d6c4dbfb662ff2" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="57bc71d308e6ee5ef978190de473b462803d8a22" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#hi-options&quot;&gt;인터페이스 파일과 관련된 기타 옵션에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="32f905a10099284e5b8eb48c14cea142a33e05ef" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#keeping-intermediates&quot;&gt;Keeping Intermediate Files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#keeping-intermediates&quot;&gt;중간 파일 유지에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="01ef1b0434fb54d267252cfe67e63278a877ae6d" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;separate_compilation#options-output&quot;&gt;은 컴파일 출력 리디렉션&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eac718647e3fed68fe7ca2678bdddded1bfb9bff" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#recomp&quot;&gt;재 컴파일 검사기의&lt;/a&gt; 자세한 내용</target>
        </trans-unit>
        <trans-unit id="a74b1204653431c31312edd9978554b178635f3f" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#search-path&quot;&gt;검색 경로&lt;/a&gt; 에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="9dc4a10a5929dae029a66e7ac4365b025fb671f9" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#temp-files&quot;&gt;임시 파일 리디렉션에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="0af5bfe303303a371ced3d780b07e43b27e4b3ba" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#modes&quot;&gt;작동 모드에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="1408534385bbc206247b2d0cacd5fc927e1376cf" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;</source>
          <target state="translated">상세 정보 &lt;a href=&quot;using#options-help&quot;&gt;옵션에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="4561b34d24c52f31aefc4effb398748be0d2b234" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#options-order&quot;&gt;배치 컴파일러 모드의&lt;/a&gt; 세부 사항</target>
        </trans-unit>
        <trans-unit id="968f4ed399272e126f045721eacf076df218221c" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-platform&quot;&gt;Platform-specific Flags&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#options-platform&quot;&gt;플랫폼 별 플래그에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="920c16a3909f0ffbf5534e62118ba2d6b6ff57fd" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;경고 및 위생 검사에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="50fd034f800c349a7431cd23c8f6ce2a124f77fa" translate="yes" xml:space="preserve">
          <source>More details:</source>
          <target state="translated">자세한 내용은:</target>
        </trans-unit>
        <trans-unit id="a5c3d993dce9c18048d2dd451f76a4bbd8fe5e29" translate="yes" xml:space="preserve">
          <source>More documentation can be found in the &lt;a href=&quot;https://wiki.haskell.org/Functional_dependencies&quot;&gt;Haskell Wiki&lt;/a&gt;.</source>
          <target state="translated">더 많은 문서는 &lt;a href=&quot;https://wiki.haskell.org/Functional_dependencies&quot;&gt;Haskell Wiki&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6ff0bd29737185cd5b1918e0904197bf24a1392" translate="yes" xml:space="preserve">
          <source>More formally, the desugaring is as follows. We write &lt;code&gt;D[ e | Q]&lt;/code&gt; to mean the desugaring of the monad comprehension &lt;code&gt;[ e | Q]&lt;/code&gt;:</source>
          <target state="translated">보다 공식적으로, 탈당은 다음과 같습니다. 우리는 &lt;code&gt;D[ e | Q]&lt;/code&gt; 모나드 이해력의 탈당을 의미하는 것 &lt;code&gt;[ e | Q]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2085068fa8f84e11b2c779916cc311b96fc67d3f" translate="yes" xml:space="preserve">
          <source>More generally, dependencies take the form &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt;, where &lt;code&gt;x1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;xn&lt;/code&gt;, and &lt;code&gt;y1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;yn&lt;/code&gt; are type variables with n&amp;gt;0 and m&amp;gt;=0, meaning that the &lt;code&gt;y&lt;/code&gt; parameters are uniquely determined by the &lt;code&gt;x&lt;/code&gt; parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in &lt;code&gt;t -&amp;gt; a b&lt;/code&gt;. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of &lt;code&gt;E&lt;/code&gt; above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don&amp;rsquo;t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include &lt;code&gt;a -&amp;gt; a&lt;/code&gt;, &lt;code&gt;a -&amp;gt; a a&lt;/code&gt;, &lt;code&gt;a -&amp;gt;&lt;/code&gt;, etc. There can also be some redundancy if multiple dependencies are given, as in &lt;code&gt;a-&amp;gt;b&lt;/code&gt;, &lt;code&gt;b-&amp;gt;c&lt;/code&gt;, &lt;code&gt;a-&amp;gt;c&lt;/code&gt;, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</source>
          <target state="translated">보다 일반적으로 종속성은 &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt; 형식을 취합니다 . 여기서 &lt;code&gt;x1&lt;/code&gt; ,&amp;hellip;, &lt;code&gt;xn&lt;/code&gt; 및 &lt;code&gt;y1&lt;/code&gt; ,&amp;hellip;, &lt;code&gt;yn&lt;/code&gt; 은 n&amp;gt; 0 및 m&amp;gt; = 0 인 유형 변수입니다. 즉, &lt;code&gt;y&lt;/code&gt; 매개 변수는 &lt;code&gt;x&lt;/code&gt; 매개 변수에 의해 고유하게 결정됩니다 . &lt;code&gt;t -&amp;gt; a b&lt;/code&gt; 와 같이 종속성의 한쪽에 둘 이상의 변수가 나타나는 경우 공백을 구분 기호로 사용할 수 있습니다 . &lt;code&gt;E&lt;/code&gt; 의 정의에서와 같이 쉼표를 구분 기호로 사용하여 클래스에 여러 종속성으로 주석을 달 수 있습니다.위. 이 표기법으로 작성할 수있는 일부 종속성은 중복되며 유용한 목적을 제공하지 않기 때문에 거부되며 대신 프로그램의 오류를 나타낼 수 있습니다. 이런 종속성의 예로 &lt;code&gt;a -&amp;gt; a&lt;/code&gt; , &lt;code&gt;a -&amp;gt; a a&lt;/code&gt; , &lt;code&gt;a -&amp;gt;&lt;/code&gt; 등 여러 종속성이 주어지면 일부가 중복 될 수 있고, 마찬가지로 &lt;code&gt;a-&amp;gt;b&lt;/code&gt; , &lt;code&gt;b-&amp;gt;c&lt;/code&gt; , &lt;code&gt;a-&amp;gt;c&lt;/code&gt; , 일부 하위 집합은 나머지 종속성을 의미합니다. 이와 같은 예는 오류로 처리되지 않습니다. 종속성은 클래스 선언에만 표시되고 언어의 다른 부분에는 표시되지 않습니다. 특히 인스턴스 선언, 클래스 제약 및 유형에 대한 구문은 완전히 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2ce620eb436f6437f620c767d1f4df6c98830db2" translate="yes" xml:space="preserve">
          <source>More generally, dependencies take the form &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt;, where &lt;code&gt;x1&lt;/code&gt;, ..., &lt;code&gt;xn&lt;/code&gt;, and &lt;code&gt;y1&lt;/code&gt;, ..., &lt;code&gt;yn&lt;/code&gt; are type variables with n&amp;gt;0 and m&amp;gt;=0, meaning that the &lt;code&gt;y&lt;/code&gt; parameters are uniquely determined by the &lt;code&gt;x&lt;/code&gt; parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in &lt;code&gt;t -&amp;gt; a b&lt;/code&gt;. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of &lt;code&gt;E&lt;/code&gt; above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don&amp;rsquo;t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include &lt;code&gt;a -&amp;gt; a&lt;/code&gt;, &lt;code&gt;a -&amp;gt; a a&lt;/code&gt;, &lt;code&gt;a -&amp;gt;&lt;/code&gt;, etc. There can also be some redundancy if multiple dependencies are given, as in &lt;code&gt;a-&amp;gt;b&lt;/code&gt;, &lt;code&gt;b-&amp;gt;c&lt;/code&gt;, &lt;code&gt;a-&amp;gt;c&lt;/code&gt;, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</source>
          <target state="translated">보다 일반적으로, 종속성은 &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt; 형식을 취합니다 . 여기서 &lt;code&gt;x1&lt;/code&gt; , ..., &lt;code&gt;xn&lt;/code&gt; 및 &lt;code&gt;y1&lt;/code&gt; , ..., &lt;code&gt;yn&lt;/code&gt; 은 n&amp;gt; 0 및 m&amp;gt; = 0 인 유형 변수입니다. 이는 &lt;code&gt;y&lt;/code&gt; 매개 변수가 &lt;code&gt;x&lt;/code&gt; 매개 변수에 의해 고유하게 결정됨을 의미합니다 . 위의 &lt;code&gt;t -&amp;gt; a b&lt;/code&gt; . &lt;code&gt;E&lt;/code&gt; 의 정의에서와 같이 쉼표를 구분 기호로 사용하여 클래스에 여러 종속성으로 주석을 달 수 있습니다. 에서와 같이 종속의 한면에 둘 이상의 변수가 나타나면 공백을 구분 기호로 사용할 수 있습니다 . 이 표기법으로 작성할 수있는 일부 종속성은 중복되며 유용한 목적을 제공하지 않으므로 거부되며 대신 프로그램의 오류를 나타낼 수 있습니다. 이와 같은 종속성의 예로는 a- &lt;code&gt;a -&amp;gt; a&lt;/code&gt; , &lt;code&gt;a -&amp;gt; a a&lt;/code&gt; , &lt;code&gt;a -&amp;gt;&lt;/code&gt; 여러 종속성 같이 주어진 경우 등 일부 중복이 될 수있다 &lt;code&gt;a-&amp;gt;b&lt;/code&gt; , &lt;code&gt;b-&amp;gt;c&lt;/code&gt; , &lt;code&gt;a-&amp;gt;c&lt;/code&gt; , 일부 하위 집합은 나머지 종속성을 의미합니다. 이와 같은 예제는 오류로 처리되지 않습니다. 종속성은 클래스 선언에만 표시되며 언어의 다른 부분에는 표시되지 않습니다. 특히 인스턴스 선언, 클래스 제약 조건 및 형식에 대한 구문은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="174c1aad58978f69590dd72b60851d08b234e600" translate="yes" xml:space="preserve">
          <source>More in-depth information can be found on the &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Roles&quot;&gt;Roles wiki page&lt;/a&gt;</source>
          <target state="translated">더 자세한 정보는 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Roles&quot;&gt;역할 위키 페이지&lt;/a&gt; 에서 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f30bdf45636fdc98dcf55a5628219c150e7f67cd" translate="yes" xml:space="preserve">
          <source>More in-depth information can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/roles&quot;&gt;Roles wiki page&lt;/a&gt;</source>
          <target state="translated">더 자세한 정보는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/roles&quot;&gt;역할 위키 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e14ab6cf4fdb8d4413797b405b5b9102d3c1bc86" translate="yes" xml:space="preserve">
          <source>More information is given for explicit holes (i.e. ones that start with an underscore), than for out-of-scope variables, because the latter are often unintended typos, so the extra information is distracting. If you want the detailed information, use a leading underscore to make explicit your intent to use a hole.</source>
          <target state="translated">범위를 벗어난 변수보다 명시적인 구멍 (즉, 밑줄로 시작하는 구멍)에 대한 자세한 정보가 제공되는데,이 변수는 의도하지 않은 오타이기 때문에 추가 정보가 산만 해집니다. 자세한 정보를 원하면 밑줄을 사용하여 구멍을 사용하려는 의도를 명시하십시오.</target>
        </trans-unit>
        <trans-unit id="cdb9413519e4acd2573608f8f06f43a109139ea4" translate="yes" xml:space="preserve">
          <source>More precisely, the scoping rules are:</source>
          <target state="translated">보다 정확하게 범위 지정 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f08e1cae5fd42d45181559f708b9f948ac50f46" translate="yes" xml:space="preserve">
          <source>More precisely, the semantics of pattern matching is given in &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17&quot;&gt;Section 3.17 of the Haskell 2010 report&lt;/a&gt;. To the informal semantics in Section 3.17.2 we add this extra rule:</source>
          <target state="translated">보다 정확하게 패턴 일치의 의미 &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17&quot;&gt;는 Haskell 2010 보고서의 섹션 3.17에 나와&lt;/a&gt; 있습니다. 3.17.2 절의 비공식 의미론에이 추가 규칙을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e4c589fb3b275a240038aa72aafa4cfbf0c4831b" translate="yes" xml:space="preserve">
          <source>More precisely, warn if a binding brings into scope a variable that is not used, except if the variable&amp;rsquo;s name starts with an underscore. The &amp;ldquo;starts-with-underscore&amp;rdquo; condition provides a way to selectively disable the warning.</source>
          <target state="translated">보다 정확하게는 변수 이름이 밑줄로 시작하는 경우를 제외하고 바인딩이 사용되지 않는 변수를 범위에 포함시키는 경우 경고합니다. &quot;밑줄로 시작&quot;조건은 경고를 선택적으로 비활성화하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e142cf9dbc576682f7db5f9767bc39f19e16ad2" translate="yes" xml:space="preserve">
          <source>More sophisticated combinators for expressing parallelism are available from the &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; module in the &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;parallel package&lt;/a&gt;. This module builds functionality around &lt;code&gt;par&lt;/code&gt;, expressing more elaborate patterns of parallel computation, such as parallel &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">병렬을 표현하기위한보다 복잡한 조합 은 &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;병렬 패키지&lt;/a&gt; 의 &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; 모듈에서 제공 됩니다 . 이 모듈은 &lt;code&gt;par&lt;/code&gt; 주위에 기능을 구축 하여 병렬 &lt;code&gt;map&lt;/code&gt; 과 같은보다 정교한 병렬 계산 패턴을 표현 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ed6b588d942e43b985dc1ef91eaa6acb3407601" translate="yes" xml:space="preserve">
          <source>More sophisticated combinators for expressing parallelism are available from the &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; module in the &lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;parallel package&lt;/a&gt;. This module builds functionality around &lt;code&gt;par&lt;/code&gt;, expressing more elaborate patterns of parallel computation, such as parallel &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">병렬화를 표현하기위한보다 정교한 결합 자는 &lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;병렬 패키지&lt;/a&gt; 의 &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; 모듈에서 사용할 수 있습니다 . 이 모듈은 &lt;code&gt;par&lt;/code&gt; 를 중심으로 기능을 구축 하여 병렬 &lt;code&gt;map&lt;/code&gt; 와 같은보다 정교한 병렬 계산 패턴을 표현 합니다 .</target>
        </trans-unit>
        <trans-unit id="7efbe8954f7d8bb33318735e14097d00de7a9a64" translate="yes" xml:space="preserve">
          <source>More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.</source>
          <target state="translated">보다 구체적으로, 이러한 바이트 문자열은 코드 포인트 0-255에 포함 된 유니 코드의 하위 세트에있는 것으로 간주됩니다. 여기에는 Unicode Basic Latin, Latin-1 Supplement 및 C0 + C1 Control이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="86749f35327922682f80058567d622a5b5a74e48" translate="yes" xml:space="preserve">
          <source>More specifically, consider the following modules:</source>
          <target state="translated">보다 구체적으로 다음 모듈을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="49ae26a58091afd7797c7d608cef98d9b3bd88ed" translate="yes" xml:space="preserve">
          <source>More substantially, an anonymous records library could provide &lt;code&gt;HasField&lt;/code&gt; instances for its anonymous records, and thus be compatible with the polymorphic record selectors introduced by this proposal. For example, something like this makes it possible to use &lt;code&gt;getField&lt;/code&gt; to access &lt;code&gt;Record&lt;/code&gt; values with the appropriate string in the type-level list of fields:</source>
          <target state="translated">보다 실질적으로, 익명 레코드 라이브러리는 그 익명 레코드에 대한 &lt;code&gt;HasField&lt;/code&gt; 인스턴스를 제공 할 수 있으며, 따라서이 제안에 의해 도입 된 다형성 레코드 선택기와 호환 될 수있다. 예를 들어 다음과 같이 &lt;code&gt;getField&lt;/code&gt; 를 사용 하여 유형 레벨 필드 목록에서 적절한 문자열로 &lt;code&gt;Record&lt;/code&gt; 값 에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005be1b0ad130c7c10cd96e65aa29871ac012aff" translate="yes" xml:space="preserve">
          <source>Moreover genuinely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (#10318)</source>
          <target state="translated">더욱이 진정한 재귀 수퍼 클래스는 때때로 유용합니다. 다음은 실제 사례입니다 (# 10318).</target>
        </trans-unit>
        <trans-unit id="48fbf1fc9f3d27864af0185af07555a2ed71738b" translate="yes" xml:space="preserve">
          <source>Moreover genuninely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (#10318)</source>
          <target state="translated">더욱이 genuninely-recursive superclass는 때때로 유용합니다. 다음은 실제 사례입니다 (# 10318).</target>
        </trans-unit>
        <trans-unit id="aee6d8add66d57251c294e797e38ba98f856c59e" translate="yes" xml:space="preserve">
          <source>Moreover genuninely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (Trac #10318)</source>
          <target state="translated">또한, 재귀 적으로 재귀적인 슈퍼 클래스가 유용 할 때가 있습니다. 실제 사례는 다음과 같습니다 (Trac # 10318).</target>
        </trans-unit>
        <trans-unit id="9daae4c546da3c409b18a41ad5d587143e25c7b1" translate="yes" xml:space="preserve">
          <source>Moreover you often don&amp;rsquo;t even need the &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in the first place. When compiling a module &lt;code&gt;M&lt;/code&gt;, GHC&amp;rsquo;s optimiser (when given the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag) automatically considers each top-level overloaded function declared in &lt;code&gt;M&lt;/code&gt;, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. The optimiser &lt;em&gt;also&lt;/em&gt; considers each &lt;em&gt;imported&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; overloaded function, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. So in our example, it would be enough for &lt;code&gt;lookup&lt;/code&gt; to be called at type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">또한 처음 에는 &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; pragma 가 필요하지 않은 경우가 많습니다 . 모듈 컴파일 할 때 &lt;code&gt;M&lt;/code&gt; 을 , (주어진 GHC의 최적화 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그는) 자동으로 선언 된 각 최상위 오버로드 기능을 고려 &lt;code&gt;M&lt;/code&gt; 을 , 그리고 그것은 호출되는 다른 유형을 전문으로 &lt;code&gt;M&lt;/code&gt; . 옵티마이 저는 &lt;em&gt;또한 &lt;/em&gt;&lt;em&gt;가져온&lt;/em&gt; 각 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; 오버로드 된 함수를 고려 하고 &lt;code&gt;M&lt;/code&gt; 에서 호출되는 여러 유형에 대해이를 전문화합니다 . 따라서이 예에서는 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;lookup&lt;/code&gt; 를 호출하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="2b9d1405f104daf49ed40d4d63a24458c96232a6" translate="yes" xml:space="preserve">
          <source>Moreover you often don&amp;rsquo;t even need the &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in the first place. When compiling a module &lt;code&gt;M&lt;/code&gt;, GHC&amp;rsquo;s optimiser (when given the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag) automatically considers each top-level overloaded function declared in &lt;code&gt;M&lt;/code&gt;, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. The optimiser &lt;em&gt;also&lt;/em&gt; considers each &lt;em&gt;imported&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; overloaded function, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. So in our example, it would be enough for &lt;code&gt;lookup&lt;/code&gt; to be called at type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">또한 처음 에는 &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; pragma 가 필요하지 않은 경우가 많습니다 . 모듈 컴파일 할 때 &lt;code&gt;M&lt;/code&gt; 을 , (주어진 GHC의 최적화 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그는) 자동으로 선언 된 각 최상위 오버로드 기능을 고려 &lt;code&gt;M&lt;/code&gt; 을 , 그리고 그것은 호출되는 다른 유형을 전문으로 &lt;code&gt;M&lt;/code&gt; . 옵티마이 저는 &lt;em&gt;또한 &lt;/em&gt;&lt;em&gt;가져온&lt;/em&gt; 각 &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; 오버로드 된 함수를 고려 하여 &lt;code&gt;M&lt;/code&gt; 에서 호출되는 다양한 유형에 특화합니다 . 따라서이 예에서는 &lt;code&gt;T&lt;/code&gt; 유형에서 &lt;code&gt;lookup&lt;/code&gt; 를 호출하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="1b09c524376f62eb132cfc4d87068c7c414ce987" translate="yes" xml:space="preserve">
          <source>Moreover, GHC will only inline the function if it is &lt;em&gt;fully applied&lt;/em&gt;, where &amp;ldquo;fully applied&amp;rdquo; means applied to as many arguments as appear (syntactically) on the LHS of the function definition. For example:</source>
          <target state="translated">또한 GHC는 함수가 &lt;em&gt;완전히 적용되는&lt;/em&gt; 경우에만 함수를 인라인합니다 . 여기서 &quot;완전히 적용됨&quot;은 함수 정의의 LHS에 나타나는 (구문 적으로) 많은 인수에 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6284ba052c710bcfe1b333b0499c004a62fd7cbd" translate="yes" xml:space="preserve">
          <source>Moreover, a local fixity declaration &lt;em&gt;must&lt;/em&gt; accompany a local binding of that name: it is not possible to revise the fixity of name bound elsewhere, as in</source>
          <target state="translated">또한 로컬 고정 선언 은 해당 이름의 로컬 바인딩과 함께 제공 &lt;em&gt;되어야합니다. 다음&lt;/em&gt; 과 같이 다른 곳에 바인딩 된 이름의 고정을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="435226f4fb8d01545e71ad9e8e0b16ea37149391" translate="yes" xml:space="preserve">
          <source>Moreover, every module that imports &lt;code&gt;Client&lt;/code&gt; (or imports a module that imports &lt;code&gt;Client&lt;/code&gt;, transitively) will &amp;ldquo;see&amp;rdquo;, and make use of, the specialised version of &lt;code&gt;lookup&lt;/code&gt;. You don&amp;rsquo;t need to put a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in every module.</source>
          <target state="translated">또한 &lt;code&gt;Client&lt;/code&gt; 를 가져 오는 (또는 &lt;code&gt;Client&lt;/code&gt; 를 전 이적으로 가져 오는 모듈을 가져 오는) 모든 모듈 은 특수화 된 버전의 &lt;code&gt;lookup&lt;/code&gt; &quot;보고&quot;사용할 것입니다 . 모든 모듈에 &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; pragma 를 넣을 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="641bceca79503a5b46c154c94304a197aa140c0b" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;Applicative&lt;/code&gt; instance declarations:</source>
          <target state="translated">또한 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스 선언에서 :</target>
        </trans-unit>
        <trans-unit id="97508f66cdde54922c388601bbdb4ef006e66daf" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;MonadFail&lt;/code&gt; instance declarations:</source>
          <target state="translated">또한 &lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 선언에서 :</target>
        </trans-unit>
        <trans-unit id="667b008ae7d33f2434031b95fad3289972f0f759" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;Semigroup&lt;/code&gt; instance declarations:</source>
          <target state="translated">또한 &lt;code&gt;Semigroup&lt;/code&gt; 인스턴스 선언에서 :</target>
        </trans-unit>
        <trans-unit id="9b463d35e3037a7b25fba6436d573b43c738063f" translate="yes" xml:space="preserve">
          <source>Moreover, we can ask &lt;code&gt;gdb&lt;/code&gt; to tell us the flow of execution that lead us to this point in the program,</source>
          <target state="translated">또한 &lt;code&gt;gdb&lt;/code&gt; 에게 프로그램의 현재 시점으로 이어지는 실행 흐름을 알려주 도록 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8feac72447d42dc6b03b07306f6ad6196a53f4dd" translate="yes" xml:space="preserve">
          <source>Most GHC users will not need to worry about levity polymorphism or unboxed types. For these users, seeing the levity polymorphism in the type of &lt;code&gt;$&lt;/code&gt; is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type &lt;code&gt;RuntimeRep&lt;/code&gt; to be &lt;code&gt;'LiftedRep&lt;/code&gt; when printing, and printing &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; as &lt;code&gt;Type&lt;/code&gt; (or &lt;code&gt;*&lt;/code&gt; when &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">대부분의 GHC 사용자는 levity polymorphism 또는 unboxed type에 대해 걱정할 필요가 없습니다. 이 사용자들에게 &lt;code&gt;$&lt;/code&gt; 의 유형에있는 다형성 다형성을 보는 것은 도움이되지 않습니다. 따라서, 기본적으로는 모든 종류의 입력 변수로 가정하면, 억제 &lt;code&gt;RuntimeRep&lt;/code&gt; 을 할 &lt;code&gt;'LiftedRep&lt;/code&gt; 인쇄, 인쇄 할 때 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 같이 &lt;code&gt;Type&lt;/code&gt; (또는 &lt;code&gt;*&lt;/code&gt; &lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 가&lt;/a&gt; 켜짐).</target>
        </trans-unit>
        <trans-unit id="17b1a5f71734de963b1a50b74875ef3731d2a5ac" translate="yes" xml:space="preserve">
          <source>Most GHC users will not need to worry about levity polymorphism or unboxed types. For these users, seeing the levity polymorphism in the type of &lt;code&gt;$&lt;/code&gt; is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type &lt;code&gt;RuntimeRep&lt;/code&gt; to be &lt;code&gt;'LiftedRep&lt;/code&gt; when printing, and printing &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; as &lt;code&gt;Type&lt;/code&gt; (or &lt;code&gt;*&lt;/code&gt; when &lt;a href=&quot;poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">대부분의 GHC 사용자는 levity polymorphism 또는 unboxed 유형에 대해 걱정할 필요가 없습니다. 이러한 사용자에게는 &lt;code&gt;$&lt;/code&gt; 유형의 levity 다형성을 보는 것이 도움이되지 않습니다. 따라서, 기본적으로는 모든 종류의 입력 변수로 가정하면, 억제 &lt;code&gt;RuntimeRep&lt;/code&gt; 을 할 &lt;code&gt;'LiftedRep&lt;/code&gt; 인쇄, 인쇄 할 때 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 같이 &lt;code&gt;Type&lt;/code&gt; (또는 &lt;code&gt;*&lt;/code&gt; &lt;a href=&quot;poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 가&lt;/a&gt; 켜짐).</target>
        </trans-unit>
        <trans-unit id="a9bfd07736bd17bc98ea30aef5ff00a2993638a7" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">대부분의 핸들에는 다음 입력 또는 출력 작업이 발생할 위치를 나타내는 현재 I / O 위치가 있습니다. 핸들 만 입력 또는 입력과 출력 모두를 관리하는 경우 &lt;em&gt;읽을&lt;/em&gt; 수 있습니다. 마찬가지로 출력 만 관리하거나 입력과 출력을 모두 관리하면 &lt;em&gt;쓰기 가능&lt;/em&gt; 합니다. 처음 할당 할 때 핸들이 &lt;em&gt;열립니다&lt;/em&gt; . 일단 닫히면 더 이상 입력 또는 출력에 사용할 수 없지만 구현은 참조를 유지하면서 스토리지를 재사용 할 수 없습니다. 핸들은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스에 있습니다. 핸들을 표시하여 생성 된 문자열은 시스템에 따라 다릅니다. 디버깅 핸들을 식별하기에 충분한 정보를 포함해야합니다. 핸들은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 에 따라 동일합니다그 자체로만; 다른 핸들의 내부 상태가 동일한 지 비교하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56a261d402c64f03bfdfa4dbbe6dc5df89e9511b" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">대부분의 핸들에는 다음 입력 또는 출력 작업이 발생할 위치를 나타내는 현재 I / O 위치도 있습니다. 핸들은 입력 만 관리하거나 입력과 출력을 모두 관리하는 경우 &lt;em&gt;읽을&lt;/em&gt; 수 있습니다. 마찬가지로 출력 만 관리하거나 입력과 출력을 모두 관리하는 경우 &lt;em&gt;쓰기 가능&lt;/em&gt; 합니다. 처음 할당되면 핸들이 &lt;em&gt;열립니다&lt;/em&gt; . 일단 닫히면 더 이상 입력 또는 출력에 사용할 수 없지만 참조가 유지되는 동안 구현은 저장소를 재사용 할 수 없습니다. 핸들은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스에 있습니다. 핸들을 표시하여 생성 된 문자열은 시스템에 따라 다릅니다. 디버깅을위한 핸들을 식별하기에 충분한 정보가 포함되어야합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 에 따라 핸들이 동일합니다.자신에게만; 서로 다른 핸들의 내부 상태가 같은지 비교하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26dd0443f8df18358fdb53a2bfd90e3b2ecb015a" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">대부분의 핸들에는 다음 입력 또는 출력 작업이 발생할 위치를 나타내는 현재 I / O 위치도 있습니다. 핸들은 입력 만 관리하거나 입력과 출력을 모두 관리하는 경우 &lt;em&gt;읽을&lt;/em&gt; 수 있습니다. 마찬가지로 출력 만 관리하거나 입력과 출력을 모두 관리하는 경우 &lt;em&gt;쓰기 가능&lt;/em&gt; 합니다. 처음 할당되면 핸들이 &lt;em&gt;열립니다&lt;/em&gt; . 일단 닫히면 더 이상 입력 또는 출력에 사용할 수 없지만 참조가 유지되는 동안 구현은 저장소를 재사용 할 수 없습니다. 핸들은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스에 있습니다. 핸들을 표시하여 생성 된 문자열은 시스템에 따라 다릅니다. 디버깅을위한 핸들을 식별 할 수있는 충분한 정보를 포함해야합니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 에 따라 핸들이 동일합니다.그 자체로만; 서로 다른 핸들의 내부 상태가 같은지 비교하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2995cc8024bf7aa8ba13dcae171563836b90420" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">대부분의 핸들에는 다음 입력 또는 출력 작업이 발생할 위치를 나타내는 현재 I / O 위치가 있습니다. 핸들 만 입력 또는 입력과 출력 모두를 관리하는 경우 &lt;em&gt;읽을&lt;/em&gt; 수 있습니다. 마찬가지로 출력 만 관리하거나 입력과 출력을 모두 관리하면 &lt;em&gt;쓰기 가능&lt;/em&gt; 합니다. 처음 할당 할 때 핸들이 &lt;em&gt;열립니다&lt;/em&gt; . 일단 닫히면 더 이상 입력 또는 출력에 사용할 수 없지만 구현은 참조를 유지하면서 스토리지를 재사용 할 수 없습니다. 핸들은 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스에 있습니다. 핸들을 표시하여 생성 된 문자열은 시스템에 따라 다릅니다. 디버깅 핸들을 식별하기에 충분한 정보를 포함해야합니다. 핸들은 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 에 따라 동일합니다그 자체로만; 다른 핸들의 내부 상태가 동일한 지 비교하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9be69b82ce264090f2137a15a7648633cb206f8e" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 모나드 변압기 모듈에는 변압기를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 의 약어입니다 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0c60abd2cf0ff60dc7be795cfcb03f696cc8115" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 모나드 변환기 모듈에는 변환기를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="1f05ad7826cba7566bcebc4116870e810986741e" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 모나드 변환기 모듈에는 변환기를 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함되어 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="1446d57bbc11269458b5fff18c4a2fbea47e1423" translate="yes" xml:space="preserve">
          <source>Most of the command-line options accepted by GHC (see &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;) also make sense in interactive mode. The ones that don&amp;rsquo;t make sense are mostly obvious.</source>
          <target state="translated">GHC ( &lt;a href=&quot;using#using-ghc&quot;&gt;GHC 사용&lt;/a&gt; 참조)에서 허용하는 대부분의 명령 줄 옵션 은 대화식 모드에서도 의미가 있습니다. 이해가되지 않는 것이 대부분 분명합니다.</target>
        </trans-unit>
        <trans-unit id="d49b83194eaa0ec88c028d8df0d8eb5797ada48a" translate="yes" xml:space="preserve">
          <source>Most of the conventions GHC expects when using packages are described in &lt;a href=&quot;packages#building-packages&quot;&gt;Building a package from Haskell source&lt;/a&gt;. In addition note that GHC expects the &lt;code&gt;.hi&lt;/code&gt; files to use the extension &lt;code&gt;.dyn_hi&lt;/code&gt;. The other requirements are the same as for C libraries and are described below, in particular the use of the flags &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC가 패키지를 사용할 때 기대하는 대부분의 규칙 &lt;a href=&quot;packages#building-packages&quot;&gt;은 Haskell 소스에서 패키지 빌드에&lt;/a&gt; 설명되어 있습니다. 또한 노트에서는 GHC는 기대하는 &lt;code&gt;.hi&lt;/code&gt; 파일 확장자를 사용하는 &lt;code&gt;.dyn_hi&lt;/code&gt; 을 . 다른 요구 사항은 C 라이브러리와 동일하며 특히 플래그 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; 를&lt;/a&gt; 사용하는 경우에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c17ee9cdb3b8c7cbc538d3e35bb5401d0f3d8af1" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module are subject to &lt;em&gt;fusion&lt;/em&gt;, meaning that a pipeline of such functions will usually allocate at most one &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">이 모듈의 대부분의 함수는 &lt;em&gt;fusion&lt;/em&gt; 에 종속됩니다 . 즉, 이러한 함수의 파이프 라인은 일반적으로 최대 하나의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="cff6fb1dc40bd9bd236bb1c241939a66f53cfba3" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module are subject to &lt;em&gt;fusion&lt;/em&gt;, meaning that a pipeline of such functions will usually allocate at most one &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">이 모듈의 대부분의 함수는 &lt;em&gt;fusion&lt;/em&gt; 에 종속됩니다 . 즉, 이러한 함수의 파이프 라인은 일반적으로 최대 하나의 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="3b644a39e26dfc78bdc3acb69da17cabd5dd58c1" translate="yes" xml:space="preserve">
          <source>Most of the performance gain stems from using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt;, which encodes a list of values from left-to-right with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;. It exploits the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; internals to avoid unnecessary function compositions (i.e., concatenations). In the future, we might expect the compiler to perform the optimizations implemented in &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt;. However, it seems that the code is currently to complicated for the compiler to see through. Therefore, we provide the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; escape hatch, which allows data structures to provide very efficient encoding traversals, like &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; for lists.</source>
          <target state="translated">성능 향상의 대부분은 사용에서 유래 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; A를 왼쪽에서 오른쪽에서 값 목록을 인코딩, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 을 . 불필요한 기능 구성 (즉, 연결)을 피하기 위해 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 내부를 활용합니다 . 앞으로 컴파일러는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; 에 구현 된 최적화를 수행 할 것으로 예상 할 수 있습니다 . 그러나 컴파일러가보기에는 코드가 복잡해 보입니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 이스케이프 해치를 제공하여 데이터 구조가 목록에 대해 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; 와 같은 매우 효율적인 인코딩 순회를 제공 할 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="93a85b72f189888c0727de2215a65f643a090a37" translate="yes" xml:space="preserve">
          <source>Most of these options are boolean and have options to turn them both &amp;ldquo;on&amp;rdquo; and &amp;ldquo;off&amp;rdquo; (beginning with the prefix &lt;code&gt;no-&lt;/code&gt;). For instance, while &lt;code&gt;-fspecialise&lt;/code&gt; enables specialisation, &lt;code&gt;-fno-specialise&lt;/code&gt; disables it. When multiple flags for the same option appear in the command-line they are evaluated from left to right. For instance, &lt;code&gt;-fno-specialise -fspecialise&lt;/code&gt; will enable specialisation.</source>
          <target state="translated">이러한 옵션의 대부분은 부울이며 접두사로 시작하여 &quot;켜기&quot;와 &quot;끄기&quot;를 모두 설정하는 옵션이 있습니다. &lt;code&gt;no-&lt;/code&gt; 로 . 예를 들어, &lt;code&gt;-fspecialise&lt;/code&gt; 는 &lt;code&gt;-fno-specialise&lt;/code&gt; 활성화하지만 -fno-specialise는 특수화를 비활성화합니다. 동일한 옵션에 대해 여러 플래그가 명령 행에 나타나면 왼쪽에서 오른쪽으로 평가됩니다. 예를 들어, &lt;code&gt;-fno-specialise -fspecialise&lt;/code&gt; 는 전문화를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b4872c5b9a708f91ab972a558b461f19d44ba677" translate="yes" xml:space="preserve">
          <source>Most packages (see &lt;a href=&quot;packages#using-packages&quot;&gt;Using Packages&lt;/a&gt;) are available without needing to specify any extra flags at all: they will be automatically loaded the first time they are needed.</source>
          <target state="translated">추가 플래그를 지정하지 않아도 대부분의 패키지 (패키지 &lt;a href=&quot;packages#using-packages&quot;&gt;사용&lt;/a&gt; 참조 )를 사용할 수 있습니다. 처음으로 필요할 때 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="f17588b3f000b1c04f72f8264ac2012d913333ca" translate="yes" xml:space="preserve">
          <source>Most profiling runtime options are only available when you compile your program for profiling (see &lt;a href=&quot;profiling#prof-compiler-options&quot;&gt;Compiler options for profiling&lt;/a&gt;, and &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for the runtime options). However, there is one profiling option that is available for ordinary non-profiled executables:</source>
          <target state="translated">대부분의 프로파일 링 런타임 옵션은 프로파일 링을 위해 프로그램을 컴파일 할 때만 사용할 수 있습니다 (프로파일 링 &lt;a href=&quot;profiling#prof-compiler-options&quot;&gt;을위한 컴파일러 옵션&lt;/a&gt; 및 런타임 옵션의 &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;힙 프로파일 링을&lt;/a&gt; 위한 RTS 옵션 참조 ). 그러나 프로파일 링되지 않은 일반 실행 파일에 사용할 수있는 프로파일 링 옵션이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd31ae39f49dd0f0c21b3aa4545a982531a6c6b" translate="yes" xml:space="preserve">
          <source>Most programs should not worry about the canonicity of a path. In particular, despite the name, the function does not truly guarantee canonicity of the returned path due to the presence of hard links, mount points, etc.</source>
          <target state="translated">대부분의 프로그램은 경로의 정통성에 대해 걱정하지 않아야합니다. 특히, 이름에도 불구하고이 기능은 하드 링크, 마운트 포인트 등으로 인해 반환 된 경로의 정성을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f735bd28bb08e83da41ac3d34e730c92c26193d9" translate="yes" xml:space="preserve">
          <source>Most specific instance, &lt;code&gt;Ix&lt;/code&gt;, defined in an &lt;code&gt;-XSafe&lt;/code&gt; compiled module.</source>
          <target state="translated">가장 구체적인 예는 &lt;code&gt;Ix&lt;/code&gt; &lt;code&gt;-XSafe&lt;/code&gt; 컴파일 된 모듈에 정의 된 Ix</target>
        </trans-unit>
        <trans-unit id="16ea8e72c52685784f78037d3d05d2240b22d1c7" translate="yes" xml:space="preserve">
          <source>Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell &lt;code&gt;Int&lt;/code&gt;, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved.</source>
          <target state="translated">GHC의 대부분의 유형은 박스로 표시되는데, 이는 해당 유형의 값이 힙 오브젝트에 대한 포인터로 표시됨을 의미합니다. 예를 들어, Haskell &lt;code&gt;Int&lt;/code&gt; 의 표현은 2 워드 힙 객체입니다. 그러나 박스 형태가 아닌 유형은 값 자체로 표시되며 포인터 나 힙 할당은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26a91b89d1f0afee1a3b838d3e07c9dda8c7019a" translate="yes" xml:space="preserve">
          <source>Most users don&amp;rsquo;t need to worry about the details described in this section. This discussion is primarily targeted at tooling authors who need to interpret the GHC-specific DWARF annotations contained in compiled binaries.</source>
          <target state="translated">대부분의 사용자는이 섹션에서 설명하는 세부 사항에 대해 걱정할 필요가 없습니다. 이 토론은 주로 컴파일 된 바이너리에 포함 된 GHC 특정 DWARF 주석을 해석해야하는 툴링 작성자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="50978952002c3f3475a398ad4c47f7515dcb5f8c" translate="yes" xml:space="preserve">
          <source>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 ⟨n⟩ 단계 앞으로 이동하십시오. ⟨n⟩는 생략하면 하나입니다. GHCi의 디버깅 기능에 대한 자세한 내용은 &lt;a href=&quot;#tracing&quot;&gt;추적 및 기록&lt;/a&gt; 을 참조하십시오 . 참조 : &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba04ac0c40eac8685578c04462bb11965eb4878" translate="yes" xml:space="preserve">
          <source>Move the last two elements from the end of the first list onto the beginning of the second one.</source>
          <target state="translated">첫 번째 목록의 끝에서 두 번째 요소의 시작 부분으로 마지막 두 요소를 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="2bb8ee2f3add85c2116c7a3a51024dad403c385b" translate="yes" xml:space="preserve">
          <source>MoveFileFlag</source>
          <target state="translated">MoveFileFlag</target>
        </trans-unit>
        <trans-unit id="5a8dfd20d44353d4ab01bf308e18462987143fb9" translate="yes" xml:space="preserve">
          <source>Moved to their own module to not bloat GHC.Float further.</source>
          <target state="translated">GHC를 팽창시키지 않기 위해 자체 모듈로 옮겼습니다.</target>
        </trans-unit>
        <trans-unit id="14766b11b99f48495ad4c21d250367a73f20edac" translate="yes" xml:space="preserve">
          <source>Msg</source>
          <target state="translated">Msg</target>
        </trans-unit>
        <trans-unit id="d136009ea859ae789c419997ed8d15cac71cf2c5" translate="yes" xml:space="preserve">
          <source>Much like lists can be constructed and matched using the &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; constructors, sequences can be constructed and matched using the &lt;code&gt;&lt;a href=&quot;data-sequence#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v::-60--124-&quot;&gt;:&amp;lt;|&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v::-124--62-&quot;&gt;:|&amp;gt;&lt;/a&gt;&lt;/code&gt; pattern synonyms.</source>
          <target state="translated">많은 목록을 이용하여 구성과 일치 될 수있다 같이 &lt;code&gt;:&lt;/code&gt; 및 &lt;code&gt;[]&lt;/code&gt; 생성자, 시퀀스들이 사용하여 생성 및 일치 할 수 &lt;code&gt;&lt;a href=&quot;data-sequence#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v::-60--124-&quot;&gt;:&amp;lt;|&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v::-124--62-&quot;&gt;:|&amp;gt;&lt;/a&gt;&lt;/code&gt; 패턴 동의어.</target>
        </trans-unit>
        <trans-unit id="3985ab0ae942e14710d14c6d2571f7087252a32c" translate="yes" xml:space="preserve">
          <source>Much of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s interface can be implemented with &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt;. Some of the rest can be implemented with a new &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; function and either &lt;code&gt;&lt;a href=&quot;data-monoid#t:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-monoid#t:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">대부분의 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 인터페이스는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 로 구현할 수 있습니다 . 나머지는 새로운 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 함수와 &lt;code&gt;&lt;a href=&quot;data-monoid#t:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 로 구현할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="ae55e00af65836b6d405f596f97e4f57bbe9ffb4" translate="yes" xml:space="preserve">
          <source>MulArrowT</source>
          <target state="translated">MulArrowT</target>
        </trans-unit>
        <trans-unit id="5cc6d803a39452a5550042d0878f9a4d2b3338ea" translate="yes" xml:space="preserve">
          <source>Multi-parameter type classes are permitted, with extension &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 다중 매개 변수 유형 클래스가 허용됩니다. . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="791ab6cd505e26e3db8530867157bb7dff3226cc" translate="yes" xml:space="preserve">
          <source>Multi-signal a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">다중 신호 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb0ebb79c7eefbdf0b5b3cf945169c1e60647b5a" translate="yes" xml:space="preserve">
          <source>Multi-way Trees and Forests</source>
          <target state="translated">다 방향 나무와 숲</target>
        </trans-unit>
        <trans-unit id="639132eb39afa461a8de30e021cb71678c2bd9f6" translate="yes" xml:space="preserve">
          <source>Multi-way if expressions introduce a new layout context. So the example above is equivalent to:</source>
          <target state="translated">다 방향 if 식에 새로운 레이아웃 컨텍스트가 도입되었습니다. 따라서 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9be2f47cbdcfe4a4ba58091a84da2eccde0463fc" translate="yes" xml:space="preserve">
          <source>MultiParamTypeClasses</source>
          <target state="translated">MultiParamTypeClasses</target>
        </trans-unit>
        <trans-unit id="16bfc155ed662e5fdfa3b7a44cb917e2896838df" translate="yes" xml:space="preserve">
          <source>MultiShot</source>
          <target state="translated">MultiShot</target>
        </trans-unit>
        <trans-unit id="7081cd2ce6a6f92ebb8e5d3af341d3d4335873da" translate="yes" xml:space="preserve">
          <source>MultiWayIf</source>
          <target state="translated">MultiWayIf</target>
        </trans-unit>
        <trans-unit id="0393d78dbbfc9e70fdf48e5344e361858dbe507c" translate="yes" xml:space="preserve">
          <source>Multiline mode is useful when entering monadic &lt;code&gt;do&lt;/code&gt; statements:</source>
          <target state="translated">여러 줄 모드는 monadic &lt;code&gt;do&lt;/code&gt; 문을 입력 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="2e295ccb8d7c53c8f3ea7ba9cfb2f93b20c6dd1d" translate="yes" xml:space="preserve">
          <source>Multiplication of type-level naturals.</source>
          <target state="translated">유형 수준의 자연의 곱셈.</target>
        </trans-unit>
        <trans-unit id="c3daf9662fef96010a16df2f6f60f2f626bb4ea3" translate="yes" xml:space="preserve">
          <source>Multiplicity polymorphism is incomplete and experimental. You may have success using it, or you may not. Expect it to be really unreliable.</source>
          <target state="translated">다중성 다형성은 불완전하고 실험적입니다. 당신은 그것을 사용하여 성공할 수도 있고 그렇지 않을 수도 있습니다. 정말 신뢰할 수 없을 것으로 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="abaf136782049164460366f9afe2dee04f6b2e91" translate="yes" xml:space="preserve">
          <source>Multiply two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">곱하기 두 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="909b32ffe66a26d38ff55c0ae1de2d5a81a56aaf" translate="yes" xml:space="preserve">
          <source>Multiply two vectors element-wise.</source>
          <target state="translated">두 벡터를 요소별로 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="05a69b1ec67732f09635ef86734c3b1a99517a9c" translate="yes" xml:space="preserve">
          <source>Multiply-defined array elements not checked</source>
          <target state="translated">곱하기 정의 된 배열 요소가 확인되지 않음</target>
        </trans-unit>
        <trans-unit id="5848ccab6e8123c4df2d4c1561fe81cd64b56b8f" translate="yes" xml:space="preserve">
          <source>MutVar#</source>
          <target state="translated">MutVar#</target>
        </trans-unit>
        <trans-unit id="52b9d6898e795eda124f4c552cab7ce01664480c" translate="yes" xml:space="preserve">
          <source>Mutable array type, for use in the ST monad.</source>
          <target state="translated">ST 모나드에서 사용하기위한 가변 배열 유형.</target>
        </trans-unit>
        <trans-unit id="215e56b349d3105e5186b842d419bb7207c023b0" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드 에서 가변 박스형 및 박스형 배열 .</target>
        </trans-unit>
        <trans-unit id="515636c71d60349203d8732bedde03c1e6d4b604" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드 에서 가변 박스형 및 박스형 배열 .</target>
        </trans-unit>
        <trans-unit id="2c7c15d19968866fe48793de76acdf671dc080e3" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능한 boxed 및 unboxed 배열 .</target>
        </trans-unit>
        <trans-unit id="31247b9a8722b87ffd65d7883ea3909ce04233ac" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능한 boxed 및 unboxed 배열 .</target>
        </trans-unit>
        <trans-unit id="8f85576fded6d39e38070c85bed31a7dca70f0a1" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능한 boxed 및 unboxed 배열 .</target>
        </trans-unit>
        <trans-unit id="619a054c943d7350b1a002ab683879f563a166f9" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능한 boxed 및 unboxed 배열 .</target>
        </trans-unit>
        <trans-unit id="3bcf35d6b49f587009acea897dbec9a7205cd79b" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the IO monad.</source>
          <target state="translated">IO 모나드의 가변 박스 및 언 박스 어레이.</target>
        </trans-unit>
        <trans-unit id="440cc7a8eb8ee990439d9b0c275e863e6bd50dfb" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the IO monad. . Safe API only of &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;.</source>
          <target state="translated">IO 모나드의 가변 박스 및 언 박스 어레이. . &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO의&lt;/a&gt; 안전한 API 만 .</target>
        </trans-unit>
        <trans-unit id="3fb3ae51bcbb4d7a420b0ebdc8a4c6115c91d585" translate="yes" xml:space="preserve">
          <source>Mutable references in the (strict) ST monad.</source>
          <target state="translated">(엄격한) ST 모나드의 가변 참조.</target>
        </trans-unit>
        <trans-unit id="42749e4461b51d539ec768df8df05dca87a2bacc" translate="yes" xml:space="preserve">
          <source>Mutable references in the IO monad.</source>
          <target state="translated">IO 모나드의 가변 참조.</target>
        </trans-unit>
        <trans-unit id="1f817ca4b49a2a2210c658ea8fd1e259ead274d2" translate="yes" xml:space="preserve">
          <source>Mutable references in the lazy ST monad.</source>
          <target state="translated">게으른 ST 모나드의 가변 참조.</target>
        </trans-unit>
        <trans-unit id="04916e4ec1fe3dc428e8538332487b612dc2bd11" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 에서 가변적이고 박스형이며 엄격하지 않은 어레이 모나드 . 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="211618f366b0b487ea1225369f9859d9b05e4ebf" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 가변, 박스형, 비 엄격 배열 . 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11382766a0d791915a7503d6ac8e7df2555a1f47" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드의 가변, 박스형, 비 엄격 배열 . 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48f88ae9ac44602611ed4f45283d41180f01bbf0" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드 에서 가변적이고 박스형이며 엄격하지 않은 배열 . 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cb43316285255ffc42363e8387f0053efdb7cd7" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 가변적이고 박스가없는 엄격한 배열 . 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a301c7b2f899d4e9c83b2d431bcea04bd569480b" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능하고 박싱되지 않은 엄격한 배열 . 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1956fd705ef698a7aa6808b42979d8096d57754" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드의 변경 가능하고 박싱되지 않은 엄격한 배열 . 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9925971623b1ac9311a057c1e6621841f8a448f7" translate="yes" xml:space="preserve">
          <source>MutableArray#</source>
          <target state="translated">MutableArray#</target>
        </trans-unit>
        <trans-unit id="40bb1cc17c060c6bd43dbf016d618af652f8c837" translate="yes" xml:space="preserve">
          <source>MutableArrayArray#</source>
          <target state="translated">MutableArrayArray#</target>
        </trans-unit>
        <trans-unit id="68b676eacbb0a7843cf46324a527ccbb0beed645" translate="yes" xml:space="preserve">
          <source>MutableByteArray#</source>
          <target state="translated">MutableByteArray#</target>
        </trans-unit>
        <trans-unit id="ddc210a400b5481a3abcf1bcd6083f807abd8b39" translate="yes" xml:space="preserve">
          <source>Mutate the contents of a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;N.B.&lt;/em&gt;, this version is non-strict.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 의 내용을 변경하십시오 . &lt;em&gt;NB&lt;/em&gt; ,이 버전은 엄격하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29f6dd6604a4083b037e5b08c77d32e780b2deac" translate="yes" xml:space="preserve">
          <source>Mutate the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 의 내용을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="65a480fe4d2e3102f2ecc2852d563e994ffa8ae8" translate="yes" xml:space="preserve">
          <source>Mutate the contents of an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 의 내용을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="beef505a6a01c0417026ebb4ed6aa4fbdd93ebfe" translate="yes" xml:space="preserve">
          <source>Mutation: In both &lt;code&gt;foreign import unsafe&lt;/code&gt; and &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls, it is safe to mutate a &lt;code&gt;MutableByteArray&lt;/code&gt;. Mutating any other type of array leads to undefined behavior. Reason: Mutable arrays of heap objects record writes for the purpose of garbage collection. An array of heap objects is passed to a foreign C function, the runtime does not record any writes. Consequently, it is not safe to write to an array of heap objects in a foreign function. Since the runtime has no facilities for tracking mutation of a &lt;code&gt;MutableByteArray#&lt;/code&gt;, these can be safely mutated in any foreign function.</source>
          <target state="translated">Mutation : &lt;code&gt;foreign import unsafe&lt;/code&gt; 및 &lt;code&gt;foreign import safe&lt;/code&gt; FFI 호출 모두 에서 &lt;code&gt;MutableByteArray&lt;/code&gt; 를 변경하는 것이 안전합니다 . 다른 유형의 배열을 변경하면 정의되지 않은 동작이 발생합니다. 이유 : 힙 개체의 가변 배열은 가비지 수집을 위해 쓰기를 기록합니다. 힙 개체의 배열은 외부 C 함수에 전달되며 런타임은 쓰기를 기록하지 않습니다. 따라서 외부 함수의 힙 개체 배열에 쓰는 것은 안전하지 않습니다. 런타임에는 &lt;code&gt;MutableByteArray#&lt;/code&gt; 변이를 추적 할 수있는 기능 이 없기 때문에 외부 함수에서 안전하게 변이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18d35073b15c0f266e315c4a406057c1c9e30791" translate="yes" xml:space="preserve">
          <source>NB! This is a legacy feature, see &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/a&gt; for the modern replacement.</source>
          <target state="translated">NB! 이것은 레거시 기능 입니다. 최신 대체는 &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt; &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4bc7da7f8019e6ba579c7168ed8ef8e123de9f" translate="yes" xml:space="preserve">
          <source>NB. Be very careful with these finalizers. One common trap is that if a finalizer references another finalized value, it does not prevent that value from being finalized. In particular, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s are finalized objects, so a finalizer should not refer to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">NB. 이 마무리 장치에 매우주의하십시오. 하나의 일반적인 함정은 종료자가 다른 최종 값을 참조하는 경우 해당 값이 종료되는 것을 막지 않는다는 것입니다. 특히 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 종료 된 객체이므로 종료자는 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 포함)을 참조하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="374a0e14aef11d696ae0e12a6af249af24d04c07" translate="yes" xml:space="preserve">
          <source>NB. This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">NB. 이 매크로는 Haskell 모듈에서 생성 된 C 소스 (예 : &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; 및 &lt;code&gt;.hc&lt;/code&gt; 파일)를 포함하여 Haskell 소스와 C 소스를 사전 처리 할 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef6198823084d192389d02aee66353f70e110347" translate="yes" xml:space="preserve">
          <source>NB: &lt;code&gt;isValidBigNat# nullBigNat&lt;/code&gt; is false</source>
          <target state="translated">NB : &lt;code&gt;isValidBigNat# nullBigNat&lt;/code&gt; 이 거짓</target>
        </trans-unit>
        <trans-unit id="ccbbb1b26af40cc778cde005c4f658b4a6d44e97" translate="yes" xml:space="preserve">
          <source>NB: This treatment of superclasses goes beyond &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;the paper&lt;/a&gt;, but is specifically desired by users.</source>
          <target state="translated">주의 :이 수퍼 클래스의 처리 &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;는 논문을&lt;/a&gt; 넘어서는 것이지만, 사용자가 특별히 요구합니다.</target>
        </trans-unit>
        <trans-unit id="5cfb84a3255f99b3a5dc5c0b199025e1ab8a956d" translate="yes" xml:space="preserve">
          <source>NFData</source>
          <target state="translated">NFData</target>
        </trans-unit>
        <trans-unit id="8bef8898d5726a9645ab52735e823a1b3b2a58ed" translate="yes" xml:space="preserve">
          <source>NFData1</source>
          <target state="translated">NFData1</target>
        </trans-unit>
        <trans-unit id="418a51c8aef1b7b43f9f69603188a3fc934fb298" translate="yes" xml:space="preserve">
          <source>NFData2</source>
          <target state="translated">NFData2</target>
        </trans-unit>
        <trans-unit id="8157bf312f87194c1b8385054be3f190c76145cd" translate="yes" xml:space="preserve">
          <source>NLSVERSIONINFOEX</source>
          <target state="translated">NLSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="a74c32096f555276472737ff5840787516207d4d" translate="yes" xml:space="preserve">
          <source>NOTE for GHC users: unless you use the &lt;code&gt;-threaded&lt;/code&gt; flag, &lt;code&gt;hWaitForInput hdl t&lt;/code&gt; where &lt;code&gt;t &amp;gt;= 0&lt;/code&gt; will block all other Haskell threads for the duration of the call. It behaves like a &lt;code&gt;safe&lt;/code&gt; foreign call in this respect.</source>
          <target state="translated">GHC 사용자를위한 참고 : 사용하지 않는 &lt;code&gt;-threaded&lt;/code&gt; 플래그, &lt;code&gt;hWaitForInput hdl t&lt;/code&gt; &lt;code&gt;t &amp;gt;= 0&lt;/code&gt; 호출의 기간 동안 다른 모든 하스켈 스레드를 차단됩니다. 이 점에서 그것은 &lt;code&gt;safe&lt;/code&gt; 외침 처럼 행동 합니다.</target>
        </trans-unit>
        <trans-unit id="f8bec3400a00d95de2aca056e95477c68ba1eb54" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; may block, because it has to attempt to read from the stream to determine whether there is any more data to be read.</source>
          <target state="translated">참고 : &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 는 더 이상 읽을 데이터가 있는지 확인하기 위해 스트림에서 읽으려고 시도하기 때문에 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e177a44ba2f2969ccf14799a97fd335989430f30" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; may block, because it has to attempt to read from the stream to determine whether there is any more data to be read.</source>
          <target state="translated">참고 : &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 는 더 이상 읽을 데이터가 있는지 확인하기 위해 스트림에서 읽으려고 시도하기 때문에 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1bbe2aede4f3fac96050d9ca6e8622d57dc7d43" translate="yes" xml:space="preserve">
          <source>NOTE: Since this library is built on top of the curses interface, it is not thread-safe.</source>
          <target state="translated">참고 :이 라이브러리는 curses 인터페이스 위에 구축되므로 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63561186ffbbc0f2e4ac1c402f5b46d5450d885c" translate="yes" xml:space="preserve">
          <source>NOTE: The implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt; is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">참고 : 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 은 구현 세부 사항이며 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73283dfca92bcfe835f52a5a26a21a5f2a2e5acc" translate="yes" xml:space="preserve">
          <source>NOTE: The implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt; is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">참고 : 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 은 구현 세부 사항이며 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98b32b5a6dce9bba2f73fac9f444388673ea544d" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">참고 : 대담한 사용자는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 이 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 의 별칭 일뿐 입니다. 이것은 구현 세부 사항이며 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4652f803bbd5a4299b501fa174c8494ddc7084c" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">참고 : 대담한 사용자는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 이 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 의 별칭 일뿐 입니다. 이것은 구현 세부 사항이며 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04964a8b393aeb4c81203022d841d735724a3657" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">참고 : 대담한 사용자는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 이 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 의 별칭 일뿐 입니다. 이것은 구현 세부 사항이며 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a3caaaf7af6b131af05747420d7f407dc4b9e0" translate="yes" xml:space="preserve">
          <source>NOTE: createHardLink is &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatibility for Unix.</source>
          <target state="translated">참고 : createHardLink는 Unix에 대한 호환성을 제공하기 위해 &lt;em&gt;반전 된 인수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="173f40eb49608b0a9f5c7dfe7826130ac61ad0f2" translate="yes" xml:space="preserve">
          <source>NOTE: createHardLink is &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatiblity for Unix.</source>
          <target state="translated">참고 : createHardLink는 Unix에 대한 호환성을 제공하기 위해 &lt;em&gt;인수&lt;/em&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="4d19907a6a79e56c857a5f3e68218d937122f148" translate="yes" xml:space="preserve">
          <source>NOTE: createSymbolicLink* functions are &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatibility for Unix, except &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : createSymbolicLink * 함수는 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 제외하고 Unix에 대한 호환성을 제공하기 위해 &lt;em&gt;반전 된 인수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65538d1f35d9ff80cfc7afb1ba3058d20b90d2b2" translate="yes" xml:space="preserve">
          <source>NOTE: createSymbolicLink* functions are &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatiblity for Unix, except &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : createSymbolicLink * 함수는 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 제외하고 Unix에 대한 호환성을 제공하기 위해 &lt;em&gt;인수&lt;/em&gt; 가 &lt;em&gt;뒤집 &lt;/em&gt;힙니다 .</target>
        </trans-unit>
        <trans-unit id="9a289febc0a62ac0fd3ddf47889458ad201b28af" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : Windows에서이 기능은 올바르게 작동하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="27648f423ffb7efa59e5c0832d0545992c2e7a71" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : Windows에서이 기능은 올바르게 작동하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="a2f5862ab04e7d70c9d237cade16ad082f1f892f" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : Windows에서이 기능은 올바르게 작동하지 않습니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="217551d8f091b6742427b78f8d4d21b8576d5bcf" translate="yes" xml:space="preserve">
          <source>NPlusKPatterns</source>
          <target state="translated">NPlusKPatterns</target>
        </trans-unit>
        <trans-unit id="16011665a1d6a1793f7af5691f78690f7db8e797" translate="yes" xml:space="preserve">
          <source>NT namespace: &lt;code&gt;\&lt;/code&gt;</source>
          <target state="translated">NT 네임 스페이스 : &lt;code&gt;\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09b181fc210e2f1a3662ae262c26a3cf3bb2036d" translate="yes" xml:space="preserve">
          <source>NTFS only supprts this functionality.</source>
          <target state="translated">NTFS는이 기능 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="e11bc388c83c1b8b82ae73a235837ab0ef1b8869" translate="yes" xml:space="preserve">
          <source>Name lookup</source>
          <target state="translated">이름 조회</target>
        </trans-unit>
        <trans-unit id="c1dd5c5a3c784d1dc660322bd2d8b0aadd9447a3" translate="yes" xml:space="preserve">
          <source>Name of the Haskell file.</source>
          <target state="translated">하스켈 파일의 이름.</target>
        </trans-unit>
        <trans-unit id="d34370b884a4e0c6661e9211124b058e6efe6336" translate="yes" xml:space="preserve">
          <source>Name of the module where the static pointer is defined</source>
          <target state="translated">정적 포인터가 정의 된 모듈의 이름</target>
        </trans-unit>
        <trans-unit id="241f55c9dbd4332d828c31c2528891c3f79c4291" translate="yes" xml:space="preserve">
          <source>NameFlavour</source>
          <target state="translated">NameFlavour</target>
        </trans-unit>
        <trans-unit id="43bd2e139f7efc3fb707f38288858777f7d29f55" translate="yes" xml:space="preserve">
          <source>NameIs</source>
          <target state="translated">NameIs</target>
        </trans-unit>
        <trans-unit id="e784a5acc01d14b30b1b161e2114eac0f9da4a44" translate="yes" xml:space="preserve">
          <source>NameS</source>
          <target state="translated">NameS</target>
        </trans-unit>
        <trans-unit id="285f33209f1413ce6482de704071ed860f4ee1f7" translate="yes" xml:space="preserve">
          <source>NameSpace</source>
          <target state="translated">NameSpace</target>
        </trans-unit>
        <trans-unit id="af5f97c76eceeda41176655ffdf797f38db674a9" translate="yes" xml:space="preserve">
          <source>Named arguments can also be given explicit kind signatures if needed. Just as with &lt;a href=&quot;#gadt&quot;&gt;GADT declarations&lt;/a&gt; named arguments are entirely optional, so that we can declare &lt;code&gt;Array&lt;/code&gt; alternatively with</source>
          <target state="translated">필요한 경우 명명 된 인수에 명시 적 종류 서명을 부여 할 수도 있습니다. &lt;a href=&quot;#gadt&quot;&gt;GADT 선언&lt;/a&gt; 과 마찬가지로 arguments라는 이름은 전적으로 선택 사항이므로 다음과 같이 &lt;code&gt;Array&lt;/code&gt; 를 대신 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62d156320deceb36f700d974fa40eaf6fd11436" translate="yes" xml:space="preserve">
          <source>Named arguments can also be given explicit kind signatures if needed. Just as with &lt;a href=&quot;gadt#gadt&quot;&gt;GADT declarations&lt;/a&gt; named arguments are entirely optional, so that we can declare &lt;code&gt;Array&lt;/code&gt; alternatively with</source>
          <target state="translated">필요한 경우 명명 된 인수에 명시적인 종류 서명을 지정할 수도 있습니다. &lt;a href=&quot;gadt#gadt&quot;&gt;GADT 선언&lt;/a&gt; 과 마찬가지로 명명 된 인수는 전적으로 선택 사항이므로 다음을 사용 하여 &lt;code&gt;Array&lt;/code&gt; 를 교대로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="453d20a6d115195746f780ef6b881f77130889c3" translate="yes" xml:space="preserve">
          <source>Named wildcards &lt;em&gt;should not be confused with type variables&lt;/em&gt;. Even though syntactically similar, named wildcards can unify with monotypes as well as be generalised over (and behave as type variables).</source>
          <target state="translated">명명 된 와일드 카드 &lt;em&gt;를 유형 변수와 혼동해서는 안됩니다&lt;/em&gt; . 구문 상 유사하지만 명명 된 와일드 카드는 단일 유형과 통합 할 수있을뿐만 아니라 일반화 할 수 있으며 유형 변수로 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd83b1022b74e5c3478447290339e566cb15ae5" translate="yes" xml:space="preserve">
          <source>NamedWildCards</source>
          <target state="translated">NamedWildCards</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="b2390be51f0839e05354a4edc7bfb9b402fb9775" translate="yes" xml:space="preserve">
          <source>Names constructed using &lt;code&gt;newName&lt;/code&gt; and &lt;code&gt;mkName&lt;/code&gt; may be used in bindings (such as &lt;code&gt;let x = ...&lt;/code&gt; or &lt;code&gt;x -&amp;gt; ...&lt;/code&gt;), but names constructed using &lt;code&gt;lookupValueName&lt;/code&gt;, &lt;code&gt;lookupTypeName&lt;/code&gt;, &lt;code&gt;'f&lt;/code&gt;, &lt;code&gt;''T&lt;/code&gt; may not.</source>
          <target state="translated">&lt;code&gt;newName&lt;/code&gt; 및 &lt;code&gt;mkName&lt;/code&gt; 을 사용하여 생성 된 이름 은 바인딩 (예 : &lt;code&gt;let x = ...&lt;/code&gt; 또는 &lt;code&gt;x -&amp;gt; ...&lt;/code&gt; )에 &lt;code&gt;lookupValueName&lt;/code&gt; 있지만 lookupValueName , &lt;code&gt;lookupTypeName&lt;/code&gt; , &lt;code&gt;'f&lt;/code&gt; , &lt;code&gt;''T&lt;/code&gt; 사용하여 생성 된 이름 은 그렇지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34803b64f16548b242233b7132d75f6e5f8fe8e6" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">명명 규칙</target>
        </trans-unit>
        <trans-unit id="9f71fd1007f8c4abc458163409fae654630b9e86" translate="yes" xml:space="preserve">
          <source>Nano</source>
          <target state="translated">Nano</target>
        </trans-unit>
        <trans-unit id="2e3e963e975a60a6a8a003da6ed817e4d4499a19" translate="yes" xml:space="preserve">
          <source>Nat</source>
          <target state="translated">Nat</target>
        </trans-unit>
        <trans-unit id="fcc28bb1503dac338f555a7ce7320bdbab52e7c3" translate="yes" xml:space="preserve">
          <source>Nat Kind</source>
          <target state="translated">낫 종류</target>
        </trans-unit>
        <trans-unit id="7322348943287d68f8c176b2c1566795ccc03b7e" translate="yes" xml:space="preserve">
          <source>Native code generator</source>
          <target state="translated">네이티브 코드 생성기</target>
        </trans-unit>
        <trans-unit id="ea26876daa9a0a0caf49391472053413ac06277e" translate="yes" xml:space="preserve">
          <source>Natural</source>
          <target state="translated">Natural</target>
        </trans-unit>
        <trans-unit id="7f0b8727de826105bbce9ba7b95859488d5a3633" translate="yes" xml:space="preserve">
          <source>Natural number</source>
          <target state="translated">자연수</target>
        </trans-unit>
        <trans-unit id="6dfc30c819c79fca570a6d67601933511b292394" translate="yes" xml:space="preserve">
          <source>Naturality</source>
          <target state="translated">Naturality</target>
        </trans-unit>
        <trans-unit id="a6a233fd10e66b739809092ee7ea7beda5f628ec" translate="yes" xml:space="preserve">
          <source>Nd: Number, Decimal</source>
          <target state="translated">Nd : 숫자, 소수</target>
        </trans-unit>
        <trans-unit id="58af6d921b3520c3002a4fbc054962eb72c7ec5b" translate="yes" xml:space="preserve">
          <source>Needed to optimize support for different IO Managers on Windows. See Note [The need for getIoManagerFlag]</source>
          <target state="translated">Windows에서 다른 IO 관리자에 대한 지원을 최적화하는 데 필요합니다. 참고 [getIoManagerFlag의 필요성]을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee52746bd96005ef182ba2d9b60655a4e0ac20d1" translate="yes" xml:space="preserve">
          <source>Negate &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">부정 게이트 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06b8058bc282e46c01399ffa04dcfaf5551d96ef" translate="yes" xml:space="preserve">
          <source>Negate element-wise.</source>
          <target state="translated">요소별로 부정하십시오.</target>
        </trans-unit>
        <trans-unit id="1c22f0963e34858feada46efcb0a5e32c38f2754" translate="yes" xml:space="preserve">
          <source>Negation (e.g. &amp;ldquo;&lt;code&gt;- (f x)&lt;/code&gt;&amp;rdquo;) means &amp;ldquo;&lt;code&gt;negate (f x)&lt;/code&gt;&amp;rdquo;, both in numeric patterns, and expressions.</source>
          <target state="translated">부정 (예 :&amp;ldquo; &lt;code&gt;- (f x)&lt;/code&gt; &amp;rdquo;)은 숫자 패턴과 표현식 모두에서 &amp;ldquo; &lt;code&gt;negate (f x)&lt;/code&gt; &amp;rdquo;을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="dd048e1f91db2495004257dbd5282e263424faee" translate="yes" xml:space="preserve">
          <source>Negative exponents are supported if an inverse modulo &lt;code&gt;&lt;em&gt;m&lt;/em&gt;&lt;/code&gt; exists.</source>
          <target state="translated">역 모듈로 &lt;code&gt;&lt;em&gt;m&lt;/em&gt;&lt;/code&gt; 이 존재 하면 음의 지수가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4f4481fb4d6d71c0fcfc0047e37c0bbb90861f5" translate="yes" xml:space="preserve">
          <source>Negative literals, such as &lt;code&gt;-3&lt;/code&gt;, are specified by (a careful reading of) the Haskell Report as meaning &lt;code&gt;Prelude.negate (Prelude.fromInteger 3)&lt;/code&gt;. So &lt;code&gt;-2147483648&lt;/code&gt; means &lt;code&gt;negate (fromInteger 2147483648)&lt;/code&gt;. Since &lt;code&gt;fromInteger&lt;/code&gt; takes the lower 32 bits of the representation, &lt;code&gt;fromInteger (2147483648::Integer)&lt;/code&gt;, computed at type &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;-2147483648::Int&lt;/code&gt;. The &lt;code&gt;negate&lt;/code&gt; operation then overflows, but it is unchecked, so &lt;code&gt;negate (-2147483648::Int)&lt;/code&gt; is just &lt;code&gt;-2147483648&lt;/code&gt;. In short, one can write &lt;code&gt;minBound::Int&lt;/code&gt; as a literal with the expected meaning (but that is not in general guaranteed).</source>
          <target state="translated">&lt;code&gt;-3&lt;/code&gt; 과 같은 음수 리터럴 은 Haskell 보고서를 &lt;code&gt;Prelude.negate (Prelude.fromInteger 3)&lt;/code&gt; 를 의미하는 것으로 신중하게 읽습니다 . 따라서 &lt;code&gt;-2147483648&lt;/code&gt; 은 &lt;code&gt;negate (fromInteger 2147483648)&lt;/code&gt; 의미합니다 (fromInteger 2147483648) . 이후 &lt;code&gt;fromInteger&lt;/code&gt; 은 표현의 하위 32 개 비트를 얻어, &lt;code&gt;fromInteger (2147483648::Integer)&lt;/code&gt; 종류에서 계산, &lt;code&gt;Int&lt;/code&gt; 이다 &lt;code&gt;-2147483648::Int&lt;/code&gt; . &lt;code&gt;negate&lt;/code&gt; 작업은 오버 플로우하지만, 그래서, 선택하지 않은 &lt;code&gt;negate (-2147483648::Int)&lt;/code&gt; 그냥 &lt;code&gt;-2147483648&lt;/code&gt; . 간단히 말해 &lt;code&gt;minBound::Int&lt;/code&gt; 작성할 수 있습니다. 예상되는 의미의 리터럴로 (그러나 일반적으로 보장되는 것은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="3e0a90cf89e0e38e6ded6a27d6e570ec770c082d" translate="yes" xml:space="preserve">
          <source>Negative numbers must be parenthesized when they appear in function argument position. &lt;code&gt;f (-5)&lt;/code&gt; is correct, whereas &lt;code&gt;f -5&lt;/code&gt; is parsed as &lt;code&gt;(-) f 5&lt;/code&gt;.</source>
          <target state="translated">음수는 함수 인수 위치에 나타날 때 괄호로 묶어야합니다. &lt;code&gt;f (-5)&lt;/code&gt; 는 정확하지만 &lt;code&gt;f -5&lt;/code&gt; 는 &lt;code&gt;(-) f 5&lt;/code&gt; 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d52baec47edee13dda9979236d74b3a6e53bb526" translate="yes" xml:space="preserve">
          <source>Negative precision is taken as 0. The meaning of the precision depends on the conversion type.</source>
          <target state="translated">음의 정밀도는 0으로 간주됩니다. 정밀도의 의미는 변환 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f622cbbe6dc0bf9f80a40c77e1e302b16367df00" translate="yes" xml:space="preserve">
          <source>NegativeLiterals</source>
          <target state="translated">NegativeLiterals</target>
        </trans-unit>
        <trans-unit id="ac634bf99f709c9e754d7e578de589c844f2186a" translate="yes" xml:space="preserve">
          <source>Neither name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">사전 서면 허가 없이는이 소프트웨어에서 파생 된 제품을 보증하거나 홍보하는 데 대학 이름이나 기여자의 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="522182dd21569f6be17220e3cac4e333aa5e69ba" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">주어진 위치 수만큼 문서를 중첩 (또는 들여 쓰기)합니다 (음수 일 수도 있음). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 는 법을 충족시킵니다 :</target>
        </trans-unit>
        <trans-unit id="949a22e40a67eb32fd127980e8bf7757812da720" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">주어진 위치 수만큼 문서를 중첩 (또는 들여 쓰기)합니다 (음수 일 수도 있음). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 는 법을 충족시킵니다 :</target>
        </trans-unit>
        <trans-unit id="2fd44f8ebe0a7e3b2bea5c918f154b8513f223e1" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">주어진 위치 수만큼 문서를 중첩 (또는 들여 쓰기)합니다 (음수 일 수도 있음). &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 는 법을 충족시킵니다 :</target>
        </trans-unit>
        <trans-unit id="2344677d8f01e8e2fca317a5c561cc80f092e37c" translate="yes" xml:space="preserve">
          <source>Nested</source>
          <target state="translated">Nested</target>
        </trans-unit>
        <trans-unit id="720741a1472872a68ca3c388c3c11a286d659bd3" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;do&lt;/code&gt; blocks do not affect each other&amp;rsquo;s meanings.</source>
          <target state="translated">중첩 된 &lt;code&gt;do&lt;/code&gt; 블록은 서로의 의미에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d67a4e0cdcad34714be98100536800680402b530" translate="yes" xml:space="preserve">
          <source>NestedAtomically</source>
          <target state="translated">NestedAtomically</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="a2577c561d86f6ba3c73b6eefeafce792f6e11cc" translate="yes" xml:space="preserve">
          <source>Nevertheless one can pretend that the following three kinds of instances exist. First, as a trivial base-case:</source>
          <target state="translated">그럼에도 불구하고 다음 세 종류의 인스턴스가 존재하는 것처럼 가장 할 수 있습니다. 먼저 사소한 기본 사례 :</target>
        </trans-unit>
        <trans-unit id="cfe594798e5ee5a9536eb68772725a21269ab358" translate="yes" xml:space="preserve">
          <source>New parsing functions</source>
          <target state="translated">새로운 파싱 함수</target>
        </trans-unit>
        <trans-unit id="1523c8acdb2ee4d7786ae768261d0c785a7a6dd4" translate="yes" xml:space="preserve">
          <source>New path</source>
          <target state="translated">새로운 길</target>
        </trans-unit>
        <trans-unit id="2f086c7950ef417a974e200114c1f6896effacb4" translate="yes" xml:space="preserve">
          <source>New reserved words and symbols: character sequences which are no longer available for use as identifiers in the program.</source>
          <target state="translated">새로운 예약어 및 기호 : 더 이상 프로그램에서 식별자로 사용할 수없는 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="2b86793d71ec22bae7c09d67603a4b5ca57fee12" translate="yes" xml:space="preserve">
          <source>New size of array</source>
          <target state="translated">새로운 크기의 어레이</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="08342fdb7e4d5979ac614e4583b9d664b9d3d88c" translate="yes" xml:space="preserve">
          <source>Newline conversion</source>
          <target state="translated">개행 변환</target>
        </trans-unit>
        <trans-unit id="ada069b2de824a0d3a8b152fde78626a8e8b8ade" translate="yes" xml:space="preserve">
          <source>NewlineMode</source>
          <target state="translated">NewlineMode</target>
        </trans-unit>
        <trans-unit id="9b709dfae84cfac1c978bbe397d4df6e001163d1" translate="yes" xml:space="preserve">
          <source>Newly created slots initialized to this element. Only used when array is grown.</source>
          <target state="translated">이 요소로 초기화 된 새로 생성 된 슬롯입니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 어레이가 커질 때만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d70c1effde2f8c015bfb84f7838e84613e007f3" translate="yes" xml:space="preserve">
          <source>NewtypeStrategy</source>
          <target state="translated">NewtypeStrategy</target>
        </trans-unit>
        <trans-unit id="ca33c65ffa7a8e2e461597acbdf8adbf2c6312c3" translate="yes" xml:space="preserve">
          <source>Newtypes are better than datatypes:</source>
          <target state="translated">새로운 유형이 데이터 유형보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bb1a13dad76ab6476212d16d134ffcbc89390074" translate="yes" xml:space="preserve">
          <source>Next free byte in current &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 의 다음 빈 바이트</target>
        </trans-unit>
        <trans-unit id="4ae9c52b894383b8025369fa03e4f1485c55d887" translate="yes" xml:space="preserve">
          <source>Next free byte in current &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 의 다음 빈 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="6ae27512f7d04b93e6ab0f5a142fdb6a159a3a6d" translate="yes" xml:space="preserve">
          <source>Next position calculating function.</source>
          <target state="translated">다음 위치 계산 기능.</target>
        </trans-unit>
        <trans-unit id="499df2c9156f9e7492c202932262c12764a363a7" translate="yes" xml:space="preserve">
          <source>Next there is information about the garbage collections done. For each generation it says how many garbage collections were done, how many of those collections were done in parallel, the total CPU time used for garbage collecting that generation, and the total wall clock time elapsed while garbage collecting that generation.</source>
          <target state="translated">다음은 가비지 수집에 대한 정보입니다. 각 세대마다 가비지 콜렉션 수, 병렬로 수행 된 콜렉션 수, 해당 세대 가비지 콜렉션에 사용 된 총 CPU 시간 및 해당 세대 가비지 콜렉션 동안 경과 된 총 벽시계 시간이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="833ff1d27fbdf158e7b505b01c19b8b1b95cec80" translate="yes" xml:space="preserve">
          <source>Next there is the CPU time and wall clock time elapsed broken down by what the runtime system was doing at the time. INIT is the runtime system initialisation. MUT is the mutator time, i.e. the time spent actually running your code. GC is the time spent doing garbage collection. RP is the time spent doing retainer profiling. PROF is the time spent doing other profiling. EXIT is the runtime system shutdown time. And finally, Total is, of course, the total.</source>
          <target state="translated">다음으로 CPU 시스템 시간과 벽시계 시간이 런타임 시스템이 당시 수행 한 작업에 따라 분류되었습니다. INIT는 런타임 시스템 초기화입니다. MUT는 뮤 테이터 시간, 즉 실제로 코드를 실행하는 데 소요 된 시간입니다. GC는 가비지 수집에 소요 된 시간입니다. RP는 리테이너 프로파일 링에 소요 된 시간입니다. PROF는 다른 프로파일 링에 소요 된 시간입니다. EXIT는 런타임 시스템 종료 시간입니다. 그리고 마지막으로 Total은 물론 합계입니다.</target>
        </trans-unit>
        <trans-unit id="6e08ae4fe787b1e828f2d0c8f144343e2fec4132" translate="yes" xml:space="preserve">
          <source>Next to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; there are a few more type constructors that occur in the representations of other datatypes.</source>
          <target state="translated">옆 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 다른 데이터 유형의 표현에서 발생하는 몇 종류 생성자있다.</target>
        </trans-unit>
        <trans-unit id="64a331e6f60cb1a7ad554cbc5ac1d707fce97281" translate="yes" xml:space="preserve">
          <source>Next, it will perform the actions in the &lt;code&gt;actions&lt;/code&gt; list in order from left to right.</source>
          <target state="translated">다음 으로 왼쪽에서 오른쪽으로 &lt;code&gt;actions&lt;/code&gt; 목록 의 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c916da70cd4a32512ca71d70e5cc765d00357df4" translate="yes" xml:space="preserve">
          <source>Nil</source>
          <target state="translated">Nil</target>
        </trans-unit>
        <trans-unit id="01254dc62ba02c8f98ce116687b65348bfae9d10" translate="yes" xml:space="preserve">
          <source>Nils Anders Danielsson 2006</source>
          <target state="translated">닐스 앤더스 다니엘 손 2006</target>
        </trans-unit>
        <trans-unit id="c6b76279a253069e49509991acb2a0fc6c0289e6" translate="yes" xml:space="preserve">
          <source>Nl: Number, Letter</source>
          <target state="translated">Nl : 숫자, 문자</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="e18dd77372be6a1409a708e6d14bcd9b7f68a5f9" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;-RTS&lt;/code&gt; option is required if the runtime-system options extend to the end of the command line, as in this example:</source>
          <target state="translated">어떤 &lt;code&gt;-RTS&lt;/code&gt; 런타임 시스템 옵션이 예에서와 같이 명령 줄 끝에 확장 할 경우 옵션이 필요하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="707c81ee0c3909e525ac07b27c0a7023a5bea3e3" translate="yes" xml:space="preserve">
          <source>No finalizer. If there is no intent to add a finalizer at any point in the future, consider &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:FinalPtr&quot;&gt;FinalPtr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; instead since these perform fewer allocations.</source>
          <target state="translated">종료자가 없습니다. 향후 어느 시점에서나 종료자를 추가 할 의도가없는 경우 할당을 더 적게 수행하므로 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:FinalPtr&quot;&gt;FinalPtr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 을 대신 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="899c963a8035b8eff10bff6d0639741ad4e409cb" translate="yes" xml:space="preserve">
          <source>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first submap less than all elements in the second, and so on).</source>
          <target state="translated">조각의 크기에 대해서는 보증하지 않습니다. 내부적이지만 결정 론적 프로세스가이를 결정합니다. 그러나 리턴 된 조각이 오름차순으로 보장됩니다 (첫 번째 서브맵의 모든 요소가 두 번째의 모든 요소보다 작음 등).</target>
        </trans-unit>
        <trans-unit id="5b4acda8d542358f213b8f3e4e1650164df9bfe7" translate="yes" xml:space="preserve">
          <source>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first subset less than all elements in the second, and so on).</source>
          <target state="translated">조각의 크기에 대해서는 보증하지 않습니다. 내부적이지만 결정 론적 프로세스가이를 결정합니다. 그러나 반환 된 조각이 오름차순으로 보장됩니다 (첫 번째 하위 집합의 모든 요소가 두 번째 요소의 모든 요소보다 적음 등).</target>
        </trans-unit>
        <trans-unit id="77c3849165d91154401b080a528c1f07258f9117" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">들여 쓰기, 무한히 긴 행 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 무시), 명시적인 새 행 (예 : &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; )은 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="d21eb7c7dc916ac561e541148784eed9a679e1bb" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">들여 쓰기, 무한히 긴 행 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 무시), 명시적인 새 행 (예 : &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; )은 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="538a5adae1b6b87754931f19e7d8936b73a4e244" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">들여 쓰기, 무한히 긴 행 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 무시), 명시적인 새 행 (예 : &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; )은 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="cbe83843190c4d65bded786e194509b323e2b4b6" translate="yes" xml:space="preserve">
          <source>No language extension is required to use typed holes. The lexeme &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo; was previously illegal in Haskell, but now has a more informative error message. The lexeme &amp;ldquo;&lt;code&gt;_x&lt;/code&gt;&amp;rdquo; is a perfectly legal variable, and its behaviour is unchanged when it is in scope. For example</source>
          <target state="translated">타입 구멍을 사용하기 위해 언어 확장이 필요하지 않습니다. exeme&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;은 이전에 Haskell에서 불법적 이었으나 이제는보다 유용한 오류 메시지가 있습니다. exeme&amp;ldquo; &lt;code&gt;_x&lt;/code&gt; &amp;rdquo;는 완벽하게 유효한 변수이며 범위 내에있을 때 동작은 변경되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e9413c2cb6cce1148a677bc74e708c4b678606be" translate="yes" xml:space="preserve">
          <source>No longer set the special variable &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="translated">더 이상 특별한 변수를 설정하지 &lt;code&gt;it&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba52b26fd5e250674e73b63230f34aa9f35b6cbc" translate="yes" xml:space="preserve">
          <source>No permissions.</source>
          <target state="translated">권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed1a8e9d366a2d42a52953aa766c21a8b8f47167" translate="yes" xml:space="preserve">
          <source>No thread can be blocked indefinitely on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; unless another thread holds that &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; indefinitely. One usual implementation of this fairness guarantee is that threads blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; are served in a first-in-first-out fashion, but this is not guaranteed in the semantics.</source>
          <target state="translated">다른 스레드가 해당 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 무기한 보유하지 않으면 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 스레드를 무기한으로 차단할 수 없습니다 . 이 공정성 보증의 일반적인 구현 중 하나는 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 차단 된 스레드가 선입 선출 방식으로 제공되지만 의미론에서 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e89a24f8be4016dc5286a75b757316d4b7da6b5e" translate="yes" xml:space="preserve">
          <source>No type variable has more occurrences in the constraint than in the head</source>
          <target state="translated">헤드보다 제약 조건에서 유형 변수가 더 많이 발생하지 않습니다</target>
        </trans-unit>
        <trans-unit id="55d4b4e7dd7bd572505570594fa8970268f4ed9d" translate="yes" xml:space="preserve">
          <source>No variable may have a levity-polymorphic type.</source>
          <target state="translated">어떤 변수도 levity-polymorphic 유형을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8537ab3e90e8c51e2b9081150af774e31041f634" translate="yes" xml:space="preserve">
          <source>No: Number, Other</source>
          <target state="translated">번호 : 기타</target>
        </trans-unit>
        <trans-unit id="fa97e7279198646152703496467a958452203e8b" translate="yes" xml:space="preserve">
          <source>NoBuffering</source>
          <target state="translated">NoBuffering</target>
        </trans-unit>
        <trans-unit id="0d317c9df796aacafead371d325df7dc06bab899" translate="yes" xml:space="preserve">
          <source>NoFinalizers</source>
          <target state="translated">NoFinalizers</target>
        </trans-unit>
        <trans-unit id="187e10d0186766ac8ef38b6b2737dbcd0a0167a3" translate="yes" xml:space="preserve">
          <source>NoFlushOnInterrupt</source>
          <target state="translated">NoFlushOnInterrupt</target>
        </trans-unit>
        <trans-unit id="70c98d57d8ada0b33fa9e5d439c03bb6aa7f0530" translate="yes" xml:space="preserve">
          <source>NoGCStats</source>
          <target state="translated">NoGCStats</target>
        </trans-unit>
        <trans-unit id="e97b63987d7eba398a31aaf58656483d162d92ad" translate="yes" xml:space="preserve">
          <source>NoHeapProfiling</source>
          <target state="translated">NoHeapProfiling</target>
        </trans-unit>
        <trans-unit id="c0bb723db37af9d0e89d2d4da6bdcdd3458e352e" translate="yes" xml:space="preserve">
          <source>NoIO</source>
          <target state="translated">NoIO</target>
        </trans-unit>
        <trans-unit id="6ded8bea31740baa2d151730d57c270b35577c09" translate="yes" xml:space="preserve">
          <source>NoInline</source>
          <target state="translated">NoInline</target>
        </trans-unit>
        <trans-unit id="444ea91c7df550f94f3d747738c1f1a3466e0cc6" translate="yes" xml:space="preserve">
          <source>NoMethodError</source>
          <target state="translated">NoMethodError</target>
        </trans-unit>
        <trans-unit id="0574b23b4939ce65f86fe9caa145b7ac867f74b5" translate="yes" xml:space="preserve">
          <source>NoRep</source>
          <target state="translated">NoRep</target>
        </trans-unit>
        <trans-unit id="1f05476b651d40952a09c240ebf9fac1ee2f0ecf" translate="yes" xml:space="preserve">
          <source>NoSig</source>
          <target state="translated">NoSig</target>
        </trans-unit>
        <trans-unit id="4f1a01f2c1623f4835ba19bede7f20adf4398de2" translate="yes" xml:space="preserve">
          <source>NoSignalSpecificInfo</source>
          <target state="translated">NoSignalSpecificInfo</target>
        </trans-unit>
        <trans-unit id="3d74bf1957091d8e6ef1871b6be8c6329c5dc42a" translate="yes" xml:space="preserve">
          <source>NoSourceStrictness</source>
          <target state="translated">NoSourceStrictness</target>
        </trans-unit>
        <trans-unit id="0c2a4e95086b0b409bb4f59152de8186a4620e2e" translate="yes" xml:space="preserve">
          <source>NoSourceUnpackedness</source>
          <target state="translated">NoSourceUnpackedness</target>
        </trans-unit>
        <trans-unit id="2c12d214fa2aec0228a5d637aa7ea65cc010993a" translate="yes" xml:space="preserve">
          <source>NoSpecConstr</source>
          <target state="translated">NoSpecConstr</target>
        </trans-unit>
        <trans-unit id="c87682f274a125492ffb6e8e300878ad8dfd10c4" translate="yes" xml:space="preserve">
          <source>NoStream</source>
          <target state="translated">NoStream</target>
        </trans-unit>
        <trans-unit id="a07ff5298c0951a2189ecc18db227733a60fe41f" translate="yes" xml:space="preserve">
          <source>NoSuchThing</source>
          <target state="translated">NoSuchThing</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="7b31028629115aecb301b21cc97f7edef2c73b0d" translate="yes" xml:space="preserve">
          <source>Noindex:</source>
          <target state="translated">Noindex:</target>
        </trans-unit>
        <trans-unit id="80e02bcdfb29620da030c45545609a5abf4202d6" translate="yes" xml:space="preserve">
          <source>NominalDiffTime</source>
          <target state="translated">NominalDiffTime</target>
        </trans-unit>
        <trans-unit id="abf94255694225d9e3e43eaf362134e8526f6ae7" translate="yes" xml:space="preserve">
          <source>NominalR</source>
          <target state="translated">NominalR</target>
        </trans-unit>
        <trans-unit id="037918d2c5120c9cbb587548e13bc313033ab3b2" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에 의해 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="20d74269687af42f4b4b46a0d3082a85e712f116" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에 의해 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="807536be49abd7e4ede9ecfbdfd745c107cf953a" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에서 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="25418d52199dc7c513f4cee3f73d6d7310cf1f5c" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에서 포착되지 않습니다. 모든 예외를 포착하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89158cc3bd13635840be9cbac3e6748db2d907e1" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에서 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="712bf5b3c0722204bbfa5e5b29cc7f28e9d26a6a" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에서 포착되지 않습니다. 모든 예외를 포착하려면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="170135375b67e03b02c70f49ab98d2f0cdc114a4" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에 의해 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="07172365937f11c692e2378e135c9de0a6c4fc1d" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">비 I / O 예외는이 변형에 의해 포착되지 않습니다. 모든 예외를 포착하려면 &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a175d95577964fb56cb4711f1d7a40794f1985b" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비 차단 버전의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25aed430b07f146833188f2c98703c7e3ef2511c" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비 차단 버전의 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15bf21e487b389622890a596e34f6fc7e8f358bf" translate="yes" xml:space="preserve">
          <source>Non-breaking space.</source>
          <target state="translated">비파괴 공간.</target>
        </trans-unit>
        <trans-unit id="657f262735772874a296a8f71e1b1c62bf07d9a2" translate="yes" xml:space="preserve">
          <source>Non-empty (and non-strict) list type.</source>
          <target state="translated">비어 있지 않은 (그리고 엄격하지 않은)리스트 타입.</target>
        </trans-unit>
        <trans-unit id="b5705ef9b6ed9ffaa0586c5a035fc344b83d2dc7" translate="yes" xml:space="preserve">
          <source>Non-empty stream transformations</source>
          <target state="translated">비어 있지 않은 스트림 변환</target>
        </trans-unit>
        <trans-unit id="66475509406517f2fea398ae5c038a688074d402" translate="yes" xml:space="preserve">
          <source>Non-empty, possibly infinite, multi-way trees; also known as &lt;em&gt;rose trees&lt;/em&gt;.</source>
          <target state="translated">비어 있지 않고, 무한한 다 방향 나무; &lt;em&gt;장미 나무&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="118fcb6b47ea6e15234cae7f675b98f3c5573c53" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">비 고아 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 인스턴스에만 정의 된 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 이상; 이전 GHC의 고아 인스턴스는 &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; 패키지에서 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ecdd09903f2088ad3dbc8beaa6ad86be3ab5df1c" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">고아가 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 이상에 대해서만 정의 됩니다. 이전 GHC의 고아 인스턴스는 &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; 패키지에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e92086f9c87448dcbfcc888dbd80a2acee59efe1" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;https://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">고아가 아닌 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 이상에 대해서만 정의 됩니다. 이전 GHC의 고아 인스턴스는 &lt;a href=&quot;https://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; 패키지에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="32a62670f2797b774ced2a5536c4d0d7d1acb628" translate="yes" xml:space="preserve">
          <source>Non-portable (Win32 API)</source>
          <target state="translated">이식 불가능 (Win32 API)</target>
        </trans-unit>
        <trans-unit id="de79a7eacd9c8f0b77168b00c602dc91ea05f6b2" translate="yes" xml:space="preserve">
          <source>Non-portable, host-dependent</source>
          <target state="translated">비 휴대용, 호스트 종속</target>
        </trans-unit>
        <trans-unit id="92677a20e8a5fd94c0d5c1b4a2da0341122cf84c" translate="yes" xml:space="preserve">
          <source>NonBlockingRead</source>
          <target state="translated">NonBlockingRead</target>
        </trans-unit>
        <trans-unit id="5b969d02f949f3f49405f19ebd47eac2c53d5a3b" translate="yes" xml:space="preserve">
          <source>NonEmpty</source>
          <target state="translated">NonEmpty</target>
        </trans-unit>
        <trans-unit id="40c6def45ece9471c76046198d964195df309603" translate="yes" xml:space="preserve">
          <source>NonSpacingMark</source>
          <target state="translated">NonSpacingMark</target>
        </trans-unit>
        <trans-unit id="b990552d62e10bbd5a741b4ac2ab3d4c18f945d9" translate="yes" xml:space="preserve">
          <source>NonTermination</source>
          <target state="translated">NonTermination</target>
        </trans-unit>
        <trans-unit id="3784bca2cdaf835e7f86ca7f9511c965f0a8c209" translate="yes" xml:space="preserve">
          <source>NondecreasingIndentation</source>
          <target state="translated">NondecreasingIndentation</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="bfdd57f5fd1d7e78a4d4d0ea99c256bf3ed1633e" translate="yes" xml:space="preserve">
          <source>None of the process-creation functions in this library wait for termination: they all return a &lt;code&gt;&lt;a href=&quot;system-process#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; which may be used to wait for the process later.</source>
          <target state="translated">이 라이브러리의 프로세스 생성 함수는 종료 를 기다리지 &lt;code&gt;&lt;a href=&quot;system-process#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; 모두 나중에 프로세스를 기다리는 데 사용할 수 있는 ProcessHandle 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c599027fb1d35ffa00b3e30d51774d4325f6d3cd" translate="yes" xml:space="preserve">
          <source>None of the process-creation functions in this library wait for termination: they all return a &lt;code&gt;&lt;a href=&quot;system-process-internals#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; which may be used to wait for the process later.</source>
          <target state="translated">이 라이브러리의 프로세스 작성 함수는 종료 를 기다리지 &lt;code&gt;&lt;a href=&quot;system-process-internals#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; 모두 프로세스 처리를 리턴하여 나중에 프로세스를 기다리는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d718b604b802439e898076aa4d8e2656afd5eb" translate="yes" xml:space="preserve">
          <source>None of these restrictions are enforced at compile time. Failure to heed these restrictions will lead to runtime errors that can be very difficult to track down. (The errors likely will not manifest until garbage collection happens.) In tabular form, these restrictions are:</source>
          <target state="translated">이러한 제한은 컴파일 타임에 적용되지 않습니다. 이러한 제한 사항에주의하지 않으면 추적하기 매우 어려운 런타임 오류가 발생할 수 있습니다. (가비지 콜렉션이 발생할 때까지 오류가 나타나지 않을 가능성이 높습니다.) 표 형식에서 이러한 제한은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="179bfbb77ce151401fc8902ad181e29e5aa72b44" translate="yes" xml:space="preserve">
          <source>None of these scenarios gives rise to an error on its own &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;1&lt;/a&gt;, but they may have some interesting consequences. For instance, if you have a type &lt;code&gt;M.T&lt;/code&gt; from version 1 of package &lt;code&gt;P&lt;/code&gt;, then this is &lt;em&gt;not&lt;/em&gt; the same as the type &lt;code&gt;M.T&lt;/code&gt; from version 2 of package &lt;code&gt;P&lt;/code&gt;, and GHC will report an error if you try to use one where the other is expected.</source>
          <target state="translated">이러한 시나리오 중 어느 것도 자체적으로 오류를 일으키지 않지만 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;1&lt;/a&gt; , 흥미로운 결과를 가져올 수 있습니다. 예를 들어, 당신은 형의 경우 &lt;code&gt;M.T&lt;/code&gt; 패키지의 버전 1에서 &lt;code&gt;P&lt;/code&gt; 를 , 다음이입니다 &lt;em&gt;하지&lt;/em&gt; 타입과 같은 &lt;code&gt;M.T&lt;/code&gt; 패키지의 버전 2에서 &lt;code&gt;P&lt;/code&gt; , 다른이 예상되는 곳 하나를 사용하려고하면 GHC는 오류를보고합니다 .</target>
        </trans-unit>
        <trans-unit id="7a74eb719911afcf06b21975147c785a0bc25d01" translate="yes" xml:space="preserve">
          <source>None of these scenarios gives rise to an error on its own &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, but they may have some interesting consequences. For instance, if you have a type &lt;code&gt;M.T&lt;/code&gt; from version 1 of package &lt;code&gt;P&lt;/code&gt;, then this is &lt;em&gt;not&lt;/em&gt; the same as the type &lt;code&gt;M.T&lt;/code&gt; from version 2 of package &lt;code&gt;P&lt;/code&gt;, and GHC will report an error if you try to use one where the other is expected.</source>
          <target state="translated">이러한 시나리오 중 어느 것도 자체적으로 오류를 일으키지 않지만 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; 흥미로운 결과를 초래할 수 있습니다. 예를 들어, 당신은 형의 경우 &lt;code&gt;M.T&lt;/code&gt; 패키지의 버전 1에서 &lt;code&gt;P&lt;/code&gt; 를 , 다음이입니다 &lt;em&gt;하지&lt;/em&gt; 타입과 같은 &lt;code&gt;M.T&lt;/code&gt; 패키지의 버전 2에서 &lt;code&gt;P&lt;/code&gt; , 다른이 예상되는 곳 하나를 사용하려고하면 GHC는 오류를보고합니다 .</target>
        </trans-unit>
        <trans-unit id="69de0eaa26a62ea07b1802cfb77025b19669e630" translate="yes" xml:space="preserve">
          <source>None, one or many flags: FORCE_DOWNLOAD, NEW_SESSION, LOGON_UI, PASSWORD_UI</source>
          <target state="translated">없음, 하나 이상의 플래그 : FORCE_DOWNLOAD, NEW_SESSION, LOGON_UI, PASSWORD_UI</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="3956b2dc6672b7a8aeba865f33ebd6d3f65e6bf3" translate="yes" xml:space="preserve">
          <source>Nor this, since we can&amp;rsquo;t match the type variable &lt;code&gt;b&lt;/code&gt; with the concrete type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">도 아니다이, 우리는 형의 변수 일치하지 않을 수 있기 때문에 &lt;code&gt;b&lt;/code&gt; 콘크리트 유형 &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d20bdaf69fe8a19867cb42c9cdb8f5cb996bbe72" translate="yes" xml:space="preserve">
          <source>Normal GHC command-line options may also be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. For example, to turn on &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;, you would say:</source>
          <target state="translated">일반 GHC 명령 줄 옵션은 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 을&lt;/a&gt; 사용하여 설정할 수도 있습니다 . 예를 들어 &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; 를 켜려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="513df9742a975687401c53473a16fb97236fc768" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">일반 렌더링 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; 존중 ').</target>
        </trans-unit>
        <trans-unit id="8783461cc620ec6206ab159d2917107156d93ac4" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">일반 렌더링 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; 존중 ').</target>
        </trans-unit>
        <trans-unit id="1141a9ad4c5428e5700498684f4c71b8dcf76603" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">일반 렌더링 ( &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; 존중 ').</target>
        </trans-unit>
        <trans-unit id="22f3e78d5abb68171706a8fafe82f673d997000a" translate="yes" xml:space="preserve">
          <source>Normalise a file</source>
          <target state="translated">파일 정규화</target>
        </trans-unit>
        <trans-unit id="611ffe5a187425b7883a55311ee06c6a7a49d00e" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; replaces the default package stack. For example, all of the following commands are equivalent, creating a stack with db1 at the top followed by db2 (use &lt;code&gt;;&lt;/code&gt; instead of &lt;code&gt;:&lt;/code&gt; on Windows):</source>
          <target state="translated">일반적으로 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 는 기본 패키지 스택을 대체합니다. 예를 들어, 다음 명령은 모두 동일하며 맨 위에 db1이 있고 그 뒤에 db2가있는 스택을 작성합니다 ( Windows 에서는 &lt;code&gt;:&lt;/code&gt; 대신 &lt;code&gt;;&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="c4d28ac1c5fe75c0d62d49db7673ea2ff1f98808" translate="yes" xml:space="preserve">
          <source>Normally GHC will do a reasonable job of deciding by itself when it is a good idea to inline a function. However, sometimes you might want to override the default behaviour. For example, if you have a key function that is important to inline because it leads to further optimisations, but GHC judges it to be too big to inline.</source>
          <target state="translated">일반적으로 GHC는 함수를 인라인하는 것이 좋을 때 스스로 결정하는 합리적인 작업을 수행합니다. 그러나 때로는 기본 동작을 무시하고 싶을 수도 있습니다. 예를 들어, 추가 최적화로 연결되어 인라인에 중요한 핵심 기능이 있지만 GHC는 인라인하기에 너무 큰 것으로 판단합니다.</target>
        </trans-unit>
        <trans-unit id="eded18b2562ae6d637501fe2701b0cdec14061a3" translate="yes" xml:space="preserve">
          <source>Normally GHCi runs the interpreted code in the same process as GHC itself, on top of the same RTS and sharing the same heap. However, if the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; is given, then GHC will spawn a separate process for running interpreted code, and communicate with it using messages over a pipe.</source>
          <target state="translated">일반적으로 GHCi는 해석 된 코드를 GHC와 동일한 프로세스에서 동일한 RTS 위에서 실행하고 동일한 힙을 공유합니다. 그러나 &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 플래그 가 지정되면 GHC는 해석 된 코드를 실행하기위한 별도의 프로세스를 생성하고 파이프를 통해 메시지를 사용하여 통신합니다.</target>
        </trans-unit>
        <trans-unit id="c241ae0454c5e6b2d8549ed450bb4a03abf609b0" translate="yes" xml:space="preserve">
          <source>Normally a profile is limited to 20 bands with additional identifiers being grouped into an &lt;code&gt;OTHER&lt;/code&gt; band. The &lt;code&gt;-l&lt;/code&gt; flag removes this 20 band and limit, producing as many bands as necessary. No key is produced as it won&amp;rsquo;t fit!. It is useful for creation time profiles with many bands.</source>
          <target state="translated">일반적으로 프로파일은 20 개의 밴드로 제한되며 추가 식별자는 &lt;code&gt;OTHER&lt;/code&gt; 밴드 로 그룹화됩니다 . &lt;code&gt;-l&lt;/code&gt; 플래그는 필요한만큼 밴드로서 생산이 20 밴드 제한을 제거한다. 맞지 않으므로 키가 생성되지 않습니다. 밴드가 많은 생성 시간 프로파일에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="64c59b3d2432ce6c3b8d68909de92442ecb84597" translate="yes" xml:space="preserve">
          <source>Normally a profile is limited to 20 bands with additional identifiers being grouped into an &lt;code&gt;OTHER&lt;/code&gt; band. The &lt;code&gt;-m&lt;/code&gt; flag specifies an alternative band limit (the maximum is 20).</source>
          <target state="translated">일반적으로 프로파일은 20 개의 밴드로 제한되며 추가 식별자는 &lt;code&gt;OTHER&lt;/code&gt; 밴드 로 그룹화됩니다 . &lt;code&gt;-m&lt;/code&gt; 플래그는 다른 대역 제한 (최대 값 20)을 지정.</target>
        </trans-unit>
        <trans-unit id="558fdf57db5511e0c5ebfaa119295e9295b0c4b3" translate="yes" xml:space="preserve">
          <source>Normally pre-compiled code for a module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces a module to be loaded as byte-code.</source>
          <target state="translated">모듈에 대해 일반적으로 사전 컴파일 된 코드는 사용 가능한 경우로드되거나 그렇지 않으면 모듈이 바이트 코드로 컴파일됩니다. &lt;code&gt;*&lt;/code&gt; 접두사를 사용하면 모듈이 바이트 코드로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ecdcacb1582613bd12eb621f5b461a7931c33bbc" translate="yes" xml:space="preserve">
          <source>Normally there is no fixed relationship between Haskell threads and OS threads. This means that when you make a foreign call, that call may take place in an unspecified OS thread. Furthermore, there is no guarantee that multiple calls made by one Haskell thread will be made by the same OS thread.</source>
          <target state="translated">일반적으로 Haskell 스레드와 OS 스레드 사이에는 고정 된 관계가 없습니다. 즉, 외부 전화를 걸 때 지정되지 않은 OS 스레드에서 해당 전화가 발생할 수 있습니다. 또한 하나의 Haskell 스레드에서 여러 번의 호출이 동일한 OS 스레드에서 이루어질 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="937628f8a7dc9eb81b2263a9e21be33c5aea1828" translate="yes" xml:space="preserve">
          <source>Normally trace elements which sum to a total of less than 1% of the profile are removed from the profile. The &lt;code&gt;-t&lt;/code&gt; option allows this percentage to be modified (maximum 5%).</source>
          <target state="translated">일반적으로 프로파일의 총 1 % 미만에 해당하는 미량 원소는 프로파일에서 제거됩니다. &lt;code&gt;-t&lt;/code&gt; 옵션은이 비율 (최대 5 %)을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d52c3563db7da009beb065365791027b03554cf" translate="yes" xml:space="preserve">
          <source>Normally ⟨x⟩ should be chosen to match the number of CPU cores on the machine &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. For example, on a dual-core machine we would probably use &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt;.</source>
          <target state="translated">일반적으로 ⟨x⟩는 시스템 &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 의 CPU 코어 수와 일치하도록 선택해야합니다 . 예를 들어 듀얼 코어 머신에서는 &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt; 를 사용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d1424cc5421e827770c2528e2d213a27497f17fe" translate="yes" xml:space="preserve">
          <source>Normally ⟨x⟩ should be chosen to match the number of CPU cores on the machine &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. For example, on a dual-core machine we would probably use &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt;.</source>
          <target state="translated">일반적으로 머신의 CPU 코어 수와 일치하도록 ⟨x⟩를 선택해야합니다 &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 예를 들어, 듀얼 코어 머신에서는 &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="adae5b8f3d2301963310d04fce57a7e110596baf" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;hp2ps&lt;/code&gt; puts the title of the graph in a small box at the top of the page. However, if the JOB string is too long to fit in a small box (more than 35 characters), then &lt;code&gt;hp2ps&lt;/code&gt; will choose to use a big box instead. The &lt;code&gt;-b&lt;/code&gt; option forces &lt;code&gt;hp2ps&lt;/code&gt; to use a big box.</source>
          <target state="translated">일반적으로 &lt;code&gt;hp2ps&lt;/code&gt; 는 그래프 제목을 페이지 상단의 작은 상자에 넣습니다. 그러나 작업 문자열이 너무 길어서 작은 상자 (35 자 이상)에 &lt;code&gt;hp2ps&lt;/code&gt; 가 큰 상자를 대신 사용하도록 선택합니다. &lt;code&gt;-b&lt;/code&gt; 옵션 세력 &lt;code&gt;hp2ps&lt;/code&gt; 큰 상자를 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c386c8961f160187b7f41a883437a0e96c21de44" translate="yes" xml:space="preserve">
          <source>Normally, &lt;em&gt;constraints&lt;/em&gt; (which appear in types to the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow) have a very restricted syntax. They can only be:</source>
          <target state="translated">일반적으로 &lt;em&gt;제약 조건&lt;/em&gt; ( &lt;code&gt;=&amp;gt;&lt;/code&gt; 화살표 의 왼쪽에 유형으로 표시 )에는 구문이 매우 제한되어 있습니다. 그들은 단지 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5f3b656a0be36fb8e60655756fc57d49ccf589ac" translate="yes" xml:space="preserve">
          <source>Normally, GHC&amp;rsquo;s runtime system provides a &lt;code&gt;main()&lt;/code&gt;, which arranges to invoke &lt;code&gt;Main.main&lt;/code&gt; in the Haskell program. However, you might want to link some Haskell code into a program which has a main function written in another language, say C. In order to do this, you have to initialize the Haskell runtime system explicitly.</source>
          <target state="translated">일반적으로 GHC의 런타임 시스템은 &lt;code&gt;main()&lt;/code&gt; 제공하며 , Haskell 프로그램에서 &lt;code&gt;Main.main&lt;/code&gt; 을 호출 합니다. 그러나 일부 Haskell 코드를 다른 언어로 작성된 주 함수가있는 프로그램 (예 : C)에 링크하려고 할 수 있습니다.이를 위해서는 Haskell 런타임 시스템을 명시 적으로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5878d2676aa27f57a51768346833740d2d73c3e" translate="yes" xml:space="preserve">
          <source>Normally, a permutation parser is first build with special operators like (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) and than transformed into a normal parser using &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 순열 구문 분석기는 먼저 ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; )와 같은 특수 연산자로 빌드되며 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 를 사용하여 일반 구문 분석기로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="be63fc241b13b25bbbfbb8119202738448bc7f25" translate="yes" xml:space="preserve">
          <source>Normally, any evaluation of top-level expressions (otherwise known as CAFs or Constant Applicative Forms) in loaded modules is retained between evaluations. Turning on &lt;code&gt;+r&lt;/code&gt; causes all evaluation of top-level expressions to be discarded after each evaluation (they are still retained &lt;em&gt;during&lt;/em&gt; a single evaluation).</source>
          <target state="translated">일반적으로로드 된 모듈에서 최상위 식 (CAF 또는 상수 적용 형식이라고도 함)에 대한 평가는 평가간에 유지됩니다. 켜기 &lt;code&gt;+r&lt;/code&gt; 최상위 식의 모든 평가 (그들은 여전히 유지됩니다 각 평가 후 폐기되도록 &lt;em&gt;하는 동안&lt;/em&gt; 하나의 평가).</target>
        </trans-unit>
        <trans-unit id="cd32d0c154484c3ec18509a839994848298d2636" translate="yes" xml:space="preserve">
          <source>Normally, setting the &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-V ⟨secs⟩&lt;/code&gt;&lt;/a&gt; option directly is not necessary: the resolution of the RTS timer is adjusted automatically if a short interval is requested with the &lt;code&gt;-C ⟨s⟩&lt;/code&gt; or &lt;a href=&quot;#rts-flag--i%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-i
⟨secs⟩&lt;/code&gt;&lt;/a&gt; options. However, setting &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-V ⟨secs⟩&lt;/code&gt;&lt;/a&gt; is required in order to increase the resolution of the time profiler.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; &lt;/a&gt; 옵션을 직접 설정 하지 않아도됩니다. &lt;code&gt;-C ⟨s⟩&lt;/code&gt; 또는 &lt;a href=&quot;#rts-flag--i%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-i ⟨secs⟩&lt;/code&gt; &lt;/a&gt; 옵션 으로 짧은 간격을 요청하면 RTS 타이머의 해상도가 자동으로 조정됩니다 . 그러나 시간 프로파일 러의 해상도를 높이려면 &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; 를&lt;/a&gt; 설정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="78ccb4fb66097bf7ec98982f1e04cc05bbdcec21" translate="yes" xml:space="preserve">
          <source>Not all subexpressions are potential breakpoint locations. Single variables are typically not considered to be breakpoint locations (unless the variable is the right-hand-side of a function definition, lambda, or case alternative). The rule of thumb is that all redexes are breakpoint locations, together with the bodies of functions, lambdas, case alternatives and binding statements. There is normally no breakpoint on a let expression, but there will always be a breakpoint on its body, because we are usually interested in inspecting the values of the variables bound by the let.</source>
          <target state="translated">모든 하위 표현식이 잠재적 중단 점 위치는 아닙니다. 단일 변수는 일반적으로 중단 점 위치로 간주되지 않습니다 (변수가 함수 정의, 람다 또는 대소 문자 대체의 오른쪽이 아닌 경우). 경험적으로, 모든 redexes는 기능, 람다, 대소 문자 대체 및 바인딩 명령문과 함께 중단 점 위치입니다. let 표현식에는 일반적으로 중단 점이 없지만, 본문에 항상 중단 점이 있습니다. 일반적으로 let에 의해 바인딩 된 변수의 값을 검사하는 데 관심이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4ab7fbf9aa0be7d87015cd3b43f6141b9208bf3f" translate="yes" xml:space="preserve">
          <source>Not all systems support &lt;code&gt;utimensat&lt;/code&gt;, in which case the function can only emulate the behavior by reading the access time and then setting both the access and modification times together. On systems where &lt;code&gt;utimensat&lt;/code&gt; is supported, the modification time is set atomically with nanosecond precision.</source>
          <target state="translated">모든 시스템이 &lt;code&gt;utimensat&lt;/code&gt; 을 지원하는 것은 아니며 ,이 경우 기능은 액세스 시간을 읽은 다음 액세스 및 수정 시간을 함께 설정하여 동작을 에뮬레이션 할 수 있습니다. &lt;code&gt;utimensat&lt;/code&gt; 가 지원되는 시스템에서 수정 시간은 원자 단위로 나노초 단위로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0085970940cf874c9d2594cf9d4dd7a8d8194f" translate="yes" xml:space="preserve">
          <source>Not all systems support &lt;code&gt;utimensat&lt;/code&gt;, in which case the function can only emulate the behavior by reading the modification time and then setting both the access and modification times together. On systems where &lt;code&gt;utimensat&lt;/code&gt; is supported, the access time is set atomically with nanosecond precision.</source>
          <target state="translated">모든 시스템이 &lt;code&gt;utimensat&lt;/code&gt; 을 지원하는 것은 아니며 ,이 경우 함수는 수정 시간을 읽은 다음 액세스 시간과 수정 시간을 함께 설정하여 동작을 에뮬레이션 할 수 있습니다. &lt;code&gt;utimensat&lt;/code&gt; 가 지원되는 시스템에서 액세스 시간은 원자 단위로 나노초 단위로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2afb94fa1ad8b2117ab0fcdb5aa0be0a87a1018" translate="yes" xml:space="preserve">
          <source>Not combined (tricky):</source>
          <target state="translated">결합되지 않은</target>
        </trans-unit>
        <trans-unit id="c0dd126e18fca943161e0d20a36b21e212c3c99b" translate="yes" xml:space="preserve">
          <source>Not combined:</source>
          <target state="translated">결합되지 않음 :</target>
        </trans-unit>
        <trans-unit id="78133acc4cfff50b8f073295fd4a15e10edaae9e" translate="yes" xml:space="preserve">
          <source>Not every index within the bounds of the array need appear in the association list, but the values associated with indices that do not appear will be undefined (i.e. bottom).</source>
          <target state="translated">배열 경계 내의 모든 인덱스가 연결 목록에 나타날 필요는 없지만 나타나지 않는 인덱스와 관련된 값은 정의되지 않습니다 (즉, 맨 아래).</target>
        </trans-unit>
        <trans-unit id="a5c24f03828759592657815b91d4e8eac318fcb9" translate="yes" xml:space="preserve">
          <source>Not every index within the bounds of the array need appear in the association list, but the values associated with indices that do not appear will be undefined.</source>
          <target state="translated">배열 범위 내의 모든 인덱스가 연결 목록에 나타날 필요는 없지만 나타나지 않는 인덱스와 관련된 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8634acd7e6ee3c03ecde3208f3a307f2f045508" translate="yes" xml:space="preserve">
          <source>Not only do we now know the type of &lt;code&gt;left&lt;/code&gt;, but all the other partial types have also been resolved. So we can ask for the value of &lt;code&gt;a&lt;/code&gt;, for example:</source>
          <target state="translated">우리는 이제 &lt;code&gt;left&lt;/code&gt; 의 유형을 알고있을뿐만 아니라 다른 모든 부분 유형도 해결되었습니다. 그래서 우리의 가치를 요청할 수 예를 들어, : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4035b9c2b5847ce2b4b7d233cc698ae5fa143ff0" translate="yes" xml:space="preserve">
          <source>Not-equal predicate.</source>
          <target state="translated">같지 않은 술어.</target>
        </trans-unit>
        <trans-unit id="122fe604627a6b3c6c7479e2e3d9b217a06c8a81" translate="yes" xml:space="preserve">
          <source>NotAssigned</source>
          <target state="translated">NotAssigned</target>
        </trans-unit>
        <trans-unit id="029164befa1985fe4c7c950daf75d5070657a309" translate="yes" xml:space="preserve">
          <source>NotAssociative</source>
          <target state="translated">NotAssociative</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="54ab9353b38cfd8cfc741410b64bcd8b4ace3d86" translate="yes" xml:space="preserve">
          <source>Note also that the following declaration is not allowed, even by itself:</source>
          <target state="translated">또한 다음 선언 자체는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e14be39fd5d5beacf8aca731e7b645e488e01620" translate="yes" xml:space="preserve">
          <source>Note also the following points</source>
          <target state="translated">다음 사항도 참고하십시오</target>
        </trans-unit>
        <trans-unit id="e391e16c3d6dadad7a54ff544e2321aabfc38d3d" translate="yes" xml:space="preserve">
          <source>Note also the inter-module dependencies at the end of the Makefile, which take the form</source>
          <target state="translated">Makefile 끝에있는 모듈 간 종속성도 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="0f69bf791521771e7eed4606436969fb2e27e8cf" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">이 연산자가 어떻게 함수 구성 &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 과 유사한 지 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d2df4cb0a27c46da53e1c8dd36d7ee084e8ccd" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">이 연산자가 함수 구성 &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 과 어떻게 유사한 지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cdf7a8e9b7d9967c0312d67976a62b0219eb7cd" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">이 연산자가 함수 구성 &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 과 어떻게 유사한 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="58c74ad1a011259a6e943fb74b3e3c3c2695a3b0" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">이 연산자가 어떻게 함수 구성 &lt;code&gt;(&lt;a href=&quot;data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 과 유사한 지 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="9feb1e502abb28d277cb1a7670feb6125b53c153" translate="yes" xml:space="preserve">
          <source>Note how we can define a uniform instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;, because we completely disregard all meta-information:</source>
          <target state="translated">모든 메타 정보를 완전히 무시하기 때문에 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 에 대해 균일 한 인스턴스를 정의하는 방법에 주목 하십시오.</target>
        </trans-unit>
        <trans-unit id="45519c1953b86b55e65ecc080a301283fb324351" translate="yes" xml:space="preserve">
          <source>Note how we write an initial tag byte to indicate each variant of the data type.</source>
          <target state="translated">데이터 유형의 각 변형을 나타 내기 위해 초기 태그 바이트를 작성하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c9cb756c35baef541318a2fa53e969cf959a31f5" translate="yes" xml:space="preserve">
          <source>Note in particular that the main program thread (the thread running &lt;code&gt;Main.main&lt;/code&gt;) is always a bound thread, so for good concurrency performance you should ensure that the main thread is not doing repeated communication with other threads in the system. Typically this means forking subthreads to do the work using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, and waiting for the results in the main thread.</source>
          <target state="translated">특히 메인 프로그램 스레드 ( &lt;code&gt;Main.main&lt;/code&gt; 을 실행하는 스레드 )는 항상 바운드 스레드이므로 동시성 성능을 향상 시키려면 메인 스레드가 시스템의 다른 스레드와 반복적으로 통신하지 않도록해야합니다. 일반적으로 이는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 스레드가 forkIO를 사용하여 작업을 수행 하고 기본 스레드에서 결과를 기다리는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="31f3f6f5adc996e06ed48014b2b93cc6d3ecc2dc" translate="yes" xml:space="preserve">
          <source>Note in particular that the translation for a &lt;code&gt;rec&lt;/code&gt; block only involves wrapping a call to &lt;code&gt;mfix&lt;/code&gt;: it performs no other analysis on the bindings. The latter is the task for the &lt;code&gt;mdo&lt;/code&gt; notation, which is described next.</source>
          <target state="translated">특히 &lt;code&gt;rec&lt;/code&gt; 블록 의 변환은 &lt;code&gt;mfix&lt;/code&gt; 호출을 래핑하는 것만 포함 합니다. 바인딩에 대한 다른 분석은 수행하지 않습니다. 후자는 &lt;code&gt;mdo&lt;/code&gt; 표기법에 대한 작업이며 다음에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3639d52b7d40ee212b47bb683d401fdb19f2b8d7" translate="yes" xml:space="preserve">
          <source>Note on rewrite rules:</source>
          <target state="translated">다시 쓰기 규칙에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="da7038b6159ab37164aeb7442907c881108aff7e" translate="yes" xml:space="preserve">
          <source>Note that</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="2bbeb687e1b7425b59bec3bcf47cccd24fd58a0f" translate="yes" xml:space="preserve">
          <source>Note that (7.) and (8.) do &lt;em&gt;not&lt;/em&gt; require &lt;code&gt;&lt;a href=&quot;data-ord#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; to return either of their arguments. The result is merely required to &lt;em&gt;equal&lt;/em&gt; one of the arguments in terms of &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(7.) 및 (8.)은 인수 중 하나를 반환하기 위해 &lt;code&gt;&lt;a href=&quot;data-ord#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-ord#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; 가 필요 하지 &lt;em&gt;않습니다&lt;/em&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt; 측면에서 인수 중 하나와 &lt;em&gt;같을&lt;/em&gt; 때만 필요합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e828fd5138d7798acc9021c701b389b03f3b726" translate="yes" xml:space="preserve">
          <source>Note that (7.) and (8.) do &lt;em&gt;not&lt;/em&gt; require &lt;code&gt;&lt;a href=&quot;prelude#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; to return either of their arguments. The result is merely required to &lt;em&gt;equal&lt;/em&gt; one of the arguments in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(7.) 및 (8.)은 인수 중 하나를 반환하기 위해 &lt;code&gt;&lt;a href=&quot;prelude#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; 가 필요 하지 &lt;em&gt;않습니다&lt;/em&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt; 측면에서 인수 중 하나와 &lt;em&gt;같을&lt;/em&gt; 때만 필요합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="041e17d2804b0af5a76a5a97a0bba4a277288826" translate="yes" xml:space="preserve">
          <source>Note that 0 &amp;lt;= &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:todSec&quot;&gt;todSec&lt;/a&gt;&lt;/code&gt; &amp;lt; 61, accomodating leap seconds. Any local minute may have a leap second, since leap seconds happen in all zones simultaneously</source>
          <target state="translated">0 &amp;lt;= &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:todSec&quot;&gt;todSec&lt;/a&gt;&lt;/code&gt; &amp;lt;61, 윤초를 수용합니다. 모든 지역에서 동시에 윤초가 발생하기 때문에 모든 지역 분은 윤초를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc3cfabe43b8bcfa1705a3dbc018667744dc410" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-via&quot;&gt;Deriving via&lt;/a&gt;) uses essentially the same specification to derive instances of associated type families as well (except that it uses the &lt;code&gt;via&lt;/code&gt; type instead of the underlying &lt;code&gt;rep-type&lt;/code&gt; of a newtype).</source>
          <target state="translated">참고 &lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; 는&lt;/a&gt; (참조 &lt;a href=&quot;#deriving-via&quot;&gt;통해 도출을&lt;/a&gt; (그것이 사용하는 것을 제외 아니라 연관된 타입 패밀리의 파생 인스턴스에 본질적으로 동일 사양을 사용) &lt;code&gt;via&lt;/code&gt; 입력하는 대신 기본적인 &lt;code&gt;rep-type&lt;/code&gt; newtype은 항).</target>
        </trans-unit>
        <trans-unit id="20cfa8d6154c21f756b99008f5e887fb998ca694" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt; does not warn about variables which arise from type-level patterns, as found in type family and data family instances. This must be enabled separately through the &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">참고 &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; 형 가족 및 데이터 가족의 경우에 발견, 타입 수준의 패턴에서 발생하는 변수에 대해 경고하지 않습니다. &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그를 통해 별도로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0394f5adfc4a1a13e3b86c72f2c51c040f42596" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;--nonmoving-gc&lt;/code&gt;&lt;/a&gt; cannot be used with &lt;code&gt;-G1&lt;/code&gt;, &lt;a href=&quot;profiling#rts-flag--hc&quot;&gt;&lt;code&gt;profiling&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;--nonmoving-gc&lt;/code&gt; &lt;/a&gt; 사용할 수 없습니다 &lt;code&gt;-G1&lt;/code&gt; , &lt;a href=&quot;profiling#rts-flag--hc&quot;&gt; &lt;code&gt;profiling&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="115cb711c4af39c249438db0b383137d0cb50d56" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;deriving_via#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;deriving_via#deriving-via&quot;&gt;Deriving via&lt;/a&gt;) uses essentially the same specification to derive instances of associated type families as well (except that it uses the &lt;code&gt;via&lt;/code&gt; type instead of the underlying &lt;code&gt;rep-type&lt;/code&gt; of a newtype).</source>
          <target state="translated">참고 &lt;a href=&quot;deriving_via#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; 는&lt;/a&gt; (참조 &lt;a href=&quot;deriving_via#deriving-via&quot;&gt;통해 도출을&lt;/a&gt; (그것이 사용하는 것을 제외 아니라 연관된 타입 패밀리의 파생 인스턴스에 본질적으로 동일 사양을 사용) &lt;code&gt;via&lt;/code&gt; 입력하는 대신 기본적인 &lt;code&gt;rep-type&lt;/code&gt; newtype은 항).</target>
        </trans-unit>
        <trans-unit id="bf7f360a57aee7e3f0b50c89a317cf8b42dfa6db" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">참고 &lt;code&gt;(&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 그래서, 경솔-다형성의 결과 유형에 &lt;code&gt;foo &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; 곳 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 잘 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="50352b9744490cab4f40a77337fe0f29b0ce0106" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">참고 &lt;code&gt;(&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 그래서, 경솔-다형성의 결과 유형에 &lt;code&gt;foo &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; 곳 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 잘 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="e8b2b6839b756e03ca674d6cc20259793fba403d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">참고 &lt;code&gt;(&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 그래서, 경솔-다형성의 결과 유형에 &lt;code&gt;foo &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; 곳 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 잘 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="123d4fdb08ddd5f13ffc17d9c9b8108ebcc613a2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(RunIO return)&lt;/code&gt; is an incorrect implementation, since it does not separate the pure and impure parts of the monadic action. This module defines implementations for several common monad transformers.</source>
          <target state="translated">그 주 &lt;code&gt;(RunIO return)&lt;/code&gt; 는 모나드 행동의 순수하고 불순한 부분을 분리하지 않기 때문에, 잘못된 구현입니다. 이 모듈은 몇 가지 공통 모나드 변압기에 대한 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2364cca1f2893be828dc285c3d3e946361aaaff8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-rtsopts&lt;/code&gt; has no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;-rtsopts&lt;/code&gt; 는 사용에는 영향이 없습니다 &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; ; 자세한 내용은 &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;자체 main () 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59f5f5ff16e9a38088c4dc6203d56f4f8fc6a9aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-rtsopts&lt;/code&gt; has no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;-rtsopts&lt;/code&gt; 는 사용에는 영향이 없습니다 &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; ; 자세한 내용은 &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;자체 main () 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7093e90bb866365952af6e50a0522c2320078eb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-with-rtsopts&lt;/code&gt; has no effect when used with &lt;code&gt;-no-hs-main&lt;/code&gt;; see &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;-with-rtsopts&lt;/code&gt; 함께 사용하면 효과가 없습니다 &lt;code&gt;-no-hs-main&lt;/code&gt; ; 자세한 내용은 &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;자체 main () 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce579c6f316db1c83cacd820fffea2c995a62db3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-with-rtsopts&lt;/code&gt; has no effect when used with &lt;code&gt;-no-hs-main&lt;/code&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">참고 &lt;code&gt;-with-rtsopts&lt;/code&gt; 함께 사용하면 효과가 없습니다 &lt;code&gt;-no-hs-main&lt;/code&gt; ; 자세한 내용은 &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;자체 main () 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3251b2749b31476313c89aa83d9865be6457e1bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; has no concept of fairness, and there is no guarantee that threads blocked in &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; will be unblocked in the same order; in fact they will all be unblocked at the same time and will fight over the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;. Hence &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is not suitable if you expect there to be a high number of threads contending for the resource. However, like other STM abstractions, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is composable.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 공정성의 개념이 없으며, 차단 스레드한다는 보장이 없다 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; 이 같은 순서로 차단 해제 될 것이; 실제로 그들은 모두 동시에 차단이 해제되고 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 을 상대로 싸울 것 입니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 은 리소스에 대해 많은 수의 스레드가있을 것으로 예상되는 경우 적합하지 않습니다. 그러나 다른 STM 추상화와 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 도 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d023ee2a96a8f414c4d59de19543cf5936dac9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and friends &lt;em&gt;do not&lt;/em&gt; have a similar default, because there is no exception handler in this case. Don't use &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; for recovering from an asynchronous exception.</source>
          <target state="translated">주의 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 하고 친구가 &lt;em&gt;없는&lt;/em&gt; 이 경우에는 예외 핸들러가 없기 때문에, 유사한 기본이있다. 비동기 예외에서 복구 하기 위해 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="2718dae009fe5e3d1238b1c135ae52c90ac37837" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are a bit verbose, but quite versatile. Here is an example of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for combined HTML escaping and UTF-8 encoding. It exploits that the escaped character with the maximal Unicode codepoint is '&amp;gt;'.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 의 매우 다양한 자세한 조금 있지만. 다음은 결합 된 HTML 이스케이프 및 UTF-8 인코딩 을위한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 예입니다 . 최대 유니 코드 코드 포인트가있는 이스케이프 된 문자가 '&amp;gt;'임을 악용합니다.</target>
        </trans-unit>
        <trans-unit id="cde3b09d583614c69aacef3bde117f6bdd3d0e24" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">하는 것으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 의는 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant을&lt;/a&gt; . 따라서 다음과 같은 법률이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc83523aa02bd92c967a0a3d0ae6d7af0d9ac4f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are &lt;code&gt;Contravariant&lt;/code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">하는 것으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 의 의는 &lt;code&gt;Contravariant&lt;/code&gt; &lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant을&lt;/a&gt; . 따라서 다음과 같은 법률이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee6deeaabf24f4412e1e49868879a0b5b1aa1c9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Complex Float&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt; 의 인스턴스 유형 매개 변수의에서 결함을 상속합니다. 예를 들어 &lt;code&gt;Complex Float&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스에는 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 와 비슷한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e1f90e9e322b989e73d82fdede82115af771f84" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 엄격 속성이 있습니다 &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dced2e98ed0e357e8b533e5a5a89a9d764b8df7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 잠재적으로 소비자가 각각의 반복 처리를 강요하지 않습니다 썽크 축적 경우에지도 게으른입니다. 이 함수의 엄격한 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dedd1659c7efcc5ad810d0e5c4b39237ba9eb03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 다음과 같은 엄격 속성이 있습니다 : &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60f7565d417c50efc94986aa99cb5f4a947f5ff6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">그 주 &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 의 인스턴스 유형 매개 변수의에서 결함을 상속합니다. 예를 들어 &lt;code&gt;Ratio Natural&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 와 비슷한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cefd424b19607d5edc1403e68699fc8f6d2f620" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (in the guise of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;) can still occur in a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; representation, namely when the datatype has a field that does not mention the parameter.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (의 모습에서 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 는 ) 여전히 발생할 수 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 의 데이터 유형이 매개 변수를 언급하지 않는 필드가 즉 때, 표현입니다.</target>
        </trans-unit>
        <trans-unit id="281ca52e047c00d45cb2f86224fe53a9a4fae794" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 잠재적으로 소비자가 각각의 반복 처리를 강요하지 않습니다 썽크 축적 경우에지도 게으른입니다. 이 함수의 엄격한 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a858cff92b21869646f30a2b371df6ee5495052" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 어떠한 요소가 있지만 0 첨가제 역이있다 : 인스턴스 링되지 않는다. 그래도 반 반지입니다.</target>
        </trans-unit>
        <trans-unit id="fc2f4f0bfb855f7375943aa12d1fb8ac219a3580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 어떠한 요소가 있지만 0 첨가제 역이있다 : 인스턴스 링되지 않는다. 그래도 반 반지입니다.</target>
        </trans-unit>
        <trans-unit id="6dbd9a25c551eff23fa22c53698220086818ffcf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 엄격 속성이 있습니다 &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd1e7ed5d4e140984d3791f7195f3b569e53a3a5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 잠재적으로 소비자가 각각의 반복 처리를 강요하지 않습니다 썽크 축적 경우에지도 게으른입니다. 이 함수의 엄격한 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3220254f0cec09ffeb96b93db4b6d62483e447b2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">참고 것을 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 다음과 같은 엄격 속성이 있습니다 : &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e52e647e2604f5fb2a960fb656ed98c28cb82a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; does not suffice for this purpose due to &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac #5041&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; 이 때문에이 목적을 위해 충분하지 않습니다 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac에 # 5041&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4590a66ec7900e5ee4d377de0bdd011b81fe11e5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; does not suffice for this purpose due to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5041&quot;&gt;#5041&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; 이 때문에이 목적을 위해 충분하지 않습니다 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5041&quot;&gt;# 5041&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08f4018cb49ca32078d9a1bef08f427eb4907a21" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">그 주 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 의 인스턴스 유형 매개 변수의에서 결함을 상속합니다. 예를 들어 &lt;code&gt;Ratio Natural&lt;/code&gt; 's &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 인스턴스에는 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 와 비슷한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="042d76d30eab792b60df6af7b09723fdf10e8be4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 어떠한 요소가 있지만 0 첨가제 역이있다 : 인스턴스 링되지 않는다. 그래도 세미 링입니다.</target>
        </trans-unit>
        <trans-unit id="e88d411cc968059e325ae13439252f0afd371b01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 어떠한 요소가 있지만 0 첨가제 역이있다 : 인스턴스 링되지 않는다. 그래도 반 반지입니다.</target>
        </trans-unit>
        <trans-unit id="1e81757f506803c58656ee3360e5e3fcdb790671" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 잠재적으로 소비자가 각각의 반복 처리를 강요하지 않습니다 썽크 축적 경우에지도 게으른입니다. 이 함수의 엄격한 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="692875f553a19ed51b447480be26cc2da0a377bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 이 파일에 대한 리터럴 문자열을 작성합니다. &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 같이 인쇄 가능한 유형의 값을 쓰려면 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 값을 문자열로 먼저 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="82ee7c2d72b3eb91473ef9443731d0f34073a559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 이 파일에 대한 리터럴 문자열을 작성합니다. &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 같이 인쇄 가능한 유형의 값을 쓰려면 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 함수를 사용 하여 값을 문자열로 먼저 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="b7939772f8f7e35e3f9e1df2549a55f3569ee2cb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;F0&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F2&lt;/code&gt;, &lt;code&gt;FD1&lt;/code&gt;, and &lt;code&gt;FD2&lt;/code&gt; all have identical standalone kind signatures. The arity is inferred from the type family header.</source>
          <target state="translated">참고 &lt;code&gt;F0&lt;/code&gt; , &lt;code&gt;F1&lt;/code&gt; , &lt;code&gt;F2&lt;/code&gt; , &lt;code&gt;FD1&lt;/code&gt; 및 &lt;code&gt;FD2&lt;/code&gt; 모두 동일한 종류 단독 서명을 갖는다. arity는 유형 패밀리 헤더에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ad5d4ac1dbd955a15cabf62ecf4ebbe8794aa4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;FUN m a b&lt;/code&gt; permits levity-polymorphism in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that types like &lt;code&gt;Int# -&amp;gt; Int#&lt;/code&gt; can still be well-kinded.</source>
          <target state="translated">참고 &lt;code&gt;FUN m a b&lt;/code&gt; 모두 경솔-다형성을 허용 와 &lt;code&gt;b&lt;/code&gt; 그래서 같은 종류의 것을, &lt;code&gt;Int# -&amp;gt; Int#&lt;/code&gt; 여전히 잘 kinded 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d841ba3035a60d47bde6683188e551f1ba64a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt; or &lt;code&gt;std_out&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">참고 &lt;code&gt;Handle&lt;/code&gt; 의가 제공 &lt;code&gt;std_in&lt;/code&gt; 또는 &lt;code&gt;std_out&lt;/code&gt; CreateProcess를 기록을 통해이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="146678c0e776f2ff851c7e2c8dcebc022186f041" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Handle&lt;/code&gt; 들에 제공 &lt;code&gt;std_in&lt;/code&gt; , &lt;code&gt;std_out&lt;/code&gt; 또는 &lt;code&gt;std_err&lt;/code&gt; 비아 &lt;code&gt;UseHandle&lt;/code&gt; 생성자이 함수 호출에 의해 폐쇄된다. 항상 원하는 동작은 아닙니다. 당신이 떠나하고자하는 경우에는 &lt;code&gt;Handle&lt;/code&gt; 자식 프로세스를 생성 한 뒤, 이용하시기 바랍니다 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 을 대신. 작성된 모든 &lt;code&gt;Handle&lt;/code&gt; 은 처음에 텍스트 모드에 있습니다. 바이너리 모드에 있어야하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ff010b0f63ecc96eaf9bd3fa189d17e640c8eb8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Handle&lt;/code&gt; 들에 제공 &lt;code&gt;std_in&lt;/code&gt; , &lt;code&gt;std_out&lt;/code&gt; 또는 &lt;code&gt;std_err&lt;/code&gt; 비아 &lt;code&gt;UseHandle&lt;/code&gt; 생성자이 함수 호출에 의해 폐쇄된다. 이것은 항상 바람직한 동작은 아닙니다. 당신이 떠나하고자하는 경우에는 &lt;code&gt;Handle&lt;/code&gt; 자식 프로세스를 생성 한 뒤, 이용하시기 바랍니다 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 을 대신. 생성 된 모든 &lt;code&gt;Handle&lt;/code&gt; 은 처음에 텍스트 모드에 있습니다. 바이너리 모드에 있어야하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="060ea5a8335f3e38195f74d7156afc215fb95950" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Handle&lt;/code&gt; 들에 제공 &lt;code&gt;std_in&lt;/code&gt; , &lt;code&gt;std_out&lt;/code&gt; 또는 &lt;code&gt;std_err&lt;/code&gt; 비아 &lt;code&gt;UseHandle&lt;/code&gt; 생성자이 함수 호출에 의해 폐쇄된다. 이것은 항상 바람직한 동작은 아닙니다. 당신이 떠나하고자하는 경우에는 &lt;code&gt;Handle&lt;/code&gt; 자식 프로세스를 생성 한 뒤, 이용하시기 바랍니다 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 을 대신. 생성 된 모든 &lt;code&gt;Handle&lt;/code&gt; 은 처음에 텍스트 모드에 있습니다. 바이너리 모드에 있어야하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0bc50405f92753187a855ca32c150ffebfb1ca1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">참고 &lt;code&gt;Handle&lt;/code&gt; 의가 제공 &lt;code&gt;std_in&lt;/code&gt; , &lt;code&gt;std_out&lt;/code&gt; , 또는 &lt;code&gt;std_err&lt;/code&gt; CreateProcess를 기록을 통해이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="741bc7436d7860a8b9d202657fd8dd01f62d1a12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;M.join&lt;/code&gt; is only needed if the final expression is not identifiably a &lt;code&gt;return&lt;/code&gt;. With &lt;code&gt;-XQualifiedDo&lt;/code&gt; enabled, &lt;code&gt;-XApplicativeDo&lt;/code&gt; looks only for the qualified &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;pure&lt;/code&gt; in a qualified do-block.</source>
          <target state="translated">참고 &lt;code&gt;M.join&lt;/code&gt; 가 최종 표현이 특정 가능하지 않은 경우에만 필요합니다 &lt;code&gt;return&lt;/code&gt; . 함께 &lt;code&gt;-XQualifiedDo&lt;/code&gt; 이 활성화 &lt;code&gt;-XApplicativeDo&lt;/code&gt; 은 오직 자격을 찾습니다 &lt;code&gt;return&lt;/code&gt; / &lt;code&gt;pure&lt;/code&gt; 자격을 갖춘 DO-블록이다.</target>
        </trans-unit>
        <trans-unit id="fb75a50ee8a25d92207e02df9efd12ab2bbd9b08" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\case&lt;/code&gt; starts a layout, so you can write</source>
          <target state="translated">참고 것을 &lt;code&gt;\case&lt;/code&gt; 당신이 쓸 수 있도록 레이아웃을 시작합니다</target>
        </trans-unit>
        <trans-unit id="ef8c98fb1e9ccb919f4d179a7222663f9bc06990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; is not overloaded; the &lt;code&gt;Eq&lt;/code&gt; constraint arising from the use of &lt;code&gt;==&lt;/code&gt; is discharged by the pattern match on &lt;code&gt;T1&lt;/code&gt; and similarly the &lt;code&gt;Show&lt;/code&gt; constraint arising from the use of &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;f&lt;/code&gt; 과부하되지 않고; &lt;code&gt;==&lt;/code&gt; 를 사용하여 발생 하는 &lt;code&gt;Eq&lt;/code&gt; 제약 조건 은 &lt;code&gt;T1&lt;/code&gt; 의 패턴 일치 와 마찬가지로 &lt;code&gt;show&lt;/code&gt; 를 사용하여 발생하는 &lt;code&gt;Show&lt;/code&gt; 제약 조건 에 의해 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="01a09441c6e85b11dd8ac3855c0f8d219030d13a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;ghc -M&lt;/code&gt; 요구가 찾을 수있는 &lt;em&gt;소스 파일&lt;/em&gt; 은 가져 오기 선언을 구문 분석하고 종속성을 따를 수 그래서, 종속성 그래프의 각 모듈을. 따라서 소스 파일이없는 사전 컴파일 된 모듈은 패키지 &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1에&lt;/a&gt; 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5d5971cd304a24fd7e0c3cb761f12d88c0c5300" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;ghc -M&lt;/code&gt; 요구가 찾을 수있는 &lt;em&gt;소스 파일&lt;/em&gt; 은 가져 오기 선언을 구문 분석하고 종속성을 따를 수 그래서, 종속성 그래프의 각 모듈을. 소스 파일이없는 사전 컴파일 된 모듈은 반드시 패키지에 속해야합니다 &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ad10b105a7bebae4f8165fa8685e319e4cd138" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;hTestEquality&lt;/code&gt; takes two arguments where the type variable &lt;code&gt;t&lt;/code&gt; is applied to types of different kinds. That type variable must then be polykinded. Accordingly, the kind of &lt;code&gt;HTestEquality&lt;/code&gt; (the class) is &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt;, a higher-rank kind.</source>
          <target state="translated">참고 것을 &lt;code&gt;hTestEquality&lt;/code&gt; 는 타입 변수 개의 인수 얻어 &lt;code&gt;t&lt;/code&gt; 는 서로 다른 종류의 타입에 적용된다. 그런 다음 해당 유형 변수는 다품종이어야합니다. 따라서 &lt;code&gt;HTestEquality&lt;/code&gt; (클래스) 의 종류는 상위 등급 인 ( for &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d49f48cab2336da3b33335456da6ac1c62fd042c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; tests whether all the keys in &lt;code&gt;m1&lt;/code&gt; are also keys in &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; 의 키를 모두 여부를 테스트 &lt;code&gt;m1&lt;/code&gt; 도에서 열쇠 &lt;code&gt;m2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d87919fed4910f020e65cc52017097a20305800" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;it&lt;/code&gt; is shadowed by the new value each time you evaluate a new expression, and the old value of &lt;code&gt;it&lt;/code&gt; is lost.</source>
          <target state="translated">참고 &lt;code&gt;it&lt;/code&gt; 새로운 값으로 새 식을 계산할 때마다 그림자, 그리고의 이전 값 &lt;code&gt;it&lt;/code&gt; 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="8965b5ad7e3a3d0f07f953f01997900513413179" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;k2&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;, and that &lt;code&gt;k&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;. Also, note that &lt;code&gt;k2&lt;/code&gt; is written here in braces. As explained with &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called &lt;em&gt;inferred&lt;/em&gt; variables.) Such variables are written in braces with &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">참고 &lt;code&gt;k2&lt;/code&gt; 배치 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; , 그리고 &lt;code&gt;k&lt;/code&gt; 는 배치 &lt;em&gt;전에&lt;/em&gt; . 또한 &lt;code&gt;k2&lt;/code&gt; 는 여기에 중괄호로 작성됩니다. &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#inferred-vs-specified&quot;&gt;Inferred vs. 지정된 유형 변수&lt;/a&gt; )에서 설명했듯이 GHC가 일반화하지만 원래 프로그램으로 작성되지 않은 유형 및 종류 변수는 가시적 유형 응용 프로그램에 사용할 수 없습니다. 이러한 변수를 &lt;em&gt;유추&lt;/em&gt; 변수 라고 합니다. 이러한 변수는 &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; 를&lt;/a&gt; 사용 하여 중괄호로 작성됩니다 . &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="816ae0198397860aa9fd60cc59c11d1ed2b5d997" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;k2&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;, and that &lt;code&gt;k&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;. Also, note that &lt;code&gt;k2&lt;/code&gt; is written here in braces. As explained with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called &lt;em&gt;inferred&lt;/em&gt; variables.) Such variables are written in braces.</source>
          <target state="translated">참고 &lt;code&gt;k2&lt;/code&gt; 배치 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; , 그리고 &lt;code&gt;k&lt;/code&gt; 는 배치 &lt;em&gt;전에&lt;/em&gt; . 또한 여기에서 &lt;code&gt;k2&lt;/code&gt; 는 중괄호로 작성됩니다. &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt; )에서 설명한 것처럼 GHC가 일반화하지만 원래 프로그램에서 작성되지 않은 유형 및 종류 변수는 가시적 유형 응용 프로그램에 사용할 수 없습니다. ( &lt;em&gt;추론 된&lt;/em&gt; 변수 라고 합니다.) 이러한 변수는 중괄호로 작성됩니다. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a55de5915599f1590abb3356c8fe6ece583ed02" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings do not automatically print the value bound, unlike monadic bindings.</source>
          <target state="translated">참고 &lt;code&gt;let&lt;/code&gt; 바인딩이 자동으로 모나드 바인딩 달리 바인딩 값을 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f999ecaeb1e7a69b4163c053a67ca1cf1c9ff63" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mkName&lt;/code&gt; may be used with qualified names:</source>
          <target state="translated">참고 &lt;code&gt;mkName&lt;/code&gt; 는 자격을 갖춘 이름을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="01c07aa245695205a32a04f4daab1815beac9b5c" translate="yes" xml:space="preserve">
          <source>Note that GHC can only follow dependencies if it has the source file available, so if your program includes a module for which there is no source file, even if you have an object and an interface file for the module, then GHC will complain. The exception to this rule is for package modules, which may or may not have source files.</source>
          <target state="translated">GHC는 소스 파일을 사용할 수있는 경우에만 종속성을 따를 수 있으므로 프로그램에 소스 파일이없는 모듈이 포함되어 있으면 모듈에 대한 오브젝트와 인터페이스 파일이 있어도 GHC가 불평합니다. 이 규칙의 예외는 소스 파일이 있거나 없을 수있는 패키지 모듈에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="628959edf33f1bf4af75378e5117a34fc0ac8086" translate="yes" xml:space="preserve">
          <source>Note that a &quot;minute&quot; of &lt;code&gt;DiffTime&lt;/code&gt; is simply 60 SI seconds, rather than a minute of civil time. Use &lt;code&gt;NominalDiffTime&lt;/code&gt; to work with civil time, ignoring any leap seconds.</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; 의 &quot;분&quot;은 1 분의 시민 시간이 아니라 단순히 60 SI 초입니다. &lt;code&gt;NominalDiffTime&lt;/code&gt; 을 사용하여 윤초 를 무시하고 민간 시간으로 작업 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db63214ed45116be549d0295c81ce0bf585bc000" translate="yes" xml:space="preserve">
          <source>Note that a given &lt;code&gt;mdo&lt;/code&gt; expression can cause the creation of multiple &lt;code&gt;rec&lt;/code&gt; blocks. If there are no recursive dependencies, &lt;code&gt;mdo&lt;/code&gt; will introduce no &lt;code&gt;rec&lt;/code&gt; blocks. In this latter case an &lt;code&gt;mdo&lt;/code&gt; expression is precisely the same as a &lt;code&gt;do&lt;/code&gt; expression, as one would expect.</source>
          <target state="translated">주어진 &lt;code&gt;mdo&lt;/code&gt; 표현식으로 인해 여러 &lt;code&gt;rec&lt;/code&gt; 블록 이 생성 될 수 있습니다 . 재귀 의존성이 없으면 &lt;code&gt;mdo&lt;/code&gt; 는 &lt;code&gt;rec&lt;/code&gt; 블록 을 도입하지 않습니다 . 후자의 경우, &lt;code&gt;mdo&lt;/code&gt; 표현식은 예상대로 &lt;code&gt;do&lt;/code&gt; 표현식 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="edb8824abf3adc676b8fc9d4d2a15be4648aabba" translate="yes" xml:space="preserve">
          <source>Note that after splitting the string at newline characters, the last part of the string is considered a line even if it doesn't end with a newline. For example,</source>
          <target state="translated">줄 바꿈 문자에서 문자열을 분할 한 후 줄 바꿈으로 끝나지 않더라도 문자열의 마지막 부분은 줄로 간주됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e48d232edc1ec00a99a6fd6c27346f29f36049ef" translate="yes" xml:space="preserve">
          <source>Note that after the closing brace, GHCi knows that the current statement is finished, so no empty line is required.</source>
          <target state="translated">닫는 중괄호 뒤에 GHCi는 현재 명령문이 완료되었음을 알고 있으므로 빈 행이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="629c79c2f8b660ab85b6013a5e3159a0a225a4a6" translate="yes" xml:space="preserve">
          <source>Note that although the above translation suggests that &lt;code&gt;let&lt;/code&gt;-bound variables like &lt;code&gt;z&lt;/code&gt; must be monomorphic, the actual translation produces Core, so polymorphic variables are allowed.</source>
          <target state="translated">위의 변환에서 &lt;code&gt;z&lt;/code&gt; 와 같은 바인딩 된 변수 &lt;code&gt;let&lt;/code&gt; 단형이어야 한다고 제안하지만 실제 변환에서는 Core가 생성되므로 다형 변수가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="629818198328cd462665ec73736ee33ba93fceb4" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; is often absolutely essential. Consider the rose-tree example</source>
          <target state="translated">명시 적 &lt;code&gt;forall&lt;/code&gt; 은 절대적으로 필수적입니다. 로즈 트리 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="92e28e232c8219184dccc4e81df68cd45a16bf4c" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; must appear at the front of the type signature and is not permitted to appear nested within the type, as in the following (erroneous) examples:</source>
          <target state="translated">명시 적 &lt;code&gt;forall&lt;/code&gt; 은 형식 시그니처의 앞에 나타나야하며 다음 (잘못된) 예에서와 같이 형식 내에 중첩되어 나타나는 것이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fedd4b9525d691022adec17bbc58c0482f1424f" translate="yes" xml:space="preserve">
          <source>Note that any multi-parameter constraints &lt;code&gt;(D a b)&lt;/code&gt; or &lt;code&gt;(D [a] Int)&lt;/code&gt; do not participate in the process (either to help or to hinder); but they must of course be soluble once the defaulting process is complete.</source>
          <target state="translated">다중 매개 변수 구속 조건 &lt;code&gt;(D a b)&lt;/code&gt; 또는 &lt;code&gt;(D [a] Int)&lt;/code&gt; 은 프로세스에 참여하지 않습니다 (도움이나 방해). 그러나 기본 설정 프로세스가 완료되면 물론 가용성이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c67cc7b453618af847cc15ad44d064d4550a5b4a" translate="yes" xml:space="preserve">
          <source>Note that any non-flag arguments are never passed to GHC. An unused non-flag argument will be considered as the name of the program to run. If a GHC flag takes an argument use &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass the argument to GHC. For example, if you want to pass &lt;code&gt;-package foo&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">플래그가 아닌 인수는 절대 GHC로 전달되지 않습니다. 사용되지 않는 비 플래그 인수는 실행할 프로그램의 이름으로 간주됩니다. GHC 플래그가 인수를 사용하는 경우 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 를 사용하여 인수를 GHC에 전달하십시오. 예를 들어, &lt;code&gt;-package foo&lt;/code&gt; 를 GHC 에 전달 하려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d2d4c489f4d5c10bf98bfdb6c95992494ea1737" translate="yes" xml:space="preserve">
          <source>Note that because constraints are just handled as types of a particular kind, this extension allows type constraint synonyms:</source>
          <target state="translated">제약 조건은 특정 종류의 유형으로 만 처리되므로이 확장은 유형 제약 조건 동의어를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1e70909e8298e18a428bd14a078ccbac8a33b1c3" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is only safe to use, therefore, if the immutable array is never referenced again in this thread, and there is no possibility that it can be also referenced in another thread. If you use an unsafeThaw&lt;em&gt;write&lt;/em&gt;unsafeFreeze sequence in a multi-threaded setting, then you must ensure that this sequence is atomic with respect to other threads, or a garbage collector crash may result (because the write may be writing to a frozen array).</source>
          <target state="translated">어레이가 복사되지 않을 수 있으므로 어레이의 변경 가능 버전에 대한 후속 수정 사항은 변경 불가능한 버전과 공유 될 수 있습니다. 따라서이 스레드에서 불변 배열이 다시 참조되지 않고 다른 스레드에서도 참조 될 가능성이없는 경우에만 사용하는 것이 안전합니다. 다중 스레드 설정에서 unsafeThaw &lt;em&gt;write&lt;/em&gt; unsafeFreeze 시퀀스 를 사용하는 경우이 시퀀스가 다른 스레드와 관련하여 원 자성인지 확인해야합니다. 그렇지 않으면 가비지 수집기 충돌이 발생할 수 있습니다 (쓰기가 고정 된 배열에 쓰기 때문에).</target>
        </trans-unit>
        <trans-unit id="312ce308d507158c0dbd1448754583dfb49275af" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is safe to use, therefore, if the mutable version is never modified after the freeze operation.</source>
          <target state="translated">어레이가 복사되지 않을 수 있으므로 어레이의 변경 가능 버전에 대한 후속 수정 사항은 변경 불가능한 버전과 공유 될 수 있습니다. 따라서 고정 작업 후에 변경 가능한 버전을 수정하지 않은 경우 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cf2145147a60ace311fa33d22d382ca44077b49d" translate="yes" xml:space="preserve">
          <source>Note that calling `breakSubstring x` does some preprocessing work, so you should avoid unnecessarily duplicating breakSubstring calls with the same pattern.</source>
          <target state="translated">`breakSubstring x`를 호출하면 일부 전처리 작업이 수행되므로 동일한 패턴으로 breakSubstring 호출을 불필요하게 복제하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fc9763765bf9b4fd333d384e2c7f6d48a5f90bb7" translate="yes" xml:space="preserve">
          <source>Note that class instances are always for particular &lt;em&gt;instances&lt;/em&gt; of a data family and never for an entire family as a whole. This is for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of &lt;em&gt;different&lt;/em&gt; instances of a single type family. It would require a form of extensible case construct.</source>
          <target state="translated">클래스 인스턴스는 항상 데이터 제품군의 특정 &lt;em&gt;인스턴스&lt;/em&gt; 를위한 것이며 전체 가족을위한 것은 아닙니다. 이는 본질적 으로 단일 유형 패밀리 의 &lt;em&gt;서로 다른&lt;/em&gt; 인스턴스의 데이터 생성자에 대해 패턴 일치를 수행하는 최상위 함수를 정의 할 수없는 것과 동일한 이유 입니다. 확장 가능한 사례 구성 형식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3fd26db2c5a937cd006a71ef434cb9a6ac571280" translate="yes" xml:space="preserve">
          <source>Note that command-line options are &lt;em&gt;order-dependent&lt;/em&gt;, with arguments being evaluated from left-to-right. This can have seemingly strange effects in the presence of flag implication. For instance, consider &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fno-specialise&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt;&lt;code&gt;-O1&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fspecialise&lt;/code&gt;&lt;/a&gt;). These two command lines mean very different things:</source>
          <target state="translated">명령 행 옵션은 &lt;em&gt;순서에 따라 다르며&lt;/em&gt; 인수는 왼쪽에서 오른쪽으로 평가됩니다. 이것은 플래그 의미가있을 때 겉보기에는 이상한 영향을 줄 수 있습니다. 예를 들어, &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fno-specialise&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt; &lt;code&gt;-O1&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fspecialise&lt;/code&gt; &lt;/a&gt; 를 의미)을 고려 하십시오. 이 두 명령 줄은 매우 다른 의미입니다.</target>
        </trans-unit>
        <trans-unit id="76091aaf5e35a41319f5ec500de56fcd89951658" translate="yes" xml:space="preserve">
          <source>Note that deriving &lt;code&gt;Eq&lt;/code&gt; is necessary for the pattern matching to work since it gets translated into an equality comparison.</source>
          <target state="translated">등식 비교로 변환되므로 패턴 일치가 작동하려면 &lt;code&gt;Eq&lt;/code&gt; 도출 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5e66a3c265c4c5b432263a07a725a136b6324e29" translate="yes" xml:space="preserve">
          <source>Note that due to Haskell's unspecified evaluation order, an expression may throw one of several possible exceptions: consider the expression &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt;. Does the expression throw &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt;, or &lt;code&gt;DivideByZero&lt;/code&gt;?</source>
          <target state="translated">Haskell의 지정되지 않은 평가 순서로 인해 표현식에서 몇 가지 가능한 예외 중 하나가 발생할 수 있습니다. 표현식 &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt; . 표현식이 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 또는 &lt;code&gt;DivideByZero&lt;/code&gt; 를 발생시킵 니까?</target>
        </trans-unit>
        <trans-unit id="a38e6766cff20e461dc54ded66126b634b012173" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ef6487a6a1f23d9e6d0eab035203c36999e612c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="718b6ec1eedc7b0e6b0505f3537b21d4d5090824" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재로 유의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 재귀을 만족하지 않는다.</target>
        </trans-unit>
        <trans-unit id="b2e8c03bc2025303c4c75357649bb45ee1572579" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bb133570167aeb8235fd7aa64e771323ce317b8" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8c80f9a804d45f8387d652852d3f1b319e89bab" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abaa8283c8c82c454b3f39dc4e8b3b95dea832bf" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재로 유의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 재귀을 만족하지 않는다.</target>
        </trans-unit>
        <trans-unit id="efa258be8dec869f272beb6b3b0719e9c9136d95" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc8602ae6c9f5374c5b3e2f4892e8ddead96cf59" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="434b11a6a2c5a23f490c3dca6b67c53a554a0d1b" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6077357d3de95b1c68b9540f7bddf5fc70a526b4" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2043553ccd4d376d49787321f94def08da904851" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="194e7c783a359ef09d66938c7b166d817c622581" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재로 유의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 재귀을 만족하지 않는다.</target>
        </trans-unit>
        <trans-unit id="9890f34bd7580f2b47b85fe9349066eb034aa874" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dcbc1e84d812484382f7054b4ea09eece714d9c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재로 유의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 재귀을 만족하지 않는다.</target>
        </trans-unit>
        <trans-unit id="20c322bafd53e5e4ac584f0f4c7683ecf396fc66" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">인해의 존재에주의 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스가 재귀을 만족하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e775258fb33a9c99aae311b322919c0b7003500f" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1f89c3ca9731aeeb8476c132b53e6e61c23b4594" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="24ad6371739df6cce2c9d49e41a79e67a4549c98" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="59b02bd4bf7fdf2cce1cbde77a7195b31de26236" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="5b8a7de16c8d613620813c9851308e5845856e62" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c868d72c8e906befa9b0e16299d79ca57971708c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="da59b4a14361d344a87c211c8c8c17fcca4de300" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="96f2507b88b419212359ae0a529d1957a3da8fe1" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="6105c208b7c6f44c6b239700c54851ff6acd9f7c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="9187cd519377bc44a76fe47963badb1dfb10c1de" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="0dc5c80ae44926709a883abad455c22674f3d607" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 부가적인 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7935bc741f62235ae7bf01a48ecac728f0a179e3" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 의 존재로 인해 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 의 모든 요소에 곱하기 역수가있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="eeb5083fb742894713808d1bf407187ed8b72976" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 합법적이라고해도 대부분의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 에 대해이 인스턴스는 합법적이지 않습니다. 이 인스턴스를 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 목록과 함께 사용 하면 다음 관습법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3853fcb3c30f45ae120a9243010c94f95839f0f3" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 합법적이라고해도 대부분의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 에 대해이 인스턴스는 합법적이지 않습니다. 이 인스턴스를 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 목록과 함께 사용 하면 다음 관습법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27585464cfdd8d01e677b0406967c001ac3c9e76" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 합법적이라고해도 대부분의 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 에 대해이 인스턴스는 합법적이지 않습니다. 이 인스턴스를 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 목록과 함께 사용 하면 다음 관습법이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="646e8b4539cacf2e9e9d3ae0b8e3c032a0312c22" translate="yes" xml:space="preserve">
          <source>Note that even with &lt;code&gt;--install-signal-handlers=no&lt;/code&gt;, the RTS interval timer signal is still enabled. The timer signal is either SIGVTALRM or SIGALRM, depending on the RTS configuration and OS capabilities. To disable the timer signal, use the &lt;code&gt;-V0&lt;/code&gt; RTS option (see &lt;code&gt;-V ⟨secs⟩&lt;/code&gt;).</source>
          <target state="translated">짝수와 주 &lt;code&gt;--install-signal-handlers=no&lt;/code&gt; 은 RTS가 인터벌 타이머 신호가 여전히 활성화되어있다. 타이머 신호는 RTS 구성 및 OS 기능에 따라 SIGVTALRM 또는 SIGALRM입니다. 타이머 신호를 비활성화하려면 &lt;code&gt;-V0&lt;/code&gt; RTS 옵션을 사용 하십시오 ( &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4432323376182dfbdca3fdc7130f34b9170ab0c0" translate="yes" xml:space="preserve">
          <source>Note that exceptions which are thrown to the current thread are thrown in turn to the thread that is executing the given computation. This ensures there's always a way of killing the forked thread.</source>
          <target state="translated">현재 스레드에 발생한 예외는 주어진 계산을 실행하는 스레드에 차례로 발생합니다. 이렇게하면 갈래 스레드를 죽일 수있는 방법이 항상 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7cb7371c58bd222ab2560f3a7d99af3af20d16" translate="yes" xml:space="preserve">
          <source>Note that fixed primitives can be considered as a special case of bounded primitives, and we can lift from fixed to bounded.</source>
          <target state="translated">고정 프리미티브는 경계 프리미티브의 특수한 경우로 간주 될 수 있으며 고정 프리미티브에서 리바운드 프리미티브로 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b0f705789ec7ac7e04637b1063cafb79dc672b" translate="yes" xml:space="preserve">
          <source>Note that for consistency &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Word64&lt;/code&gt;, and &lt;code&gt;Int64&lt;/code&gt; constructor fields are unpacked on 32-bit platforms, even though they are technically larger than a pointer on those platforms.</source>
          <target state="translated">일관성을 위해 &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;Word64&lt;/code&gt; 및 &lt;code&gt;Int64&lt;/code&gt; 생성자 필드는 기술적으로 해당 플랫폼의 포인터보다 크더라도 32 비트 플랫폼에서 압축이 풀립니다.</target>
        </trans-unit>
        <trans-unit id="6128c2afaa4b4099fa2f7f80159c3c3eb7d037da" translate="yes" xml:space="preserve">
          <source>Note that for non-C languages (for example C++) &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; directives must be used to get symbols that we can access from Haskell.</source>
          <target state="translated">C 언어가 아닌 언어 (예 : C ++)의 경우 &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 지시문을 사용하여 Haskell에서 액세스 할 수있는 기호를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="250d6d584d95f50004937c03dc209e45f1572a99" translate="yes" xml:space="preserve">
          <source>Note that for scripts and interactive sessions, this is the path to the interpreter (e.g. ghci.)</source>
          <target state="translated">스크립트 및 대화식 세션의 경우이 경로는 인터프리터의 경로입니다 (예 : ghci).</target>
        </trans-unit>
        <trans-unit id="2a64a1dfeaac3f04e05a2dfa765d6f00da1d204a" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;package-db&lt;/code&gt; directive, if a relative path is given it must be relative to the location of the package environment file.</source>
          <target state="translated">참고가에 대한 것을 &lt;code&gt;package-db&lt;/code&gt; 지시, 상대 경로가 주어진 경우는 패키지 환경 파일의 위치에 상대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="96e9f8d44f9309d061a4735a30dbfcf393329303" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.</source>
          <target state="translated">글 머리 기호 (4) 및 (5)에서 주입 검사의 목적으로 GHC는 유형 패밀리 응용 프로그램을 가능한 한 통합하는 것으로 취급하는 특수한 통합 알고리즘 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b361a1480c4039f0cd985063822cba34298460c6" translate="yes" xml:space="preserve">
          <source>Note that foreign calls made by different Haskell threads may execute in &lt;em&gt;parallel&lt;/em&gt;, even when the &lt;code&gt;+RTS -N&lt;/code&gt; flag is not being used (&lt;a href=&quot;../using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;). The &lt;code&gt;-N ⟨x⟩&lt;/code&gt; flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the &lt;code&gt;+RTS -N&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;+RTS -N&lt;/code&gt; 플래그가 사용되지 않는 경우에도 다른 Haskell 스레드에 의한 외부 호출이 &lt;em&gt;병렬로&lt;/em&gt; 실행될 수 있습니다 ( &lt;a href=&quot;../using-concurrent#parallel-options&quot;&gt;SMP 병렬 처리를위한 RTS 옵션&lt;/a&gt; ). &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 플래그 제어 병렬 하스켈 스레드 실행하지만 관계없이 중, 어느 한 시점에서 진행 외국 통화 임의의 개수가있을 수 &lt;code&gt;+RTS -N&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="ffa639807aa32c333508357828c548fb4190cf20" translate="yes" xml:space="preserve">
          <source>Note that foreign calls made by different Haskell threads may execute in &lt;em&gt;parallel&lt;/em&gt;, even when the &lt;code&gt;+RTS -N&lt;/code&gt; flag is not being used (&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;). The &lt;code&gt;-N ⟨x⟩&lt;/code&gt; flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the &lt;code&gt;+RTS -N&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;+RTS -N&lt;/code&gt; 플래그를 사용하지 않는 경우에도 서로 다른 Haskell 스레드에서 수행 한 외래 호출은 &lt;em&gt;병렬로&lt;/em&gt; 실행될 수 있습니다 ( &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;SMP 병렬 처리를위한 RTS 옵션&lt;/a&gt; ). &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 플래그 제어 병렬 하스켈 스레드 실행하지만 관계없이 중, 어느 한 시점에서 진행 외국 통화 임의의 개수가있을 수 &lt;code&gt;+RTS -N&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="b570082e206f3882d05ae56cc37de0fcb8caa829" translate="yes" xml:space="preserve">
          <source>Note that functions marked with &quot;&lt;em&gt;Heavy inlining.&lt;/em&gt;&quot; are forced to be inlined because they must be specialized for concrete encodings, but are rather heavy in terms of code size. We recommend to define a top-level function for every concrete instantiation of such a function in order to share its code. A typical example is the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;, which is implemented as follows.</source>
          <target state="translated">&quot; &lt;em&gt;Heavy inlining.&lt;/em&gt; &quot;으로 표시된 함수 는 구체적인 인코딩에 특화되어야하므로 인라인되어야하지만 코드 크기 측면에서는 다소 무겁습니다. 코드를 공유하기 위해 이러한 함수의 모든 구체적인 인스턴스화에 대해 최상위 함수를 정의하는 것이 좋습니다. 일반적인 예는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; 의 &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;byteStringHex&lt;/a&gt; 함수 이며 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="e12827f70b05908494f598eac9c4f60068827e87" translate="yes" xml:space="preserve">
          <source>Note that functions marked with &quot;&lt;em&gt;Heavy inlining.&lt;/em&gt;&quot; are forced to be inlined because they must be specialized for concrete encodings, but are rather heavy in terms of code size. We recommend to define a top-level function for every concrete instantiation of such a function in order to share its code. A typical example is the function &lt;code&gt;byteStringHex&lt;/code&gt; from &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;, which is implemented as follows.</source>
          <target state="translated">&quot; &lt;em&gt;무거운 인라이닝&lt;/em&gt; &quot;으로 표시된 함수 는 구체적인 인코딩을 위해 특수화되어야하지만 코드 크기면에서는 다소 무겁기 때문에 인라인되어야합니다. 코드를 공유하기 위해 이러한 함수의 모든 구체적인 인스턴스화에 대해 최상위 함수를 정의하는 것이 좋습니다. 일반적인 예는 &lt;code&gt;byteStringHex&lt;/code&gt; 의 &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;byteStringHex&lt;/a&gt; 함수 이며 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a81cbfbf457be603965ed8e6e32f7b3176154d2b" translate="yes" xml:space="preserve">
          <source>Note that functions requiring varargs arguments are unsupported by the &lt;code&gt;ccall&lt;/code&gt; calling convention. Foreign imports needing to call such functions should rather use the &lt;code&gt;capi&lt;/code&gt; convention, giving an explicit signature for the needed call-pattern. For instance, one could write:</source>
          <target state="translated">varargs 인수가 필요한 함수는 &lt;code&gt;ccall&lt;/code&gt; 호출 규칙 에서 지원되지 않습니다 . 이러한 함수를 호출해야하는 해외 수입품 은 필요한 호출 패턴에 대한 명시 적 서명을 제공하는 &lt;code&gt;capi&lt;/code&gt; 규칙을 사용해야합니다 . 예를 들어 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2216bc2850d8b97233a3efc13f854171f19bee87" translate="yes" xml:space="preserve">
          <source>Note that higher optimisation levels cause more cross-module optimisation to be performed, which can have an impact on how much of your program needs to be recompiled when you change something. This is one reason to stick to no-optimisation when developing code.</source>
          <target state="translated">최적화 수준이 높을수록 더 많은 모듈 간 최적화가 수행되므로 무언가를 변경할 때 재 컴파일해야하는 프로그램의 양에 영향을 줄 수 있습니다. 이것이 코드를 개발할 때 최적화되지 않는 이유 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="30a1f39225163748211fd926207dd09b8855fbec" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c0dcced941ac54917c55caf21e22d4636d250c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2364a113ff09ab00bf106323a9ba1b4c3714d917" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11abb5f8d9b5fba3f33fa0b7e155694cf82d23ad" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620ca9a9df68bf26044f5d872190781472e76ff1" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55ba0c9a076ac9b515d71482f78bc92a96d264e8" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade933651993a04a370b1b74f8baa0d698471747" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d66210fda4350eaec16e5b09b559810cf819baea" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53bdddcd649e7c0b18af6cbb0a2342c2614754df" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12809b4532f5331b24f07fd2836313e5463fa8a2" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우주의 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 을 대상으로 현재의 thread로 호출, 예외가 스레드가 현재 내부 경우에도 발생합니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd84aceb1741c1097100af32525f39087b79c2c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;C&lt;/code&gt; does not contain any class methods, the instance context is wholly unnecessary, and as such GHC will instead generate:</source>
          <target state="translated">경우 참고 &lt;code&gt;C&lt;/code&gt; 가 어떤 클래스 메소드를 포함하지 않는 인스턴스 컨텍스트가 전적으로 불필요하고, 대신 생성 등 GHC 같은 :</target>
        </trans-unit>
        <trans-unit id="28c37978b95dd575e513b0b23b8deb28631dd7fb" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="288715920cc43c37cbcf03237a6afbc9e9f1ca44" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">참고이 경우 &lt;code&gt;f&lt;/code&gt; 는 엄격한, &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23075918281a3d4a9a4393210ab00757f30add13" translate="yes" xml:space="preserve">
          <source>Note that if Haskeline is built against a version of the &lt;code&gt;Win32&lt;/code&gt; library earlier than 2.5, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; will incorrectly echo back input on MinTTY consoles (such as Cygwin or MSYS).</source>
          <target state="translated">Haskeline이 2.5 이전 의 &lt;code&gt;Win32&lt;/code&gt; 라이브러리 버전에 대해 빌드 된 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; 는 MinTTY 콘솔 (예 : Cygwin 또는 MSYS)의 입력을 잘못 반향합니다.</target>
        </trans-unit>
        <trans-unit id="748b314274792a265ed7c2434a739a0777fcbd47" translate="yes" xml:space="preserve">
          <source>Note that if the expression can&amp;rsquo;t be translated into uses of &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; only, then it will incur a &lt;code&gt;Monad&lt;/code&gt; constraint as usual. This happens when there is a dependency on a value produced by an earlier statement in the &lt;code&gt;do&lt;/code&gt;-block:</source>
          <target state="translated">식을 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 의 용도 로만 변환 할 수없는 경우 평소처럼 &lt;code&gt;Monad&lt;/code&gt; 제약 조건 이 발생합니다 . 이것은 &lt;code&gt;do&lt;/code&gt; - block 의 이전 문장에 의해 생성 된 값에 의존 할 때 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="3cbb7152b808b31e2c0cac825f8fb2dae7c7b28d" translate="yes" xml:space="preserve">
          <source>Note that if you do need to interpret file paths or environment strings as text, then some Unicode encoding or decoding should be applied first.</source>
          <target state="translated">파일 경로 또는 환경 문자열을 텍스트로 해석해야하는 경우 일부 유니 코드 인코딩 또는 디코딩을 먼저 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="727e91ac7cf7235ceb01512e066f5fa194d7f879" translate="yes" xml:space="preserve">
          <source>Note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;. The reason is that the latter does not force the &quot;inner&quot; results, resulting in a thunk chain which then must be evaluated from the outside-in.</source>
          <target state="translated">당신이 효율적으로하려면 왼쪽 배 것을 참고, 당신은 아마 사용하려는 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; . 그 이유는 후자가 &quot;내부&quot;결과를 강요하지 않기 때문에 썽크 체인이 생겨 외부에서 평가되어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3f920b899f0a93de7b234be63afb284d817b0204" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;S2&lt;/code&gt; and &lt;code&gt;S3&lt;/code&gt;, the kind of the right-hand side is rather apparent, but it is still not considered to have a complete signature &amp;ndash; no inference can be done before detecting the signature.</source>
          <target state="translated">하는 것으로는에 &lt;code&gt;S2&lt;/code&gt; 및 &lt;code&gt;S3&lt;/code&gt; , 오른쪽의 종류는 오히려 명백하다,하지만 여전히 완전한 서명이 간주되지 않습니다 - 어떤 추론은 서명을 검출하기 전에 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ed65ace60cec8fe502a481f05e3dda7d603ff35" translate="yes" xml:space="preserve">
          <source>Note that in GHCi, and &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode, the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for &lt;em&gt;source&lt;/em&gt; files, whereas in standard batch-compilation mode the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for interface files, see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;.</source>
          <target state="translated">GHCi 및 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드에서 &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션은 &lt;em&gt;소스&lt;/em&gt; 파일 의 검색 경로를 지정하는 데 사용되는 반면 표준 배치 컴파일 모드에서는 &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션이 인터페이스 파일의 검색 경로를 지정하는 데 사용됩니다 &lt;a href=&quot;separate_compilation#search-path&quot;&gt;. 검색 경로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f74e9b413c970241bf9e71c360a313d3c98064d3" translate="yes" xml:space="preserve">
          <source>Note that in the last example, it&amp;rsquo;s impossible to learn that &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;k&lt;/code&gt; in the body of the &lt;code&gt;forall&lt;/code&gt; (that is, the &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt;). And so GHC rejects the program.</source>
          <target state="translated">마지막 예제에서 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;forall&lt;/code&gt; 의 본문 에서 &lt;code&gt;k&lt;/code&gt; 에 의존 한다는 것을 알 수 없습니다 (즉, &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt; ). 따라서 GHC는 프로그램을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="585d2c2d29d7e260cd5cf60d36a2bb2eded38317" translate="yes" xml:space="preserve">
          <source>Note that in this example, &lt;code&gt;a&lt;/code&gt; is a universal variable in the data type &lt;code&gt;T&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is existential. When writing the pattern synonym, both types are allowed to be specified or inferred.</source>
          <target state="translated">이 예에서 &lt;code&gt;a&lt;/code&gt; 는 데이터 유형 &lt;code&gt;T&lt;/code&gt; 의 범용 변수 이며 여기서 &lt;code&gt;b&lt;/code&gt; 는 실존 적입니다. 패턴 동의어를 작성할 때 두 유형 모두 지정하거나 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3f39847ba19e77a6a582f15278eee9d18590bf" translate="yes" xml:space="preserve">
          <source>Note that invariant checking (namely the &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;alwaysSucceeds&lt;/code&gt; functions) has been removed. See ticket &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;#14324&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;removal proposal&lt;/a&gt;. Existing users are encouraged to encapsulate their STM operations in safe abstractions which can perform the invariant checking without help from the runtime system.</source>
          <target state="translated">변하지 않는 검사 (즉, &lt;code&gt;always&lt;/code&gt; 및 &lt;code&gt;alwaysSucceeds&lt;/code&gt; 함수)가 제거되었습니다. 티켓 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;# 14324&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;제거 제안서를&lt;/a&gt; 참조하십시오 . 기존 사용자는 런타임 시스템의 도움없이 변하지 않는 검사를 수행 할 수있는 안전한 추상화로 STM 작업을 캡슐화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bfd5ca80319611f2ad6a6d58665d93fcbb3c156f" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">이 유의 &lt;em&gt;하지 않는&lt;/em&gt; 관례의 유형 인스턴스 것으로 예상 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 필드를 구현한다. 그러나 &lt;code&gt;base&lt;/code&gt; 인스턴스는 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="525bc9621da46140b66110bf09981d8c0a2b7083" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">이 유의 &lt;em&gt;하지 않는&lt;/em&gt; 관례의 유형 인스턴스 것으로 예상 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 필드를 구현한다. 그러나 &lt;code&gt;base&lt;/code&gt; 인스턴스는 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccaf9ee57d711da801bed84dfadd525a75d70df7" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">이 점에 유의 &lt;em&gt;하지 않는&lt;/em&gt; 관례 모두의 유형 인스턴스 것으로 예상 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 순서 반지를 구현합니다. 사실에 &lt;code&gt;base&lt;/code&gt; 에만 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0ebefaf6a8fd7841a426ebbf90075219fca0d8" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">이 점에 유의 &lt;em&gt;하지 않는&lt;/em&gt; 관례 모두의 유형 인스턴스 것으로 예상 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 순서 반지를 구현합니다. 사실에 &lt;code&gt;base&lt;/code&gt; 에만 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2c82e2d7986abad0ba04ff393eba4038a79448c" translate="yes" xml:space="preserve">
          <source>Note that it &lt;strong&gt;does not&lt;/strong&gt; regard CR (&lt;code&gt;'\r'&lt;/code&gt;) as a newline character.</source>
          <target state="translated">이 점에 유의 &lt;strong&gt;하지 않는&lt;/strong&gt; CR (간주 &lt;code&gt;'\r'&lt;/code&gt; 개행 문자로).</target>
        </trans-unit>
        <trans-unit id="b265c3aed4a0fae4215ed6797047f0fad0de3ff1" translate="yes" xml:space="preserve">
          <source>Note that it doesn&amp;rsquo;t fully negate the effects of &lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; - the warning will still be enabled.</source>
          <target state="translated">&lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; 의 영향을 완전히 무시 하지는 않습니다 . 경고는 계속 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3552763f2d02369b30ff3cbbef7706ae37b7af80" translate="yes" xml:space="preserve">
          <source>Note that it is acceptable to use parentheses in a &lt;code&gt;inst_head&lt;/code&gt;. For instance, &lt;code&gt;instance (C a)&lt;/code&gt; is accepted, as is &lt;code&gt;instance forall a. (C a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inst_head&lt;/code&gt; 에 괄호를 사용할 수 있습니다 . 예를 들어, 모든 &lt;code&gt;instance (C a)&lt;/code&gt; 대한 인스턴스와 마찬가지로 인스턴스 (C a) 가 허용됩니다 &lt;code&gt;instance forall a. (C a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea6254822cea7a64100f40aab8def82b94101fda" translate="yes" xml:space="preserve">
          <source>Note that it is acceptable to use parentheses in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. For instance, &lt;code&gt;MkV1 :: forall a. (a) -&amp;gt; (V1)&lt;/code&gt; is acceptable, as is &lt;code&gt;MkV2 :: forall a. (a -&amp;gt; V2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prefix_gadt_body&lt;/code&gt; 에 괄호를 사용할 수 있습니다 . 예를 들어, &lt;code&gt;MkV1 :: forall a. (a) -&amp;gt; (V1)&lt;/code&gt; 은 &lt;code&gt;MkV2 :: forall a. (a -&amp;gt; V2)&lt;/code&gt; 와 마찬가지로 허용됩니다 . (a-&amp;gt; V2) .</target>
        </trans-unit>
        <trans-unit id="c83014bf24d82bb0e1a70474d5dce7c56ea55a43" translate="yes" xml:space="preserve">
          <source>Note that it is safe to call &lt;code&gt;waitForProcess&lt;/code&gt; for the same process in multiple threads. When the process ends, threads blocking on this call will wake in FIFO order.</source>
          <target state="translated">여러 스레드에서 동일한 프로세스에 대해 &lt;code&gt;waitForProcess&lt;/code&gt; 를 호출하는 것이 안전 합니다. 프로세스가 종료되면이 호출을 차단하는 스레드가 FIFO 순서로 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="7005610565a4c7898f3b659dd8d96fce7be60db0" translate="yes" xml:space="preserve">
          <source>Note that line numbers start counting at one, but column numbers start at zero. This choice was made to follow existing convention (i.e. this is how Emacs does it).</source>
          <target state="translated">줄 번호는 1부터 시작하지만 열 번호는 0부터 시작합니다. 이 선택은 기존 규칙을 따르도록 만들어졌습니다 (즉, Emacs가하는 방식).</target>
        </trans-unit>
        <trans-unit id="b58c5082533c6ce920a238e2630b3a0a649c4aa4" translate="yes" xml:space="preserve">
          <source>Note that memory allocation is unrelated to &lt;em&gt;live memory&lt;/em&gt;, also known as &lt;em&gt;heap residency&lt;/em&gt;. A thread can allocate a large amount of memory and retain anything between none and all of it. It is better to think of the allocation limit as a limit on &lt;em&gt;CPU time&lt;/em&gt;, rather than a limit on memory.</source>
          <target state="translated">메모리 할당은 &lt;em&gt;힙 상주&lt;/em&gt; 라고도 하는 &lt;em&gt;라이브 메모리&lt;/em&gt; 와 관련이 없습니다 . 스레드는 많은 양의 메모리를 할당 할 수 있으며 없음과 전체 사이에 어떤 것도 보유 할 수 있습니다. 할당 제한을 메모리 제한이 아니라 &lt;em&gt;CPU 시간&lt;/em&gt; 제한으로 생각하는 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="273d41914c5c6dac58d5704a8903f640ae883fcf" translate="yes" xml:space="preserve">
          <source>Note that module &lt;code&gt;D&lt;/code&gt; was compiled, but in this instance because its source hadn&amp;rsquo;t really changed, its interface remained the same, and the recompilation checker determined that &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; didn&amp;rsquo;t need to be recompiled.</source>
          <target state="translated">모듈 &lt;code&gt;D&lt;/code&gt; 는 컴파일되었지만이 경우 소스가 실제로 변경되지 않았고 인터페이스가 동일하게 유지되어 재 컴파일 검사기에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 다시 컴파일 할 필요가 없다고 판단했습니다.</target>
        </trans-unit>
        <trans-unit id="aa9b10733e365e8f6145122de16aa95fd734e161" translate="yes" xml:space="preserve">
          <source>Note that no assumptions may be made about the values representing stable pointers. In fact, they need not even be valid memory addresses. The only guarantee provided is that if they are passed back to Haskell land, the function &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; will be able to reconstruct the Haskell value referred to by the stable pointer.</source>
          <target state="translated">안정적인 포인터를 나타내는 값에 대해서는 가정 할 수 없습니다. 실제로 유효한 메모리 주소 일 필요도 없습니다. 제공된 유일한 보증은 이들이 Haskell 랜드로 다시 전달되면 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 함수 가 안정적인 포인터가 참조하는 Haskell 값을 재구성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ebfa96acca93e187bf978a8f0c66831f5deb550f" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">&lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt; 가 Prelude를 참조하는지 여부를 변경 하더라도 Prelude를 암시 적으로 참조하는 구문에 대해서는 경고가 제공되지 않습니다 . 예를 들어 &lt;code&gt;368&lt;/code&gt; 이 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; 의미하는 경우 경고가 제공되지 않습니다 (여기서 &lt;code&gt;Prelude&lt;/code&gt; 는 컴파일되는 모듈의 가져 오기에 관계없이 실제 Prelude 모듈을 나타냄).</target>
        </trans-unit>
        <trans-unit id="cc4fefad8cc30b2189f543b2c01f22060d9ca1a7" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt; 가 Prelude를 참조하는지 여부를 변경 하더라도 Prelude를 암시 적으로 참조하는 구문에 대해서는 경고가 표시되지 않습니다 . 예를 들어, &lt;code&gt;368&lt;/code&gt; 이 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; 의미하는 경우 경고가 표시되지 않습니다 (여기서 &lt;code&gt;Prelude&lt;/code&gt; 는 컴파일중인 모듈의 가져 오기에 관계없이 실제 Prelude 모듈을 나타냄).</target>
        </trans-unit>
        <trans-unit id="49a7cd2da732a498264fe69cdc55ccc2e5f59d22" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt; 가 Prelude를 참조하는지 여부를 변경 하더라도 Prelude를 암시 적으로 참조하는 구문에 대해서는 경고가 제공되지 않습니다 . 예를 들어 &lt;code&gt;368&lt;/code&gt; 이 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; 의미하는 경우 경고가 제공되지 않습니다 (여기서 &lt;code&gt;Prelude&lt;/code&gt; 는 컴파일중인 모듈의 가져 오기에 관계없이 실제 Prelude 모듈을 나타냄).</target>
        </trans-unit>
        <trans-unit id="b3961e6b1d44470d139a066bd7e5e99b36cc380d" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ASCII 범위를 벗어난 숫자 (예 : &quot;٤&quot;또는 &lt;code&gt;U+0664&lt;/code&gt; 와 같은 아라비아 숫자 )와 숫자가 아닌 숫자는이 함수에 의해 구문 분석되지만 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a7ed51f37ef06c30fed9104ea5ecb01d29f66f7e" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ASCII 범위를 벗어난 숫자 (예 : &quot;٤&quot;또는 &lt;code&gt;U+0664&lt;/code&gt; 와 같은 아라비아 숫자 )와 숫자가 아닌 숫자는이 함수에 의해 구문 분석되지만 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="3aca93abfde5ec064588876b85a983dba2e1d897" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">ASCII 범위 밖의 숫자와 숫자가 아닌 숫자는이 함수에 의해 선택되지만 &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 에서는 선택되지 않습니다 . 이러한 문자는 식별자의 일부일 수 있지만 프린터와 리더에서 숫자를 나타내는 데 사용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6ca479e6c19d19f7cbdf53fa1975eb3bf201fe0" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">ASCII 범위 밖의 숫자와 숫자가 아닌 숫자는이 함수에 의해 선택되지만 &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 에서는 선택되지 않습니다 . 이러한 문자는 식별자의 일부일 수 있지만 프린터와 리더에서 숫자를 나타내는 데 사용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="00198523cbc0082fb3428e68e1d61ecf58a45ae8" translate="yes" xml:space="preserve">
          <source>Note that on Windows parent directories &lt;code&gt;..&lt;/code&gt; are always fully expanded before the symbolic links, as consistent with the rest of the Windows API (such as &lt;code&gt;GetFullPathName&lt;/code&gt;). In contrast, on POSIX systems parent directories &lt;code&gt;..&lt;/code&gt; are expanded alongside symbolic links from left to right. To put this more concretely: if &lt;code&gt;L&lt;/code&gt; is a symbolic link for &lt;code&gt;R/P&lt;/code&gt;, then on Windows &lt;code&gt;L\..&lt;/code&gt; refers to &lt;code&gt;.&lt;/code&gt;, whereas on other operating systems &lt;code&gt;L/..&lt;/code&gt; refers to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">Windows 상위 디렉토리에서 &lt;code&gt;..&lt;/code&gt; 은 다른 Windows API (예 : &lt;code&gt;GetFullPathName&lt;/code&gt; ) 와 일치하여 기호 링크 전에 항상 완전히 확장됩니다 . 반면, POSIX 시스템의 상위 디렉토리에 &lt;code&gt;..&lt;/code&gt; 왼쪽에서 오른쪽으로 심볼릭 링크와 함께 확장됩니다. 보다 구체적으로 말하면 : &lt;code&gt;L&lt;/code&gt; 이 &lt;code&gt;R/P&lt;/code&gt; 에 대한 심볼릭 링크 인 경우 Windows &lt;code&gt;L\..&lt;/code&gt; 은을 참조하십시오 &lt;code&gt;.&lt;/code&gt; 다른 운영 체제에서 &lt;code&gt;L/..&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cce57e0602bd626d4114bc65f1120819b7a872c0" translate="yes" xml:space="preserve">
          <source>Note that packages only contain compiled code, so debugging a package requires finding its source and loading that directly.</source>
          <target state="translated">패키지에는 컴파일 된 코드 만 포함되므로 패키지를 디버깅하려면 소스를 찾아서 직접로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="92c2203dfd5a194d5612dfeec8df42a4f09f5338" translate="yes" xml:space="preserve">
          <source>Note that primitives are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">프리미티브는 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt; 입니다. 따라서 다음과 같은 법률이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9748416b7c720b60f4c8302a487524d4091598b0" translate="yes" xml:space="preserve">
          <source>Note that primitives are &lt;code&gt;Contravariant&lt;/code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">프리미티브는 &lt;code&gt;Contravariant&lt;/code&gt; &lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt; 입니다. 따라서 다음과 같은 법률이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b038144c16c5927ecb1a6490213329a05b30c08f" translate="yes" xml:space="preserve">
          <source>Note that processes which use the POSIX &lt;code&gt;exec&lt;/code&gt; system call (e.g. &lt;code&gt;gcc&lt;/code&gt;) require special care on Windows. Specifically, the &lt;code&gt;msvcrt&lt;/code&gt; C runtime used frequently on Windows emulates &lt;code&gt;exec&lt;/code&gt; in a non-POSIX compliant manner, where the caller will be terminated (with exit code 0) and execution will continue in a new process. As a result, on Windows it will appear as though a child process which has called &lt;code&gt;exec&lt;/code&gt; has terminated despite the fact that the process would still be running on a POSIX-compliant platform.</source>
          <target state="translated">POSIX &lt;code&gt;exec&lt;/code&gt; 시스템 호출 (예 : &lt;code&gt;gcc&lt;/code&gt; ) 을 사용하는 프로세스 는 Windows에서 특별한주의가 필요합니다. 특히, Windows에서 자주 사용되는 &lt;code&gt;msvcrt&lt;/code&gt; C 런타임은 POSIX를 준수하지 않는 방식으로 &lt;code&gt;exec&lt;/code&gt; 를 에뮬레이트합니다 . 여기서 호출자는 종료되고 종료 코드 0으로 종료되며 새 프로세스에서 계속 실행됩니다. 결과적으로 Windows 에서는 프로세스가 여전히 POSIX 호환 플랫폼에서 실행되고 있음에도 불구하고 &lt;code&gt;exec&lt;/code&gt; 라는 하위 프로세스 가 종료 된 것처럼 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="5e2096ed561c2bf3900c21383006ef3f61805855" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">종료자를 참조한다고해서 다른 객체가 종료되는 것을 반드시 막을 필요는 없습니다. A의 종료자가 아마도 사용 (B 참조하는 경우 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다음 유일한 보증은 B의 종결 자에의 이전에 시작되지 않을 것입니다. A와 B 모두가 도달 할 수없는 경우, 다음 두 파이 나라가 함께 시작됩니다. 참조 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 종료 자 순서에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="e1e90d7572d19320cf7344ae3b1d0ce896d5029a" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">종료자를 참조한다고해서 다른 객체가 종료되는 것을 반드시 막을 필요는 없습니다. A의 종료자가 아마도 사용 (B 참조하는 경우 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다음 유일한 보증은 B의 종결 자에의 이전에 시작되지 않을 것입니다. A와 B 모두가 도달 할 수없는 경우, 다음 두 파이 나라가 함께 시작됩니다. 참조 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 종료 자 순서에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="cc356b8793bb083a67ad53425e549e6eaf817f79" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is ignored. For example,</source>
          <target state="translated">&lt;code&gt;:^:&lt;/code&gt; 의 오른쪽 연관 은 무시됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ea16129864c9bc69b1267cd317e60b8e1cd54033" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is unused.</source>
          <target state="translated">&lt;code&gt;:^:&lt;/code&gt; 의 오른쪽 연관 은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb25fb232eaa8d92d1074e6f26210af239a4d814" translate="yes" xml:space="preserve">
          <source>Note that sequences are typically &lt;em&gt;slower&lt;/em&gt; than lists when using only operations for which they have the same big-(O) complexity: sequences make rather mediocre stacks!</source>
          <target state="translated">복잡도가 동일한 (O) 복잡도를 가진 연산 만 사용할 때 시퀀스는 일반적으로 목록보다 &lt;em&gt;느립니다&lt;/em&gt; . 시퀀스는 다소 평범한 스택을 만듭니다!</target>
        </trans-unit>
        <trans-unit id="c723aeed4af9dd83a9b82069c07b9c3ccbc5da99" translate="yes" xml:space="preserve">
          <source>Note that signature matching does check if &lt;em&gt;fixity&lt;/em&gt; matches, so be sure specify fixity of ordinary identifiers if you intend to use them with backticks.</source>
          <target state="translated">서명 일치는 고 &lt;em&gt;정성이&lt;/em&gt; 일치하는지 확인하므로 백틱과 함께 사용하려면 일반 식별자의 고정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f095c03ad06a310fd52b2a6d717b98f26776e7da" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;integer-gmp&lt;/code&gt; does not depend on &lt;code&gt;base&lt;/code&gt;, error reporting via exceptions, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; is not available. Instead, the low-level functions will crash the runtime if called with invalid arguments.</source>
          <target state="translated">이후 있습니다 &lt;code&gt;integer-gmp&lt;/code&gt; 에 의존하지 않는 &lt;code&gt;base&lt;/code&gt; , 예외를 통해 오류보고 &lt;code&gt;error&lt;/code&gt; , 또는 &lt;code&gt;undefined&lt;/code&gt; 사용할 수 없습니다. 대신 잘못된 인수로 호출하면 하위 수준 함수가 런타임에 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="9b83514c0ce414a47b834dc48f510e88bcd807c9" translate="yes" xml:space="preserve">
          <source>Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group</source>
          <target state="translated">표현식 스플 라이스가 동일한 선언 그룹의 선언을 참조 할 수 없으므로 선언 그룹을 분리하기 위해 최상위 (빈) 스플 라이스를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19af66470dd0fd372aaa290faf9416a29cb5103d" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">결과 표현식의 헤드는 연산자를 목록의 첫 번째 요소에 적용하여 생성되므로 오른쪽 인수에 lazy 연산자가 주어지면 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 는 제한되지 않은 목록에서 종료 표현식을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1edeaaceca22d9e6e48a4ec76b65a79cb29fc0dc" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">결과 표현식의 헤드는 연산자를 목록의 첫 번째 요소에 적용하여 생성되므로 오른쪽 인수에 lazy 연산자가 주어지면 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 는 제한되지 않은 목록에서 종료 표현식을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa5cc95e997d42e3f9b2f8917f3475eae62b8bc" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">결과 표현식의 헤드는 연산자를 목록의 첫 번째 요소에 적용하여 생성되므로 오른쪽 인수에 lazy 연산자가 주어지면 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 는 제한되지 않은 목록에서 종료 표현식을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74f896437a88c7d014238b3770a7c1c62b51099" translate="yes" xml:space="preserve">
          <source>Note that the 32-bit x86 native code generator only supports excess-precision mode, so neither &lt;code&gt;-fexcess-precision&lt;/code&gt; nor &lt;code&gt;-fno-excess-precision&lt;/code&gt; has any effect. This is a known bug, see &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;.</source>
          <target state="translated">32 비트 x86 기본 코드 생성기는 초과 정밀도 모드 만 지원하므로 &lt;code&gt;-fexcess-precision&lt;/code&gt; 및 &lt;code&gt;-fno-excess-precision&lt;/code&gt; 은 영향을 미치지 않습니다. 이것은 알려진 버그 &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;입니다 (GHC의 버그&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="330613fe18f73ee23466f7511d7b202676e5cd38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-odir&lt;/code&gt; option does &lt;em&gt;not&lt;/em&gt; affect where the interface files are put; use the &lt;code&gt;-hidir&lt;/code&gt; option for that. In the above example, they would still be put in &lt;code&gt;parse/Foo.hi&lt;/code&gt;, &lt;code&gt;parse/Bar.hi&lt;/code&gt;, and &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;-odir&lt;/code&gt; 옵션은 않습니다 &lt;em&gt;하지&lt;/em&gt; 인터페이스 파일을 넣어 어디 영향; 이를 위해 &lt;code&gt;-hidir&lt;/code&gt; 옵션을 사용하십시오 . 위의 예에서 여전히 &lt;code&gt;parse/Foo.hi&lt;/code&gt; , &lt;code&gt;parse/Bar.hi&lt;/code&gt; 및 &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt; 에 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="309a5bb3e84ee602253ec738970608aecfccc201" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">점을 유의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 있어서, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 특히 지연 아니다. 무엇이든 생성하기 위해서는 개별 결과 시퀀스의 로그 합계에 비례하는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ecf7bfd1b411f608d1147e0ef0a9518d1e3597b7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">점을 유의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 있어서, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 특히 지연 아니다. 무엇이든 생성하려면 개별 결과 시퀀스의 로그 합계에 비례하는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9baa0deab26388879fdb97317652cc5b58ef6ba5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">점을 유의 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 있어서, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 특히 지연 아니다. 무엇이든 생성하려면 개별 결과 시퀀스의 로그 합계에 비례하는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="5e6f2cf53da86d8f316c7d0c0ffc6df711b35a02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">있습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 이에서 사용중인 인코더 / 디코더의 상태에 대해 아무것도 기억하지 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 예를 들어 사용중인 인코딩이 UTF-16 인 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 사용 하여 인코딩을 저장하고 복원하면 추가 바이트 순서 표시가 파일에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="532a96aa546fe516b65f4c317f8d98964d1adb0b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">있습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 이에서 사용중인 인코더 / 디코더의 상태에 대해 아무것도 기억하지 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 예를 들어, 사용중인 인코딩이 UTF-16 인 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 사용 하여 인코딩을 저장 및 복원하면 추가 바이트 순서 표시가 파일에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5177125357c8ba392c64ff5a83db619e0110c256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">있습니다 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 이에서 사용중인 인코더 / 디코더의 상태에 대해 아무것도 기억하지 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 예를 들어 사용중인 인코딩이 UTF-16 인 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 사용 하여 인코딩을 저장하고 복원하면 추가 바이트 순서 표시가 파일에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2204063e4c34f1c3a4a4b15d40a00171735eecd7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">있습니다 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 이에서 사용중인 인코더 / 디코더의 상태에 대해 아무것도 기억하지 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . 예를 들어, 사용중인 인코딩이 UTF-16 인 경우 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 사용 하여 인코딩을 저장 및 복원하면 추가 바이트 순서 표시가 파일에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b693c1b448bc94cf66607a78730b10d509a368a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Lift&lt;/code&gt; typeclass takes advantage of &lt;a href=&quot;#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt; in order to support instances involving unboxed types. This means &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; also works for these types:</source>
          <target state="translated">있습니다 &lt;code&gt;Lift&lt;/code&gt; typeclass이 이용합니다 &lt;a href=&quot;#runtime-rep&quot;&gt;경솔 다형성을&lt;/a&gt; 언 박싱 된 유형을 포함하는 지원 인스턴스 위해. 이는 &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; 가 다음 유형에서도 작동 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="7e0b7ebca01c04086bce79e74e8b55a503cf518c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Lift&lt;/code&gt; typeclass takes advantage of &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt; in order to support instances involving unboxed types. This means &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; also works for these types:</source>
          <target state="translated">있습니다 &lt;code&gt;Lift&lt;/code&gt; typeclass이 이용합니다 &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;경솔 다형성을&lt;/a&gt; 언 박싱 된 유형을 포함하는 지원 인스턴스 위해. 이는 &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; 가 다음 유형에서도 작동 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="9f1e65aa301e4b1be82f664f9499398a1e7e1f92" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Prelude&lt;/code&gt; import is marked as implicit. It can be overridden with an explicit &lt;code&gt;Prelude&lt;/code&gt; import, just like in a Haskell module.</source>
          <target state="translated">있습니다 &lt;code&gt;Prelude&lt;/code&gt; 가져 오기가 암시 적으로 표시됩니다. Haskell 모듈에서와 같이 명시적인 &lt;code&gt;Prelude&lt;/code&gt; 가져 오기 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="502132d21d5978b3a8ec6cd6de231a4d98125ce2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;nominal&lt;/code&gt; type arguments are equal, the &lt;code&gt;representational&lt;/code&gt; type arguments can differ, but need to have a &lt;code&gt;Coercible&lt;/code&gt; instance themself, and the &lt;code&gt;phantom&lt;/code&gt; type arguments can be changed arbitrarily.</source>
          <target state="translated">참고는 것을 &lt;code&gt;nominal&lt;/code&gt; 형식 인수가 동일한의 &lt;code&gt;representational&lt;/code&gt; 형식 인수는 다를 수 있지만 필요는 가지고 &lt;code&gt;Coercible&lt;/code&gt; 경우 스스로가를, 그리고 &lt;code&gt;phantom&lt;/code&gt; 형태 인수를 임의로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e840ae12e6ff09c359b921347e60a8e6a051ed31" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 인수에 전달 된 &lt;code&gt;restore&lt;/code&gt; 조치는 비동기 예외를 반드시 마스크 해제 할 필요는 없으며 마스킹 상태를 엔 클로징 컨텍스트의 상태로 복원합니다. 따라서 비동기 예외가 이미 마스크 된 경우 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하여 예외를 다시 마스크 해제 할 수 없습니다. 따라서 예외가 마스크 된 라이브러리 함수를 호출하면 라이브러리 호출이 예외를 다시 마스크 해제 할 수 없도록 할 수 있습니다. 라이브러리 코드를 작성 중이고 비동기 예외를 사용해야하는 경우 유일한 방법은 새 스레드를 작성하는 것입니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87a7979be5edffeddb07b20613db6dbe774e135f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 인수에 전달 된 &lt;code&gt;restore&lt;/code&gt; 조치는 비동기 예외를 반드시 마스크 해제 할 필요는 없으며 마스킹 상태를 엔 클로징 컨텍스트의 상태로 복원합니다. 따라서 비동기 예외가 이미 마스크 된 경우 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하여 예외를 다시 마스크 해제 할 수 없습니다. 따라서 예외가 마스크 된 라이브러리 함수를 호출하면 라이브러리 호출이 예외를 다시 마스크 해제 할 수 없도록 할 수 있습니다. 라이브러리 코드를 작성 중이고 비동기 예외를 사용해야하는 경우 유일한 방법은 새 스레드를 작성하는 것입니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="454010dcf1120ceeb3132c227f791c724eec83d9" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 인수에 전달 된 &lt;code&gt;restore&lt;/code&gt; 조치는 비동기 예외를 반드시 마스크 해제 할 필요는 없으며 마스킹 상태를 엔 클로징 컨텍스트의 상태로 복원합니다. 따라서 비동기 예외가 이미 마스크 된 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하여 예외를 다시 마스크 해제 할 수 없습니다. 따라서 예외가 마스크 된 라이브러리 함수를 호출하면 라이브러리 호출이 예외를 다시 마스크 해제 할 수 없도록 할 수 있습니다. 라이브러리 코드를 작성 중이고 비동기 예외를 사용해야하는 경우 유일한 방법은 새 스레드를 작성하는 것입니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="170a4ee31f2d0f202d220168ec1fdc8ad29400b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 에 대한 인수에 전달 된 &lt;code&gt;restore&lt;/code&gt; 작업이 반드시 비동기 예외의 마스크를 해제하는 것은 아니며, 마스킹 상태를 둘러싸는 컨텍스트의 상태로 복원 할뿐입니다. 따라서 비동기 예외가 이미 마스크 된 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하여 예외를 다시 마스크 해제 할 수 없습니다. 이는 마스킹 된 예외를 사용하여 라이브러리 함수를 호출하는 경우 라이브러리 호출이 예외 마스킹을 다시 해제 할 수 없도록하기위한 것입니다. 라이브러리 코드를 작성 중이고 비동기 예외를 사용해야하는 경우 유일한 방법은 새 스레드를 만드는 것입니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3624d40bf59c16249f1f5a20a1a937e21d71882b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 에 대한 인수에 전달 된 &lt;code&gt;restore&lt;/code&gt; 작업이 반드시 비동기 예외의 마스크를 해제하는 것은 아니며, 마스킹 상태를 둘러싸는 컨텍스트의 상태로 복원 할뿐입니다. 따라서 비동기 예외가 이미 마스크 된 경우 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용하여 예외를 다시 마스크 해제 할 수 없습니다. 이는 마스킹 된 예외를 사용하여 라이브러리 함수를 호출하는 경우 라이브러리 호출이 예외 마스킹을 다시 해제 할 수 없도록하기위한 것입니다. 라이브러리 코드를 작성 중이고 비동기 예외를 사용해야하는 경우 유일한 방법은 새 스레드를 만드는 것입니다. &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e60d714ad07dfbcb448ae9178edf63b83c268312" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;via&lt;/code&gt; type does not have to be a &lt;code&gt;newtype&lt;/code&gt;. The only restriction is that it is coercible with the original data type. This means there can be arbitrary nesting of newtypes, as in the following example:</source>
          <target state="translated">점을 유의 &lt;code&gt;via&lt;/code&gt; 유형이 될 필요가 없습니다 &lt;code&gt;newtype&lt;/code&gt; 은 . 유일한 제한 사항은 원래 데이터 유형과 강제 변환한다는 것입니다. 이는 다음 예와 같이 newtype이 임의로 중첩 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49a9ad3bbf35b1a32c2be7eda4a33ddd430bcebb" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">ASCII 인코딩은 UTF-8 인코딩의 하위 집합 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 최적화 함수 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 UTF-8 인코딩 숫자로 10 진수로 인코딩 할 수 있습니다 . 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 는 보다 효율적입니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 중간 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 구성하지 않기 때문에 show . 이러한 중간 데이터 구조를 피하면 &lt;code&gt;Cell&lt;/code&gt; s 인코딩 이 CSV 테이블 렌더링의 핵심 작업 이므로 성능이 크게 향상됩니다 . 참조 &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim을&lt;/a&gt; 의 성능을 개선하는 방법에 대한 자세한 내용은 &lt;code&gt;renderString&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="c0dbdccc6b0227bdbf0bac2e7e966328224fe997" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">ASCII 인코딩은 UTF-8 인코딩의 하위 집합이므로 최적화 된 함수 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 UTF-8로 인코딩 된 숫자로 10 진수로 인코딩 할 수 있습니다 . 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 는 보다 효율적입니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; , 중간 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 생성을 방지하기 때문 입니다. 이 중간 데이터 구조를 피하면 &lt;code&gt;Cell&lt;/code&gt; 인코딩 이 CSV 테이블 렌더링의 핵심 작업 이므로 성능이 크게 향상됩니다 . 참조 &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim을&lt;/a&gt; 의 성능을 개선하는 방법에 대한 자세한 내용은 &lt;code&gt;renderString&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="72baf6503424ff97ce5c5dd03531e15932ab0bf3" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">ASCII 인코딩은 UTF-8 인코딩의 하위 집합이므로 최적화 된 함수 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 UTF-8 인코딩 숫자로 10 진수로 인코딩 할 수 있습니다 . 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 는 보다 효율적입니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; , 중간 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 생성하지 않기 때문 입니다. 이 중간 데이터 구조를 피하면 &lt;code&gt;Cell&lt;/code&gt; 인코딩 이 CSV 테이블 렌더링의 핵심 작업 이므로 성능이 크게 향상됩니다 . 참조 &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim을&lt;/a&gt; 의 성능을 개선하는 방법에 대한 자세한 내용은 &lt;code&gt;renderString&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="72f06bfc55bfbd403475823742e13e429c0ca2e0" translate="yes" xml:space="preserve">
          <source>Note that the RTS will not set CPU affinity for bound threads and threads entering Haskell from C/C++, so if your program uses bound threads you should ensure that each bound thread calls the RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; from C/C++ before calling into Haskell. Otherwise there could be a mismatch between the CPU that the thread is running on and the memory it is using while running Haskell code, which will negate any benefits of &lt;code&gt;--numa&lt;/code&gt;.</source>
          <target state="translated">RTS는 C / C ++에서 Haskell에 들어가는 바운드 스레드 및 스레드에 대한 CPU 선호도를 설정하지 않으므로 프로그램이 바운드 스레드를 사용하는 경우 각 바운드 스레드가 C / C ++에서 RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; 를 호출하는지 확인해야합니다. 하스켈을 불러 그렇지 않으면 스레드가 실행중인 CPU와 Haskell 코드를 실행하는 동안 사용중인 메모리간에 불일치가있을 수 있으며, 이로 인해 &lt;code&gt;--numa&lt;/code&gt; 의 이점이 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="33e79ebf6a7ee502ff6ae1da2ae2588427c0bcf7" translate="yes" xml:space="preserve">
          <source>Note that the ability to catch an exception does &lt;em&gt;not&lt;/em&gt; guarantee that we can deal with all possible exit points from a computation. Some monads, such as continuation-based stacks, allow for more than just a success/failure strategy, and therefore &lt;code&gt;catch&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; be used by those monads to properly implement a function such as &lt;code&gt;finally&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadMask&quot;&gt;MonadMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외를 잡을 수 있다고해서 계산에서 가능한 모든 종료점을 다룰 수 있다는 보장 은 &lt;em&gt;없습니다&lt;/em&gt; . 연속 기반 스택과 같은 일부 모나드는 성공 / 실패 전략 이상의 것을 허용하므로 이러한 모나드는 &lt;code&gt;finally&lt;/code&gt; 와 같은 함수를 제대로 구현 하기 &lt;code&gt;catch&lt;/code&gt; &lt;em&gt;사용할 수 없습니다&lt;/em&gt; . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadMask&quot;&gt;MonadMask&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d5dd0ddd0336b419dba13d539e292846c264a2" translate="yes" xml:space="preserve">
          <source>Note that the application of &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; is not an action in the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context, as &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; type. While the fresh bindings in the following example will force the &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; expressions to be reduced every time the &lt;code&gt;do&lt;/code&gt;-block is executed, &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; would only be reduced once, and the message would only be printed once. If your monad is in &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; may be a better option.</source>
          <target state="translated">의 적용합니다 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 가 에서 작업하지 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 으로 문맥, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 가 에 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 유형입니다. 다음 예제의 새로운 바인딩 은 &lt;code&gt;do&lt;/code&gt; - &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 표현식이 감소되도록 강제하지만 traceM &quot;충돌되지 않음&quot; 은 한 번만 감소되며 메시지는 한 번만 인쇄됩니다. 모나드가 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 에있는 경우 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt; 가 더 나은 옵션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84f82e7fb65a174913c30b1e72c6c8b2742829f2" translate="yes" xml:space="preserve">
          <source>Note that the bang has no effect at all in this case</source>
          <target state="translated">이 경우 뱅은 전혀 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4b32cd6cbf824718f0bdfb9b704b062cdf90b8a" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">현재 구현은 3 개 이상의 서브맵을 리턴하지 않지만, 향후 통지없이 변경 될 수 있으므로이 동작에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="68d7fa1f654e15d8602e5a0f9e4ae840941c5c24" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three subsets, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">현재 구현은 세 개 이상의 하위 집합을 반환하지 않지만 나중에 예고없이 변경 될 수 있으므로이 동작에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="adfda92db68ba407dc5fdfba24f554547fcbb251" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">현재 구현은 두 개 이상의 서브맵을 반환하지는 않지만이 동작은 나중에 예고없이 변경 될 수 있으므로이 동작에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a8b5ab808606c44886a770fd7971f5bf90a9f368" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two subsets, but you should not depend on this behaviour because it can change in the future without notice. Also, the current version does not continue splitting all the way to individual singleton sets -- it stops at some point.</source>
          <target state="translated">현재 구현은 두 개 이상의 하위 집합을 반환하지 않지만 나중에 예고없이 변경 될 수 있으므로이 동작에 의존해서는 안됩니다. 또한 현재 버전은 개별 싱글 톤 세트로 계속 분할되지 않으며 어느 시점에서 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="086a1162aacfb2236087d8ed35712ce6942f14ad" translate="yes" xml:space="preserve">
          <source>Note that the datatype &lt;code&gt;G&lt;/code&gt; is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion. It is thus only possible to use this feature if you have provided a complete user-supplied kind signature for the datatype (&lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">데이터 유형 &lt;code&gt;G&lt;/code&gt; 는 본문에서 다른 종류로 사용되므로 종류 인덱스 GADT는 다형성 재귀 형식을 사용합니다. 따라서 데이터 유형에 대해 완전한 사용자 제공 종류 서명을 제공 한 경우에만이 기능을 사용할 수 있습니다 ( &lt;a href=&quot;#complete-kind-signatures&quot;&gt;완전한 사용자 제공 종류 서명 및 다형성 재귀&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="442f6f35f8b2e112d5cfdda0a46fff2deeaa6cc5" translate="yes" xml:space="preserve">
          <source>Note that the following operator interactions are expected to hold:</source>
          <target state="translated">다음과 같은 연산자 상호 작용이 유지 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c120d45347ef3551abdd412d6c3c744d162a17b6" translate="yes" xml:space="preserve">
          <source>Note that the foreign function &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;ccall&lt;/code&gt; calling convention.</source>
          <target state="translated">외부 함수 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;ccall&lt;/code&gt; 호출 규칙을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b614124ab834b2d7b11895f2dcc340c5cee01ee" translate="yes" xml:space="preserve">
          <source>Note that the formatting for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; types is currently a bit different from that of C &lt;code&gt;printf(3)&lt;/code&gt;, conforming instead to &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; (and their alternate versions &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt;). This is hard to fix: the fixed versions would format in a backward-incompatible way. In any case the Haskell behavior is generally more sensible than the C behavior. A brief summary of some key differences:</source>
          <target state="translated">서식 유의 &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 의 종류, 현재의 C와는 다른 비트 &lt;code&gt;printf(3)&lt;/code&gt; 에 따르는 대신, &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; (및 다른 버전 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt; ). 고정 버전은 이전 버전과 호환되지 않는 방식으로 포맷됩니다. 어쨌든 하스켈 행동은 일반적으로 C 행동보다 더 합리적입니다. 몇 가지 주요 차이점에 대한 간략한 요약 :</target>
        </trans-unit>
        <trans-unit id="6333d0cd3c8a1c9277e720de89a814eceeaca59c" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">기능이 유의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; 는 (아래 사용 기록 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 구성하기에 충분할)를 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 모든 비 재귀 대수 데이터 유형들에 대한. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e5834f94034f4c9c7099a4fe839728a49c4d2727" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">기능이 유의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; 는 (아래 사용 기록 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 구성하기에 충분할)를 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 모든 비 재귀 대수 데이터 유형들에 대한. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8f8de4b46e9fc5311e12637212df5e73b817991a" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;#8657&lt;/a&gt;.</source>
          <target state="translated">그래프 색상 할당자는 약간 실험적이며 높은 레지스터 압력 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;# 8657&lt;/a&gt; 코드에 직면하면 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45346d36f74c21a2830e97a59a45b659f59ada4b" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue #8657&lt;/a&gt;.</source>
          <target state="translated">그래프 색상 할당자는 약간 실험적이며 레지스터 압력이 높은 코드에 직면 할 때 실패 할 수 있음 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue # 8657&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e6fa4ccd6707887b270260302a346013c42cc4" translate="yes" xml:space="preserve">
          <source>Note that the implementation is &lt;em&gt;left-biased&lt;/em&gt; -- the elements of a first argument are always preferred to the second, for example in &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현은 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 첫 번째 인수의 요소는 예를 들어 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 와 같이 두 번째 인수보다 항상 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="26e0c734ac95701d148351fdd4b47d9138fb0c9b" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 개의 맵을 인수로 가져 와서 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 과 같이 결합 하는 함수는 첫 번째 인수의 값 을 두 번째 맵 의 값보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="259d0e9c405d160a835af61c7ce39b23637e93f5" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 개의 맵을 인수로 가져 와서 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 과 같이 결합 하는 함수는 첫 번째 인수의 값 을 두 번째 맵 의 값보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="70bb8bafe9d5794e15a6e0a9bc59a3fd519eaaca" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 개의 맵을 인수로 가져 와서 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 과 같이 결합 하는 함수는 첫 번째 인수의 값 을 두 번째 맵 의 값보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f2ac01eed48e680198fa41a99d8fed147ac41510" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 개의 맵을 인수로 가져 와서 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 과 같이 결합 하는 함수는 첫 번째 인수의 값 을 두 번째 맵 의 값보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="38d11ff08ef387c96608bffa08a777dba57a2a33" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 개의 맵을 인수로 가져 와서 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 과 같이 결합 하는 함수는 첫 번째 인수의 값 을 두 번째 맵 의 값보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="cb352c04cf593932ccc7109649ee4df971ea1e0e" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two sets as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the entries in the first argument to those in the second. Of course, this bias can only be observed when equality is an equivalence relation instead of structural equality.</source>
          <target state="translated">구현은 일반적으로 &lt;em&gt;왼쪽 바이어스&lt;/em&gt; 입니다. 두 집합을 인수로 사용하고 &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 와 같이 결합 하는 함수는 첫 번째 인수의 항목을 두 번째 인수의 항목보다 선호합니다. 물론,이 편향은 평등이 구조적 평등 대신에 등가 관계인 경우에만 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a24a4ea20d65f2df9e64aaf0077349c30737f9" translate="yes" xml:space="preserve">
          <source>Note that the kind of &lt;code&gt;a&lt;/code&gt; is specified in the kind of &lt;code&gt;C&lt;/code&gt; but inferred in the kind of &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">의 종류 참고 &lt;code&gt;a&lt;/code&gt; 의 종류에 지정된 &lt;code&gt;C&lt;/code&gt; 만의 종류에 유추 &lt;code&gt;F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b863c9095848a793815119dcb80b73aa065664bb" translate="yes" xml:space="preserve">
          <source>Note that the line information in this section is not nearly as rich as the information provided in &lt;code&gt;.debug_info&lt;/code&gt;. Whereas &lt;code&gt;.debug_line&lt;/code&gt; requires that each instruction is assigned exactly one source location, the DIEs in &lt;code&gt;.debug_info&lt;/code&gt; can be used to identify all relevant sources locations.</source>
          <target state="translated">이 섹션의 줄 정보는 &lt;code&gt;.debug_info&lt;/code&gt; 에 제공된 정보만큼 풍부하지는 않습니다 . 반면 &lt;code&gt;.debug_line&lt;/code&gt; 내는 각 명령이 정확히 하나 개의 소스 위치를 할당해야합니다,의 다이 &lt;code&gt;.debug_info&lt;/code&gt; 는 모든 관련 소스 위치를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf810684fcb41725f6886705bdc64d801b1f9b52" translate="yes" xml:space="preserve">
          <source>Note that the local variables at each step in the history have been preserved, and can be examined as usual. Also note that the prompt has changed to indicate that we&amp;rsquo;re currently examining the first step in the history: &lt;code&gt;-1&lt;/code&gt;. The command &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt; can be used to traverse forward in the history.</source>
          <target state="translated">히스토리의 각 단계에서 로컬 변수가 보존되었으며 평소와 같이 검사 할 수 있습니다. 또한 현재 히스토리의 첫 번째 단계를 검토 중임을 표시하도록 프롬프트가 변경되었습니다. &lt;code&gt;-1&lt;/code&gt; . &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt; 명령 은 히스토리에서 앞으로 이동하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e761e2ee0af0b91555a2d86f5cd5907f02009f" translate="yes" xml:space="preserve">
          <source>Note that the operations to be qualified must be in scope for QualifiedDo to work. I.e. &lt;code&gt;import MAC (label)&lt;/code&gt; in the example above would result in an error, since &lt;code&gt;MAC.&amp;gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;MAC.&amp;gt;&amp;gt;&lt;/code&gt; would not be in scope.</source>
          <target state="translated">QualifiedDo가 작동하려면 자격을 부여 할 작업이 범위 내에 있어야합니다. 즉 , &lt;code&gt;MAC.&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;MAC.&amp;gt;&amp;gt;&lt;/code&gt; 가 범위에 포함되지 않기 때문에 위의 예에서 &lt;code&gt;import MAC (label)&lt;/code&gt; 는 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="34cdea8f3371da06ac1a345345c3c5002304f5fa" translate="yes" xml:space="preserve">
          <source>Note that the package might still end up being linked into the final program, if it is a dependency (direct or indirect) of another exposed package.</source>
          <target state="translated">패키지가 노출 된 다른 패키지의 종속성 (직접 또는 간접) 인 경우 최종 프로그램에 계속 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="654350bad2f19f9da14ea79da18d4e92d82c3375" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">엿보기 및 찌르기 기능이 제대로 작동하려면 올바르게 정렬 된 주소가 필요할 수 있습니다. 이것은 아키텍처에 따라 다릅니다. 따라서, 엿보기 휴대용 코드 또는 몇몇 타입의 파고 값 때 확인해야 &lt;code&gt;a&lt;/code&gt; 위한 얼라인먼트 제약 함수에 의해 주어진 바와 같이, &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 성취된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e394d38fdeaac337578117a43906351c1d79b5f" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">엿보기 및 찌르기 기능이 제대로 작동하려면 올바르게 정렬 된 주소가 필요할 수 있습니다. 이것은 아키텍처에 따라 다릅니다. 따라서, 엿보기 휴대용 코드 또는 몇몇 타입의 파고 값 때 확인해야 &lt;code&gt;a&lt;/code&gt; 위한 얼라인먼트 제약 함수에 의해 주어진 바와 같이, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 성취된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e73723a6b46c23d5ed4a216d4c7a2b7c6b5806fa" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 레벨 이므로 무제한 레벨이 있습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d82712c12c8cee5b77f4ba6fbc419e98e702525b" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 레벨 이므로 무제한 레벨이 있습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="22e279d3458c2e34319e6e20c6829368879e2a50" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 이므로 레벨 수에는 제한이 없습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="1166a95e8823cf3e0d0bc99a95c0278ded704bed" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 이므로 레벨 수에는 제한이 없습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3bfbd6466cf9031a0e65d2f5ee134d92903f93ba" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 이므로 레벨 수에는 제한이 없습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="48307915548614ed31e55439a104a2889c670ae0" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 레벨은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 이므로 레벨 수에는 제한이 없습니다. 이 모듈은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3f8de5a86d574b2ca399eee3e30f64be312fc9bc" translate="yes" xml:space="preserve">
          <source>Note that the rather verbose syntax for composition stems from the requirement to be able to compute the size / size bound at compile time.</source>
          <target state="translated">컴포지션의 다소 장황한 구문은 컴파일 타임에 바인딩 된 크기 / 크기를 계산할 수 있어야한다는 점에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="54b1d4f1be10b0845077542d67e90448dc344e0a" translate="yes" xml:space="preserve">
          <source>Note that the second example has a &lt;code&gt;forall&lt;/code&gt; that binds both a kind &lt;code&gt;k&lt;/code&gt; and a type variable &lt;code&gt;a&lt;/code&gt; of kind &lt;code&gt;k&lt;/code&gt;. In general, there is no limit to how deeply nested this sort of dependency can work. However, the dependency must be well-scoped: &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; is an error.</source>
          <target state="translated">참고 번째 예는 가지고 &lt;code&gt;forall&lt;/code&gt; 그 귀속 종류 모두 &lt;code&gt;k&lt;/code&gt; 및 입력 변수 가지 &lt;code&gt;k&lt;/code&gt; . 일반적으로 이러한 종류의 종속성이 얼마나 깊이 중첩 될 수 있는지에 대한 제한은 없습니다. 그러나 종속성은 범위가 &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; : forall (a :: k) k. ... 오류입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b1310d229e7aede634064e0ec7e66e799d19c89" translate="yes" xml:space="preserve">
          <source>Note that the second item only at the &lt;em&gt;head&lt;/em&gt; of the quantified constraint, not its context. Reason: the head is the new goal that has to be solved if we use the instance declaration.</source>
          <target state="translated">두 번째 항목 은 컨텍스트가 아닌 수량화 된 제약 조건 의 &lt;em&gt;헤드&lt;/em&gt; 에만 있습니다. 이유 : 헤드는 인스턴스 선언을 사용하는 경우 해결해야하는 새로운 목표입니다.</target>
        </trans-unit>
        <trans-unit id="3c8c63d3b44c41dfd3ecc9855ec677afa1387569" translate="yes" xml:space="preserve">
          <source>Note that the strictness of &lt;code&gt;f&lt;/code&gt; differs from that of &lt;code&gt;g&lt;/code&gt; defined below:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 엄격도는 아래 정의 된 &lt;code&gt;g&lt;/code&gt; 의 엄격 도와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b0d67f48c00a6048890cd9462dc5217e24546eeb" translate="yes" xml:space="preserve">
          <source>Note that the suffix rules are all repeated twice, once for normal Haskell source files, and once for &lt;code&gt;hs-boot&lt;/code&gt; files (see &lt;a href=&quot;#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;).</source>
          <target state="translated">접미사 규칙은 일반 Haskell 소스 파일 및 &lt;code&gt;hs-boot&lt;/code&gt; 파일에 대해 한 번씩 두 번 반복됩니다 ( &lt;a href=&quot;#mutual-recursion&quot;&gt;상호 재귀 모듈을 컴파일하는 방법&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ca6ebf983fc1a2fd926f4a83f66b04b8d23d1437" translate="yes" xml:space="preserve">
          <source>Note that the unmask function passed to the child thread should only be used in that thread; the behaviour is undefined if it is invoked in a different thread.</source>
          <target state="translated">자식 스레드에 전달 된 unmask 함수는 해당 스레드에서만 사용해야합니다. 다른 스레드에서 호출 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf747bb4028682f6c8c46cd28564c6d642c94e32" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s in instance declarations is somewhat restricted in comparison to other types. For example, instance declarations are not allowed to contain nested &lt;a href=&quot;#id3&quot;&gt;&lt;span id=&quot;id4&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s. See &lt;a href=&quot;instances#formal-instance-syntax&quot;&gt;Formal syntax for instance declaration types&lt;/a&gt; for more information.</source>
          <target state="translated">인스턴스 선언에서 &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;''&lt;/span&gt;&lt;/a&gt; forall`` 의 사용은 다른 유형에 비해 다소 제한됩니다. 예를 들어, 인스턴스 선언은 중첩 된 &lt;a href=&quot;#id3&quot;&gt;&lt;span id=&quot;id4&quot;&gt;''&lt;/span&gt;&lt;/a&gt; forall`` 을 포함 할 수 없습니다 . 자세한 내용 &lt;a href=&quot;instances#formal-instance-syntax&quot;&gt;은 인스턴스 선언 유형에&lt;/a&gt; 대한 형식적 구문을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="c1c671757e9a3af40d5bdde86bfebfd0651c0310" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; in this module conflicts with an operator with the same name that is being exported by &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;. However, this package re-exports (most of) the contents of Data.Monoid, so to use semigroups and monoids in the same package just</source>
          <target state="translated">참고 사용 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 에 의해 반출되고 같은 이름을 가진 조작이 모듈 충돌 &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; . 그러나이 패키지는 Data.Monoid의 내용을 대부분 내보내므로 동일한 패키지에 세미 그룹과 모노 ID를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="da3869327f08d21fab9f4a7548818e33dbc49531" translate="yes" xml:space="preserve">
          <source>Note that there is an orphan &lt;code&gt;Binary&lt;/code&gt; instance for this type supplied by the &lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt; module provided by &lt;code&gt;ghc-boot&lt;/code&gt;. We can't provide here as this would require adding transitive dependencies to the &lt;code&gt;template-haskell&lt;/code&gt; package, which must have a minimal dependency set.</source>
          <target state="translated">&lt;code&gt;ghc-boot&lt;/code&gt; 가 제공 하는 &lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt; 모듈에서 제공 한이 유형에 대한 고아 &lt;code&gt;Binary&lt;/code&gt; 인스턴스가 있습니다. 여기서는 최소한의 의존성 세트를 가져야하는 &lt;code&gt;template-haskell&lt;/code&gt; 패키지에 전이 의존성을 추가해야하므로 여기서 제공 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25f165099a7186900fe29f29d734746be66f7ff0" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">대문자 사용은 지원되지 않습니다. 대문자를 사용하는 16 진 인코딩 없이도 응용 프로그램이 작동하지 않으면 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="42fd927f1ef5d9b3a3e3d4ec201b36298d76dcdc" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer, if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">대문자 사용은 지원되지 않습니다. 대문자를 사용하는 16 진 인코딩 없이도 응용 프로그램을 사용할 수없는 경우 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="815e86136be57ff7983e8867a1653ca3748062a4" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 7 release series.</source>
          <target state="translated">이 GHC 릴리스에는 7 릴리스 시리즈의 LLVM 버전이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="054fc5bfe46fd252b25912f49de7b42d063bf60e" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 9 release series.</source>
          <target state="translated">이 GHC 릴리스는 9 릴리스 시리즈의 LLVM 버전을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="140a5a874045474c447887a9c7534e65797715b8" translate="yes" xml:space="preserve">
          <source>Note that this change relies on an existing meta-rule to resolve ambiguities:</source>
          <target state="translated">이 변경 사항은 기존 메타 규칙을 사용하여 모호성을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="6daa68880e86cbbf8117c1ecf2aaa1d59b601a6d" translate="yes" xml:space="preserve">
          <source>Note that this compatibility condition is independent of whether the type family is associated or not, and it is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">이 호환성 조건은 유형 군의 연관 여부에 관계없이 일관성의 문제 일뿐만 아니라 유형 안전성의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="6a49b31c7b3933e096f19de10387ce395bfc388b" translate="yes" xml:space="preserve">
          <source>Note that this feature is intended for debugging, and should not be relied on for the correct operation of your program. There is no guarantee that the garbage collector will be accurate enough to detect your deadlock, and no guarantee that the garbage collector will run in a timely enough manner. Basically, the same caveats as for finalizers apply to deadlock detection.</source>
          <target state="translated">이 기능은 디버깅을위한 것으로 프로그램의 올바른 작동에 의존해서는 안됩니다. 가비지 수집기가 교착 상태를 감지하기에 충분히 정확하다는 보장은 없으며 가비지 수집기가 적시에 충분한 방식으로 실행된다는 보장은 없습니다. 기본적으로 종료 자와 동일한 경고가 교착 상태 감지에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="09a81f8404822ee34cd07d9b5aaca225d5f7984b" translate="yes" xml:space="preserve">
          <source>Note that this flag makes GHC&amp;rsquo;s parser more strict so programs which are accepted without Haddock may be rejected with &lt;a href=&quot;#ghc-flag--haddock&quot;&gt;&lt;code&gt;-haddock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 GHC의 파서를 더 엄격하게 만들어 Haddock없이 받아 들여지는 프로그램은 &lt;a href=&quot;#ghc-flag--haddock&quot;&gt; &lt;code&gt;-haddock&lt;/code&gt; &lt;/a&gt; 으로 거부 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f93e105b95e71dad1e256717f21218ff603f0e60" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">이 기능은 작업에서 &lt;em&gt;엄격&lt;/em&gt; 합니다. 즉, &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt; 입니다. 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a3f1beae872eb8d0767738fe954a7102092701f" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchException undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">이 기능은 작업에서 &lt;em&gt;엄격&lt;/em&gt; 합니다. 즉, &lt;code&gt;catchException undefined b == _|_&lt;/code&gt; 입니다. 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="164ca1931ad3e1b8b8f22ee4c67b74af2bb32823" translate="yes" xml:space="preserve">
          <source>Note that this function may be called by multiple threads simultaneously.</source>
          <target state="translated">이 함수는 여러 스레드에서 동시에 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be14bcfbfa87beefee836b26fb76d5e01c5bceae" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 finalizer 간의 종속성을 표현하는 데이 함수를 사용해서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 자가 두 번째 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 touchForeignPtr 을 호출 하는 경우 &lt;code&gt;F2&lt;/code&gt; 의 종료자가 &lt;code&gt;F1&lt;/code&gt; 의 종료 자보다 먼저 시작되지 않는다는 것이 유일한 보장입니다 . 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 에 모두 도달 할 수없는 경우에는 함께 시작될 수 있으며 ,이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 의 종료자를 먼저 실행하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="4677b22a99bb8480062aaee7c99a3069c99501b0" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 finalizer 간의 종속성을 표현하는 데이 함수를 사용해서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 자가 두 번째 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 touchForeignPtr 을 호출 하는 경우 &lt;code&gt;F2&lt;/code&gt; 의 종료자가 &lt;code&gt;F1&lt;/code&gt; 의 종료 자보다 먼저 시작되지 않는다는 것이 유일한 보장입니다 . 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 에 모두 도달 할 수없는 경우에는 함께 시작될 수 있으며 ,이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 의 종료자를 먼저 실행하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="204ab198814021ed6627310d82463388c4393515" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 finalizer 간의 종속성을 표현하는 데이 함수를 사용해서는 안됩니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 자가 두 번째 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; 에서 touchForeignPtr 을 호출 하는 경우 &lt;code&gt;F2&lt;/code&gt; 의 종료자가 &lt;code&gt;F1&lt;/code&gt; 의 종료 자보다 먼저 시작되지 않는다는 것이 유일한 보장입니다 . 예를 들어 &lt;code&gt;F1&lt;/code&gt; 과 &lt;code&gt;F2&lt;/code&gt; 에 모두 도달 할 수없는 경우에는 함께 시작될 수 있으며 ,이 경우 스케줄러가 &lt;code&gt;F2&lt;/code&gt; 의 종료자를 먼저 실행하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="6e3ecf4648736200d9ff929266ddf8cefc397759" translate="yes" xml:space="preserve">
          <source>Note that this is a &quot;shallow&quot; test; the declarations returned merely have instance heads which unify with &lt;code&gt;nm tys&lt;/code&gt;, they need not actually be satisfiable.</source>
          <target state="translated">이것은 &quot;얕은&quot;테스트입니다. 반환 된 선언은 단지 &lt;code&gt;nm tys&lt;/code&gt; 와 통합되는 인스턴스 헤드를 가지고 있으며 실제로 만족할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="439905505d9474fed9ffc65381b6ac6111a52311" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 이 이미 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 과의 일관성에 대한 동작 변경입니다. 0.5 이전 버전에서는 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="a0ff55b445dc3b8027838fa247f8b759ea676ef6" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 이 이미 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 과의 일관성에 대한 동작 변경입니다. 0.5 이전 버전에서는 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="159781685c28a0f652ef7a2657affedee9b597c8" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 이 이미 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 과의 일관성에 대한 동작 변경입니다. 0.5 이전 버전에서는 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="ade4eadc51bb90be35da5528bf329479e583e59a" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 이 이미 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; 버전 0.5 와의 일관성에 대한 동작 변경으로 인해 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="191887df22eeccf7c1081143dfdd938d7b2699e9" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 이 이미 비어 있으면 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; 버전 0.5 와의 일관성에 대한 동작 변경으로 인해 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="b569264b0537b82b52a587dd6185d1e70e6667fe" translate="yes" xml:space="preserve">
          <source>Note that this is an &lt;em&gt;expensive&lt;/em&gt; operation that forces the whole lazy ByteString into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</source>
          <target state="translated">이것은 게으른 ByteString을 메모리에 강제로 저장하고 모든 데이터를 복사 하는 &lt;em&gt;고가의&lt;/em&gt; 작업입니다. 가능하면 엄격한 바이트 스트링과 게으른 바이트 스트링간에 앞뒤로 변환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="94e1d743d6549fd6c8f8a3e5156f86de80dc015d" translate="yes" xml:space="preserve">
          <source>Note that this is essentially a type-specialized version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt;. This function has a more common signature (matching the signature from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;), and is often more convenient to use. By contrast, &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; is more expressive, allowing us to implement other functions like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 의 유형 특화 버전입니다 . 이 함수는보다 일반적인 시그니처 ( &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 시그니처와 일치 )를 가지며 종종 사용하기 더 편리합니다. 대조적으로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 은 더 표현력이 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt; 와 같은 다른 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2df90bf5e787f12773d403c246b319494ad6a673" translate="yes" xml:space="preserve">
          <source>Note that this is essentially a type-specialized version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt;. This function has a more common signature (matching the signature from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;), and is often more convenient to use. By contrast, &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; is more expressive, allowing us to implement other functions like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 의 유형 특화 버전입니다 . 이 함수는보다 일반적인 시그니처 ( &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 시그니처와 일치 )를 가지며 종종 사용하기 더 편리합니다. 대조적으로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 은 더 표현력이 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt; 와 같은 다른 함수를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6aebbc89aa137801ec2b9b8db93a16d46e98c00" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as a grapheme (e.g. a composition of code points that form one visual symbol). For instance, consider the grapheme &quot;&amp;auml;&quot;. This symbol has two Unicode representations: a single code-point representation &lt;code&gt;U+00E4&lt;/code&gt; (the &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; code point), and a two code point representation &lt;code&gt;U+0061&lt;/code&gt; (the &quot;&lt;code&gt;A&lt;/code&gt;&quot; code point) and &lt;code&gt;U+0308&lt;/code&gt; (the &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; code point).</source>
          <target state="translated">이것은 grapheme과 같은 것이 아닙니다 (예 : 하나의 시각적 기호를 형성하는 코드 포인트의 구성). 예를 들어, 그래프 &quot;&amp;auml;&quot;를 고려하십시오. 이 기호에는 두 개의 유니 코드 표현이 있습니다. 단일 코드 포인트 표현 &lt;code&gt;U+00E4&lt;/code&gt; ( LAAERESIS가 있는 &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; 코드 포인트)와 두 코드 포인트 표현 &lt;code&gt;U+0061&lt;/code&gt; ( &quot; &lt;code&gt;A&lt;/code&gt; &quot;코드 포인트) 및 &lt;code&gt;U+0308&lt;/code&gt; ( &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; 코드 포인트).</target>
        </trans-unit>
        <trans-unit id="f1fb7a0e32b7e5f879759dbeacfe592b9604fb63" translate="yes" xml:space="preserve">
          <source>Note that this is only a specification, not necessarily the concrete implementation of the function.</source>
          <target state="translated">이것은 단지 사양 일 뿐이며, 함수의 구체적인 구현 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="669d9533b1634ff933892e992fae9bef3085f70e" translate="yes" xml:space="preserve">
          <source>Note that this is unsafe as it allows you to construct ill-kinded types.</source>
          <target state="translated">잘못된 유형을 구성 할 수 있으므로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d02571c77536bd22aa42f3d92c1dd568dc209d06" translate="yes" xml:space="preserve">
          <source>Note that this kind of backtracking parser is very inefficient; reading a large structure may be quite slow (cf &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 종류의 역 추적 파서는 매우 비효율적입니다. 큰 구조를 읽는 것은 상당히 느릴 수 있습니다 (cf &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="436febebad9716edb3813b0bdb233588fd016eb7" translate="yes" xml:space="preserve">
          <source>Note that this option also has an effect on code generation (see above).</source>
          <target state="translated">이 옵션은 코드 생성에도 영향을 미칩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="a6b15405a93ed10e85a7b3a620cdf673c82ced0d" translate="yes" xml:space="preserve">
          <source>Note that this policy has changed slightly in GHC 7.4.1 relative to earlier versions, and may yet change further, feedback is welcome.</source>
          <target state="translated">이 정책은 GHC 7.4.1에서 이전 버전에 비해 약간 변경되었으며, 더 변경 될 수 있으므로 피드백을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="b69c87ebe8336d7ccf7274b115a1b224456d8a37" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 와 함께 사용하면 오류가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="371339dae687a1a51a3fb07f036275ab96d4f0aa" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 와 함께 사용되는 경우 오류를 발생시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="690fcd2d09231ef4b1eb51f1d47ac594a9ff2305" translate="yes" xml:space="preserve">
          <source>Note that this will also match a function type,</source>
          <target state="translated">이것은 함수 유형과도 일치합니다.</target>
        </trans-unit>
        <trans-unit id="38577a39855d6c49037bc139ad505bfea55af18e" translate="yes" xml:space="preserve">
          <source>Note that to avoid wasting space, this value should typically be less than 10% of the size of a stack chunk (&lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-kc ⟨size⟩&lt;/code&gt;&lt;/a&gt;), because in a chain of stack chunks, each chunk will have a gap of unused space of this size.</source>
          <target state="translated">공간 낭비를 피하기 위해이 값은 일반적으로 스택 청크 크기 ( &lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-kc ⟨size⟩&lt;/code&gt; &lt;/a&gt; ) 의 10 %보다 작아야합니다. 스택 청크 체인에서는 각 청크에 사용되지 않은 공간의 간격이 있기 때문입니다. 크기.</target>
        </trans-unit>
        <trans-unit id="50c38f07d65fbe728d13e67127cf7478adb9040c" translate="yes" xml:space="preserve">
          <source>Note that to change some, but not all permissions, a construct on the following lines must be used.</source>
          <target state="translated">모든 권한이 아닌 일부 권한을 변경하려면 다음 행의 구성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="66851a84c14b94c80085f7f6434bc9436c845696" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">연산자의 가장 바깥 쪽 응용 프로그램을 생성하려면 전체 입력 목록을 통과해야합니다. 모든 왼쪽 연관 접기와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 무한 목록이 주어지면 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="a61c274d0b954c6dca484514778958a431247b5e" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">연산자의 가장 바깥 쪽 응용 프로그램을 생성하려면 전체 입력 목록을 통과해야합니다. 모든 왼쪽 연관 접기와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 무한 목록이 주어지면 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="9b90a1692bdb0a28629187868f305ac5e1a54c18" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">연산자의 가장 바깥 쪽 응용 프로그램을 생성하려면 전체 입력 목록을 통과해야합니다. 모든 왼쪽 연관 접기와 마찬가지로 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 무한 목록이 주어지면 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="948767acfa623815c2e53deacab04e0b2b72ef49" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">연산자의 가장 바깥 쪽 응용 프로그램을 생성하려면 전체 입력 목록을 순회해야합니다. 이것은 무한 목록이 주어지면 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 이 분기 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="1c06bd2a9205927068bd825ef9aa825d38908e90" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">연산자의 가장 바깥 쪽 응용 프로그램을 생성하려면 전체 입력 목록을 순회해야합니다. 이것은 무한 목록이 주어지면 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 이 분기 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="09a9ad7f696385ace7655fee5e3964335e8ceabd" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;&lt;a href=&quot;data-set#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-set#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; replace an element equal to the given value.</source>
          <target state="translated">달리 유의 &lt;code&gt;&lt;a href=&quot;data-set#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-set#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 는 것 &lt;em&gt;없는&lt;/em&gt; 요소를 대체 지정된 값과 동일.</target>
        </trans-unit>
        <trans-unit id="639bcb4a8a84771a9594ddef615c26a4482fa193" translate="yes" xml:space="preserve">
          <source>Note that using this option when linking causes GHC to link against shared libraries.</source>
          <target state="translated">링크 할 때이 옵션을 사용하면 GHC가 공유 라이브러리에 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="15c08fdbeb90f2cad5ab816623c21e3981596c4c" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">컴포지션에서 나중에 사용되지 않는 변수가 투영됩니다. &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에 정의 된 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시&lt;/a&gt; 쓰기 규칙 ( 다시 쓰기 규칙 참조)을 사용하여 단순화 한 후</target>
        </trans-unit>
        <trans-unit id="d081dca768500d8bfebb68333b03740fb45995ab" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">나중에 컴포지션에서 사용되지 않는 변수는 투영됩니다. &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에 정의 된 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시&lt;/a&gt; 쓰기 규칙 ( 다시 쓰기 규칙 참조)을 사용하여 단순화 한 후</target>
        </trans-unit>
        <trans-unit id="9afd9087ab3e281f2d9f79e8753dffedc3950893" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">나중에 컴포지션에서 사용되지 않는 변수는 투영됩니다. &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; 모듈에 정의 된 &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;다시&lt;/a&gt; 쓰기 규칙 ( 다시 쓰기 규칙 참조)을 사용하여 단순화 한 후 다음 과 같이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="e5449f9493cc87f80694124b3b78a072657bfaa5" translate="yes" xml:space="preserve">
          <source>Note that we do promote existential data constructors that are otherwise suitable. For example, consider the following:</source>
          <target state="translated">다른 방식으로 적합한 존재 데이터 생성자를 승격시킵니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="314ff3aa2a3753338a78c5d3b1a3ae5cc49a2871" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">우리는 &lt;code&gt;e&lt;/code&gt; 에 타입 서명을 주어야한다. 그렇지 않으면 프로그램은 타입이 모호하기 때문에 타입 검사를하지 않을 것이다. 모든 유형의 예외를 포착 할 수는 있지만 &quot;모든 예외 포착&quot;( &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception의&lt;/a&gt; ) 섹션 에서 문제점에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e4fcbcc185ba6453250d12b73264bd5a24e8c57" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 에 유형 서명을 제공해야 합니다. 그렇지 않으면 유형이 모호하기 때문에 프로그램이 유형 검사를하지 않습니다. 모든 유형의 예외를 포착하는 것이 가능하지만 그렇게 하는 문제에 대한 설명은 &quot;모든 예외 포착&quot;( &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; ) 섹션을 참조하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
