<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="b77b2a992aaa4c5d69ac5d9df4c739fffdace5ec" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadP</source>
          <target state="translated">Text.ParserCombinators.ReadP</target>
        </trans-unit>
        <trans-unit id="bd62cb34823dd96a921d926b9390b7652930d50d" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadPrec</source>
          <target state="translated">Text.ParserCombinators.ReadPrec</target>
        </trans-unit>
        <trans-unit id="841f953fb25d967de66bdc2bfa7b808a4902b9cc" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated</source>
          <target state="translated">Text.PrettyPrint.Annotated</target>
        </trans-unit>
        <trans-unit id="933dae42a8460538e7deec160889c28236a5659e" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJ</target>
        </trans-unit>
        <trans-unit id="6ba7533c729a21d883c35ea710a41810576fe3f9" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="75d296916408b85ed138aacae307021f81e9b105" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.HughesPJ</target>
        </trans-unit>
        <trans-unit id="070a1b0e3666fba02bf11cf21864f94454e18fee" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="852f9faf333892c8bfed010752077687bc710eb3" translate="yes" xml:space="preserve">
          <source>Text.Printf</source>
          <target state="translated">Text.Printf</target>
        </trans-unit>
        <trans-unit id="3e467eeda741670cee0544e799baf3bc68f8f6af" translate="yes" xml:space="preserve">
          <source>Text.Read</source>
          <target state="translated">Text.Read</target>
        </trans-unit>
        <trans-unit id="e7d2b433e6b1a5bfaf0e500258b53ab2699f6b40" translate="yes" xml:space="preserve">
          <source>Text.Read.Lex</source>
          <target state="translated">Text.Read.Lex</target>
        </trans-unit>
        <trans-unit id="82d6f31f8994e83ef79b1676df6acd06d40c0952" translate="yes" xml:space="preserve">
          <source>Text.Show</source>
          <target state="translated">Text.Show</target>
        </trans-unit>
        <trans-unit id="a8c2710c3553b8ef538c168f7f038d784360e352" translate="yes" xml:space="preserve">
          <source>Text.XHtml</source>
          <target state="translated">Text.XHtml</target>
        </trans-unit>
        <trans-unit id="1c794c577eeed3e827f3f4434b0b677541efc237" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Frameset</source>
          <target state="translated">Text.XHtml.Frameset</target>
        </trans-unit>
        <trans-unit id="4e310429294785c3e4ed13f69b32d21e7e3c6e8a" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Strict</source>
          <target state="translated">Text.XHtml.Strict</target>
        </trans-unit>
        <trans-unit id="eaaae80f3e09d76e5b52e5458697c3fd39663493" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Table</source>
          <target state="translated">Text.XHtml.Table</target>
        </trans-unit>
        <trans-unit id="b60bd5c761b5c1a8480926f234df22b56fc27ec9" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Transitional</source>
          <target state="translated">Text.XHtml.Transitional</target>
        </trans-unit>
        <trans-unit id="840c7e38544dbd613fa0b1f9a59f6f627ea3dd88" translate="yes" xml:space="preserve">
          <source>TextDecoder</source>
          <target state="translated">TextDecoder</target>
        </trans-unit>
        <trans-unit id="b1ec439dd8ac6da12ff0821c5bfa7393b4881faa" translate="yes" xml:space="preserve">
          <source>TextEncoder</source>
          <target state="translated">TextEncoder</target>
        </trans-unit>
        <trans-unit id="9195c9a1d76bd3421ac42c82a5d2ce786ab09b23" translate="yes" xml:space="preserve">
          <source>TextEncoding</source>
          <target state="translated">TextEncoding</target>
        </trans-unit>
        <trans-unit id="ef309892f2826f378147927737ca881b40420a37" translate="yes" xml:space="preserve">
          <source>Textual name of this user (pw_name)</source>
          <target state="translated">이 사용자의 텍스트 이름 (pw_name)</target>
        </trans-unit>
        <trans-unit id="45b3ae04eef9762e57f97f506e36c837398301fc" translate="yes" xml:space="preserve">
          <source>Textual source positions.</source>
          <target state="translated">텍스트 소스 위치.</target>
        </trans-unit>
        <trans-unit id="6a2ec719ddee27b8ee0018e15dcb0d3552659a4c" translate="yes" xml:space="preserve">
          <source>Th32SnapFlags</source>
          <target state="translated">Th32SnapFlags</target>
        </trans-unit>
        <trans-unit id="f1c71aeaa559503cb5c111582956f3709a70b40b" translate="yes" xml:space="preserve">
          <source>Th32SnapHandle</source>
          <target state="translated">Th32SnapHandle</target>
        </trans-unit>
        <trans-unit id="78e1c498231e4965c95cd3fcf27fb9a7f46b40a8" translate="yes" xml:space="preserve">
          <source>That being said, with the appropriate use of wrapper datatypes, the above limitations induce no loss of generality:</source>
          <target state="translated">랩퍼 데이터 유형을 적절하게 사용하면 위의 제한으로 인해 일반성이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58dcecccbdfb19a6c28d4e72b8694cf3a95079aa" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;lsquo;s fundep!</source>
          <target state="translated">그것은 &lt;code&gt;(X [Bool] beta)&lt;/code&gt; 제약 을 야기하고 , 인스턴스를 사용한다는 것은 우리가 필요하다는 것을 의미하고 &lt;code&gt;(D Bool beta)&lt;/code&gt; &lt;code&gt;D&lt;/code&gt; 를 통해 &lt;code&gt;beta&lt;/code&gt; 를 수정합니다 !</target>
        </trans-unit>
        <trans-unit id="6a7f123da8ed9434c97040e703694b356a4d2399" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;rsquo;s fundep!</source>
          <target state="translated">그러면 &lt;code&gt;(X [Bool] beta)&lt;/code&gt; 제약이 발생하고 인스턴스를 사용하면 &lt;code&gt;(D Bool beta)&lt;/code&gt; 가 필요 하며 &lt;code&gt;D&lt;/code&gt; 의 fundep을 통해 &lt;code&gt;beta&lt;/code&gt; 를 수정합니다 !</target>
        </trans-unit>
        <trans-unit id="f2a29bc8dbb5ee0c4a1930b318abbbb60994a117" translate="yes" xml:space="preserve">
          <source>That is because we require an &lt;code&gt;Eq (Option a)&lt;/code&gt; instance from the default type signature for &lt;code&gt;(==#)&lt;/code&gt;, which in turn requires an &lt;code&gt;Eq a&lt;/code&gt; instance, which we don&amp;rsquo;t have in scope. But if you tweak the definition of &lt;code&gt;HigherEq&lt;/code&gt; slightly:</source>
          <target state="translated">우리가 필요로하기 때문에 즉 &lt;code&gt;Eq (Option a)&lt;/code&gt; 의 기본 유형 서명에서 인스턴스 &lt;code&gt;(==#)&lt;/code&gt; , 차례에서 요구하는 &lt;code&gt;Eq a&lt;/code&gt; 우리가 범위에없는 인스턴스를. 그러나 &lt;code&gt;HigherEq&lt;/code&gt; 의 정의를 약간 조정하면 :</target>
        </trans-unit>
        <trans-unit id="462366d2ca673f43337d58fb2f79b52eb40d828a" translate="yes" xml:space="preserve">
          <source>That is the same as the dynamic linking on other platforms, and it is described in &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt;.</source>
          <target state="translated">이는 다른 플랫폼의 동적 링크와 동일하며 &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;공유 라이브러리 사용에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5adb8f6d680643cb988e19cd9ebd95685b0e9084" translate="yes" xml:space="preserve">
          <source>That is, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; pattern-matches its way into tuples and maps over each type that constitutes the tuple. The generated code is reminiscent of what would be generated from &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt;, except with extra machinery to handle the tuple.</source>
          <target state="translated">즉, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 패턴을 튜플에 일치시키고 튜플을 구성하는 각 유형에 매핑합니다. 생성 된 코드는 튜플을 처리하는 추가 기계를 제외하고 &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt; 에서 생성 된 것을 연상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4a82aebf2ff4e63f82086bf2da9eae4d7a61ab25" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 가 에 의해 생성 된 문자열 구문 분석 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 을 하고, 그 값을 제공 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 가 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9e481507876f41c367fe06e578b12b78a4e7b1ac" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 가 에 의해 생성 된 문자열 구문 분석 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 을 하고, 그 값을 제공 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 가 시작합니다.</target>
        </trans-unit>
        <trans-unit id="49ebb42c3d6e117d12265da60c750a18218cde33" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 가 에 의해 생성 된 문자열 구문 분석 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 을 하고, 그 값을 제공 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 가 시작합니다.</target>
        </trans-unit>
        <trans-unit id="924d09ba70f052db4b220a5f8dac59b3109fa413" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 가 에 의해 생성 된 문자열 구문 분석 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 을 하고, 그 값을 제공 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 가 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5981428896475a8992aaf356fb600c2886c3b975" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 가 에 의해 생성 된 문자열 구문 분석 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 을 하고, 그 값을 제공 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 가 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a0d56a2fcb64d6ff47305c969e3cc186106c4d12" translate="yes" xml:space="preserve">
          <source>That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.</source>
          <target state="translated">즉, 따옴표는 4 개의 구문 분석기로 구성된 튜플입니다. 각 인용 부호는 준 인용 부호가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac21267c135501bf8d1d0d91f2b069a3782591d" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="translated">즉, &lt;code&gt;SPretty Foo&lt;/code&gt; 인스턴스는 모든 메소드에 대해 빈 구현으로 작성됩니다. 이 예제에서는 &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 를 사용하므로 &lt;code&gt;sPpr&lt;/code&gt; 의 기본 구현이 자동으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="663aa2118010ecc8a1e027d6bf82ba72221ad60a" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="translated">즉, &lt;code&gt;SPretty Foo&lt;/code&gt; 인스턴스는 모든 메서드에 대해 빈 구현으로 생성됩니다. 이 예제에서는 &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 를 사용하고 있으므로 &lt;code&gt;sPpr&lt;/code&gt; 의 기본 구현이 자동으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8b860dffaafb771638ee538e2b0ac1693cebe622" translate="yes" xml:space="preserve">
          <source>That is, since the type variable &lt;code&gt;a&lt;/code&gt; isn&amp;rsquo;t in scope, it&amp;rsquo;s implicitly universally quantified.</source>
          <target state="translated">즉, 타입 변수 &lt;code&gt;a&lt;/code&gt; 는 범위 내에 있지 않기 때문에 암시 적으로 보편적으로 정량화됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a4e9e2c0f64dd1b628ca2224d1a3e388241d4f" translate="yes" xml:space="preserve">
          <source>That is, the &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; methods should be the inverse of each other. A range of instances are provided for basic Haskell types.</source>
          <target state="translated">즉, &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 메소드는 서로 반대 여야합니다. 기본 Haskell 유형에 대해 다양한 인스턴스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2de858dbd3f42f7a78dc46a1d661e4c45116e634" translate="yes" xml:space="preserve">
          <source>That is, the operator must be a function of two arguments. GHC allows it to take only one argument, and that in turn allows you to write the function postfix.</source>
          <target state="translated">즉, 연산자는 두 인수의 함수 여야합니다. GHC를 사용하면 인수를 하나만 사용할 수 있으며 함수 접미사를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2666094f8dd3b89fcecfae7a344b137b1c390e" translate="yes" xml:space="preserve">
          <source>That is, the scoping is the same as it would be if the curried arguments were collected into a tuple.</source>
          <target state="translated">즉, 범위 지정은 카레 인수가 튜플로 수집 된 경우와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a08280c0c335de4d817b47c060a3f4af660b030a" translate="yes" xml:space="preserve">
          <source>That is, to match a variable ⟨v⟩ against a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt;, evaluate &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ ⟨v⟩ &lt;code&gt;)&lt;/code&gt; and match the result against ⟨pat⟩.</source>
          <target state="translated">즉, 패턴에 대한 변수 ⟨v⟩에 맞게 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; , 평가를 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ ⟨v⟩ &lt;code&gt;)&lt;/code&gt; 와 ⟨pat⟩에 대한 결과와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f81ae30760fa45f0027ed10944dbae9bf4a7947d" translate="yes" xml:space="preserve">
          <source>That is, we add a new form of pattern, written ⟨expression⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pattern⟩ that means &amp;ldquo;apply the expression to whatever we&amp;rsquo;re trying to match against, and then match the result of that application against the pattern&amp;rdquo;. The expression can be any Haskell expression of function type, and view patterns can be used wherever patterns are used.</source>
          <target state="translated">즉, 우리 는&amp;ldquo;표현식&amp;rdquo; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟩ 패턴&amp;rdquo;이라는 새로운 형태의 패턴을 추가 합니다. 이는&amp;ldquo;표현식에 적용하려는 모든 것에 표현식을 적용한 다음 해당 응용 프로그램의 결과를 패턴과 일치시키는 것&amp;rdquo;을 의미합니다. 표현식은 함수 유형의 하스켈 표현식 일 수 있으며 패턴이 사용되는 모든 위치에서 뷰 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4472bb74389d304d179494e5f818bbd3e2091fe" translate="yes" xml:space="preserve">
          <source>That is, we represent every functional dependency (FD) &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; by an FD type family &lt;code&gt;F a1 .. an&lt;/code&gt; and a superclass context equality &lt;code&gt;F a1 .. an ~ b&lt;/code&gt;, essentially giving a name to the functional dependency. In class instances, we define the type instances of FD families in accordance with the class head. Method signatures are not affected by that process.</source>
          <target state="translated">즉, FD 유형 패밀리 &lt;code&gt;F a1 .. an&lt;/code&gt; 및 수퍼 클래스 컨텍스트 동등성 &lt;code&gt;F a1 .. an ~ b&lt;/code&gt; 모든 기능적 종속성 (FD) &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; 를 나타내며 , 기본적으로 기능 종속성에 이름을 지정합니다. 클래스 인스턴스에서는 클래스 헤드에 따라 FD 패밀리의 유형 인스턴스를 정의합니다. 메소드 서명은 해당 프로세스의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="087a1186066043015d53285a25aa834f074c4bb9" translate="yes" xml:space="preserve">
          <source>That last one deserves a special mention, however, since &lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; is a straightforward instantiation of &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. You can still write such a default type signature, but you now must use type equalities to do so:</source>
          <target state="translated">&lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; 는 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 의 간단한 인스턴스화 이기 때문에 마지막에 특별한 언급이 필요합니다 . b. a-&amp;gt; b-&amp;gt; b . 여전히 이러한 기본 유형 서명을 작성할 수 있지만 이제 유형 평등을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7aa747ff9513051d2f3e0f63c5ab4677db5c86d5" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="translated">그것은 하스켈 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;3.12 절에&lt;/a&gt; 주어진 번역 표현을 남겨둔다 . &amp;ldquo;번역&amp;rdquo;을 다음과 같이 바꾸십시오. &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt; 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="cd50fc2b9c34278d98468c36da785c66b0803c5a" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="translated">하스켈 보고서의 &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;섹션 3.12&lt;/a&gt; 에 번역 된 let 표현식이 남습니다 . 거기에서 &quot;번역&quot;을 다음으로 바꿉니다. 주어진 &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9239200a2fcf1e520b700775bc66f764a197c669" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">에있는 인스턴스의 질문은 전화 사이트를 선택하는 그 연기합니다 &lt;code&gt;f&lt;/code&gt; 어떤 시간에 더 많은 유형에 대해 알려진 &lt;code&gt;b&lt;/code&gt; . &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 확장 을 사용하는 경우이 유형 서명을 직접 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d389a135a3109bdad0320beb8a57c6c2152f2179" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">이는 &lt;code&gt;b&lt;/code&gt; 유형에 대해 더 많이 알려진 &lt;code&gt;f&lt;/code&gt; 에 대해 호출 사이트로 선택할 인스턴스에 대한 질문을 연기합니다 . &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 확장 을 사용하는 경우이 유형 서명을 직접 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0af663474763fbec92b5233bfe0db021c376fce2" translate="yes" xml:space="preserve">
          <source>That would make no sense if the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; involves the bound variable &lt;code&gt;x&lt;/code&gt;. More generally, the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; may not involve any local variable, i.e. a variable bound in the current arrow abstraction. For such a situation there is a variant &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt;, as in</source>
          <target state="translated">&lt;code&gt;-&amp;lt;&lt;/code&gt; 의 왼쪽에있는 표현식에 바인딩 된 변수 &lt;code&gt;x&lt;/code&gt; 가 포함 되어 있으면 의미가 없습니다 . 보다 일반적으로 &lt;code&gt;-&amp;lt;&lt;/code&gt; 의 왼쪽에있는 표현식 은 로컬 변수, 즉 현재 화살표 추상화에 바인딩 된 변수를 포함하지 않을 수 있습니다. 이러한 상황에서는 다음과 같이 변형 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8395997f12760883e7bd00deba567522fa0be628" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all a little confusing, so here&amp;rsquo;s a few examples. To start with, here&amp;rsquo;s a new GHCi command which doesn&amp;rsquo;t take any arguments or produce any results, it just outputs the current date and time:</source>
          <target state="translated">모두 약간 혼란 스럽습니다. 여기 몇 가지 예가 있습니다. 우선, 인수를 취하거나 결과를 생성하지 않는 새로운 GHCi 명령이 있습니다. 현재 날짜와 시간 만 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3a5d327acf1cda84e99ba8c8418f8a6e3f1a6041" translate="yes" xml:space="preserve">
          <source>The &quot;%v&quot; specifier is provided for all built-in types, and should be provided for user-defined type formatters as well. It picks a &quot;best&quot; representation for the given type. For the built-in types the &quot;%v&quot; specifier is converted as follows:</source>
          <target state="translated">&quot;% v&quot;지정자는 모든 내장 유형에 제공되며 사용자 정의 유형 포맷터에도 제공해야합니다. 주어진 유형에 대해 &quot;최상의&quot;표현을 선택합니다. 내장 유형의 경우 &quot;% v&quot;지정자는 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="307d8dbf7393ba19bad8b70f752ec95aa046ce44" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;By&lt;/code&gt;&quot; operations</source>
          <target state="translated">&quot; &lt;code&gt;By&lt;/code&gt; &quot;조작</target>
        </trans-unit>
        <trans-unit id="599928469bbf0c1871f851f1ade723c44533fb25" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;generic&lt;/code&gt;&quot; operations</source>
          <target state="translated">&quot; &lt;code&gt;generic&lt;/code&gt; &quot;작업</target>
        </trans-unit>
        <trans-unit id="d6bed068edef8687960252343aec2dce4a6f9960" translate="yes" xml:space="preserve">
          <source>The &quot;alternate form&quot; for unsigned radix conversions is as in C &lt;code&gt;printf(3)&lt;/code&gt;:</source>
          <target state="translated">부호없는 기수 변환에 대한 &quot;대체 형식&quot;은 C &lt;code&gt;printf(3)&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="594cda52526f7a4ced49e3f563eb6b3d2f24eeb4" translate="yes" xml:space="preserve">
          <source>The &quot;format parser&quot; walks over argument-type-specific modifier characters to find the primary format character. This is the type of its result.</source>
          <target state="translated">&quot;형식 파서&quot;는 기본 형식 문자를 찾기 위해 인수 유형별 수정 자 문자를 검토합니다. 이것이 결과의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7723ee8b77a369d6247096077763bfcd23d475ce" translate="yes" xml:space="preserve">
          <source>The &quot;live&quot; elements of the buffer are those between the &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; offsets. In an empty buffer, &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt;, but they might not be zero: for example, the buffer might correspond to a memory-mapped file and in which case &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; will point to the next location to be written, which is not necessarily the beginning of the file.</source>
          <target state="translated">버퍼의 &quot;라이브&quot;요소는 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; 오프셋 사이의 요소입니다 . 빈 버퍼에서 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; 과 같지만 0이 아닐 수 있습니다. 예를 들어, 버퍼는 메모리 매핑 된 파일에 해당 할 수 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 경우 bufL 은 다음에 쓸 위치를 가리킬 것입니다. 파일의 시작</target>
        </trans-unit>
        <trans-unit id="2a8382d16990b13cd15a39a55ae784945d07894a" translate="yes" xml:space="preserve">
          <source>The &quot;normal&quot; (Level 0) of detail.</source>
          <target state="translated">세부 사항의 &quot;일반&quot;(레벨 0)입니다.</target>
        </trans-unit>
        <trans-unit id="f72b6aeac8d85eeec70693b005224f9243157a76" translate="yes" xml:space="preserve">
          <source>The &quot;reflection trick&quot;, which takes advantanage of the fact that in &lt;code&gt;class C a where { op :: ty }&lt;/code&gt;, we can safely coerce between &lt;code&gt;C a&lt;/code&gt; and &lt;code&gt;ty&lt;/code&gt; (which have different kinds!) because it's really just a newtype. Note: there is &lt;em&gt;no guarantee, at all&lt;/em&gt; that this behavior will be supported into perpetuity.</source>
          <target state="translated">&quot;반사 트릭&quot;은 &lt;code&gt;class C a where { op :: ty }&lt;/code&gt; 에서 &lt;code&gt;C a&lt;/code&gt; 와 &lt;code&gt;ty&lt;/code&gt; (다른 종류가 있습니다!) 사이를 안전하게 강제 할 수 있다는 사실을 활용하는 것입니다. 왜냐하면 실제로 는 새로운 유형이기 때문입니다. 참고 : 이 동작이 영구적으로 지원된다는 &lt;em&gt;보장&lt;/em&gt; 은 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c953365586bc5a5e627fb11bde8ec6bbd7800149" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; exposed via the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; etc. instances.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 등의 인스턴스 를 통해 노출 된 &quot;값&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="667c18fb4c63293a30cf0ae6252784353ac2d4c3" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;&lt;code&gt;forall a&lt;/code&gt;&amp;rdquo; brings &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; into scope in the definition of &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&quot; &lt;code&gt;forall a&lt;/code&gt; &quot;는 &quot; &lt;code&gt;f&lt;/code&gt; &quot; 의 정의에서 &quot; &lt;code&gt;a&lt;/code&gt; &quot;를 범위 내로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c6c6c6b0c9636ffbfcb145dd52b6cf329767257a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes allocated in the heap&amp;rdquo; is the total bytes allocated by the program over the whole run.</source>
          <target state="translated">&amp;ldquo;힙에 할당 된 바이트&amp;rdquo;는 전체 실행에서 프로그램이 할당 한 총 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="584d620fa2734b6b5eaa0370f4dc4f644b3e240e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes maximum slop&amp;rdquo; tells you the most space that is ever wasted due to the way GHC allocates memory in blocks. Slop is memory at the end of a block that was wasted. There&amp;rsquo;s no way to control this; we just like to see how much memory is being lost this way.</source>
          <target state="translated">&quot;바이트 최대 슬로프&quot;는 GHC가 블록 단위로 메모리를 할당하는 방식으로 인해 낭비되는 가장 많은 공간을 알려줍니다. Slop은 낭비 된 블록의 끝에있는 메모리입니다. 이것을 제어 할 수있는 방법이 없습니다. 우리는이 방법으로 얼마나 많은 메모리가 손실되고 있는지 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="45090aca257e8cf2e737992e0dab8be6af802dda" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;general principle&amp;rdquo; described here is meant to make all this more predictable for users. It would not be hard to extend GHC to relax this principle. If you should want a change here, consider writing a &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;proposal&lt;/a&gt; to do so.</source>
          <target state="translated">여기에 설명 된 &quot;일반 원칙&quot;은 사용자가이 모든 것을보다 예측 가능하게 만들기위한 것입니다. 이 원칙을 완화하기 위해 GHC를 확장하는 것은 어렵지 않습니다. 여기에서 변경을 원하면 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;제안서&lt;/a&gt; 를 작성해보십시오 .</target>
        </trans-unit>
        <trans-unit id="4fef8e475f005ce6d6f926436263775847cc3803" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;i&amp;rdquo; stands for &amp;ldquo;Interactive&amp;rdquo;</source>
          <target state="translated">&quot;i&quot;는 &quot;Interactive&quot;를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="fc84efa3e37fb0d48e7458b75c4700965bef870a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;total memory in use&amp;rdquo; tells you the peak memory the RTS has allocated from the OS.</source>
          <target state="translated">&quot;사용중인 총 메모리&quot;는 RTS가 OS에서 할당 한 최대 메모리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c4ca1b8698b4c3c42a66add6d5685bab0dd89277" translate="yes" xml:space="preserve">
          <source>The (binary) &lt;code&gt;Tree&lt;/code&gt; instance example makes use of both, after defining the &lt;code&gt;Empty&lt;/code&gt; base case and the singleton &lt;code&gt;Leaf&lt;/code&gt; node case, non-empty internal nodes introduce both a prepended child node on the left and an appended child node on the right:</source>
          <target state="translated">(바이너리) &lt;code&gt;Tree&lt;/code&gt; 인스턴스 예제는 &lt;code&gt;Empty&lt;/code&gt; 기본 케이스와 싱글 톤 &lt;code&gt;Leaf&lt;/code&gt; 노드 케이스를 정의한 후 비어 있지 않은 내부 노드가 왼쪽에 앞에 추가 된 자식 노드와 오른쪽에 추가 된 자식 노드를 모두 도입합니다.</target>
        </trans-unit>
        <trans-unit id="eb3433e82abbee6557ae4932640c2d8da6b781db" translate="yes" xml:space="preserve">
          <source>The (mono)type: &lt;code&gt;tau&lt;/code&gt;</source>
          <target state="translated">(모노) 타입 : &lt;code&gt;tau&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60b26e67d917cc3a857c71a7f8b8990a2841e52f" translate="yes" xml:space="preserve">
          <source>The 0 pointer. Used to indicate the empty Bytestring.</source>
          <target state="translated">0 포인터. 빈 Bytestring을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f2110e66ee660be4c8c2f43b8e22fc7b2ac364" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension allows these constructs to be directly used as a function argument. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; 의&lt;/a&gt; 확장은 이러한 구조에 직접 함수의 인수로서 사용되는 것을 허용한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64bdb3d073f079d531b8a96572945cc8af7548ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; 의&lt;/a&gt; 확장에 따라이 생성 규칙 이동 &lt;code&gt;aexp&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="7c6312d568cf2735ca75edec69b8ff484ecdbef9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; 의&lt;/a&gt; 확장에 따라이 생성 규칙을 이동 &lt;code&gt;aexp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c11e29052e1ea592c72c0d937dab2a12cd84eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;exts/pragmas#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; 의&lt;/a&gt; 언어 확장은 또한 사용하여 활성화 될 수 &lt;a href=&quot;exts/pragmas#language-pragma&quot;&gt;언어의&lt;/a&gt; 프라그를; 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="35c65f0dc74f4931d91c01fa9c6d3700981ddac7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;glasgow_exts#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; 의&lt;/a&gt; 언어 확장은 또한 사용하여 활성화 될 수 &lt;a href=&quot;glasgow_exts#language-pragma&quot;&gt;언어의&lt;/a&gt; 프라그를; 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="cb9ce911311ab5062d718c76033a5381bcc759c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension enables the C pre-processor. This can be turned into a command-line flag by prefixing it with &lt;code&gt;-X&lt;/code&gt;; For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; 의&lt;/a&gt; 언어 확장은 C의 전처리를 가능하게한다. &lt;code&gt;-X&lt;/code&gt; 접두사를 붙여서 명령 줄 플래그로 바꿀 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ae4cf567699873d6594767b8148b3283fe3e91e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt; extension enables case expressions, or lambda-case expressions, that have no alternatives, thus:</source>
          <target state="translated">&lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 의&lt;/a&gt; 확장 따라서, 어떤 대안이없는 경우 식 또는 람다의 경우 표현을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="abbd0ecca5ae43844dd2d11341709a7cbf2688b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="translated">&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 플래그는 (하스켈 보고서에 언급 된)이 4 개의 &quot;표준&quot;형 클래스의 파생 사용하는 데 필요합니다. 아래에서 자세히 설명 하는 &lt;code&gt;deriving&lt;/code&gt; 메커니즘 에 대한 다른 확장 에서는 &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 을 빈 데이터 유형과 함께 사용할 필요가 없습니다 . 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="012817880879ac3870d5610c6cda1f372d2afa1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; extension allows you to prefix the name of a type constructor in an import or export list with &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to disambiguate this case, thus:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; 의&lt;/a&gt; 확장은 당신이 &quot;를 가져 오기 또는 내보내기 목록에서 형식 생성자의 이름 앞에 할 수 있습니다 &lt;code&gt;type&lt;/code&gt; 따라서,이 사건을 명확하게하기 위해&quot;</target>
        </trans-unit>
        <trans-unit id="5ba167f467ba97a573f10efce8b6b966cd314396" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 &amp;hellip; typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 의&lt;/a&gt; 확장은 유형 서명의 타입 클래스 제약 양식이 있어야 하스켈 (98) 제한 리프트 &lt;em&gt;(클래스 형 변수)&lt;/em&gt; 또는 &lt;em&gt;(클래스 (유형 변수를 타입 1 타입 2 ... typen))&lt;/em&gt; . &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 를&lt;/a&gt; 사용하면 이러한 유형 서명이 완벽하게 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="1e42ac5c594dfd901f58792044e9a9041c4003be" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 의&lt;/a&gt; 확장은 유형 서명의 타입 클래스 제약 양식이 있어야 하스켈 (98) 제한 리프트 &lt;em&gt;(클래스 형 변수)&lt;/em&gt; 또는 &lt;em&gt;(클래스 (유형 변수를 타입 1 타입 2 ... typen))&lt;/em&gt; . &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 사용하면 이러한 유형 서명이 완벽하게 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="7a3b07e5c3b3f792ae9a2205da0ebe6f644dadb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 의&lt;/a&gt; 확장이 규칙뿐만 아니라 타입 시그니처에 해당하는 규칙 (참조 휴식을 완화 &lt;a href=&quot;#flexible-contexts&quot;&gt;타입 서명의 컨텍스트&lt;/a&gt; ). 특히 &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 는 인스턴스 선언의 맥락에서 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 형식의 ( 종종) 클래스 제약 조건을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="0562613b8f75a0cd91d39da3210ac809ea1b3a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; 의&lt;/a&gt; 확장은 인스턴스 선언의 머리가 임의의 중첩 된 유형을 언급 할 수 있습니다. 예를 들어, 이것은 유효한 인스턴스 선언이됩니다.</target>
        </trans-unit>
        <trans-unit id="661ec8113ef99ccdd08a9cd1e3cdeaf21af63fa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension implies &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; 의&lt;/a&gt; 확장을 의미한다 &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdcc91b25b9ed4cc5c0260c1f012c1a5f82d2927" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-LambdaCase&quot;&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt; extension enables expressions of the form</source>
          <target state="translated">&lt;a href=&quot;#extension-LambdaCase&quot;&gt; &lt;code&gt;LambdaCase&lt;/code&gt; 의&lt;/a&gt; 확장 형태의 표현을 가능하게</target>
        </trans-unit>
        <trans-unit id="ae186343574b4460d96f7f83aeb4d511026cbbfd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 은&lt;/a&gt; 또한 리터럴 (참조의 새로운 형태를 가능하게 &lt;a href=&quot;#glasgow-unboxed&quot;&gt;박스 없음 타입&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e3929c268c7ca8099bc7fccc912027c58685a7e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 은&lt;/a&gt; 또한 리터럴 (참조의 새로운 형태를 가능하게 &lt;a href=&quot;primitives#glasgow-unboxed&quot;&gt;박스 없음 타입&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f156d0b8de4e1a07b993f716b37564cac76a1370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-PostfixOperators&quot;&gt;&lt;code&gt;PostfixOperators&lt;/code&gt;&lt;/a&gt; extension enables a small extension to the syntax of left operator sections, which allows you to define postfix operators. The extension is this: the left section</source>
          <target state="translated">&lt;a href=&quot;#extension-PostfixOperators&quot;&gt; &lt;code&gt;PostfixOperators&lt;/code&gt; 의&lt;/a&gt; 확장은 후위 연산자를 정의 할 수 있습니다 왼쪽 운영자 섹션의 구문에 작은 확장 할 수 있습니다. 확장은 이쪽 : 왼쪽 섹션</target>
        </trans-unit>
        <trans-unit id="a89c98a9a3a672e6e0625684027419f38aef7f06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; option is also required for any type with a &lt;code&gt;forall&lt;/code&gt; or context to the right of an arrow (e.g. &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt;, or &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt;). Such types are technically rank 1, but are clearly not Haskell-98, and an extra extension did not seem worth the bother.</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 옵션은 또한 어떤 유형 필요 &lt;code&gt;forall&lt;/code&gt; (화살표의 우측 또는 문맥 예 &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt; 또는 &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt; ). 이러한 유형은 기술적으로 1 등급이지만 분명히 Haskell-98이 아니며 추가 확장은 귀찮은 것으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35fe223925e3329d9b396b0289c0f1edb80c5f64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TupleSections&quot;&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt; extension enables partially applied tuple constructors. For example, the following program</source>
          <target state="translated">&lt;a href=&quot;#extension-TupleSections&quot;&gt; &lt;code&gt;TupleSections&lt;/code&gt; 의&lt;/a&gt; 확장 부분인가 튜플 생성자 수있다. 예를 들어, 다음 프로그램</target>
        </trans-unit>
        <trans-unit id="b17d31417452ac7082cc9ac3c80a11f860e37344" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;lsquo;s type.</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; 의&lt;/a&gt; 확장은 사용할 수 있습니다 &lt;em&gt;눈에 보이는 유형의 응용 프로그램을&lt;/em&gt; 표정에. 다음은 예입니다 : &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt; . &lt;code&gt;@Int&lt;/code&gt; 는 가시 형 응용 프로그램; &lt;code&gt;read&lt;/code&gt; 의 타입으로 타입 변수의 값을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="815a49f2870c920071d25b5de51faa8078cb6a12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;rsquo;s type.</source>
          <target state="translated">The &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt; . The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt; &amp;rsquo;s type.</target>
        </trans-unit>
        <trans-unit id="2ebe94937368bfa68f3a743d993e9e33b0ab16eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; 의&lt;/a&gt; 확장은 형 가족 인스턴스에 부과 된 제한의 일부를 해제하는 데 사용됩니다. &lt;a href=&quot;#type-family-decidability&quot;&gt;동의어 인스턴스 유형의 결정 가능성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f4536f5d8a26219603d39e37690a74527cca915" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;type_families#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; 의&lt;/a&gt; 확장은 형 가족 인스턴스에 부과 된 제한의 일부를 해제하는 데 사용됩니다. &lt;a href=&quot;type_families#type-family-decidability&quot;&gt;유형 동의어 인스턴스의 결정 가능성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a40f430193c52ab9a3cf3f22af8fbf5bb4348a51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt;&lt;code&gt;-Wmissing-export-lists&lt;/code&gt;&lt;/a&gt; flag will warn that &lt;code&gt;M&lt;/code&gt; does not declare an export list. Declaring an explicit export list for &lt;code&gt;M&lt;/code&gt; enables GHC dead code analysis, prevents accidental export of names and can ease optimizations like inlining.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt; &lt;code&gt;-Wmissing-export-lists&lt;/code&gt; &lt;/a&gt; 플래그는 것을 경고합니다 &lt;code&gt;M&lt;/code&gt; 은 수출 목록을 선언하지 않습니다. &lt;code&gt;M&lt;/code&gt; 에 대한 명시 적 내보내기 목록을 선언 하면 GHC 데드 코드 분석이 가능하며 실수로 이름을 내보내는 것을 방지하고 인라인과 같은 최적화를 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a474ac6ba444d90bd68f49cf89271d299c2d550" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;lsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt; &lt;code&gt;-Wmissing-import-lists&lt;/code&gt; &lt;/a&gt; 플래그는 수입에 대해 경고한다 &lt;code&gt;Y&lt;/code&gt; 아니라 &lt;code&gt;X&lt;/code&gt; 모듈 경우 &lt;code&gt;Y&lt;/code&gt; 는 나중에 내보내기 (말)로 변경된다 &lt;code&gt;f&lt;/code&gt; 다음에, 기준 &lt;code&gt;f&lt;/code&gt; 에서 &lt;code&gt;M&lt;/code&gt; 은 모호해질 것이다. &lt;code&gt;Z&lt;/code&gt; 의 수출을 늘리는 것이 &lt;code&gt;M&lt;/code&gt; 에서 모호성을 일으키지 않기 때문에 &lt;code&gt;Z&lt;/code&gt; 의 수입에 대해서는 경고가 없다 .</target>
        </trans-unit>
        <trans-unit id="0e9463d37bc7356ac89d64ece95dfb6664646492" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;rsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt; &lt;code&gt;-Wmissing-import-lists&lt;/code&gt; &lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt; , then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt; &amp;rsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e36bf4d5a27eab719495aba2d65180ff3cb627fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 플래그는 (하스켈 보고서에 언급 된)이 4 개의 &quot;표준&quot;형 클래스의 파생 사용하는 데 필요합니다. &lt;code&gt;deriving&lt;/code&gt; 메커니즘 에 대한 다른 확장 ( 아래에서 더 자세히 설명)은 빈 데이터 유형과 함께 &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 을 사용할 필요가 없습니다 . 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="db722c4293a180623ff6c051b1d85ff7e25c05ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt; 플래그 타입의 모든 기능을 지정할 수 &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt; 일부 제한을 위해, &lt;code&gt;C&lt;/code&gt; 평가 식을 인쇄하기위한 함수로서,. 이 함수는로드 된 모듈 또는 등록 된 패키지에 상주 할 수 있지만 등록 된 패키지에 상주하는 경우에만 &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 유지&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="630c44ffedd4dd17a812ef0191fcfe9f164168e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt; 에서 GHC를 실행할 때 플래그도 사용할 수 있습니다 &lt;code&gt;-e mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78f35da957d4cd52b15e9fdc17483788082f1d5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt; &lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt; , for some constraint &lt;code&gt;C&lt;/code&gt; , as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="21b2b57c36c8c1575a9d46ca71c9857aa94c645d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="translated">The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt; &lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a9ee5aa0e4404a66caea5cfa0e31661321a8a071" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; option makes GHC &lt;em&gt;verbose&lt;/em&gt;: it reports its version number and shows (on stderr) exactly how it invokes each phase of the compilation system. Moreover, it passes the &lt;code&gt;-v&lt;/code&gt; flag to most phases; each reports its version number (and possibly some other information).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt; 옵션은 GHC를 만드는 &lt;em&gt;자세한&lt;/em&gt; : 그것은 컴파일 시스템의 각 단계를 호출 정확히 어떻게 (표준 에러에) 버전 번호와 쇼를보고합니다. 또한 &lt;code&gt;-v&lt;/code&gt; 플래그를 대부분의 단계로 전달합니다 . 각 버전 번호 (및 기타 정보)를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f2aaf666449f19ca504a747ac617450334ac0091" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command is particularly useful when single-stepping, to see where you currently are:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; 현재 어디에 단일 스테핑이 볼 때 명령은 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="c742c2c7dca48891181fe9d4cdbd89257e05f404" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command lists the source code around the current breakpoint. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; 명령 목록 현재 중단 점 주위의 소스 코드를. 출력 장치가 지원하는 경우 GHCi는 활성 하위 표현식을 굵게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="207cb516d01051ef8920382f50ac703484da325f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#ghci-load-scope&quot;&gt;The effect of :load on what is in scope&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 명령 ( &lt;a href=&quot;#ghci-load-scope&quot;&gt;의 효과 : 범위가 무엇인지에 대한 부하&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8573f5c2fc7b5e00d88d28e04c98a9bc731777f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#loading-source-files&quot;&gt;Loading source files&lt;/a&gt; and &lt;a href=&quot;#ghci-compiled&quot;&gt;Loading compiled code&lt;/a&gt;) affect the top-level scope. Let&amp;rsquo;s start with the simple cases; when you start GHCi the prompt looks like this:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 명령 ( &lt;a href=&quot;#loading-source-files&quot;&gt;로드 소스 파일&lt;/a&gt; 과 &lt;a href=&quot;#ghci-compiled&quot;&gt;로드 컴파일 된 코드&lt;/a&gt; ) 최상위 범위에 영향을 미친다. 간단한 경우부터 시작하겠습니다. GHCi를 시작할 때 프롬프트는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="37bb2b0da32b33f4372a12f64ecdf95d300dbf99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command (&lt;a href=&quot;#ghci-module-cmd&quot;&gt;Controlling what is in scope with the :module command&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; (명령 &lt;a href=&quot;#ghci-module-cmd&quot;&gt;와 범위에 어떤 제어 : 모듈 명령&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f54887dc2345c58aa577bced9bca30f40c4398ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command provides a way to do two things that cannot be done with ordinary &lt;code&gt;import&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령은 보통으로 할 수없는 두 가지 할 수있는 방법 제공 &lt;code&gt;import&lt;/code&gt; 선언 :</target>
        </trans-unit>
        <trans-unit id="18bed73a85898df39bbfb21bec72caa1d380f65e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command modifies both, but there is also a &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; command (for &amp;ldquo;set interactive&amp;rdquo;) that affects only the interactive options set.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령 수정 모두뿐만 아니라이 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 설정 한 경우에만 대화 형 옵션에 영향을 미친다 ( &quot;설정 대화&quot;에 대한) 명령.</target>
        </trans-unit>
        <trans-unit id="93a4b5fbe24659bd6501066dacfcac63a656645a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;ldquo;.</source>
          <target state="translated">The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo; &lt;code&gt;+&lt;/code&gt; &amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;ldquo;.</target>
        </trans-unit>
        <trans-unit id="09a5d114307bab84d24ded440bb5e92a7d6743f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 명령 세트 두 가지 옵션의 종류 : &quot;로 시작 GHCi 옵션 &lt;code&gt;+&lt;/code&gt; &quot;및 시작 &quot;명령 줄&quot;옵션 &quot; &lt;code&gt;-&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="994ae649374ddd00dcbdb0398a07b789d70d3ee6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command can be used with or without an expression. When used without an expression, tracing begins from the current breakpoint, just like &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; 명령 또는 식없이 사용할 수 있습니다. 표현식없이 사용하면 &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; 과 같이 현재 중단 점에서 추적이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="d895b0d326a117dc38216e64627bcf0b504cc040" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt; 명령이 필요합니다 &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="199a238337750e7292c80d8483aa164b1180ba95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:uses&quot;&gt;&lt;code&gt;:uses&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:uses&quot;&gt; &lt;code&gt;:uses&lt;/code&gt; &lt;/a&gt; 명령이 필요합니다 &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa13aae9cfabe1538d35b3d45ac31cfcc6173609" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma has the additional effect of making the function body look small, so that when inlining is allowed it is very likely to happen.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; 의&lt;/a&gt; pragma는 인라인이 허용 될 때 매우 가능성이 발생하는 것입니다 때문에, 함수 본문 모양이 작은 만드는 부가적인 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f27181af99e9c0027aecbaabc8044d1c05e8049" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma does exactly what you&amp;rsquo;d expect: it stops the named function from being inlined by the compiler. You shouldn&amp;rsquo;t ever need to do this, unless you&amp;rsquo;re very cautious about code size.</source>
          <target state="translated">&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; 의&lt;/a&gt; pragma는 당신이 기대하는 것을 정확히 않습니다 : 그것은 컴파일러에 의해 인라인되는 명명 된 기능을 중지합니다. 코드 크기에 대해 신중하지 않으면이 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1a5fffbed9c12afd5da25081d7fe2ae31e2b1e9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma는 당신이 재 작성 규칙을 지정할 수 있습니다. &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0632a671131031d8937312a06897d2e45574c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt; setting will be automatically reduced by the garbage collector when the maximum heap size (the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; setting) is approaching.</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; 설정은 자동으로 최대 힙 사이즈 (상기 가비지 컬렉터에 의해 감소 될 것이다 &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; 설정)에 접근한다.</target>
        </trans-unit>
        <trans-unit id="e8b0c5124d5ea3dd22ec93a4e1efaee8762c585c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; option produces a more detailed report containing the actual time and allocation data as well. (Not used much.)</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; 의&lt;/a&gt; 옵션이 아니라 실제 시간 및 할당 데이터를 포함하는 자세한 보고서를 생성합니다. (별로 사용하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="1bd683aedc043a933d9975ed15640d3bb66f7a3a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; option produces a standard &lt;em&gt;time profile&lt;/em&gt; report. It is written into the file &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt;; the stem is taken to be the program name by default, but can be overridden by the &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po
⟨stem⟩&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 옵션은 표준 생산 &lt;em&gt;시간 프로파일&lt;/em&gt; 보고서를. &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt; 파일에 기록됩니다 . 기본적으로 스템은 프로그램 이름으로 사용되지만 &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt; 플래그 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f811997f5e52254e16a04cd53e244ebe3b6c6f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pa&quot;&gt;&lt;code&gt;-pa&lt;/code&gt;&lt;/a&gt; option produces the most detailed report containing all cost centres in addition to the actual time and allocation data.</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pa&quot;&gt; &lt;code&gt;-pa&lt;/code&gt; 의&lt;/a&gt; 옵션은 실제 시간 및 할당 데이터뿐만 아니라 모든 비용 센터를 포함하는 가장 상세한 보고서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7a84a3b7430c33f4f0db03022262f484fb7742f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; option produces a time/allocation profile report in JSON format written into the file &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; 옵션은 파일에 기록 JSON 형식의 시간 / 할당 프로필 보고서 생성 &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e571794c298f99f38543a85d7967e52fd97375" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po ⟨stem⟩&lt;/code&gt;&lt;/a&gt; option overrides the stem used to form the output file paths for the cost-centre profiler (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flags above) and heap profiler (see &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt; 옵션은 비용 센터 프로파일 러의 출력 파일 경로를 형성한다 (참조하는 데 사용되는 줄기 무시 &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; 플래그 이상) 및 힙 프로파일 러 (참조 &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5635087d38bc262bde4371eac4de7d97f976c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO의&lt;/a&gt; 입력 기능 (예를 들면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 이 기능이 적절한 유니 코드 문자열로 지정된 코드 페이지의 멀티 바이트 캐릭터의 전환을 위해 제공되도록) 자동 유니 코드로 변환하지 않는다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9765ad4ea03f4950380592b31970ad8c5c5f3ec8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO의&lt;/a&gt; 출력 기능 (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 는 이 기능이 적절한 멀티 바이트 문자열로 지정된 코드 페이지에 유니 코드 문자열에서 변환을 제공되도록) 자동으로 Windows에서 멀티 바이트 문자열로 변환하지 않습니다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ce9122f50ea53be58cbd2cf028ecc8f4c1bc2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcced739f4877615ca0b1d338f8fe3c56b49eea5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; ) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7715095f5c8ef807cdbc23a84037a885e460b586" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/system-io&quot;&gt;System.IO의&lt;/a&gt; 입력 기능 (예를 들면 &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 이 기능이 적절한 유니 코드 문자열로 지정된 코드 페이지의 멀티 바이트 캐릭터의 전환을 위해 제공되도록) 자동 유니 코드로 변환하지 않는다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd8e728d7d3436bf9c9bfd3d9742877fbe0b85c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/system-io&quot;&gt;System.IO의&lt;/a&gt; 출력 기능 (예 : &lt;code&gt;&lt;a href=&quot;../base/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 는 이 기능이 적절한 멀티 바이트 문자열로 지정된 코드 페이지에 유니 코드 문자열에서 변환을 제공되도록) 자동으로 Windows에서 멀티 바이트 문자열로 변환하지 않습니다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b352da45baeb9202cb7df82ff50b474eca2ca6d4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt; can sometimes do a far better job at producing fast code than the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;. This is not universal and depends on the code. Numeric heavy code seems to show the best improvement when compiled via LLVM. You can also experiment with passing specific flags to LLVM with the &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; and &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; flags. Be careful though as setting these flags stops GHC from setting its usual flags for the LLVM optimiser and compiler.</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM 코드 생성기는&lt;/a&gt; 때때로보다 빠른 코드를 생산에서 훨씬 더 나은 일을 할 수있는 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기&lt;/a&gt; . 이것은 보편적이지 않으며 코드에 따라 다릅니다. LLVM을 통해 컴파일 할 때 숫자가 많은 코드가 가장 개선 된 것으로 보입니다. &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; 및 &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; 플래그를 사용하여 특정 플래그를 LLVM에 전달하여 실험 할 수도 있습니다 . 이 플래그를 설정하면 GHC가 LLVM 옵티 마이저 및 컴파일러에 대한 일반적인 플래그를 설정하지 못하므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="23545e3e460bae073f6181734f7192afe90ccb39" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exts/template_haskell#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="translated">&lt;a href=&quot;exts/template_haskell#th-usage&quot;&gt;템플릿 하스켈 준비 제한&lt;/a&gt; 때문에 예를 들어, 당신은 컴파일되는 모듈에서 기능을 실행할 수 없습니다, 주석되는 표현에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="441b96de5f40c0b544a2b13e929cf0a32ab969bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 의&lt;/a&gt; 확장은 유형 서명의 타입 클래스 제약 양식이 있어야 하스켈 (98) 제한 리프트 &lt;em&gt;(클래스 형 변수)&lt;/em&gt; 또는 &lt;em&gt;(클래스 (유형 변수를 타입 1 타입 2 ... typen))&lt;/em&gt; . &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 를&lt;/a&gt; 사용하면 이러한 유형 서명이 완벽하게 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="4a4611a6bd66536dd5d384f455f6f4187e13b84f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="translated">&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; 의&lt;/a&gt; 확장이 규칙뿐만 아니라 타입 시그니처에 해당하는 규칙 (참조 휴식을 완화 &lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;타입 서명의 컨텍스트&lt;/a&gt; ). 특히 &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 는 인스턴스 선언 컨텍스트에서 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 형식의 (잘 종류의) 클래스 제약 조건을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="25f2f2f377d7a4d9d4c30076fac395670f976ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ghc-err&quot;&gt;GHC.Err&lt;/a&gt; module defines the code for the wired-in error functions, which have a special type in the compiler (with &quot;open tyvars&quot;).</source>
          <target state="translated">&lt;a href=&quot;ghc-err&quot;&gt;GHC.Err의&lt;/a&gt; 모듈을위한 코드를 정의하고 유선 된 ( &quot;개방 tyvars&quot;)와 컴파일러 특별한 유형이 오차 함수.</target>
        </trans-unit>
        <trans-unit id="be2bac9dc3e1c4a106dab0bef04844b8cf103571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;템플릿 하스켈 준비 제한&lt;/a&gt; 때문에 예를 들어, 당신은 컴파일되는 모듈에서 기능을 실행할 수 없습니다, 주석되는 표현에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7bcd2aebd16cff6eded9cdf9d7624bc94b45657f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &amp;lt;Language.Haskell.TH.&amp;gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="translated">GHC Wiki 의 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; 페이지에는 풍부한 정보가 있습니다. Haddock 참조 문서 &amp;lt;Language.Haskell.TH.&amp;gt;를 참조 할 수도 있습니다. 원본 디자인에 대한 많은 변경 &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;사항은 Template Haskell 버전 2에 대한 참고 사항에&lt;/a&gt; 설명되어 있습니다. 그러나 이러한 변경 사항이 모두 GHC에있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="813ef8b7c698943925b858288d022656cbf4c0e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</target>
        </trans-unit>
        <trans-unit id="b007f5500c0bf2359ef4d7c48a45339585e270b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact의&lt;/a&gt; 모듈은 수명이 긴 데이터 구조에 대한 가비지 컬렉션을보다 효율적으로 할 수있는 방법을 제공합니다. 데이터 구조를 압축하면 객체가 메모리에 함께 수집되어 가비지 수집기에서 단일 객체로 취급되며 개별적으로 순회하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="846fd4cdbb42806031c1db4eb657c7e293898b2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact의&lt;/a&gt; 모듈은 수명이 긴 데이터 구조에 대한 가비지 컬렉션을보다 효율적으로 할 수있는 방법을 제공합니다. 데이터 구조를 압축하면 개체가 메모리에 함께 수집되며, 가비지 수집기에 의해 단일 개체로 처리되고 개별적으로 순회되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f5f20ac4d1c46620e544e0b73094893e035e0db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/fmlist&quot;&gt;&lt;code&gt;fmlist&lt;/code&gt;&lt;/a&gt; package takes this approach, by representing a list via its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">&lt;a href=&quot;https://hackage.haskell.org/package/fmlist&quot;&gt; &lt;code&gt;fmlist&lt;/code&gt; &lt;/a&gt; 패키지는 통해 목록을 표시하여,이 접근 방식을 취하고 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 의 행동을.</target>
        </trans-unit>
        <trans-unit id="419b4e0aea1efdbf0b01d8b1d21faeb75cc776ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/foldl&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; package implements a robust general framework for dealing with this situation. If you choose to to do it yourself, with a bit of care, the simplest cases are not difficult to handle directly. You just need to accumulate the individual aggregates as &lt;strong&gt;strict&lt;/strong&gt; components of a single data type, and then apply a final transformation to it to extract the composite result. For example, computing an average requires computing both the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; of a (non-empty) structure and dividing the sum by the length:</source>
          <target state="translated">&lt;a href=&quot;https://hackage.haskell.org/package/foldl&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; 의&lt;/a&gt; 패키지는이 상황을 처리하기위한 강력한 일반 프레임 워크를 구현합니다. 약간의주의를 기울여 직접 수행하기로 선택한 경우 가장 간단한 경우를 직접 처리하기가 어렵지 않습니다. 개별 집계를 단일 데이터 유형의 &lt;strong&gt;엄격한&lt;/strong&gt; 구성 요소 로 누적 한 다음 최종 변환을 적용하여 복합 결과를 추출 하기 만하면 됩니다. 예를 들어 평균을 계산하려면 (비어 있지 않은) 구조 의 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 모두 계산하고 합계 를 길이 로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="b627e268f4e5e65bb4d343165c72971cc53747cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th&quot;&gt;Language.Haskell.TH&lt;/a&gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="translated">GHC Wiki 의 &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; 페이지에는 풍부한 정보가 있습니다. Haddock 참조 문서 &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th&quot;&gt;Language.Haskell.TH를&lt;/a&gt; 참조 할 수도 있습니다 . 원래 디자인에 대한 많은 변경 &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;사항은 템플릿 Haskell 버전 2에 대한 메모에&lt;/a&gt; 설명되어 있습니다. 그러나 이러한 모든 변경 사항이 GHC에있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="070dd57b8d8cd78717786ee303fe48951109a4cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 플래그는 공유 라이브러리에 결국 모든 코드가 필요합니다. &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 플래그를 지정하는 공유 라이브러리가 아닌 프로그램을 확인합니다. 이를 더 명확하게하기 위해이를 별도의 컴파일 및 링크 단계로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ecf85c887a15b246620bb154b24adf3249c4f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma는 당신이 재 작성 규칙을 지정할 수 있습니다. &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;다시 쓰기 규칙에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="096f364a4638bd5a30481fff7cf63dd60a75f2bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library manages multiplexing in its own way. On Windows systems it uses &lt;code&gt;safe&lt;/code&gt; foreign calls to ensure that threads doing I/O operations don't block the whole runtime, whereas on Unix systems all the currently blocked I/O requests are managed by a single thread (the &lt;em&gt;IO manager thread&lt;/em&gt;) using a mechanism such as &lt;code&gt;epoll&lt;/code&gt; or &lt;code&gt;kqueue&lt;/code&gt;, depending on what is provided by the host operating system.</source>
          <target state="translated">&lt;a href=&quot;system-io&quot;&gt;System.IO의&lt;/a&gt; 라이브러리는 자신의 방식으로 다중화 관리합니다. Windows 시스템에서는 &lt;code&gt;safe&lt;/code&gt; 외부 호출을 사용하여 I / O 작업을 수행하는 스레드가 전체 런타임을 차단하지 않도록하고, Unix 시스템에서는 현재 차단 된 모든 I / O 요청이 단일 스레드 ( &lt;em&gt;IO 관리자 스레드&lt;/em&gt; )에 의해 관리됩니다. 호스트 운영 체제에서 제공하는 기능에 따라 &lt;code&gt;epoll&lt;/code&gt; 또는 &lt;code&gt;kqueue&lt;/code&gt; 와 같은 메커니즘 .</target>
        </trans-unit>
        <trans-unit id="ad73609e01e96153a93cfebddc86a915d6769a77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;text-read&quot;&gt;Text.Read&lt;/a&gt; library is the canonical library to import for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;-class facilities. For GHC only, it offers an extended and much improved &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class, which constitutes a proposed alternative to the Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;. In particular, writing parsers is easier, and the parsers are much more efficient.</source>
          <target state="translated">&lt;a href=&quot;text-read&quot;&gt;Text.Read의&lt;/a&gt; 라이브러리에 대한 가져올 수있는 표준 라이브러리 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; - 클래스의 시설과 서비스를 제공합니다. GHC의 경우에만 확장되고 훨씬 개선 된 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스를 제공하며 , 이는 Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 에 대한 제안 된 대안을 구성합니다 . 특히 파서를 작성하는 것이 더 쉽고 파서가 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6049bb328d08178d103c9076445b562b087834cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;state hack&lt;/code&gt;&lt;/a&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;#7411&lt;/a&gt;). For instance,</source>
          <target state="translated">The &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;state hack&lt;/code&gt; &lt;/a&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;#7411&lt;/a&gt;). For instance,</target>
        </trans-unit>
        <trans-unit id="f6bc8b6c64115e4a7c4698a00f5d0d1bc2ad89f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; operator adds the bound function into the continuation chain.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 연산자가 연속 사슬로 결합 된 기능을 추가한다.</target>
        </trans-unit>
        <trans-unit id="5c388ccd0a655842d446db681e2ea71ce5783acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'MetaSel&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt;, which can be used to obtain information about the field at the value level.</source>
          <target state="translated">&lt;code&gt;'MetaSel&lt;/code&gt; 의 종류도 입력 클래스의 인스턴스 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt; 값 레벨의 필드에 대한 정보를 얻기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d0fc85998eb7929a8a09016834cb15b185c38b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(!)&lt;/code&gt; operator, when written in prefix form (preceded by whitespace and not followed by whitespace, as in &lt;code&gt;f !x = ...&lt;/code&gt;), is interpreted as a bang pattern, contrary to the Haskell Report, which prescribes to treat &lt;code&gt;!&lt;/code&gt; as an operator regardless of surrounding whitespace. Note that this does not imply that GHC always enables &lt;a href=&quot;exts/strict#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;. Without the extension, GHC will issue a parse error on &lt;code&gt;f !x&lt;/code&gt;, asking to enable the extension.</source>
          <target state="translated">&lt;code&gt;(!)&lt;/code&gt; 연산자, 프리픽스 형태로 기록 될 때 (같이 공백이 선행 및 공백으로 따르지 &lt;code&gt;f !x = ...&lt;/code&gt; ) 쾅 패턴으로서 해석되며, 치료되는 규정한다 하스켈 보고서, 반대로 &lt;code&gt;!&lt;/code&gt; 주변 공백에 관계없이 연산자로. 이것이 GHC가 항상 &lt;a href=&quot;exts/strict#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; 를&lt;/a&gt; 활성화한다는 것을 의미하지는 않습니다 . 확장이 없으면 GHC는 &lt;code&gt;f !x&lt;/code&gt; 에서 구문 분석 오류를 발행 하여 확장을 사용하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="866373df1d7e4a2d96c88db426b8a4e214a580f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(C t1..tj)&lt;/code&gt; is a partial applications of the class &lt;code&gt;C&lt;/code&gt;, where the arity of &lt;code&gt;C&lt;/code&gt; is exactly &lt;code&gt;j+1&lt;/code&gt;. That is, &lt;code&gt;C&lt;/code&gt; lacks exactly one type argument.</source>
          <target state="translated">&lt;code&gt;(C t1..tj)&lt;/code&gt; 클래스의 부분 인 어플리케이션 &lt;code&gt;C&lt;/code&gt; 의 인수에 대응, &lt;code&gt;C&lt;/code&gt; 가 정확히 &lt;code&gt;j+1&lt;/code&gt; . 즉, &lt;code&gt;C&lt;/code&gt; 에는 정확히 하나의 유형 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e53d457109427ef5ddcdce2f9d16292b3ffd5e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt;-form is only available for modules which are interpreted; for compiled modules (including modules from packages) only the non-&lt;code&gt;*&lt;/code&gt; form of &lt;a href=&quot;#ghci-cmd-:browse&quot;&gt;&lt;code&gt;:browse&lt;/code&gt;&lt;/a&gt; is available.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; - 형은 해석 모듈에서만 사용할 수 있습니다; 컴파일 된 모듈 (패키지의 모듈 포함)의 경우 &lt;code&gt;*&lt;/code&gt; 형식이 아닌 &lt;a href=&quot;#ghci-cmd-:browse&quot;&gt; &lt;code&gt;:browse&lt;/code&gt; &lt;/a&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b53e971ecc81a3e0c6bf1b64d28ddf52cdda1a1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-#include&lt;/code&gt; option is now deprecated, and the &lt;code&gt;include-files&lt;/code&gt; field in a Cabal package specification is ignored.</source>
          <target state="translated">&lt;code&gt;-#include&lt;/code&gt; 옵션이 사용되지 않습니다, 그리고이 &lt;code&gt;include-files&lt;/code&gt; 음모 패키지 사양의 필드를 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab34545a3d0cf93b61e2311037778df3c80a23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; flag is typically beneficial when a program is using all cores of a large multi-core NUMA system, with a large allocation area (&lt;code&gt;-A&lt;/code&gt;). All memory accesses to the allocation area will go to local memory, which can save a significant amount of remote memory access. A runtime speedup on the order of 10% is typical, but can vary a lot depending on the hardware and the memory behaviour of the program.</source>
          <target state="translated">&lt;code&gt;--numa&lt;/code&gt; 의 프로그램이 큰 할당 영역 (함께 큰 멀티 코어 NUMA 시스템의 모든 코어를 사용하는 경우 플래그는 전형적으로 유리하다 &lt;code&gt;-A&lt;/code&gt; ). 할당 영역에 대한 모든 메모리 액세스는 로컬 메모리로 이동하여 상당한 양의 원격 메모리 액세스를 절약 할 수 있습니다. 10 % 정도의 런타임 속도 향상이 일반적이지만 하드웨어 및 프로그램의 메모리 동작에 따라 크게 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="561f71da812b2bddee25afb3e6e2e25bcb2e2f87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; option tells the RTS to tune its memory usage to maximize local memory accesses. In particular, the RTS will:</source>
          <target state="translated">&lt;code&gt;--numa&lt;/code&gt; 의 옵션은 로컬 메모리 액세스를 극대화하기 위해 조정 메모리 사용에 RTS를 알려줍니다. 특히 RTS는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="82790760e32203fbe3b3708f08a40fb1f26d4abb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-O*&lt;/code&gt; options specify convenient &amp;ldquo;packages&amp;rdquo; of optimisation flags; the &lt;code&gt;-f*&lt;/code&gt; options described later on specify &lt;em&gt;individual&lt;/em&gt; optimisations to be turned on/off; the &lt;code&gt;-m*&lt;/code&gt; options specify &lt;em&gt;machine-specific&lt;/em&gt; optimisations to be turned on/off.</source>
          <target state="translated">&lt;code&gt;-O*&lt;/code&gt; 옵션은 최적화 플래그의 편리한 &quot;패키지&quot;를 지정; 나중에 설명 할 &lt;code&gt;-f*&lt;/code&gt; 옵션은 &lt;em&gt;개별&lt;/em&gt; 최적화가 설정 / 해제되도록 지정 합니다. &lt;code&gt;-m*&lt;/code&gt; 지정 옵션 &lt;em&gt;기계 별의&lt;/em&gt; 최적화가 켜져 수 / 오프.</target>
        </trans-unit>
        <trans-unit id="00acee18a5b40f8ae0cd328101fb51b5648ea410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-S&lt;/code&gt; flag, as well as giving the same output as the &lt;code&gt;-s&lt;/code&gt; flag, prints information about each GC as it happens:</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; 플래그뿐만 아니라, 동일한 출력을 제공 &lt;code&gt;-s&lt;/code&gt; 공교롭게도 플래그 각 GC에 대한 정보를 출력한다 :</target>
        </trans-unit>
        <trans-unit id="5abe89944b59b5975a75aacf7b4842e37070b39c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; extension switches the desugaring of &lt;code&gt;do&lt;/code&gt;-blocks to use &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of &lt;code&gt;Monad.fail&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; 확장의 desugaring 전환 &lt;code&gt;do&lt;/code&gt; 사용하는 -blocks &lt;code&gt;MonadFail.fail&lt;/code&gt; 대신 &lt;code&gt;Monad.fail&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="97d0f469a862a380331313f906971c001e89be36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-fno-gen-manifest&lt;/code&gt; disables generation of the manifest file. One reason to do this would be if you had a manifest file of your own, for example.</source>
          <target state="translated">&lt;code&gt;-fno-gen-manifest&lt;/code&gt; 매니페스트 파일의 비활성화 생성. 이를위한 한 가지 이유는 예를 들어 자신의 매니페스트 파일이있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f09316b31fc22fa8a933567bd8337abedb8c8a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hie&lt;/code&gt; file suffix for extended interface files to whatever you specify.</source>
          <target state="translated">&lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩이 변경됩니다 &lt;code&gt;.hie&lt;/code&gt; 의 사용자가 지정한대로로 확장 인터페이스 파일에 대한 파일 접미사를.</target>
        </trans-unit>
        <trans-unit id="181c112c9b1448494d00b3a0eb2345692c427713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hisuf&lt;/code&gt;/&lt;code&gt;-osuf&lt;/code&gt; game is particularly useful if you want to compile a program both with and without profiling, in the same directory. You can say:</source>
          <target state="translated">&lt;code&gt;-hisuf&lt;/code&gt; / &lt;code&gt;-osuf&lt;/code&gt; 당신이 같은 디렉토리에 프로파일 링없이 두 프로그램을 컴파일하려면 게임에 특히 유용합니다. 당신은 말할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9cfd0028b8c4e48cc0b0a43a4c0d4e8fc3d08a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-no-hs-main&lt;/code&gt; flag can also be used to persuade the compiler to do the link step in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode when there is no Haskell &lt;code&gt;Main&lt;/code&gt; module present (normally the compiler will not attempt linking when there is no &lt;code&gt;Main&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;-no-hs-main&lt;/code&gt; 플래그도에 링크 단계를 수행하도록 컴파일러 설득하는 데 사용할 수 있습니다 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 더 하스켈이없는 경우 모드 &lt;code&gt;Main&lt;/code&gt; 모듈 존재는 (어떤이없는 경우 일반적으로 컴파일러가 연결을 시도하지 않습니다 &lt;code&gt;Main&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cfb7b69d0673862e9ddfa0a4b5f54819de95e5d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.o&lt;/code&gt; file suffix for object files to whatever you specify. We use this when compiling libraries, so that objects for the profiling versions of the libraries don&amp;rsquo;t clobber the normal ones.</source>
          <target state="translated">&lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩이 변경됩니다 &lt;code&gt;.o&lt;/code&gt; 인 사용자가 지정한대로에 오브젝트 파일에 대한 파일 접미사를. 라이브러리를 컴파일 할 때이를 사용하여 라이브러리의 프로파일 링 버전에 대한 객체가 일반 객체를 방해하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="cf7cc663be7922fef0739796260273d9b72b496e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hiedir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hiedir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-outputdir&lt;/code&gt; 옵션의 조합에 대한 속기 &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--hiedir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hiedir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58fc191cffb134d6d4bcb21e65f27ae26e638ff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir
⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-outputdir&lt;/code&gt; 옵션의 조합에 대한 속기 &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae93959276ca239dd5463c43ee8f6f822a7abcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option also causes package ⟨pkg⟩ to be linked into the resulting executable or shared object. Whether a packages&amp;rsquo; library is linked statically or dynamically is controlled by the flag pair &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/ &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 의 옵션은 패키지 ⟨pkg⟩이 결과 실행 또는 공유 객체로 연결되도록합니다. 패키지 라이브러리가 정적으로 또는 동적으로 링크되는지 여부는 플래그 쌍 &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 에&lt;/a&gt; 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="712c183f0262639bdefc67f670ef5786d9f9839d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qn&lt;/code&gt; flag may be useful when running with a large &lt;code&gt;-A&lt;/code&gt; value (so that GC is infrequent), and a large &lt;code&gt;-N&lt;/code&gt; value (so as to make use of hyperthreaded cores, for example). For example, on a 24-core machine with 2 hyperthreads per core, we might use &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; to specify that the mutator should use hyperthreads but the GC should only use real cores. Note that this configuration would use 6GB for the allocation area.</source>
          <target state="translated">&lt;code&gt;-qn&lt;/code&gt; 큰 실행 플래그 때 유용 할 수 &lt;code&gt;-A&lt;/code&gt; 의 값 (GC가 빈번가되도록), 큰 &lt;code&gt;-N&lt;/code&gt; 에 (예를 들어, 하이퍼 때문에 코어 화장 용도에 관한) 값. 예를 들어 코어 당 2 개의 하이퍼 스레드가있는 24 코어 시스템에서 &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; 을 사용하여 뮤 테이터가 하이퍼 스레드를 사용해야하지만 GC는 실제 코어 만 사용해야한다고 지정할 수 있습니다. 이 구성은 할당 영역에 6GB를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b8f8cb8014da701a79e6b46cb3e225b86d226612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. Note that the &lt;code&gt;where&lt;/code&gt; clause is still necessary to distinguish closed families from open ones. If you give any equations of a closed family, you must give all of them, in the same order as they appear in the accompanying Haskell file.</source>
          <target state="translated">은 &lt;code&gt;..&lt;/code&gt; 말 그대로 의미 - 당신은 당신의 파일에 두 개의 점을 작성해야합니다. 닫힌 패밀리와 열린 패밀리를 구별 하려면 &lt;code&gt;where&lt;/code&gt; 절이 여전히 필요합니다. 폐쇄 된 패밀리의 방정식을 제공하는 경우 첨부 된 Haskell 파일에 나타나는 순서대로 모든 방정식을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="83164f5917a7372adba9f0624f17681c738f05e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. The &lt;code&gt;where&lt;/code&gt; clause distinguishes closed families from open ones.</source>
          <target state="translated">은 &lt;code&gt;..&lt;/code&gt; 말 그대로 의미 - 당신은 당신의 파일에 두 개의 점을 작성해야합니다. &lt;code&gt;where&lt;/code&gt; 절을 구별하는 열린 사람에서 가족을 마감했다.</target>
        </trans-unit>
        <trans-unit id="dcb0143d4440c731a3c677d373f63d932883b86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hp&lt;/code&gt; file is generated incrementally as your program runs. In principle, running &lt;strong&gt;hp2ps&lt;/strong&gt; on the incomplete file should produce a snapshot of your program&amp;rsquo;s heap usage. However, the last sample in the file may be incomplete, causing &lt;strong&gt;hp2ps&lt;/strong&gt; to fail. If you are using a machine with UNIX utilities installed, it&amp;rsquo;s not too hard to work around this problem (though the resulting command line looks rather Byzantine):</source>
          <target state="translated">&lt;code&gt;.hp&lt;/code&gt; 파일은 프로그램이 실행으로 점진적으로 생성됩니다. 불완전한 파일 에서 &lt;strong&gt;hp2ps&lt;/strong&gt; 를 실행 &lt;strong&gt;하면&lt;/strong&gt; 프로그램 힙 사용량의 스냅 샷이 생성됩니다. 그러나 파일의 마지막 샘플이 불완전하여 &lt;strong&gt;hp2ps&lt;/strong&gt; 가 실패 할 수 있습니다. UNIX 유틸리티가 설치된 시스템을 사용하는 경우이 문제를 해결하기가 어렵지 않습니다 (명령 행은 비잔틴으로 보이지만).</target>
        </trans-unit>
        <trans-unit id="cc7ae67c0b8544a12cdcfe050a8d2d65b4d2d666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:loc-at&lt;/code&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">&lt;code&gt;:loc-at&lt;/code&gt; 명령이 필요합니다 &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="868acbe7a67a816021798517632096beabaa53fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 방법 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="245cbed390fbb3e5caa7e31d436f7995b13c904c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 많은 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 사례는 큰 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="642ea10a7ef999e759dd2a8003076f1bb542bca1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 많은 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 사례는 큰 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a07f81de1f86161a74a26e3f56178d074bbb9cb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 많은 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 사례는 큰 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2d902fab64461e51ee2d74548c6c487fbabdaebf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 많은 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 사례는 큰 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3c17f4dbd13e6f82990bc913e1553422faf7c0d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 하면서 기능은 환경을 무시 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 모두 subcomputations에 상속 된 환경을 통과한다.</target>
        </trans-unit>
        <trans-unit id="51a96013d171e823610e883b0dcca6ee8756149e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 하면서 기능, 상태가 변경되지 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제의 초기 상태로서 상기 제 계산의 최종 상태를 이용한다.</target>
        </trans-unit>
        <trans-unit id="d443b950974bb112ab951f3d2eeff5624ca7c870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 함수는 출력 생성 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 을 하면서 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 사용 subcomputations의 출력 결합 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="a5978bf75b4f58ddc37c3dcfcb955a35e4410f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 함수는 출력 생성 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 을 하면서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 사용 subcomputations의 출력 결합 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="eefac33165054643d0f820e7473410a1e3ca417e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 통상의 값을 반환 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 종료. 오류 발생 후 계속되고 모든 오류를 수집하는 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="197b7d8676ceb906c4004a1522862a02b89f5e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 통상의 값을 반환 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 종료. 오류 발생 후 계속되고 모든 오류를 수집하는 변형에 대해서는 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e2a2bef52e7aaec2926a366a49ef4ff7f5dc015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 그 값을 생성하는 연산을 수득 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 어느 연산이 종료 않는 경우, 두 서열 subcomputations.</target>
        </trans-unit>
        <trans-unit id="a772099ec423a1c20cd2f57c2352719bbfc68ad0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 주어진 값을 생성하는 연산을 수득 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 빠져, 두 서열 subcomputations.</target>
        </trans-unit>
        <trans-unit id="0c02e3b1c74fff6be8fd138b7b81638f5520f137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능은 있지만, 성공 계산을 산출 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 에러 실패 서열 두 subcomputations.</target>
        </trans-unit>
        <trans-unit id="591c2084b78ba16832d7264b63d440c1c164a1fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 방법은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 와 함께, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fd5d1becb199aae7fcf8f5cddb1b46323f94938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 는 같은 목적을 위해 사용되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 예.</target>
        </trans-unit>
        <trans-unit id="b9caf64cdefb09c64255eb7f22c88a16a5fc1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 는 같은 목적을 위해 사용되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 예.</target>
        </trans-unit>
        <trans-unit id="d633291de962b83e64a4f5366d8780f130fabd29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자에 대해이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 는 동일한 결과를 제공하지만 나머지 5.8 %의 경우이 함수는 소수 15 번째 자리에서 정밀도를 잃습니다. 0.001 %의 숫자의 경우이 함수는 소수점 13 ~ 14 번째 자리에서 정밀도를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="d703712be7881bd93cfd2bc01dfee32118d427e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자의 경우이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 는 동일한 결과를 제공하지만 나머지 5.8 %의 경우이 함수는 소수 15 번째 자리에서 정밀도를 잃습니다. 0.001 %의 숫자의 경우이 함수는 소수점 13 ~ 14 번째 자리에서 정밀도를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="f8c0ff807ccff9eb26062cb229ca77b0ed057850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음 과 같은 여러 파서의 결과를 추가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c784a6d7ab10d7763556a008a4766e1b2eda4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음 과 같은 여러 파서의 결과를 추가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d81a3f4c85b4191151075e8c67e5bf6b30eb413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 작업 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 왼쪽 피연산자의 값을 선호한다. 경우 &lt;code&gt;m1&lt;/code&gt; 키 맵핑 &lt;code&gt;k&lt;/code&gt; 값에 대한 &lt;code&gt;a1&lt;/code&gt; , 및 &lt;code&gt;m2&lt;/code&gt; 는 다른 값에 대해 동일한 키를 맵핑 &lt;code&gt;a2&lt;/code&gt; 그들의 조합, &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 매핑 &lt;code&gt;k&lt;/code&gt; 에 &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="886078b2aaab08d590ba45d81857ef8f5563600b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 작업 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 왼쪽 피연산자의 값을 선호한다. 경우 &lt;code&gt;m1&lt;/code&gt; 키 맵핑 &lt;code&gt;k&lt;/code&gt; 값에 대한 &lt;code&gt;a1&lt;/code&gt; , 및 &lt;code&gt;m2&lt;/code&gt; 는 다른 값에 대해 동일한 키를 맵핑 &lt;code&gt;a2&lt;/code&gt; 그들의 조합, &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 매핑 &lt;code&gt;k&lt;/code&gt; 에 &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="519517bb832149c99d7d65f9e38c30f74e55d8c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 인수 이름 실행, 그리고 실행 파일 검색을위한 플랫폼의 표준 정책에 따라 해석됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="9c0ad1ae490321b15fc5c17f80550d3243babef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dece6bc59608b974325c5124d02a6f75ef4c62d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</target>
        </trans-unit>
        <trans-unit id="f7a9c0b4e24f513886a0fe3de6f9f53dadcdf0d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</target>
        </trans-unit>
        <trans-unit id="1bc09e39326ac463b521633cc81f1ec225a8a20d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</target>
        </trans-unit>
        <trans-unit id="68eed02a9714eb35cf81751d72df7caa308a61f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</target>
        </trans-unit>
        <trans-unit id="7f2da1b81116404bb6e8b43cb3a0637a688bb46e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</target>
        </trans-unit>
        <trans-unit id="260fcde2dc8277fbba23a670e261449948424309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</target>
        </trans-unit>
        <trans-unit id="dc6d56b3f6d2c5e6f40ede452ae79b597fe5912c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; , while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c0f713409cb9cf5a1a1a5c72fd485b5db43eb31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de8acf7cc9bc186692daa7881912af0fc23a852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1706a86dea612dae3883f17c7ddf1ff83583e970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56aecaa933008307756b2efe20503802422650bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</target>
        </trans-unit>
        <trans-unit id="1cc201c4c6a6bfd3a1b5af7fbb6792cb6cd39609" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</target>
        </trans-unit>
        <trans-unit id="d623297a7b53d6225cb0faf61fb94fa727435ae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</target>
        </trans-unit>
        <trans-unit id="55ee7b9be2c0feeeaeb3c31adf4da82d6f854ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; , along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11e1aa3150c01618910f02e8bbc7bf355bd69cbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="translated">은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 튜플 섹션을 처리 할 필요가있다.</target>
        </trans-unit>
        <trans-unit id="11b5bc40c86fffa7a6076174b1bffbac140f29df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</target>
        </trans-unit>
        <trans-unit id="f95780e47c020eeeda31a8c201eb535a8974578f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</target>
        </trans-unit>
        <trans-unit id="8a75b664a9646e6aa02764c34d0fe587f5a1dfbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자에 대해서는이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 가 동일한 결과를 제공하지만 나머지 5.8 %에 대해서는이 함수가 소수점 15 자리 부근에서 정밀도를 잃습니다. 0.001 %의 숫자에 대해이 함수는 소수점 13 번째 또는 14 번째 자리에서 정밀도를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="1201c6da12de4aba1276a3d6388e0825a36aceda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자에 대해서는이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 가 동일한 결과를 제공하지만 나머지 5.8 %에 대해서는이 함수가 소수점 15 자리 부근에서 정밀도를 잃습니다. 0.001 %의 숫자에 대해이 함수는 소수점 13 번째 또는 14 번째 자리에서 정밀도를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="2acb16e4a1657fdc3b4413dfd0838f6380ef5ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</target>
        </trans-unit>
        <trans-unit id="a9de1cc1416c3082400d8b6dfbf1289ad2cbe6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</target>
        </trans-unit>
        <trans-unit id="d955c1b4b45545a54049a0a44af93865745803be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt; , and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt; , then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1e8a62dc2c0577ea2e4fa388d91268432827035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; , which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt; , and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt; , then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e7c89abb8ca4cf07ac674bde1a74e6e1be7e25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 인수 이름 실행, 그리고 실행 파일 검색을위한 플랫폼의 표준 정책에 따라 해석됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="f78ea894305fa2f92651eb848a796e984b4e4110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 방법 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d405feb3a6b9895afaa0f318b7f28398f4bd6aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 대부분의 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 인스턴스는 중대한 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="86f1266aae7ad8bdc0dba42358ae53d2bcc3771f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 대부분의 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 인스턴스는 중대한 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="458e0e129dcbdfa5cce87aefa9e19048a965d645" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 대부분의 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 인스턴스는 중대한 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fc0c4cd9b9fd204bedd14ea51fb195630c8139d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 의 가 유효하기 때문에 전술이 포함되어 있습니다. 그러나 대부분의 경우 비효율적이며 일반적으로 피해야합니다. &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술 의 인스턴스는 중대한 효율성 문제 를 일으키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d72da00b002507603215122aff2a0c788a0b577d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 하면서 기능은 환경을 무시 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 모두 subcomputations에 상속 된 환경을 통과한다.</target>
        </trans-unit>
        <trans-unit id="975265378d608c7754aeb46eef5e343d004094c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 하면서 기능, 상태가 변경되지 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제의 초기 상태로서 상기 제 계산의 최종 상태를 이용한다.</target>
        </trans-unit>
        <trans-unit id="046b9ec685e02d0b7255d415f7a53e51ece44c02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 함수는 출력 생성 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 을 하면서 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 사용 subcomputations의 출력 결합 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1ce59aa9aa7770be720fe2f9ab4b78c390dafeca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 함수는 출력 생성 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 을 하면서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 사용 subcomputations의 출력 결합 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ab2094e6381df03e75161328d5b93c89ad3d9048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 통상의 값을 반환 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 종료. 오류를 오류 후 계속 모두를 수집하는 변형을 참조 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc17f1fd4fad20e7ff547a572bbb918d61a43edc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 통상의 값을 반환 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 종료. 오류를 오류 후 계속 모두를 수집하는 변형을 참조 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9fbc9218ae7816a7764ba8f4b7ea997abf1ec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 그 값을 생성하는 연산을 수득 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 어느 연산이 종료 않는 경우, 두 서열 subcomputations.</target>
        </trans-unit>
        <trans-unit id="dbde8b545bd4180a31e36b9eaf901736baf44dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능이 있지만, 주어진 값을 생성하는 연산을 수득 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 예외에 빠져, 두 서열 subcomputations.</target>
        </trans-unit>
        <trans-unit id="70d2fe74f9a13fe2abf46ab4a20202c52ca11c4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 기능은 있지만, 성공 계산을 산출 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 제 에러 실패 서열 두 subcomputations.</target>
        </trans-unit>
        <trans-unit id="0392dbac15f5a29ace95ddc3854629ee10a2c673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 방법은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 와 함께, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a49a233b3aaeb66c434e12308ae79ebd04f8c90b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="translated">은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 튜플 섹션을 처리 할 필요가있다.</target>
        </trans-unit>
        <trans-unit id="4a31b665a96aa687aea00989af736838ac7b1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 는 같은 목적을 위해 사용되는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 예.</target>
        </trans-unit>
        <trans-unit id="ba0b18140a235048175aac50f5fcbba208d418d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 는 같은 목적을 위해 사용되는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 예.</target>
        </trans-unit>
        <trans-unit id="97ca3a40e1687acc199ba4ae4156a478a2153d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자에 대해서는이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 가 동일한 결과를 제공하지만 나머지 5.8 %에 대해서는이 함수가 소수점 15 자리 부근에서 정밀도를 잃습니다. 0.001 %의 숫자에 대해이 함수는 소수점 13 번째 또는 14 번째 자리에서 정밀도를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="28366f4f1cc4165989efbd16469d4c39f286fe41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 정밀도의 16 개 진수 장소에 대한 유형 지원합니다. 94.2 %의 숫자에 대해서는이 함수와 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 가 동일한 결과를 제공하지만 나머지 5.8 %에 대해서는이 함수가 소수점 15 자리 부근에서 정밀도를 잃습니다. 0.001 %의 숫자에 대해이 함수는 소수점 13 번째 또는 14 번째 자리에서 정밀도를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="54880289dd15dc1c7fcd477651a6537f2d2ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 은 예를 들어 여러 파서 결과를 추가하는 데 사용된다 :</target>
        </trans-unit>
        <trans-unit id="dc53a4659b8ab96fd92904a1a6f76268c60e672b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 은 예를 들어 여러 파서 결과를 추가하는 데 사용된다 :</target>
        </trans-unit>
        <trans-unit id="89cddb92704acf6ee37cc5e18ac776492c7fd174" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 작업 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 왼쪽 피연산자의 값을 선호한다. 경우 &lt;code&gt;m1&lt;/code&gt; 키 맵핑 &lt;code&gt;k&lt;/code&gt; 값에 대한 &lt;code&gt;a1&lt;/code&gt; , 및 &lt;code&gt;m2&lt;/code&gt; 는 다른 값에 대해 동일한 키를 맵핑 &lt;code&gt;a2&lt;/code&gt; 그들의 조합, &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 매핑 &lt;code&gt;k&lt;/code&gt; 에 &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece285de7b69fb6ebec656427cb5d85fead59f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 작업 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 왼쪽 피연산자의 값을 선호한다. 경우 &lt;code&gt;m1&lt;/code&gt; 키 맵핑 &lt;code&gt;k&lt;/code&gt; 값에 대한 &lt;code&gt;a1&lt;/code&gt; , 및 &lt;code&gt;m2&lt;/code&gt; 는 다른 값에 대해 동일한 키를 맵핑 &lt;code&gt;a2&lt;/code&gt; 그들의 조합, &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 매핑 &lt;code&gt;k&lt;/code&gt; 에 &lt;code&gt;a1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161eb66f14a2659bb4450195c7fef766d0c5fa15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 인수 이름 실행, 그리고 실행 파일 검색을위한 플랫폼의 표준 정책에 따라 해석됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="b8ec1a27d9645ead49a8fac70722d498afadafab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 펑터.</target>
        </trans-unit>
        <trans-unit id="404d7369c3ed5cd7574fad867737a14afb444a12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; class is equivalent to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;: any monad gives rise to a &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; arrow, and any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; defines a monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 의 클래스에 상당 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; : 모든 모나드는 상승을 제공 &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; 의 화살표를의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 모나드를 정의한다.</target>
        </trans-unit>
        <trans-unit id="712abe7e2f78e39742519eb3d9a6b4a2f4ce365d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; operator expresses computations in which an output value is fed back as input, although the computation occurs only once. It underlies the &lt;code&gt;rec&lt;/code&gt; value recursion construct in arrow notation. &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; should satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 계산 번만 발생하지만 운영자는, 출력값을 입력으로 다시 공급되는 연산을 나타낸다. 화살표 표기법으로 &lt;code&gt;rec&lt;/code&gt; 값 재귀 구성의 기초가 됩니다. &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 는 다음 법칙을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d5ea08c77b20ca5949edb787e87c9bfc18d424c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 조치는 다른 현재 실행 가능한 스레드 (있는 경우)에의 (a 협동 멀티 태스킹 구현에 힘) 컨텍스트 스위치를 허용하고, 동시성 추상화를 구현할 때 가끔 유용하다.</target>
        </trans-unit>
        <trans-unit id="2aecf2fbfb3505dad21f83e912f2781f57633420" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; classes, with some useful operations on monads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 모나드에 대한 몇 가지 유용한 작업과 클래스.</target>
        </trans-unit>
        <trans-unit id="e42cbe3850d6befefe426ee80a44a4c35d7e57b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 클래스는 통해 기본 동작을 정의 &lt;em&gt;모나드&lt;/em&gt; 로 알려진 수학의 지점에서, 개념을 &lt;em&gt;범주 이론&lt;/em&gt; . 그러나 Haskell 프로그래머의 관점에서 모나드는 &lt;em&gt;추상적 인 데이터&lt;/em&gt; 작업 &lt;em&gt;유형&lt;/em&gt; 으로 생각하는 것이 가장 좋습니다 . Haskell의 &lt;code&gt;do&lt;/code&gt; 표현식은 모나 딕 표현식을 작성하기위한 편리한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fc32a4cddc34ade233961b4012b777dbb17097e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하면 실패 할 수있는 여러 작업을 함께 연결할 수 있으며 개별 단계 중 하나라도 실패하면 전체적으로 실패 할 수 있습니다. 먼저 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 파싱 ​​할 수있는 함수를 작성합니다 하거나 실패 .</target>
        </trans-unit>
        <trans-unit id="841e7fb83df459d53e389056b37c0fc15cd60e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are not strict in the state. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 조작 상태에 엄격하지 않다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8492deac48ede758cea8f52bc65fb3e2f9ba2826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are strict in the state (though not in values stored in the state). For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 작업 (상태 값을 저장 아니지만) 상태에서 엄격하다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="27d5a6c8ea1acb5010f2c9679c264fd5c989ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, except that its result is encapsulated in a monad. Note that &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; works from left-to-right over the list arguments. This could be an issue where &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; and the `folded function' are not commutative.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 의 기능과 유사하다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 그 결과 모나드에 캡슐화한다는 점을 제외. 참고 것을 &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 가 에서 작동 왼쪽에서 오른쪽 목록 인수를 통해. 이 문제는 &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 과 '접힌 함수'가 정식이 아닌 .</target>
        </trans-unit>
        <trans-unit id="9ee235b387a6a14db33bdf2a6b2158fa66bc38c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">은 &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 함수 종래 모나드 조인 연산자이다. 하나의 레벨의 모나 딕 구조를 제거하고 바인딩 된 인수를 외부 레벨로 투영하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e9731c305b0f549055c674d9ac68832bd130e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; 의 기능은리스트의 쌍으로 결과를 반환 목록을 통해 자사의 첫 번째 인수를 매핑합니다. 이 기능은 주로 복잡한 데이터 구조 또는 상태 모나드와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="adfaa2036ac4e96d2cf9b7c53ce9041b46c41b72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; to arbitrary applicative functors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; 함수 는 zipWith를 일반화 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 임의 실용적으로 펑.</target>
        </trans-unit>
        <trans-unit id="9e4c77f8896de4159de2b19d91214d29c830fc9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 클래스는 통해 기본 동작을 정의 &lt;em&gt;모나드&lt;/em&gt; 로 알려진 수학의 지점에서, 개념을 &lt;em&gt;범주 이론&lt;/em&gt; . 그러나 Haskell 프로그래머의 관점에서 모나드는 &lt;em&gt;추상적 인 데이터&lt;/em&gt; 작업 &lt;em&gt;유형&lt;/em&gt; 으로 생각하는 것이 가장 좋습니다 . Haskell의 &lt;code&gt;do&lt;/code&gt; 표현식은 모나 딕 표현식을 작성하기위한 편리한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="680d557813d267dc8f3ee06e2da84590ab3ebc77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; 모나드 (또한 환경 모나드라고합니다). 공유 환경에서 값을 읽고 함수에서 값을 전달하며 수정 된 환경에서 하위 계산을 실행할 수있는 계산을 나타냅니다. 사용 &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; 와 같은 계산에 모나드은 사용하는 것보다 종종 명확하고 쉽게 &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; 모나드를.</target>
        </trans-unit>
        <trans-unit id="81283641c0b20f0b2748a09d602fde66cbffe272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; operation has a more complex type, so we need to use the special-purpose lifting function &lt;code&gt;liftCatch&lt;/code&gt; provided by most monad transformers. Here we use the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; version followed by the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; version:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; 의 우리가 특수 목적 리프팅 기능을 사용할 필요가 있으므로 작업은 더 복잡한 유형이 &lt;code&gt;liftCatch&lt;/code&gt; 대부분의 모나드 변압기에서 제공합니다. 여기에 우리가 사용 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 에 의해 다음 버전 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 의 버전 :</target>
        </trans-unit>
        <trans-unit id="545d7b475a316b28ef1da840a21adda70380c2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; monad transformer extends a monad with the ability to exit the computation without returning a value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; 모나드 변압기의 값을 리턴하지 않고 연산을 종료하는 기능을 확장 모나드.</target>
        </trans-unit>
        <trans-unit id="a2118806ea587f5911ee90a60aa429d89bdcab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; 의 사용 연관리스트에 반복 지수 함수와 상품 &lt;em&gt;축적 함수&lt;/em&gt; 인덱스와 같은 연관 값을 결합한다.</target>
        </trans-unit>
        <trans-unit id="0179248504c3fa08ab2a958c9b5147b68d6c33e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; 함수 술어 및 구조 복귀 좌단 술어 일치 구조의 요소 또는 필요 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="87802a775d4245309a8eade317e7d18abe967e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; 의 기능 구조의 수의 곱을 계산한다.</target>
        </trans-unit>
        <trans-unit id="e6a2674d1a15617e9adc9ceb2614394b34abbb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="dc2ecd95ed8a8f0c6f2cf1d560aaa6d8aea4ed41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스는 제공 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; , 인코딩하는 방법과 게으른에 하스켈 값 디코딩 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . Haskell 유형의 텍스트 표현을 위해 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스를 미러링 하며 네트워크를 통해 Haskell 값을 디스크에 직렬화하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ef67bb75d4cd691a3105fe1fbf4dfcaa9ea238dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스는 제공 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; , 인코딩하는 방법과 게으른에 하스켈 값 디코딩 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . Haskell 유형의 텍스트 표현을 위해 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스를 미러링 하고 네트워크를 통해 Haskell 값을 디스크에 직렬화하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="359a7c862ec288bde5c781831027b2789d88d4e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스는 제공 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; , 인코딩하는 방법과 게으른에 하스켈 값 디코딩 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . Haskell 유형의 텍스트 표현을 위해 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스를 미러링 하고 네트워크를 통해 Haskell 값을 디스크에 직렬화하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fc3c4e321db0da5c60f5e57209330b5697cd8103" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad. A monad for efficiently building structures from encoded lazy ByteStrings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 모나드. 인코딩 된 지연 ByteString으로부터 구조를 효율적으로 구축하기위한 모나드.</target>
        </trans-unit>
        <trans-unit id="4d3613093bfbb78cd7a2a16f8922cee7681b2bed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from left to right, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; 그 유형의 상태 스레딩, 왼쪽에서 오른쪽으로 구성 횡단 &lt;code&gt;a&lt;/code&gt; 하고 새로운 구조 요소를 계산하기 위해 소정의 액션을 사용한다.</target>
        </trans-unit>
        <trans-unit id="9a87ec27622ff13e398e24344f3a64ac0e1395d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; 그 유형의 상태 스레딩, 오른쪽에서 왼쪽으로 구조를 가로 지르는 &lt;code&gt;a&lt;/code&gt; 하고 새로운 구조 요소를 계산하기 위해 소정의 액션을 사용.</target>
        </trans-unit>
        <trans-unit id="8fde160a7fc5705892a4e1ea87c284f4780166ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; ; 오른쪽에서 왼쪽으로 구조를 가로 지르며 유형 &lt;code&gt;a&lt;/code&gt; 의 상태를 스레딩 하고 주어진 조치를 사용하여 구조에 대한 새 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="48db54c46d3aa624ae5d297b1ebeb1fa3977d71b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; class defines bitwise operations over integral types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 클래스 정의는 정수형을 통해 작업을 비트 단위.</target>
        </trans-unit>
        <trans-unit id="0ad9b411edb3c5e8c1b9471ab75ecc126a6721eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; class denotes types with a finite, fixed number of bits.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; 의 클래스 비트 한정된 고정 수와 종류를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="20817eeecc682279fcdb27f8168c9dc5e0bd900f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type and related functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 유형 및 관련 기능.</target>
        </trans-unit>
        <trans-unit id="0ac698df5fa5f3ca66ad118ffad20bf3b266295d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 술어를 만족 ByteString의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="a88a45076c0dfb13c7596a49a77c0da26a873595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="d89ae35b30db39f44c3fe60d6b3d04049f068a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 함수 ByteString 소요 결과 병합이 인수 동일하도록 ByteStrings의리스트를 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4ee4acaf8e9d95a9f5ef4c31e80b5ce11a67d031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e617691064b9b4b87d847163f54ff7d363170a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누산기의 최종 값을 새 목록과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ea34718a3c5162fce3eb666e6adf60a8a7d062c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd51442d30fe2b55d7fe46723f9d58913d2aa41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는의 행과 열 전치 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 인수를.</target>
        </trans-unit>
        <trans-unit id="c1aa92f924157b1d391e0c5573f2c097c3b5ec16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; itself is an IO action: you supply it with a buffer (as a pointer and length) and it will write data into the buffer. It returns a number indicating how many bytes were actually written (which can be &lt;code&gt;0&lt;/code&gt;). It also returns a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; which describes what comes next.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 자체는 IO 작업입니다 : 당신은 (포인터와 길이로) 버퍼로 공급하며 버퍼에 데이터를 기록합니다. 실제로 쓴 바이트 수를 나타내는 숫자를 리턴합니다 ( &lt;code&gt;0&lt;/code&gt; 일 수 있음 ). 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 오는 것을 설명 하는 Next 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ea2d270840cc8c9daa194a459da571d928cff274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 바이트 길이 제로의 순서를 나타내는. 이 함수는 다시 쓰기 규칙에서만 사용하도록 내 보냅니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="77e9d20b09fe3cb5d3e34c82f2d34d8c4d1fbd52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="93dd19fcd92601ecabd679db17cd19a75a81c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 바이트 길이 제로의 순서를 나타내는. 이 함수는 다시 쓰기 규칙에 사용하기 위해서만 내보내집니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="02c6b6ed74cc07d8a8ef6b6a51e39f07fbdde207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 항상 길이 제로의 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="386c97767c9a0e690099a424827f366fbf618180" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 항상 길이 제로의 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e4a29465a0ac4c8f6fffb025991665c12b63f1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; pairing and mapping operators can be used with &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; 페어링 및 매핑 연산자와 함께 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd16a4104dcd27da4c5d7c015155569458cf5d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 항상 길이 제로의 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5ca076d9cd96bbcd373168527623c2c7280cd67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 항상 길이 제로의 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34fcdbaf6996fe7f65d389f0c0fdfc1f2f89c754" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 술어를 만족 ByteString의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="2808d77c990696b44b127af7d539f85921526158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="3b2f3c13460a923ec70902424b286392ebcf4ee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 함수 ByteString 소요 결과 병합이 인수 동일하도록 ByteStrings의리스트를 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="011ecd68a05489bd1b20ac9d77a9cea0655b8352" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72cc5f08d56e30d247f072343ee4d0e1aa87e68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누산기의 최종 값을 새 목록과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9e160c9ad7473babd1af40af00cbf0162bdef7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83f55a6f846dc49344b68895528bedee225f9b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는의 행과 열 전치 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 인수를.</target>
        </trans-unit>
        <trans-unit id="cfef4b206c70c32eec3092e778efb683d81d66b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; 기능은 유사 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; 의 단어, 기능.</target>
        </trans-unit>
        <trans-unit id="1d758a0f563300419f025322f07bdf29baaf99ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 술어를 만족 ByteString의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="014ce90607c5489f1d18b6f1c446b9bba5ae0212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndexEnd&quot;&gt;findIndexEnd&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the last element in the ByteString satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndexEnd&quot;&gt;findIndexEnd&lt;/a&gt;&lt;/code&gt; 의 함수는 술어와 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 하고 조건을 만족하는 ByteString의 마지막 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc3fedbb007a3889a87db49cdfcce211f6dec12f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="11978bfbf1d81f38393dc6440b94501585d47dc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 함수 ByteString 소요 결과 병합이 인수 동일하도록 ByteStrings의리스트를 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="063223aebad86f89a99e6e89e5807a67aa057281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de39eec2cad2fac68f9d8a352ebb2380e3936c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 기능은 얻어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 산재 ''의 요소 사이의 바이트 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 . Lists의 intersperse 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6625add11fa1e445312d92a0c6788839896adacf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . It is analogous to the intersperse function on Lists.</target>
        </trans-unit>
        <trans-unit id="ca33e217cddf98a06cc4dd73bac5dae5740289e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 기능은 얻어 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 및 산재 ''의 요소 사이의 바이트 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 . 목록의 intersperse 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="8b89a766d13b74128a8333abb002900f94b6b437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c773ca1b34d782e061cf0d6996806a66376f97f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="612dd81abb27b510de3a02ab1ed120cd76a9a6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는의 행과 열 전치 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 인수를.</target>
        </trans-unit>
        <trans-unit id="b02cc89d4861343dc4906429c0519e1e575b9b01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 소요 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 를 술어를 만족 ByteString의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="89e6612f1c49c256bb1909e6d5ea7235d2f56477" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="0683ca6fb89db86c531b2e317168c1b2a68d2259" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 함수 ByteString 소요 결과 병합이 인수 동일하도록 ByteStrings의리스트를 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7f63028123ecc27ee69e82bdcdeb63da564a6078" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9318a5a01ea45d555a0875fa484d9ff476c3e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e142671c8576be4ab4d32dbd1993a19bfee360ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 ByteString의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 ByteString과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21e9a6162eb970619d9172486dd0b5106006c4bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는의 행과 열 전치 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 인수를.</target>
        </trans-unit>
        <trans-unit id="981ef85d841145750af6b8e72525229c75f0ae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; 기능은 유사 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; 의 단어, 기능.</target>
        </trans-unit>
        <trans-unit id="70b1e8ad66966b19620f6916e96d89ef82853d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class comprehends a fundamental primitive &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; for folding over constructor applications, say terms. This primitive can be instantiated in several ways to map over the immediate subterms of a term; see the &lt;code&gt;gmap&lt;/code&gt; combinators later in this class. Indeed, a generic programmer does not necessarily need to use the ingenious gfoldl primitive but rather the intuitive &lt;code&gt;gmap&lt;/code&gt; combinators. The &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; primitive is completed by means to query top-level constructors, to turn constructor representations into proper terms, and to list all possible datatype constructors. This completion allows us to serve generic programming scenarios like read, show, equality, term generation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 클래스는 기본적인 원시 이해한다 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 를 생성자 응용 프로그램을 통해 접는 용어들은 말한다. 이 기본 요소는 여러 가지 방법으로 인스턴스화하여 용어의 즉각적인 하위 용어를 맵핑 할 수 있습니다. 이 클래스 후반에 있는 &lt;code&gt;gmap&lt;/code&gt; 결합기를 참조하십시오 . 실제로, 일반 프로그래머는 반드시 독창적 인 gfoldl 프리미티브가 아니라 직관적 인 &lt;code&gt;gmap&lt;/code&gt; 결합기를 사용해야합니다 . &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 프리미티브는 적절한 조건으로 생성자 표현을 설정하고, 모든 가능한 데이터 유형을 나열 생성자 쿼리 최상위 생성자에 의해 완성된다. 이 완료를 통해 읽기, 표시, 평등, 용어 생성과 같은 일반적인 프로그래밍 시나리오를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형은 종종 하나 또는 정확한 오류라고하는 값을 나타내는 데 사용된다; 일반적으로 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자는 오류 값 을 보유하는 데 사용되고 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자는 올바른 값을 보유하는 데 사용됩니다 (니모닉 : &quot;right&quot;는 &quot;correct&quot;를 의미 함).</target>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형은 두 가지 가능성으로 값을 나타냄 타입의 값 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 하나 인 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 정의를 항등 ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) 불평등 ( &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). &lt;a href=&quot;prelude&quot;&gt;Prelude에서&lt;/a&gt; 내 보낸 모든 기본 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 는 구성 요소가 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 데이터 유형에 대해 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스 먼저 실수 부분을 통과.</target>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 기능은 술어와 구조 및 반환 왼쪽 술어 일치하는 구조의 요소 또는 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="1b7c06198a94e0e0bdce1efceb1fa1157608eeea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` method is a special case of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, in which the initial accumulator is &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; and the operator is &lt;code&gt;mappend . f&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; maps each input element into the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in question. Therefore, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is an appropriate choice under essentially the same conditions as &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, and its implementation for a given &lt;code&gt;Foldable&lt;/code&gt; structure should also be a strict left-associative reduction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `방법의 특별한 경우이다 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; `하는 어큐뮬레이터는 초기 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 오퍼레이터는 &lt;code&gt;mappend . f&lt;/code&gt; , 여기서 &lt;code&gt;f&lt;/code&gt; 는 각 입력 요소를 해당 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 매핑합니다 . 따라서 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; ` 은 본질적으로 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ` 과 동일한 조건에서 적절한 선택 이며 주어진 &lt;code&gt;Foldable&lt;/code&gt; 구조에 대한 구현 도 엄격한 왼쪽 연관 축소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="40cadb370f92894eea0177fbad74525b49368dd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; form works verbatim if the type of &lt;strong&gt;&lt;code&gt;mvalue&lt;/code&gt;&lt;/strong&gt; is later refactored from &lt;strong&gt;&lt;code&gt;Maybe a&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; (assuming it remains OK to silently do nothing in the error case).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 의 유형 경우 형태는 그대로 작동 &lt;strong&gt; &lt;code&gt;mvalue&lt;/code&gt; 가&lt;/strong&gt; 나중에에서 리팩토링 &lt;strong&gt; &lt;code&gt;Maybe a&lt;/code&gt; &lt;/strong&gt; 에 &lt;strong&gt; &lt;code&gt;Either e a&lt;/code&gt; &lt;/strong&gt; (자동 오류 경우 아무것도하지 않는 것이 OK 유지 가정).</target>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 곱을 계산한다.</target>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="4e16e1b415ac8aa1d79a0e8941de4b3fd089e939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; base class means that the container cannot impose any constraints on the element type, so containers that require elements to be comparable, or hashable, etc., cannot be instances of the &lt;code&gt;Traversable&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 요소를 필요로 용기 등에 필적하거나 해쉬 수 있도록 컨테이너의 인스턴스 일 수 없으며, 소자의 타입에 어떤 제한을 부과 할 수 있다는 기본 클래스 수단 &lt;code&gt;Traversable&lt;/code&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 fmap 은 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값을 무시하지만 제공된 함수를 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 에 포함 된 값에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수의 기능은 또한 중위 연산자 가능 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 펑터.</target>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; 형태는 유한의 인접리스트 표현 형식의 정점으로 향하는 그래프 &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 의 유형은 대표 &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;강하게 연결된 구성 요소&lt;/a&gt; 그래프의이.</target>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인수가 지정하는 &lt;em&gt;기능 번호를&lt;/em&gt; (참조 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 을 ). 일반적으로 기능은 실제 프로세서에 해당하지만 정확한 동작은 구현에 따라 다릅니다. 에 전달 된 값 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 에 의해 반환 기능의 총 수를 모듈로 해석된다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인수가 지정하는 &lt;em&gt;기능 번호를&lt;/em&gt; (참조 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 을 ). 일반적으로 기능은 실제 프로세서에 해당하지만 정확한 동작은 구현에 따라 다릅니다. 에 전달 된 값 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 에 의해 반환 기능의 총 수를 모듈로 해석된다 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인수가 지정하는 &lt;em&gt;기능 번호를&lt;/em&gt; (참조 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 을 ). 일반적으로 기능은 실제 프로세서에 해당하지만 정확한 동작은 구현에 따라 다릅니다. 에 전달 된 값 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 에 의해 반환 기능의 총 수를 모듈로 해석된다 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 유형이 유형의 키에서 (때로는 사전이라고 함) 유한지도 나타냅니다 &lt;code&gt;Int&lt;/code&gt; 형의 값으로 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 기능은 게으른 엄격한 모듈에 의해 공유됩니다. 병합 전술의 선택 만이 엄격 성을 결정합니다. 당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; 에서 mapMissing결과가 삽입되기 전에 강제 적용됩니다. 이 모듈에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용하면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 기능은 게으른 엄격한 모듈에 의해 공유됩니다. 병합 전술의 선택 만이 엄격 성을 결정합니다. 당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 이 모듈에서 mapMissing하면 결과가 삽입되기 전에 결과가 적용됩니다. &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용하면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 유형이 유형의 키에서 (때로는 사전이라고 함) 유한지도 나타냅니다 &lt;code&gt;Int&lt;/code&gt; 형의 값으로 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 유형은 동일한 것을 의미하는 엄격한 지연 모듈간에 공유 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 값은 모두 기능 모듈로 전달 될 수있다. 이것은 &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Traversable&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 모듈 과 동일 하므로 사용 된 경우 결과 맵에 일시 중단 된 값 (썽크)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d01cac285dd99db980e4e71910e5f17ef1269f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</target>
        </trans-unit>
        <trans-unit id="de110598e79367090ddf9a9502e16c3db920c1a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 유형은 동일한 것을 의미하는 엄격한 지연 모듈간에 공유 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 값은 모두 기능 모듈로 전달 될 수있다. 이는 &lt;code&gt;Functor&lt;/code&gt; , &lt;code&gt;Traversable&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 모듈 의 경우와 동일 하므로 사용되는 경우 결과 맵에 일시 중단 된 값 (thunks)이 포함될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 유형이 유형의 키에서 (때로는 사전이라고 함) 유한지도 나타냅니다 &lt;code&gt;Int&lt;/code&gt; 형의 값으로 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 유형은 동일한 것을 의미하는 엄격한 지연 모듈간에 공유 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 값은 모두 기능 모듈로 전달 될 수있다. 이는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 모듈 과 동일 하므로 사용 된 경우 결과 맵에 일시 중단 된 값 (썽크)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="352aafc40cb132717ac79f053c1b34a159a6c7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</target>
        </trans-unit>
        <trans-unit id="4df8970586f0c961dd4f430a41d51d650439ca67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 유형은 동일한 것을 의미하는 엄격한 지연 모듈간에 공유 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 의 값은 모두 기능 모듈로 전달 될 수있다. 이는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; 모듈 의 경우와 동일 하므로 사용되는 경우 결과 맵에 일시 중단 된 값 (thunks)이 포함될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 의 타입 타입의 요소 세트 나타내는 &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스는 정수 상에 형의 값의 연속 부분 범위를 매핑하는 데 사용됩니다. 주로 배열 인덱싱에 사용됩니다 (어레이 패키지 참조).</target>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스는 정수로 형의 값의 연속 부분 범위를 매핑하는 데 사용됩니다. 주로 배열 인덱싱에 사용됩니다 (어레이 패키지 참조). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 는 행 주요 순서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 의 기능 목록 차 (비 결합)이다. 결과에서 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; , 각 요소의 첫 번째 발생 &lt;code&gt;ys&lt;/code&gt; 차례로 (있는 경우)에서 제거 된 &lt;code&gt;xs&lt;/code&gt; . 그러므로</target>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 함수 술어 두리스트를 취하고 제거 번째 목록의 각 요소의 최초 발생에 첫 번째 목록을 반환한다.</target>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 의 함수는 주어진 술어 모든 요소에 보유 된리스트의 최대 접미사 떨어진다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 의 함수 (동일한 의해 지정된리스트의 첫 번째 요소의 인덱스를 반환 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 질의 요소 또는 행) &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우를.</target>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 오름차순으로, 모든 요소의 인덱스는 쿼리 소자 동일 반환하여.</target>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 기능은 그냥 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 리스트 모나드에 전문 :</target>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 기능은 술어와 구조 및 반환 왼쪽 술어 일치하는 구조의 요소 또는 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수는 술어와리스트를 취해 조건을 만족하는 목록의 첫 번째 요소의 인덱스를 반환하거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 드롭 소자의 수와 같은 값.</target>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; 모든 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 값을 인덱스로 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 반복 횟수를 확인하기 위해 값.</target>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 분할하는 위치로서 값.</target>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 취할 소자의 수와 같은 값.</target>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 기능 목록을 취하여 결과 병합이 인수 동일하도록리스트의 목록을 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 는 짧은 첫째, 반환에게 인수의 모든 초기 세그먼트를 작동합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 기능은 두 목록의 목록 교차합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의 목록 및 반환 소요 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 어디서나 초 이내에 전적으로 그대로, 포함 된 첫 번째 목록 IFF를.</target>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두리스트를 받아 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 제리스트의 요소가 발생하는 모든 경우에 두 번째 순서. 요소가 연속적으로 발생할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의리스트를 받아 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 첫 번째 목록이 두 번째의 접미사입니다 IFF에. 두 번째 목록은 유한해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 및 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 이 함수는 구조의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누적 기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8dd53e15a4486e163e923e5edcb16e98edcfede4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 및 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 구조의 각 요소에 함수를 적용하고 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누적 기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 구조체의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="58255312061a37b729a440f59df1d47f433cf4a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 구조의 각 요소에 함수를 적용하고 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누적 기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 단지와 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , 대신 과부하의 사용자 제공 동등 술어 사용 제외 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 기능 목록 술어 소요 할 각각 술어를 만족하지 않는 요소들의리스트의 한 쌍의 리턴; 즉,</target>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 반환에게 인수의 모든 순열의 목록을 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 곱을 계산한다.</target>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능 구현은 안정적인 알고리즘을 정렬. &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 비교 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 반환에게 인수의 모든 서브 시퀀스의 목록을 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는 인수의 행 및 열을 바꿉니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능을 할 '는'듀얼입니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : 동안 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 은 요약 값 목록을 감소 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값의 목록을 작성합니다. 이 함수는 요소 반환지지 않습니다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 가 목록 또는 반환 생성 할 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ,이 경우, &lt;code&gt;a&lt;/code&gt; A가 목록에 앞에 추가이고 &lt;code&gt;b&lt;/code&gt; 는 재귀 호출의 다음 요소로 사용된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 기능은 두 목록의 목록 조합을 반환합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 기능은 유사 트리플 돌아갑니다 세 가지 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 기능이 유사한 4 배로 돌아갑니다 넷 개리스트의 목록 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 기능은 유사 다섯 튜플 반환 다섯 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 기능은 유사 여섯 튜플 반환 여섯 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 기능은 유사 일곱 튜플 반환 일곱 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 기능은 네 개의리스트를 취하고 유사한 4 배의 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 기능은 다섯 명 목록을 받아 유사한 다섯 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 기능은 여섯리스트를 취하고 유사 여섯 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 기능은 일곱리스트를 취하고 유사 일곱 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="808a6c884122f71311b11b7294556f8f16861f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 함수는 세 요소뿐만 아니라 세 개의리스트를 결합하여 기능의 목록과 유사한 대응 요소에 적용 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합이 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 기능은 세 가지 요소뿐만 아니라, 세 가지 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 의 기능은 네 가지 요소뿐만 아니라, 네 개의 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 의 기능은 다섯 개 가지 요소뿐만 아니라 다섯 개 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 의 함수 여섯 개 요소뿐만 아니라 여섯리스트를 결합하고 유사한 자신의 포인트 - 방식의 조합의리스트를 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 의 기능은 일곱 개 요소뿐만 아니라 칠 개 목록 및 반환 유사 자신의 포인트 현명한 조합의 목록을 결합하는 기능을한다 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; 함수에 상당 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 기능이 스트림을 받아서 생성 된 목록을 평탄화하는 인수와 동일하도록 스트림의리스트를 반환한다. 또한 결과 목록의 각 스트림에는 동일한 요소 만 포함됩니다. 예를 들어, 목록 표기법에서 :</target>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 의 함수는 스트림 소요 &lt;code&gt;xs&lt;/code&gt; 모두에게의 유한 접두사 반환 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 첫 번째 인수가 두 번째의 접두사 인 경우.</target>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 함수는 목록에서 중복 요소를 제거합니다. 특히 각 요소의 첫 번째 항목 만 유지합니다. &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 라는 이름 은 '본질'을 의미합니다. &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 불평등 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 단지와 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , 대신 과부하의 사용자 제공 동등 술어 사용 제외 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 함수는 술어 소요 &lt;code&gt;p&lt;/code&gt; 와 스트림 &lt;code&gt;xs&lt;/code&gt; , 및 목록의 한 쌍을 반환합니다. 제리스트의 요소에 대응 &lt;code&gt;xs&lt;/code&gt; 되는 &lt;code&gt;p&lt;/code&gt; 보유하고; 의 요소에 대응하고 상기 제 &lt;code&gt;xs&lt;/code&gt; 있는 &lt;code&gt;p&lt;/code&gt; 보유하지 않는다.</target>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 함수는 스트림 소요 &lt;code&gt;xs&lt;/code&gt; 모두에게의 접미사 반환 &lt;code&gt;xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 함수 유사 &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 동작.</target>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 함수의 역인 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 함수는 두 개의 스트림을 취하여 해당 쌍의 스트림을 리턴한다.</target>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 의 기능 일반화는 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 요소를 터플 링하는 대신 첫 번째 인수로 전달 된 함수를 사용하여 요소를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 유형은 유형의 키에서 (때로는 사전이라고 함) 유한지도 나타냅니다 &lt;code&gt;k&lt;/code&gt; 형의 값으로 &lt;code&gt;v&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 그 값의 키에 엄격하지만 게으른입니다.</target>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 기능은 게으른 엄격한 모듈에 의해 공유됩니다. 병합 전술의 선택 만이 엄격 성을 결정합니다. &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용 하면 결과가 삽입되기 전에 결과가 적용됩니다. 이 모듈에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용 하면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 기능은 게으른 엄격한 모듈에 의해 공유됩니다. 병합 전술의 선택 만이 엄격 성을 결정합니다. 이 모듈에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용 하면 결과가 삽입되기 전에 결과가 적용됩니다. &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 을 사용 하면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 유형은 유형의 키에서 (때로는 사전이라고 함) 유한지도 나타냅니다 &lt;code&gt;k&lt;/code&gt; 형의 값으로 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 유형은 같은 의미 게으른 엄격한 모듈간에 공유되는 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 값이 두 모듈에서 함수에 전달 될 수 있습니다. 이는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; 모듈 과 동일 하므로 사용되는 경우 결과 맵에 일시 중단 된 값 (썽크)이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a0485ade9c643df5c2ea0bf0c47d55fb54166e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</target>
        </trans-unit>
        <trans-unit id="ff715be94759f4fe46e742d1184a2a615aa793fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 유형은 같은 의미 게으른 엄격한 모듈간에 공유되는 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 값이 두 모듈에서 함수에 전달 될 수 있습니다. 이는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스가 &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; 모듈 의 경우와 동일 하므로 사용되는 경우 결과 맵에 일시 중단 된 값 (thunks)이 포함될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 옵션 값을 캡슐화합니다. 유형의 값은 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 두 유형의 값을 포함 (로 표현 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 을 ), 또는 (로 표현 비어 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). 사용 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 등 과감한 조치에 의존하지 않고 오류 또는 예외적 인 경우를 처리 할 수있는 좋은 방법입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 모나드이다. 모든 오류가 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 으로 표시되는 간단한 종류의 오류 모나드 입니다. 보다 풍부한 에러 모나드는 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 타입을 사용하여 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 의 기능의 목록이 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 들과 모든 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; 의 기능은 밖으로 요소를 추출 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 그 인수 인 경우 오류가 발생합니다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e0e0ae5827a91039e8b0c00412d73abae7c014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 의 기능은 기본 값과 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. (가) 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 그것은 기본 값을 반환 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 에 포함 된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 의 기능은 기본 값 및 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. (가) 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 그것은 기본 값을 반환 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 에 포함 된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; 의 기능은 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인수의 형식입니다 IFF에 &lt;code&gt;Just _&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; 의 함수가 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 인수 IFF는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; 의 함수를 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 빈리스트 나에 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 리스트의 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 의 기능은 버전입니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 요소를 던질 수 있습니다. 특히, 함수 인수는 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt; 유형을 리턴합니다 . 이것이 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이면 결과 목록에 요소가 추가되지 않습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt; 다음 &lt;code&gt;b&lt;/code&gt; 결과 목록에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 함수는 디폴트 값, 함수 및 소요 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. 는 IF &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값이없는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 함수는 기본 값을 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 내부의 값에 함수를 적용 하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 의 주어 졌을 때 함수는 빈 목록을 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어 졌을 때 또는 싱글 목록을 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; 모노 이드 중성 원소로서 '0'수치 또한 오퍼레이터에 의해 정의된다 :</target>
        </trans-unit>
        <trans-unit id="7f108b74d9d0f499180865c6097577550b780ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 유형은 편리하게 정렬 순서를 반대로 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 유형의 값 에는 a 유형 &lt;code&gt;a&lt;/code&gt; 값이 포함 됩니다 ( &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 로 표시됨).</target>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 유형은 편리하게 정렬 순서를 반대로 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 유형의 값 에는 a 유형 &lt;code&gt;a&lt;/code&gt; 값이 포함 됩니다 ( &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 로 표시 ). 경우 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 그 다음 따라서 당신에게 정상적인 정렬 순서의 반대를 줄 것이다 감싸 두 값을 비교와 관련된 인스턴스를. 이것은 &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 과 같이 일반화 된 목록 이해에서 정렬 할 때 특히 유용합니다. then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스는 완전히 정렬 된 데이터 유형에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대한 인스턴스 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 작은 번호 선택 항상 정의된다 : &amp;gt;&amp;gt;&amp;gt; 최소 1 &amp;lt;&amp;gt; 최소 2 &amp;lt;&amp;gt; 3 분 &amp;lt;&amp;gt; :: 최소 4 분 지능 최소 getMin = {1}</target>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; 형 타입의 값의 유한 시퀀스 나타낸다 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 형 타입의 소자의 세트 나타내는 &lt;code&gt;e&lt;/code&gt; . 대부분의 작업에서는 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스 여야합니다 . &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 요소에 엄격하다.</target>
        </trans-unit>
        <trans-unit id="1038dcfb90af9b5c0cfcdb7ab1311da4e5ed3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt; . Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</target>
        </trans-unit>
        <trans-unit id="c9efbd927cc3f3d70bf87d84d4a730da30c040e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 형 타입의 소자의 세트 나타내는 &lt;code&gt;e&lt;/code&gt; . 대부분의 작업에서는 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스 여야합니다 . &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 요소에 엄격하다.</target>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 하스켈 힙에 고정 된 주소가 보장되지 않습니다 배열을 사용하여 구현됩니다. 따라서 원시 코드와의 모든 통신은 데이터를 앞뒤로 복사하여 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 형식의 내부 표현은 플랫폼의 네이티브 엔디안을 사용하여 UTF-16입니다. 따라서 복사 된 데이터는 ICU와 같은 유사한 표현을 사용하는 기본 라이브러리와 함께 사용하기에 적합합니다. UTF-8 또는 UTF-32와 같은 다른 내부 표현을 사용하는 기본 라이브러리와 상호 운용하려면 &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; 모듈 의 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 엄격한 &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 각 요소에 함수를 적용 하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 와 함께 반환합니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 생성자는 이후 노출 된 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 의 생성자는 이후 노출 된 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 기능은 수락 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; UTF-8 경계에서 종료하지 않을 수 불완전한 입력 (네트워크 스트림 패킷 등)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="651e438c6d91bc7b186512f8dad01a122ee5eab0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 기능은 수락 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; UTF-8 경계에서 종료하지 않을 수 불완전한 입력 (네트워크 스트림 패킷 등)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 스트림을 취하고 술어를 만족하는 스트림의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; 의 함수 술어 및 스트림을 취하고 술어를 만족하는 스트림의 첫 번째 요소의 인덱스를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 코드 포인트 의 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="translated">주어진 코드 포인트 의 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 기능이 타입의 함수 소요 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 를 인수로서. 표준 입력 장치의 전체 입력이 인수로이 함수에 전달되고 결과 문자열이 표준 출력 장치에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 함수는 파일을 읽고 문자열로 파일의 내용을 반환합니다. &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 와 같이 전체 파일을 엄격하게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 기능이 얻어 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 및 목록 돌려 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 결과 병합이 인수와 동일한 것을들 등을. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 엄격한 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 각 요소에 함수를 적용 하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 와 함께 반환합니다 . 유효하지 않은 스칼라 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 기능이 타입의 함수 소요 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 를 인수로서. 표준 입력 장치의 전체 입력이 인수로이 함수에 게으르게 전달되고 결과 문자열이 표준 출력 장치에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 및 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 이 함수는 구조의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누적 기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 구조체의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누산기의 최종 값을 새 구조와 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37d7ebaf143b71c90e000c5e485da2fe61a5ea4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; methods are useful when what you have is a container of applicative or, respectively, monadic actions, and you want to evaluate them left-to-right to obtain a container of the computed values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 당신이해야하는 것은 각각 실용적 또는 모나드 행동의 컨테이너 때 방법이 유용합니다, 당신은 그들을 왼쪽에서 오른쪽으로 계산 된 값의 용기를 얻기 위해 평가하고 싶다.</target>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; 유형의 숲 나타내는 &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 유형은 (또한으로 알려진 게으른 가능성이 무한, 멀티 웨이 트리 나타내는 &lt;em&gt;장미 나무&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 클래스는 유형 유형 표현을 연결하여 어느 정도 유형을 reifies. 이러한 형식 표현을 비교할 수 있으며 형식에 안전한 캐스트 작업을 정의 할 수 있습니다. 이를 위해 안전하지 않은 캐스트는 유형 (표현) 동등성 테스트에 의해 보호됩니다. &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; 모듈 은 동적 구현을 ​​위해 Typeable을 사용합니다. &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; 모듈 은 Typeable 및 Type-Safe 캐스트 (동적 제외)를 사용하여 &quot;보일러 플레이트 스크랩&quot;스타일의 일반 프로그래밍을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 기능은 결과적으로 두 번째 인수를 리턴하기 전에, 그 첫 번째 인수로 주어진 추적 메시지를 출력한다.</target>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 기능한다 &lt;em&gt;만&lt;/em&gt; , 또는 실행을 감시하는 디버깅에 사용된다. 이 함수는 참조 적으로 투명하지 않습니다.이 함수의 유형은 순수한 함수임을 나타내지 만 추적 메시지를 출력하는 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 함수는 출력 스트림에 메시지를 인쇄 할 수 있습니다. 이들은 &quot;printf 디버깅&quot;, 즉 실행 흐름을 추적하고 흥미로운 값을 인쇄하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; 의 추천 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 메시지가 이벤트 로그 프로파일을 사용할 수있는 경우, 이벤트 로그 출사 런타임시에 활성화되어 있다는 차이.</target>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 의 이벤트 로그 프로파일 링이 가능하며 런타임에 활성화 된 경우 함수는 이벤트 로그에 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 의 함수는 IO 모나드에서 추적 메시지를 출력한다. 이는 다른 IO 동작과 관련하여 출력을 시퀀싱합니다.</target>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; 의 이벤트 로그 프로파일 링이 가능하며 런타임에 활성화 된 경우 함수는 이벤트 로그에 마커를 방출한다. &lt;code&gt;String&lt;/code&gt; 마커의 이름입니다. 이 이름은 프로파일 링 도구에서 어떤 마커가 어떤 마커인지 명확하게 유지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 의 이벤트 로그 프로파일 링이 가능하며 런타임에 활성화 된 경우 함수는 이벤트 로그에 마커를 방출한다.</target>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 는 같은 방법으로 매개 변수화됩니다 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 type 인수 는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 유형 및 운영. 이 모듈은 FFI (Foreign Function Interface)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;외부&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 는 같은 방법으로 매개 변수화됩니다 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 type 인수 는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 유형 및 운영. 이 모듈은 FFI (Foreign Function Interface)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;외부&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 의 기능은 하나 개의 유형에서 다른 포인터를 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스는 정수 상에 형의 값의 연속 부분 범위를 매핑하는 데 사용됩니다. 주로 배열 인덱싱에 사용됩니다 (어레이 패키지 참조).</target>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; 의 사용 연관리스트에 반복 지수 함수와 상품 &lt;em&gt;축적 함수&lt;/em&gt; 인덱스와 같은 연관 값을 결합한다.</target>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 클래스는 통해 기본 동작을 정의 &lt;em&gt;모나드&lt;/em&gt; 로 알려진 수학의 지점에서, 개념을 &lt;em&gt;범주 이론&lt;/em&gt; . 그러나 Haskell 프로그래머의 관점에서 모나드는 &lt;em&gt;추상적 인 데이터&lt;/em&gt; 작업 &lt;em&gt;유형&lt;/em&gt; 으로 생각하는 것이 가장 좋습니다 . Haskell의 &lt;code&gt;do&lt;/code&gt; 표현식은 모나 딕 표현식을 작성하기위한 편리한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">은 &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 함수 종래 모나드 조인 연산자이다. 하나의 레벨의 모나 딕 구조를 제거하고 바인딩 된 인수를 외부 레벨로 투영하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 조치는 다른 현재 실행 가능한 스레드 (있는 경우)에의 (a 협동 멀티 태스킹 구현에 힘) 컨텍스트 스위치를 허용하고, 동시성 추상화를 구현할 때 가끔 유용하다.</target>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 조치는 다른 현재 실행 가능한 스레드 (있는 경우)에의 (a 협동 멀티 태스킹 구현에 힘) 컨텍스트 스위치를 허용하고, 동시성 추상화를 구현할 때 가끔 유용하다.</target>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스는 형의 상한과 하한의 이름을 지정하는 데 사용됩니다. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 는 완전히 정렬되지 않은 유형에도 상한과 하한이있을 수 있으므로 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 의 수퍼 클래스 가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스는 임의의 열거 형에 대해 유도 될 수있다; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;data&lt;/code&gt; 선언에 나열된 첫 번째 생성자 이며 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 는 마지막입니다. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 유형은 구성 유형이 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 인 단일 생성자 데이터 유형에 대해서도 파생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="5927fd518988da69d26cdf922ae3e2a15412bf75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 유형은 편리하게 정렬 순서를 반대로 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 유형의 값 에는 a 유형 &lt;code&gt;a&lt;/code&gt; 값이 포함 됩니다 ( &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 로 표시됨).</target>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 유형은 편리하게 정렬 순서를 반대로 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 유형의 값 에는 a 유형 &lt;code&gt;a&lt;/code&gt; 값이 포함 됩니다 ( &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 로 표시 ). 경우 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 그 다음 따라서 당신에게 정상적인 정렬 순서의 반대를 줄 것이다 감싸 두 값을 비교와 관련된 인스턴스를. 이것은 &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 과 같이 일반화 된 목록 이해에서 정렬 할 때 특히 유용합니다. then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; 의 클래스 및 메소드는 OverloadedLists 확장과 함께 사용되는 것으로 의도된다.</target>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; 유형 기능은 구조의 항목 유형 반환 &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 기능 구조 구조체 &lt;code&gt;l&lt;/code&gt; 주어진 목록으로부터 &lt;code&gt;Item l&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39677f8a87165f5afc7795359f53bb6627c8c811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length and potentially uses it to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given number does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 의 기능은 입력리스트의 길이를 취하고 잠재적 구조 구축을 사용하여 &lt;code&gt;l&lt;/code&gt; 비교하여보다 효율적 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; . 주어진 숫자가 입력 목록의 길이와 같지 않으면 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 의 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 의 함수 힌트로 입력리스트의 길이가 걸린다. 동작은 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 와 동일해야합니다 . 힌트는 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 와 비교하여 &lt;code&gt;l&lt;/code&gt; 구조를 보다 효율적 으로 구성하는 데 사용될 수 있습니다 . 주어진 힌트가 입력 목록의 길이와 같지 않으면 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 의 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; 의 기능이 투영 요소에 의해 형성 평등 그룹 먼저 정렬 입력리스트하기 위해 각리스트 요소로부터 돌출 된 요소와 사용자의 함수를 사용하여</target>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 기능을 제지 엄격 분석 좀. 호출 &lt;code&gt;lazy e&lt;/code&gt; 같은 의미 &lt;code&gt;e&lt;/code&gt; ,하지만 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 지금까지 엄격 분석에 관한 한 마법의 속성이 있습니다 : 그것의 의미는 엄격에도 불구하고, 첫 번째 인자에 게으른입니다. 엄격 성 분석이 실행 된 후 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 호출 은 ID 함수로 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; 기능 (또는하지 않을 수 있습니다) 특정 최적화를 가능하게 할 수있다 인수 한 번 가장 호출 할 것을 컴파일러에 힌트를 제공 할 수 있습니다. 연속 전달 스타일에서 코드 성능을 향상시키는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; 의 기능은 각 요소의 돌출 된 것을 사용자에게 제공되는 기능을 이용하여 요소의 목록을 정렬</target>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 의 기능의리스트 추출 &lt;code&gt;Item l&lt;/code&gt; 구조에서 &lt;code&gt;l&lt;/code&gt; . fromList를 만족시켜야합니다. toList = id.</target>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 는 같은 방법으로 매개 변수화됩니다 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 type 인수 는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; 호출은 밀폐 부분 데이터 타입의 제 1 및 제 2 생성자의 표현임을 나타내 &lt;code&gt;Tree&lt;/code&gt; 각각. 여기에서 생성자 이름, 고 정성 및 필드 이름 지정 여부에 관한 메타 정보가 유형 레벨로 인코딩됩니다. &lt;code&gt;'MetaCons&lt;/code&gt; 의 유형은 유형 클래스의 인스턴스 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt; . 이 형식 클래스는 값 수준에서 생성자에 대한 정보를 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; 태그는 동봉 된 부분은 데이터 형식의 표현을 나타냅니다 &lt;code&gt;Tree&lt;/code&gt; . 다시, 메타 정보는 타입 레벨에서 인코딩된다. &lt;code&gt;'MetaData&lt;/code&gt; 타입 클래스의 인스턴스 인 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt; 데이터 유형의 이름을 획득하기 위해 사용될 수있다,이 정의 된 모듈은 아래에있는 패키지 및이를 이용하여 정의되었는지 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 은을 상기 가치 수준.</target>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 의 클래스 가지 유형 이상의 범위로 일반화 될 수있다 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; 에 대한 어떠한 &lt;code&gt;k&lt;/code&gt; . 그렇게하려면 &lt;code&gt;PolyKinds&lt;/code&gt; 확장이 활성화 된 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 인스턴스를 파생시킵니다 . 예를 들어, 선언</target>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)&lt;/code&gt; 태그는 몇 가지를 나타냅니다. &lt;code&gt;'Nothing&lt;/code&gt; (이 있다면, 그것은 표시 한 것입니다 생성자의이 분야와 관련된 레코드 필드 선택기가 없음을 나타냅니다 &lt;code&gt;'Just &quot;recordName&quot;&lt;/code&gt; 대신). 다른 유형에는 필드의 엄격성에 대한 메타 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; 를 구성하는 데 사용됩니다 &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 들, 그리고 지정은 어떻게 불법 시퀀스를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="71ec4fbd1cac8b401802c535c7f65214143acd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 작업은로 반환하기 전에 주어진 핸들의 모든 입력을 읽고 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 핸들을 닫는.</target>
        </trans-unit>
        <trans-unit id="787de66be7bec193d5479d5569e0c178f340123a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 작업은로 반환하기 전에 주어진 핸들의 모든 입력을 읽고 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 핸들을 닫는.</target>
        </trans-unit>
        <trans-unit id="755de46cccecfaefa5e6388cdeaf72d6ecd06136" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 클래스는 정수 상에 형의 값의 연속 부분 범위를 매핑하는 데 사용됩니다. 주로 배열 인덱싱에 사용됩니다 (배열 패키지 참조).</target>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 함수는 숫자 유한 목록의 제품을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 함수는 숫자 한정된리스트의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 기능은 유사 트리플 돌아갑니다 세 가지 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5514609ab8e7a4d1ade5d1bc201f6e65aae2801a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 함수는 세 요소뿐만 아니라 세 개의리스트를 결합하여 기능의 목록과 유사한 대응 요소에 적용 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합이 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 기능은 세 가지 요소뿐만 아니라, 세 가지 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 옵션 값을 캡슐화합니다. 유형의 값은 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 두 유형의 값을 포함 (로 표현 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 을 ), 또는 (로 표현 비어 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). 사용 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 등 과감한 조치에 의존하지 않고 오류 또는 예외적 인 경우를 처리 할 수있는 좋은 방법입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 모나드이다. 모든 오류가 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 으로 표시되는 간단한 종류의 오류 모나드 입니다. 보다 풍부한 에러 모나드는 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 타입을 사용하여 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 클래스와 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 의 기능 목록 차 (비 결합)이다. 결과에서 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; , 각 요소의 첫 번째 발생 &lt;code&gt;ys&lt;/code&gt; 차례로 (있는 경우)에서 제거 된 &lt;code&gt;xs&lt;/code&gt; . 그러므로</target>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 함수 술어 두리스트를 취하고 제거 번째 목록의 각 요소의 최초 발생에 첫 번째 목록을 반환한다.</target>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 의 함수는 주어진 술어 모든 요소에 보유 된리스트의 최대 접미사 떨어진다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 의 함수 (동일한 의해 지정된리스트의 첫 번째 요소의 인덱스를 반환 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 질의 요소 또는 행) &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우를.</target>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 를 오름차순으로, 모든 요소의 인덱스는 쿼리 소자 동일 반환하여.</target>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 기능은 술어와 목록을 받아서 첫 번째 술어와 일치하는 목록의 요소 또는 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 의 함수는 술어와리스트를 취해 조건을 만족하는 목록의 첫 번째 요소의 인덱스를 반환하거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 그러한 요소가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 의 기능 확장 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 을 오름차순 술어를 만족하는 모든 원소의 인덱스를 반환하여.</target>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 드롭 소자의 수와 같은 값.</target>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; 모든 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 값을 인덱스로 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 반복 횟수를 확인하기 위해 값.</target>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 분할하는 위치로서 값.</target>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 의 함수의 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 임의 받아 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 취할 소자의 수와 같은 값.</target>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 기능 목록을 취하여 결과 병합이 인수 동일하도록리스트의 목록을 반환한다. 또한 결과의 각 하위 목록에는 동일한 요소 만 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 기능의 비 과부하 버전 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 는 짧은 첫째, 반환에게 인수의 모든 초기 세그먼트를 작동합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 기능은 두 목록의 목록 교차합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의 목록 및 반환 소요 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 어디서나 초 이내에 전적으로 그대로, 포함 된 첫 번째 목록 IFF를.</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 의 기능은 두 개의리스트를 받아 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 첫 번째 목록이 두 번째의 접미사입니다 IFF에. 두 번째 목록은 유한해야합니다.</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 이 함수는 목록의 각 요소에 함수를 적용하여 누적 매개 변수를 왼쪽에서 오른쪽으로 전달하고이 누산기의 최종 값을 새 목록과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 의 조합과 같은 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ; 이 함수는 목록의 각 요소에 함수를 적용하여 누적 매개 변수를 오른쪽에서 왼쪽으로 전달하고이 누적 기의 최종 값을 새 목록과 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; 의 기능 비교 기능과 목록을 받아 비교 기능으로 목록의 가장 큰 요소를 반환합니다. 목록은 유한하고 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; 의 기능 비교 기능리스트를 취하고, 비교 함수 목록의 적어도 한 요소를 반환한다. 목록은 유한하고 비어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 단지와 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; , 대신 과부하의 사용자 제공 동등 술어 사용 제외 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 기능 목록 술어 소요 할 각각 술어를 만족하지 않는 요소들의리스트의 한 쌍의 리턴; 즉,</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 반환에게 인수의 모든 순열의 목록을 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 함수는 숫자 유한 목록의 제품을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능 구현은 안정적인 알고리즘을 정렬. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 비교 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 반환에게 인수의 모든 서브 시퀀스의 목록을 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 함수는 숫자 한정된리스트의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 함수는 인수의 행 및 열을 바꿉니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 기능을 할 '는'듀얼입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; : 동안 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 은 요약 값 목록을 감소 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 시드 값의 목록을 작성합니다. 이 함수는 요소 반환지지 않습니다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 가 목록 또는 반환 생성 할 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ,이 경우, &lt;code&gt;a&lt;/code&gt; A가 목록에 앞에 추가이고 &lt;code&gt;b&lt;/code&gt; 는 재귀 호출의 다음 요소로 사용된다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 기능은 두 목록의 목록 조합을 반환합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 의 기능의 비 오버로드 된 버전입니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 기능은 유사 트리플 돌아갑니다 세 가지 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 기능이 유사한 4 배로 돌아갑니다 넷 개리스트의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 기능은 유사 다섯 튜플 반환 다섯 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 기능은 유사 여섯 튜플 반환 여섯 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 기능은 유사 일곱 튜플 반환 일곱 개 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 기능은 네 개의리스트를 취하고 유사한 4 배의 목록을 반환 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 기능은 다섯 명 목록을 받아 유사한 다섯 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 기능은 여섯리스트를 취하고 유사 여섯 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 기능은 일곱리스트를 취하고 유사 일곱 튜플의 목록을 반환 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe2dcade01df40ba8567bc29c6d76d5179227b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 함수는 세 요소뿐만 아니라 세 개의리스트를 결합하여 기능의 목록과 유사한 대응 요소에 적용 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합이 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 기능은 세 가지 요소뿐만 아니라, 세 가지 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 의 기능은 네 가지 요소뿐만 아니라, 네 개의 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 의 기능은 다섯 개 가지 요소뿐만 아니라 다섯 개 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 의 함수 여섯 개 요소뿐만 아니라 여섯리스트를 결합하고 유사한 자신의 포인트 - 방식의 조합의리스트를 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 의 기능은 일곱 개 요소뿐만 아니라 칠 개 목록 및 반환 유사 자신의 포인트 현명한 조합의 목록을 결합하는 기능을한다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 유형 및 운영.</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 의 기능은 하나 개의 유형에서 다른 포인터를 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 기본 데이터 유형에 대한 클래스와 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 함수는 초기 공백을 폐기하고, 어휘를 구성하는 문자를 반환 입력에서 하나의 어휘를 읽는다. 입력 문자열에 공백 만있는 경우 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 는 빈 문자열로 구성된 성공적인 단일 'lexeme'을 반환합니다. (따라서 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) 입력 문자열의 시작 부분에 유효한 어휘가 없으면 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 가 실패합니다 (예 : &lt;code&gt;[]&lt;/code&gt; 반환 ).</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 및 관련 작업.</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드.</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; 주어진 찾아 볼 수 있습니다 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7476e9e0f102360787454857433b298127a63a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; 클래스는 견적을 desugaring에 필요한 최소한의 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 의 기능을 사용하면 / O 계산의 I 실행할 수 있습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 의 모나드를. 주의 : 단일 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 계산 내 에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 호출 순서는 보장 되지만 스플 라이스 실행 순서는 보장 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">이 형식의 값 &lt;code&gt;q&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 형식 은 구문 &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; 구문 분석 할 문자열 ... |] . 실제로, 편의상, &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 는 실제로 여러 스플 라이스 컨텍스트에서 사용되도록 여러 개의 준 따옴표를 정의합니다. 당신은 단지 표현에 사용하는 quasiquoter을 정의에 관심이 있다면, 당신은 정의 할 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 를 에서만 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; 및 오류 함께 스텁 다른 필드를 둡니다.</target>
        </trans-unit>
        <trans-unit id="312071dde460138e1108547da6f4f1b6fb25ee33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; 클래스는 견적을 desugaring에 필요한 최소한의 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 의 기능을 사용하면 / O 계산의 I 실행할 수 있습니다 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 의 모나드를. 주의 : 단일 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 계산 내 에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 호출 순서는 보장 되지만 스플 라이스 실행 순서는 보장 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스는 형의 상한과 하한의 이름을 지정하는 데 사용됩니다. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 는 완전히 정렬되지 않은 유형에도 상한과 하한이있을 수 있으므로 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 의 수퍼 클래스 가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스는 임의의 열거 형에 대해 유도 될 수있다; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;data&lt;/code&gt; 선언에 나열된 첫 번째 생성자 이며 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 는 마지막입니다. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 유형은 구성 유형이 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 인 단일 생성자 데이터 유형에 대해서도 파생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형은 종종 하나 또는 정확한 오류라고하는 값을 나타내는 데 사용된다; 일반적으로 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자는 오류 값 을 보유하는 데 사용되고 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자는 올바른 값을 보유하는 데 사용됩니다 (니모닉 : &quot;right&quot;는 &quot;correct&quot;를 의미).</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 유형은 두 가지 가능성으로 값을 나타냄 타입의 값 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 하나 인 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 정의를 항등 ( &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ) 불평등 ( &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ). &lt;a href=&quot;prelude&quot;&gt;Prelude에서&lt;/a&gt; 내 보낸 모든 기본 데이터 유형 은 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며 , &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 는 구성 요소가 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 데이터 유형에 대해 파생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 옵션 값을 캡슐화합니다. 유형의 값은 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 두 유형의 값을 포함 (로 표현 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 을 ), 또는 (로 표현 비어 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ). 사용 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 등 과감한 조치에 의존하지 않고 오류 또는 예외적 인 경우를 처리 할 수있는 좋은 방법입니다 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 유형은 모나드이다. 모든 오류가 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 으로 표시되는 간단한 종류의 오류 모나드 입니다. 보다 풍부한 에러 모나드는 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 타입을 사용하여 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 클래스는 통해 기본 동작을 정의 &lt;em&gt;모나드&lt;/em&gt; 로 알려진 수학의 지점에서, 개념을 &lt;em&gt;범주 이론&lt;/em&gt; . 그러나 Haskell 프로그래머의 관점에서 모나드는 &lt;em&gt;추상적 인 데이터&lt;/em&gt; 작업 &lt;em&gt;유형&lt;/em&gt; 으로 생각하는 것이 가장 좋습니다 . Haskell의 &lt;code&gt;do&lt;/code&gt; 표현식은 모나 딕 표현식을 작성하기위한 편리한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용하면 실패 할 수있는 여러 작업을 함께 연결할 수 있으며 개별 단계 중 하나라도 실패하면 전체적으로 실패 할 수 있습니다. 먼저 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 구문 분석 하거나 실패 할 수있는 함수를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스는 완전히 정렬 된 데이터 유형에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 의 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값 을 무시 하지만 제공된 함수를 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 에 포함 된 값에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 의 방법은 유형에 제한 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 의 동작 (동일 그것을 필요로 느리게 판독 한 문자열, 모든 사용자 입력 반환 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15b8f72cef1878abf7fe3c9117a25867af1d77b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 의 동작 (동일 그것을 필요로 느리게 판독 한 문자열, 모든 사용자 입력 반환 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 기능은 유형의 기능을한다 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 인수한다. 표준 입력 장치의 전체 입력이 인수로이 함수에 전달되고 결과 문자열이 표준 출력 장치에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 함수는 초기 공백을 폐기하고, 어휘를 구성하는 문자를 반환 입력에서 하나의 어휘를 읽는다. 입력 문자열에 공백 만있는 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 는 빈 문자열로 구성된 성공적인 단일 'lexeme'을 반환합니다. (따라서 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) 입력 문자열의 시작 부분에 유효한 어휘가 없으면 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 가 실패합니다 (예 : &lt;code&gt;[]&lt;/code&gt; 반환 ).</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 함수는 디폴트 값, 함수 및 소요 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. 는 IF &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값이없는 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 함수는 기본 값을 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 내부의 값에 함수를 적용 하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능 은 인쇄 가능한 모든 유형의 값을 표준 출력 장치에 출력합니다. 인쇄 가능한 형식은 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 작업을 사용하여 값을 문자열로 변환 하여 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 곱을 계산한다.</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 기능을 완전히 입력 처리에 의해 소비해야하는 문자열의 입력을 판독한다. 구문 분석에 실패 하면 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 가 발생하여 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 가 실패 하므로 실제 응용 프로그램에서 사용하지 않는 것이 좋습니다. 안전한 대안을 위해 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 함수는 파일을 읽고 문자열로 파일의 내용을 반환합니다. &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 와 같이 필요할 때 파일을 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 기능과 유사한 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 해석에 실패 신호 것을 제외 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 가 프로그램을 종료하는 대신 모나드한다.</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 의 기능은 결합 &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 기능 구조의 수의 합을 계산한다.</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 의 방법은 유형에 제한 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 기능은 유사 트리플 돌아갑니다 세 가지 목록의 목록 소요 &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="164c0899882615aec29723262627c2283ba64928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 함수는 세 요소뿐만 아니라 세 개의리스트를 결합하여 기능의 목록과 유사한 대응 요소에 적용 반환하는 함수 얻어 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 를 . 목록 융합이 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 의 기능은 세 가지 요소뿐만 아니라, 세 가지 목록을 결합하고 유사 자신의 포인트 현명한 조합의 목록을 반환하는 함수 소요 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 을 . 목록 융합은 가능하지만 첫 번째 목록 인수와 결과 목록으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 입력 기능 (예를 들면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 이 기능이 적절한 유니 코드 문자열에 주어진 코드 페이지에서 멀티 바이트 문자열에서 변환을 제공되도록) 자동으로 유니 코드로 변환하지 않습니다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;getConsoleCP&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d9c12dfa8f43bbbd8a126756fa99035e9751842" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e61834da932da0adacdc02d3dfdbd2e02c1903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 입력 기능 (예를 들면 &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 이 기능이 적절한 유니 코드 문자열에 주어진 코드 페이지에서 멀티 바이트 문자열에서 변환을 제공되도록) 자동으로 유니 코드로 변환하지 않습니다. 콘솔의 코드 페이지를 가져 오려면 &lt;code&gt;getConsoleCP&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; 는 변압기가 사용자의 행 히스토리 상태로 직접, 낮은 수준의 액세스를 제공 모나드.</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; 의 방법은 &quot;리프트&quot;(예 : IO 작업 관리 기능에 우리를있게 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 랩은 모나드 조치를 임의하는 함수로).</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 의 모노 이드 모든 패딩 제어 시퀀스 출력을 얻어 추상화. 불행히도, 해당 데이터 유형은 pretty-printers와 같은 기존 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 기반 API 에 통합하기가 어렵습니다 . 따라서 해결 방법으로 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 을 사용하여 제어 시퀀스에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 액세스 할 수도 있습니다 . 한 가지주의 사항은 패딩 된 제어 시퀀스에 문자열로 액세스 할 수 없다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa804a6c1292fd02b3dfa80191cff02ea40114ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; -based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</target>
        </trans-unit>
        <trans-unit id="9841931aa367ad9ec0fec011cdda76359ac86c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 의 모노 이드 모든 패딩 제어 시퀀스 출력을 얻어 추상화. 안타깝게도이 데이터 유형은 pretty-printer와 같은 기존 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 기반 API 에 통합하기가 어렵습니다 . 따라서 해결 방법으로 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 을 사용하면 제어 시퀀스에 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 액세스 할 수도 있습니다 . 한 가지주의 할 점은 패딩 처리 된 컨트롤 시퀀스에 문자열로 액세스 할 수 없다는 것입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; 의 정수 구현을 기록 할 수있는 CPU 시간에서의 작은 차이 측정 및 피코 정수로서 주어진다.</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 유형은 특정 작업 파일 / 디렉토리에 대한 허용 여부를 기록하는 데 사용됩니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 는 각각 이러한 권한을 가져오고 설정합니다. 권한은 파일과 디렉토리 모두에 적용됩니다. 디렉토리의 경우 실행 가능 필드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이고 파일의 경우 검색 가능 필드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 입니다. 디렉토리를 경로의 일부로 사용할 권한이 부여되었지만 디렉토리 내용을 검사 할 수없는 경우 디렉토리를 읽을 수없이 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d69896f050cda9242fbd0b11650fb1d4798c283" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; . Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</target>
        </trans-unit>
        <trans-unit id="81b34c5c4fafcde21f795d5b394e5bb5a6d86701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 유형은 특정 작업 파일 / 디렉토리에 대한 허용 여부를 기록하는 데 사용됩니다. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 는 각각 이러한 권한을 가져오고 설정합니다. 권한은 파일과 디렉토리 모두에 적용됩니다. 디렉토리의 경우 실행 가능 필드는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이고 파일의 경우 검색 가능한 필드는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 입니다. 디렉토리를 경로의 일부로 사용할 수있는 권한이 부여 된 경우 디렉토리를 읽을 수없는 상태로 검색 할 수 있지만 디렉토리 내용을 검사 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 의 기능의 목록이 소요 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 들과 모든 목록을 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="6c024b37fca52e47d642918b547e5abf37fb3fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</target>
        </trans-unit>
        <trans-unit id="7508fdaba8c4fef16bb54aaa518032f06b07a40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 의 기능의 목록이 소요 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 들과 모든 목록을 반환 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 의 기능은 수신 핸들러 확립 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 보호 작용에서 발생 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 를 . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 예외 처리 기능 중 하나에 의해 설립 된 가장 최근의 핸들러에 의해 체포된다. 이 핸들러는 선택 사항이 아닙니다. 모든 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 포착됩니다. 원치 않는 예외를 다시 발생시켜 핸들러에 예외 전파를 명시 적으로 제공해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f3b229367a29bd9496f06fab85e58716c437cd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 의 기능은 기본 값과 소요 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. (가) 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 그것은 기본 값을 반환 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 에 포함 된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 의 기능은 기본 값 및 소요 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값입니다. (가) 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 그것은 기본 값을 반환 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 에 포함 된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9769cc1036b71fdb3662c8da0daae0ce7bf97a68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 의 주어 졌을 때 함수는 빈 목록을 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어 졌을 때 또는 싱글 목록을 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fbaf05deefa3d41622751d07a352a608fb45d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98dbef89b986d97360e7b13124294962d761670e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 의 주어 졌을 때 함수는 빈 목록을 반환 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 주어 졌을 때 또는 싱글 목록을 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 의 동작 (동일 그것을 필요로 느리게 판독 한 문자열, 모든 사용자 입력 반환 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9903da760704cfbe9ebaf26276c9f6d1fe29b948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is fully read before being returned (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; (작업은 동일 완전히 반환하기 전에 읽어 단일 문자열, 모든 사용자 입력 반환 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1624a7bf77b1533080ced7e88bbdc61480bcdf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 작업은로 반환하기 전에 주어진 핸들의 모든 입력을 읽고 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 핸들을 닫는.</target>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 기능은 유형의 기능을한다 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 인수한다. 표준 입력 장치의 전체 입력이 인수로이 함수에 전달되고 결과 문자열이 표준 출력 장치에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능 은 인쇄 가능한 모든 유형의 값을 표준 출력 장치에 출력합니다. 인쇄 가능한 형식은 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 작업을 사용하여 값을 문자열로 변환 하여 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 함수는 파일을 읽고 문자열로 파일의 내용을 반환합니다. &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 와 같이 필요할 때 파일을 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="a31c1b6bd7ac14eeefe46c3d60ed2cc1bc11f6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile-39-&quot;&gt;readFile'&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is fully read before being returned, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readFile-39-&quot;&gt;readFile'&lt;/a&gt;&lt;/code&gt; 기능은 파일을 읽고 문자열로 파일의 내용을 반환합니다. 파일은 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 반환되기 전에 완전히 읽혀 집니다.</target>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 기능과 유사한 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 해석에 실패 신호 것을 제외 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 가 프로그램을 종료하는 대신 모나드한다.</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 의 기능은 결합 &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 의 기능은 수신 핸들러 확립 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 보호 작용에서 발생 &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 를 . &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 예외 처리 기능 중 하나에 의해 설립 된 가장 최근의 핸들러에 의해 체포된다. 이 핸들러는 선택 사항이 아닙니다. 모든 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 포착됩니다. 원치 않는 예외를 다시 발생시켜 핸들러에 예외 전파를 명시 적으로 제공해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; 기능은 모든 이름 - 값 쌍의 환경을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 기능 삽입 또는 재설정 현재 환경 목록에서 환경 변수 이름입니다. 변수 &lt;code&gt;name&lt;/code&gt; 이 목록에 없으면 주어진 값으로 삽입됩니다. 변수가 존재하면 인수 &lt;code&gt;overwrite&lt;/code&gt; 가 테스트됩니다. 만약 &lt;code&gt;overwrite&lt;/code&gt; 인 &lt;code&gt;False&lt;/code&gt; 변수가 초기화되지 그렇지 않으면 소정의 값으로 리셋된다.</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 기능은 환경의 변수 이름의 모든 인스턴스를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 기능 삽입 또는 재설정 현재 환경 목록에서 환경 변수 이름입니다. 변수 &lt;code&gt;name&lt;/code&gt; 이 목록에 없으면 주어진 값으로 삽입됩니다. 변수가 존재하면 인수 &lt;code&gt;overwrite&lt;/code&gt; 가 테스트됩니다. 만약 &lt;code&gt;overwrite&lt;/code&gt; 인 &lt;code&gt;False&lt;/code&gt; 변수가 초기화되지 그렇지 않으면 소정의 값으로 리셋된다.</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 기능은 환경의 변수 이름의 모든 인스턴스를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 의 기능은 연결된 파일 디스크립터의 쌍을 생성한다. 첫 번째 구성 요소는 읽을 fd이고 두 번째 구성 요소는 쓰기 끝입니다. 파이프는 양방향 일 수 있지만이 동작은 이식성이 없으며 프로그래머는이 목적을 위해 두 개의 별도 파이프를 사용해야합니다. 이 설명이 잘못된 경우 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 의 기능은 연결된 파일 디스크립터의 쌍을 생성한다. 첫 번째 구성 요소는 읽을 fd이고 두 번째 구성 요소는 쓰기 끝입니다. 파이프는 양방향 일 수 있지만이 동작은 이식성이 없으며 프로그래머는이 목적을 위해 두 개의 별도 파이프를 사용해야합니다. 이 설명이 잘못된 경우 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; 의 클래스에 대한 변수 인수 마법 제공 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 을 . 구현은 의도적으로이 모듈에서 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 의 클래스에 대한 변수 인수 마법 제공 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . 구현은 의도적으로이 모듈에서 보이지 않습니다. 이 클래스의 인스턴스가 아닌 유형의 인수를 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 에 전달하려고 하면 컴파일러는이를 누락 된 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 인스턴스로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 함수는 초기 공백을 폐기하고, 어휘를 구성하는 문자를 반환 입력에서 하나의 어휘를 읽는다. 입력 문자열에 공백 만있는 경우 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 는 빈 문자열로 구성된 성공적인 단일 'lexeme'을 반환합니다. (따라서 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; .) 입력 문자열의 시작 부분에 유효한 어휘가 없으면 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 가 실패합니다 (예 : &lt;code&gt;[]&lt;/code&gt; 반환 ).</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 기능을 완전히 입력 처리에 의해 소비해야하는 문자열의 입력을 판독한다. 구문 분석에 실패 하면 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 가 발생하여 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 가 실패 하므로 실제 응용 프로그램에서 사용하지 않는 것이 좋습니다. 안전한 대안을 위해 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; 개의 인수를 제어 얼마나 많은 테스트 라운드는 결정하기 위해 수행 &lt;em&gt;가능성 프라임&lt;/em&gt; . 자세한 내용 &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;은`mpz_probab_prime_p ()`에 대한 GMP 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;BigNat&lt;/code&gt; 의 유형</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Bits&lt;/code&gt; 클래스는없는 &lt;code&gt;Num&lt;/code&gt; 슈퍼 클래스입니다. 따라서 &lt;code&gt;bit&lt;/code&gt; , &lt;code&gt;testBit&lt;/code&gt; 및 &lt;code&gt;popCount&lt;/code&gt; 메소드에 대한 기본 메소드가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; 의 유형과 표현</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">&lt;code&gt;CApiFFI&lt;/code&gt; 의 확장은의 호출 규칙 허용 &lt;code&gt;capi&lt;/code&gt; 외국 선언 예에 사용되는</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; pragma는 패턴의 특정 설정이 완료되었음을 패턴 일치 검사를 알리기 위해 사용되는 모든 지정된 패턴에 일치하는 모든 기능은 총입니다.</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">&lt;code&gt;CallStack&lt;/code&gt; 종류가 그것을 허용하는 경우에만 예를 들어, 지금까지의 연장됩니다</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Chan&lt;/code&gt; 종류</target>
        </trans-unit>
        <trans-unit id="d49e2d29e0d016b816ecb90ca81622c4424ea99a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Coercible&lt;/code&gt; machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of &lt;code&gt;A&lt;/code&gt; given above, users would additionally have access to a coercion between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;Coercible&lt;/code&gt; machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of &lt;code&gt;A&lt;/code&gt; given above, users would additionally have access to a coercion between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">&lt;code&gt;DOCTYPE&lt;/code&gt; 엄격한 XHTML 1.0.</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Dynamic&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">&lt;code&gt;ErrorT&lt;/code&gt; 모나드 구조는 두 가지 이상의 파라미터한다 :</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">&lt;code&gt;FOO.hp&lt;/code&gt; 의 당신이 프로그램의 힙 프로파일을 요청 때 생성 파일 &lt;code&gt;FOO&lt;/code&gt; 는 특히 간단한 구조의 텍스트 파일입니다. 다음은 실제 데이터가 많이 생략 된 대표적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="141ca8f382c40e251a5df604ac774ed0428d094e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FieldName&lt;/code&gt; is open-ended, but typically it should contain the producing package name, along with the actual field name. Then, the version number can either be attached to the serialised data for that field, or in cases where multiple versions of a field could exist in the same interface file, included in the field name.</source>
          <target state="translated">&lt;code&gt;FieldName&lt;/code&gt; 개방형이지만, 일반적으로는 실제 필드 이름과 함께 생산 패키지 이름을 포함해야합니다. 그런 다음 버전 번호를 해당 필드의 직렬화 된 데이터에 첨부하거나 필드 이름에 포함 된 동일한 인터페이스 파일에 여러 버전의 필드가 존재할 수있는 경우에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04db3a4ce85cd545b2791b532c1d65a006beea18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; class makes it possible to use idioms familiar from the List type with container structures that are better suited to the task at hand. This allows a user to substitute more appropriate &lt;code&gt;Foldable&lt;/code&gt; data types for Lists without requiring new idioms (see &lt;a href=&quot;#uselistsnot&quot;&gt;[1]&lt;/a&gt; for when not to use lists).</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 클래스는 가능한 더 손에 작업에 적합한 컨테이너 구조와 목록 유형 익숙한 숙어를 사용 할 수 있습니다. 이를 통해 사용자는 새로운 관용구를 사용하지 않고도 목록에 대해 보다 적절한 &lt;code&gt;Foldable&lt;/code&gt; 데이터 유형 을 대체 할 수 있습니다 (목록을 사용하지 않는 경우 &lt;a href=&quot;#uselistsnot&quot;&gt;[1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="46bbc9453d0aa157f0a481b32f1e12742cfde543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; instance should be defined in a manner that avoids construction of an unnecesary copy of the container.</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 인스턴스는 용기의 unnecesary 복사본의 구성을 피하는 방식으로 정의한다.</target>
        </trans-unit>
        <trans-unit id="d3310324645be48c511e536603b07bcff55b712f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; method &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; and its flipped version &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; can be used to sequence IO actions over all the elements of a &lt;code&gt;Traversable&lt;/code&gt; container (just for their side-effects, ignoring any results) . One special case is a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; container that optionally holds a value. Given:</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 방법 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 과 대칭 버전 &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 는 (A)의 모든 요소의 시퀀스 IO 동작에 사용될 수있는 &lt;code&gt;Traversable&lt;/code&gt; 용기 (그들의 부작용에 대해, 결과가 무시). 하나의 특별한 경우는 선택적으로 값을 보유하는 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 컨테이너입니다. 주어진:</target>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">&lt;code&gt;Foo @k a = a&lt;/code&gt; 다음과 같은 식 표현 될 것이다 :</target>
        </trans-unit>
        <trans-unit id="4c4c7a176e62f2d3f87095896756c7aad5096548" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;../separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo_stub.h&lt;/code&gt; 의 파일을 사용하여 리디렉션 할 수 있습니다 &lt;code&gt;-stubdir&lt;/code&gt; 옵션을; &lt;a href=&quot;../separate_compilation#options-output&quot;&gt;컴파일 출력 리디렉션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo_stub.h&lt;/code&gt; 의 파일을 사용하여 리디렉션 할 수 있습니다 &lt;code&gt;-stubdir&lt;/code&gt; 옵션을; &lt;a href=&quot;separate_compilation#options-output&quot;&gt;컴파일 출력 리디렉션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 의 환경 변수가 설정 될 수있다 &lt;code&gt;:&lt;/code&gt; 단락 지어진 ( &lt;code&gt;;&lt;/code&gt; Windows에서 단락 지어진) 패키지 데이터베이스를 포함하는 파일의 목록입니다. GHC 및 ghc-pkg에서 사용하는이 패키지 데이터베이스 목록은 위에서 아래로 패키지 데이터베이스 스택을 지정합니다. 이 순서는 &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 의 이전 항목이 나중에 나오는 항목을 대체 하는 PATH 환경 변수 의 동작과 일치하도록 선택되었습니다 . 패키지 데이터베이스 스택 사용 방법에 대한 자세한 내용 은 &lt;a href=&quot;#package-databases&quot;&gt;패키지 데이터베이스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">&lt;code&gt;GenLanguageDef&lt;/code&gt; 의 유형은 모든 파라미터 화 기능이 포함 된 기록이다 &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token의&lt;/a&gt; 모듈을. &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; 모듈 에는 몇 가지 기본 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Generic1&lt;/code&gt; 의 클래스</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">&lt;code&gt;Generic&lt;/code&gt; 및 &lt;code&gt;Generic1&lt;/code&gt; 클래스는 사용자 정의 된 데이터 타입과의 합 생성물 그들의 내부 표현 중재 :</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">&lt;code&gt;HSfoo.o&lt;/code&gt; 의 파일이 자동으로 음모에 의해 만들어집니다; 비활성화 하려면 &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; 를 사용하십시오. 하나를 수동으로 빌드하기 위해 다음 GNU &lt;code&gt;ld&lt;/code&gt; 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">은 &lt;code&gt;INCLUDE&lt;/code&gt; FFI를 사용 C. 그것은 더 이상 GHC 필요로 컴파일하지 않을 때 포함 할 헤더 파일을 지정하기위한 필요하는 데 사용하지만, 다른 컴파일러와의 호환성을 허용 (무시)한다.</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; pragma는 또한 작동 &lt;code&gt;SPECIALISE&lt;/code&gt; : 당신이 함수로 표시하는 경우 &lt;code&gt;f&lt;/code&gt; 로 &lt;code&gt;INLINABLE&lt;/code&gt; 을 하고 이후에 수 &lt;code&gt;SPECIALISE&lt;/code&gt; (참조 다른 모듈에서 &lt;a href=&quot;#specialize-pragma&quot;&gt;구체화 프라그를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b36c40931e360e8d5c5cef07a830cd7b25a1fd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ImportQualifiedPost&lt;/code&gt; extension allows &lt;code&gt;qualified&lt;/code&gt; to appear in postpositive position : &lt;code&gt;import M qualified&lt;/code&gt;. With this extension enabled, one can write:</source>
          <target state="translated">The &lt;code&gt;ImportQualifiedPost&lt;/code&gt; extension allows &lt;code&gt;qualified&lt;/code&gt; to appear in postpositive position : &lt;code&gt;import M qualified&lt;/code&gt; . With this extension enabled, one can write:</target>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; 잘 해결할 수 있습니다 &lt;code&gt;b&lt;/code&gt; 그 서명을 거부해서는 안, 전화 사이트에서. 또한 종속성이 숨겨져있을 수 있습니다. 치다</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;IsList&lt;/code&gt; 의 클래스 및 방법이 함께 사용되는 것으로 의도된다 &lt;code&gt;OverloadedLists&lt;/code&gt; 의 연장.</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; 클래스 및 운영</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">&lt;code&gt;checkTEQ&lt;/code&gt; 가 &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;t ~ u&lt;/code&gt; 를 생성 할 수 있으 려면 보유해야 하므로 &lt;code&gt;step2&lt;/code&gt; 의 &lt;code&gt;Just Refl&lt;/code&gt; 케이스에 액세스 할 수 없지만 &lt;code&gt;Foo1&lt;/code&gt; 및 &lt;code&gt;Foo2&lt;/code&gt; 를 전달 하므로 &lt;code&gt;t ~ Char&lt;/code&gt; 및 &lt;code&gt;u ~ Int&lt;/code&gt; 를 따릅니다. 따라서 &lt;code&gt;t ~ u&lt;/code&gt; 는 유지할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">&lt;code&gt;LANGUAGE&lt;/code&gt; pragma는 언어 확장 휴대용 방법으로 사용할 수 있습니다. 물론 모든 확장 프로그램이 모든 컴파일러에서 지원되는 것은 아니지만 모든 Haskell 컴파일러 는 동일한 구문으로 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma를 지원합니다 . &lt;code&gt;LANGUAGE&lt;/code&gt; 프라그 대신 사용해야합니다 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 가능하면.</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">&lt;code&gt;MArray&lt;/code&gt; 의 클래스는 모두 위에 매개 변수화된다 및 &lt;code&gt;e&lt;/code&gt; (특정 요소 타입에 전문 인스턴스와 동일한 방법으로 정의 될 수 있도록 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; ), 또한 모나드의 종류 이상, &lt;code&gt;m&lt;/code&gt; 은 ,되는 가변 배열 것 조작. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2c38f8bb84f00cd772ad558cf0397e189ff32c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;exts/pragmas#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; 프라그는 방법의 조합이 특정 클래스의 인스턴스에 대해 요구 될 것이다 변경하는데 사용될 수있다. &lt;a href=&quot;exts/pragmas#minimal-pragma&quot;&gt;MINIMAL pragma를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; 프라그는 방법의 조합이 특정 클래스의 인스턴스에 대해 요구 될 것이다 변경하는데 사용될 수있다. &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;최소 pragma를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; 프라그는 모든 인스턴스에 의해 구현되어야하는 방법을 지정 즉, 클래스의 최소한의 완전한 정의를 지정하는 데 사용됩니다. 인스턴스가 최소의 완전한 정의를 만족하지 않으면 경고가 생성됩니다. 클래스에 순환 기본값이있는 메소드가있는 경우 유용 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">&lt;code&gt;Maybe Dec&lt;/code&gt; 필드가 포함되어 &lt;code&gt;Just&lt;/code&gt; 선언의 RHS 포함 - - 그렇지 않으면 변수를 정의 선언 &lt;code&gt;Nothing&lt;/code&gt; 의 RHS는 컴파일러를 사용할 수없는 경우입니다. 현재이 값은 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;Nothing&lt;/code&gt; 입니다 . RHS 반품은 아직 관심이 없어 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">&lt;code&gt;Maybe String&lt;/code&gt; 인수는 선택 사양 시간 사양을 제공 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1242be218ada359701dd67c2a646eb32b9e883ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MkG&lt;/code&gt; GADT constructor has two records, &lt;code&gt;unG1&lt;/code&gt; and &lt;code&gt;unG2&lt;/code&gt;. However, only &lt;code&gt;unG1&lt;/code&gt; can be used as a top-level field selector. &lt;code&gt;unG2&lt;/code&gt; cannot because it is a &amp;ldquo;hidden&amp;rdquo; selector (see &lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;); its type mentions a free variable &lt;code&gt;n&lt;/code&gt; that does not appear in the result type &lt;code&gt;G a (Maybe x)&lt;/code&gt;. On the other hand, the only free type variables in the type of &lt;code&gt;unG1&lt;/code&gt; are &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, so &lt;code&gt;unG1&lt;/code&gt; is fine to use as a top-level function.</source>
          <target state="translated">&lt;code&gt;MkG&lt;/code&gt; GADT 생성자는 두 개의 레코드,이 &lt;code&gt;unG1&lt;/code&gt; 및 &lt;code&gt;unG2&lt;/code&gt; 을 . 그러나 &lt;code&gt;unG1&lt;/code&gt; 만 최상위 필드 선택기로 사용할 수 있습니다. &lt;code&gt;unG2&lt;/code&gt; 는 &quot;숨겨진&quot;선택자이기 때문에 할 수 없습니다 ( &lt;a href=&quot;existential_quantification#existential-records&quot;&gt;레코드 생성자&lt;/a&gt; 참조 ). 그 유형 은 결과 유형 &lt;code&gt;G a (Maybe x)&lt;/code&gt; 나타나지 않는 자유 변수 &lt;code&gt;n&lt;/code&gt; 을 언급합니다 . 반면에 &lt;code&gt;unG1&lt;/code&gt; 유형의 유일한 자유 유형 변수 는 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 이므로 &lt;code&gt;unG1&lt;/code&gt; 은 최상위 함수로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7cc66baaebfeab0512a0b98ea32973ef95be01d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModIface&lt;/code&gt; datatype also contains facilities for extending it with extra data, stored in a &lt;code&gt;Map&lt;/code&gt; of serialised fields, indexed by field names and using GHC&amp;rsquo;s internal &lt;code&gt;Binary&lt;/code&gt; class. The interface to work with these fields is:</source>
          <target state="translated">&lt;code&gt;ModIface&lt;/code&gt; 의 데이터 타입은 또한에 저장된 추가 데이터, 그것을 확장하기위한 시설을 포함 &lt;code&gt;Map&lt;/code&gt; 필드 이름 색인 직렬화 필드 및 GHC의 내부 사용하여 &lt;code&gt;Binary&lt;/code&gt; 클래스를. 이러한 필드를 사용하는 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">&lt;code&gt;ModSummary&lt;/code&gt; 는 컴파일 된 모듈에 대한 유용한 메타 정보가 포함되어 있습니다. &lt;code&gt;HsParsedModule&lt;/code&gt; 는 우리가 전에 언급 한 어휘 및 구문 정보가 포함되어 있습니다. 리턴 한 결과는 구문 분석 결과를 변경합니다. 결과를 변경하지 않으려면 인수로받은 &lt;code&gt;HsParsedModule&lt;/code&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="48e5172db92414aea034dae74f377abfc598950a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad m&lt;/code&gt; superclass is needed to stitch together the different AST fragments.</source>
          <target state="translated">&lt;code&gt;Monad m&lt;/code&gt; 수퍼 클래스가 다른 AST 단편을 함께 스티칭하는데 필요하다.</target>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Monad&lt;/code&gt; 클래스는이 &lt;code&gt;Applicative&lt;/code&gt; 슈퍼 클래스입니다. GHC 및 &lt;code&gt;Applicative&lt;/code&gt; 를 정의하지 않은 Haskell 2010 구현에 작동하는 &lt;code&gt;Monad&lt;/code&gt; 인스턴스를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;NOCLDSTOP&lt;/code&gt; 의 플래그</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">&lt;code&gt;NOINLINE&lt;/code&gt; 의 pragma는하지 인라인에 GHC를 알려줍니다 &lt;code&gt;foo&lt;/code&gt; 는 0 단계까지; 이 속성은 전문화 RULE에 의해 상속되므로 단계 0에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">&lt;code&gt;NOUNPACK&lt;/code&gt; 의 pragma는이 생성자 필드의 내용을 압축하지 않도록 컴파일러에 나타냅니다. 예:</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">&lt;code&gt;Natural&lt;/code&gt; 번호 유형</target>
        </trans-unit>
        <trans-unit id="8cad6ad0a7f69274a3358108b76be507fd692fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; case is a right fold of the left subtree whose initial value is a right fold of the rest of the tree.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 경우는 잘 초기의 값이 바로 나무의 나머지의 배입니다 왼쪽 서브 트리의 배입니다.</target>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">&lt;code&gt;Num&lt;/code&gt; 클래스가 없습니다 &lt;code&gt;Show&lt;/code&gt; 또는 &lt;code&gt;Eq&lt;/code&gt; 슈퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="47f8c2780da53550af283e3c4d79cd73d8a4eb47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;../using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; 의 프라그이 소스 파일을 컴파일 할 때 컴파일러에게 제공되는 추가 옵션을 지정하는 데 사용됩니다. 자세한 내용 &lt;a href=&quot;../using#source-file-options&quot;&gt;은 소스 파일의 명령 줄 옵션&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; 의 프라그이 소스 파일을 컴파일 할 때 컴파일러에게 제공되는 추가 옵션을 지정하는 데 사용됩니다. 참조 &lt;a href=&quot;using#source-file-options&quot;&gt;소스 파일에서 명령 행 옵션&lt;/a&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">&lt;code&gt;Plugin&lt;/code&gt; 타입 필드 갖는다 &lt;code&gt;tcPlugin&lt;/code&gt; 형 &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; 1, &lt;code&gt;TcPlugin&lt;/code&gt; 의 종류가 따라서 정의된다 :</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">&lt;code&gt;PluginRecompile&lt;/code&gt; 의 데이터 유형은 플러그인을 재 컴파일에 영향을 미치는 방법을 결정하는 열거 형입니다.</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">&lt;code&gt;Pointer&lt;/code&gt; 태그가 그것의 말할 때 필드가 사용되지 않는 &lt;code&gt;Nothing&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;Pointer&lt;/code&gt; 는 &lt;code&gt;Just&lt;/code&gt; 의 값을 가리 킵니다 . 위에서 언급 했듯이이 유형은 들판에서 게으 릅니다. 따라서 유형</target>
        </trans-unit>
        <trans-unit id="6e89ab13d6b3312a22f1cb7af0a4c7b83065d7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Q&lt;/code&gt; monad is a monad defined in &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; which supports several useful operations during code generation such as reporting errors or looking up identifiers in the environment.</source>
          <target state="translated">&lt;code&gt;Q&lt;/code&gt; 의 모나드에 정의 된 모나드이다 &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 이러한 오류를보고하거나 환경에서 식별자를 찾는 등의 코드를 생성하는 동안 몇 가지 유용한 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="06c6b11868285014da3646f38b0333396538986f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Quote&lt;/code&gt; type class (&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax#t:Quote&quot;&gt;Language.Haskell.TH.Syntax.Quote&lt;/a&gt;) is the minimal interface necessary to implement the desugaring of quotations. The &lt;code&gt;Q&lt;/code&gt; monad is an instance of &lt;code&gt;Quote&lt;/code&gt; but contains many more operations which are not needed for defining quotations.</source>
          <target state="translated">&lt;code&gt;Quote&lt;/code&gt; 유형 클래스 ( &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax#t:Quote&quot;&gt;Language.Haskell.TH.Syntax.Quote가&lt;/a&gt; ) 인용의 desugaring을 구현하는 데 필요한 최소한의 인터페이스입니다. &lt;code&gt;Q&lt;/code&gt; 의 모나드의 인스턴스 &lt;code&gt;Quote&lt;/code&gt; 하지만 인용문을 정의하는데 필요하지 않은 더 많은 동작들을 포함한다.</target>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="e93842ca545a852f968c15b8fc8e56550de74c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;exts/rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 클래스는 두 개의 별도의 방법이있다 &lt;code&gt;readPrec&lt;/code&gt; 및 &lt;code&gt;readListPrec&lt;/code&gt; 그들이에 의존하기 때문에 하스켈 2010 년에 발견되지 않는, &lt;code&gt;ReadPrec&lt;/code&gt; 필요 데이터 유형, &lt;a href=&quot;exts/rank_polymorphism#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 확장. GHC는 파생 &lt;code&gt;Read&lt;/code&gt; 구현하여 인스턴스를 &lt;code&gt;readPrec&lt;/code&gt; 대신 &lt;code&gt;readsPrec&lt;/code&gt; 을 , 그리고 기본 구현에 의존 &lt;code&gt;readsPrec&lt;/code&gt; 의 관점에서 정의된다 &lt;code&gt;readPrec&lt;/code&gt; . GHC는 &lt;code&gt;ReadPrec&lt;/code&gt; 이 &lt;code&gt;ReadS&lt;/code&gt; ( &lt;code&gt;readsPrec&lt;/code&gt; 의 기반이 되는 유형) 보다 더 효율적 이기 때문에이 두 가지 추가 메서드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 클래스는 두 개의 별도의 방법이있다 &lt;code&gt;readPrec&lt;/code&gt; 및 &lt;code&gt;readListPrec&lt;/code&gt; 그들이에 의존하기 때문에 하스켈 2010 년에 발견되지 않는, &lt;code&gt;ReadPrec&lt;/code&gt; 필요 데이터 유형, &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; 의&lt;/a&gt; 확장. GHC는 파생 &lt;code&gt;Read&lt;/code&gt; 구현하여 인스턴스를 &lt;code&gt;readPrec&lt;/code&gt; 대신 &lt;code&gt;readsPrec&lt;/code&gt; 을 , 그리고 기본 구현에 의존 &lt;code&gt;readsPrec&lt;/code&gt; 의 관점에서 정의된다 &lt;code&gt;readPrec&lt;/code&gt; . GHC는 &lt;code&gt;ReadPrec&lt;/code&gt; 이 &lt;code&gt;ReadS&lt;/code&gt; ( &lt;code&gt;readsPrec&lt;/code&gt; 의 기반이 되는 유형 )보다 효율적 이기 때문에이 두 가지 추가 방법을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1bac9e36b9c420f9455517fb66bd240e808467c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt; , that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt; , and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt; . GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</target>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ReadP&lt;/code&gt; 의 유형</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; 모나드 (또한 환경 모나드라고합니다). 공유 환경에서 값을 읽고 함수에서 값을 전달하며 수정 된 환경에서 하위 계산을 실행할 수있는 계산을 나타냅니다. 사용 &lt;code&gt;Reader&lt;/code&gt; 와 같은 계산에 모나드은 사용하는 것보다 종종 명확하고 쉽게 &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; 모나드를.</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">&lt;code&gt;R{..}&lt;/code&gt; 로 확장 &lt;code&gt;R{a=a}&lt;/code&gt; , 생략 &lt;code&gt;b&lt;/code&gt; 기록 필드 이후하는 범위되지 않고, 생략 &lt;code&gt;c&lt;/code&gt; 가변의 이후 &lt;code&gt;c&lt;/code&gt; 상기 레코드 선택기의 결합으로부터 이격 (범위에없는 &lt;code&gt;c&lt;/code&gt; 물론 ).</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">&lt;code&gt;SPARKS&lt;/code&gt; 통계의 사용을 의미 &lt;code&gt;Control.Parallel.par&lt;/code&gt; 프로그램 및 관련 기능을 제공합니다. 각 스파크는 &lt;code&gt;par&lt;/code&gt; 호출을 나타냅니다 . 스파크는 병렬로 실행될 때 &quot;변환&quot;됩니다. 스파크는 이미 평가 된 것으로 확인되면 가비지 수집기에 의해 풀에서 제거됩니다. 실행 종료시 남아있는 스파크는 모두 버려 지므로 &quot;변환 된&quot;+ &quot;제거 된&quot;이 반드시 총계에 합산되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; 모나드</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; 의 모나드</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">&lt;code&gt;Semigroup&lt;/code&gt; 연산자 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 에있을 것이다 &lt;code&gt;Prelude&lt;/code&gt; 등 오퍼레이터의 지정 지역 정의와 충돌하는,</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; 의 유형</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; 의 유형과 표현</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SomeException&lt;/code&gt; 의 유형은 예외 유형 계층 구조의 루트입니다. &lt;code&gt;e&lt;/code&gt; 유형의 예외 가 발생하면 뒤에서 &lt;code&gt;SomeException&lt;/code&gt; 에 캡슐화됩니다 .</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">&lt;code&gt;StablePtr&lt;/code&gt; 을 하여 해제 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; . 이는 &lt;code&gt;StablePtr&lt;/code&gt; 을 안정적 으로 해제하기가 ​​어려울 수 있기 때문입니다. haskell 에서 해제 할 수 없습니다. &lt;code&gt;takeMVar&lt;/code&gt; 가 비동기 예외에 의해 중단되면 나중에 콜백이 발생하기 때문입니다. 우리가 모르기 때문에 우리는 그것을 무료로 할 때, C에서 그것을 해제 할 수 없습니다 (하지 않을 경우 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 반환, 즉 사용하는 비동기 호출하기 때문에 &lt;code&gt;StablePtr&lt;/code&gt; 을 미래의 어떤 시간에).</target>
        </trans-unit>
        <trans-unit id="93f61b2e2afac0b4f71ea13ddcca5d653fa2b424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StateT s m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; delegates to the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt;. The &lt;code&gt;acquire&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, and &lt;code&gt;release&lt;/code&gt; arguments given to &lt;code&gt;StateT&lt;/code&gt;'s implementation produce actions of type &lt;code&gt;StateT s m a&lt;/code&gt;, &lt;code&gt;StateT s m b&lt;/code&gt;, and &lt;code&gt;StateT s m c&lt;/code&gt;. In order to run those actions in the base monad, we need to call &lt;code&gt;runStateT&lt;/code&gt;, from which we obtain actions of type &lt;code&gt;m (a, s)&lt;/code&gt;, &lt;code&gt;m (b, s)&lt;/code&gt;, and &lt;code&gt;m (c, s)&lt;/code&gt;. Since each action produces the next state, it is important to feed the state produced by the previous action to the next action.</source>
          <target state="translated">&lt;code&gt;StateT s m&lt;/code&gt; 구현 &lt;code&gt;generalBracket&lt;/code&gt; 을 받는 위임 &lt;code&gt;m&lt;/code&gt; 의 구현 &lt;code&gt;generalBracket&lt;/code&gt; . &lt;code&gt;acquire&lt;/code&gt; , &lt;code&gt;use&lt;/code&gt; 및 &lt;code&gt;release&lt;/code&gt; 에 지정된 인수 &lt;code&gt;StateT&lt;/code&gt; 의 유형의 구현 생산 작업 &lt;code&gt;StateT s m a&lt;/code&gt; , &lt;code&gt;StateT s m b&lt;/code&gt; 및 &lt;code&gt;StateT s m c&lt;/code&gt; . 기본 모나드에서 이러한 작업을 실행하려면 &lt;code&gt;runStateT&lt;/code&gt; 를 호출해야합니다. 여기서 &lt;code&gt;m (a, s)&lt;/code&gt; , &lt;code&gt;m (b, s)&lt;/code&gt; 및 &lt;code&gt;m (c, s)&lt;/code&gt; 유형의 작업을 가져 옵니다 .. 각 작업은 다음 상태를 생성하므로 이전 작업에서 생성 된 상태를 다음 작업에 공급하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 및 관련 작업.</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tree&lt;/code&gt; 데이터 타입은 두 개의 생성자가 있습니다. 개별 생성자의 표현은 이진 형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 를 사용하여 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 필드는 변수의 기초가되는 유형이 포함되어 있습니다. 현재 이것은 항상 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; 이지만 향후 변경으로이를 구체화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 필드는 변수의 기초가되는 유형이 포함되어 있습니다. 현재 이것은 항상 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; 이지만 향후 변경으로이를 구체화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">&lt;code&gt;UNPACK&lt;/code&gt; 이 간접 수준을 제거, 생성자 자체에 생성자 필드의 내용을 압축 해제해야한다는 컴파일러 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; pragma는 특정 함수, 클래스, 또는 유형에 임의의 경고를 부착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">&lt;code&gt;[2]&lt;/code&gt; 규칙 2 단계 및 후속 단계에서 활성화되는 것을 의미한다. 역 표기법 &lt;code&gt;[~2]&lt;/code&gt; 도 허용됩니다. 즉, 규칙이 2 단계까지는 유효하지만 규칙은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 패키지는 모두 순수를 제공하는 주목할만한, 그리고 고성능 직렬화이다.</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">&lt;code&gt;buildExpressionParser&lt;/code&gt; 는 표현 파서 구축에 관련된 모든 복잡성을 담당한다. 다음은 접두사 부호, 접미사 증가 및 기본 산술을 처리하는 표현식 파서의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">&lt;code&gt;cr&lt;/code&gt; 현재 행의 처음 열을 커서 이동 기능.</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">&lt;code&gt;deriving( Sizable )&lt;/code&gt; 말과 동일합니다</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 기능은 버퍼의 변환 소자 &lt;code&gt;from&lt;/code&gt; 상기 버퍼에 &lt;code&gt;to&lt;/code&gt; . 가능한 한 많은 요소 중 하나에 충분한 공간이없는 경우 제로 요소를 번역 포함, 버퍼의 크기를 주어진 그것은 번역해야 &lt;code&gt;to&lt;/code&gt; , 또는 &lt;code&gt;from&lt;/code&gt; 완전한 멀티 바이트 시퀀스가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">&lt;code&gt;enumFrom&lt;/code&gt; ... 방법은 산술 시퀀스의 하스켈의 번역에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">Prelude 의 &lt;code&gt;error&lt;/code&gt; 기능은 일반적인 오류 메시지 외에 오류가 발생한 호출 스택 인쇄를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">는 &lt;code&gt;evaluate&lt;/code&gt; 기능을</target>
        </trans-unit>
        <trans-unit id="2fbc5531096df720b55b588e7e44b2f7fb05c108" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forall&lt;/code&gt;-or-nothing rule takes effect in the following places:</source>
          <target state="translated">&lt;code&gt;forall&lt;/code&gt; - 또는 - 아무것도 규칙은 다음과 같은 장소에 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fromInteger&lt;/code&gt; (따라서 또한 &lt;code&gt;fromIntegral&lt;/code&gt; 는 로 변환시) 특별한 경우 &lt;code&gt;Int&lt;/code&gt; . 값 &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; 하부 ⟨n⟩ 비트 취하여 주어진다 &lt;code&gt;(abs x)&lt;/code&gt; 의 부호로 승산, &lt;code&gt;x&lt;/code&gt; (2의 보수 ⟨n⟩ 비트 산술). 이 동작은 예를 들어 &lt;code&gt;0xffffffff :: Int&lt;/code&gt; 작성 이 결과 &lt;code&gt;Int&lt;/code&gt; 의 비트 패턴을 유지 하도록 선택되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">&lt;code&gt;fromIntegral&lt;/code&gt; 정립 정수형 (사이에서 변환 할 때 함수는 비트 패턴을 유지 &lt;code&gt;Int8&lt;/code&gt; , &lt;code&gt;Int16&lt;/code&gt; , &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int64&lt;/code&gt; 상기 부호 &lt;code&gt;Word&lt;/code&gt; 변종), 모듈 참조 &lt;code&gt;Data.Int&lt;/code&gt; 및 &lt;code&gt;Data.Word&lt;/code&gt; 를 라이브러리 문서.</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;ghc-pkg&lt;/code&gt; 프로그램은 아래의 방법으로 실행할 수 있습니다. 패키지 이름이 필요한 경우 버전 번호 (예 : &lt;code&gt;network-1.0&lt;/code&gt; )를 포함하거나 버전 번호없이 패키지 이름을 지정할 수 있습니다 . 버전 번호가없는 패키지 이름 지정은 모든 버전의 패키지와 일치합니다. 지정된 작업은 일치하는 모든 패키지에 적용됩니다. 모든 버전의 패키지와 일치하는 패키지 지정자를 &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; 로 쓸 수도 있으므로 여러 패키지가 일치하는지 명확하게 알 수 있습니다. 패키지 이름과 버전 대신 설치된 패키지 ID와 일치 시키려면 &lt;code&gt;--ipid&lt;/code&gt; 플래그를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; 따라서 패키지 사용자에게 노출하는 가장 GHC의 프론트 엔드의를, 그리고 그 활용에게 그것을 프로그램을 작성할 수 있습니다. 이 라이브러리는 실제로 GHC의 내부 프론트 엔드 컴파일 드라이버에서 사용하는 것과 동일한 라이브러리이므로 프로그래밍 방식으로 소스 코드를 컴파일하고 검사하는 도구를 작성할 수 있습니다. 이러한 기능은 IDE 또는 리팩토링 도구와 같은 것을 작성하는 데 유용합니다. 간단한 예로, 다음은 ghc 자체가 호출 될 때 기본적으로 수행하는 것과 유사하게 모듈을 컴파일하는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">&lt;code&gt;ghci.conf&lt;/code&gt; 의 파일은 즐겨 사용하는 옵션 (예를 켜기에 가장 유용합니다 &lt;code&gt;:set +s&lt;/code&gt; 및 정의 유용한 매크로).</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">&lt;code&gt;hi-boot&lt;/code&gt; 컴파일하여 생성 &lt;code&gt;hs-boot&lt;/code&gt; 파일은 다른 GHC 생성 된 인터페이스 파일과 같은 컴퓨터 생성 된 바이너리 포맷 (예이다 &lt;code&gt;B.hi&lt;/code&gt; ). &lt;code&gt;ghc --show-iface&lt;/code&gt; 로 내용을 표시 할 수 있습니다 . 인터페이스 파일의 디렉토리 인 &lt;code&gt;-ohidir&lt;/code&gt; 플래그 를 지정하면 &lt;code&gt;hi-boot&lt;/code&gt; 파일에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">&lt;code&gt;hsc2hs&lt;/code&gt; 의 명령은 C 코드에 하스켈 바인딩을 작성하는 과정의 일부를 자동화 할 수 있습니다. 특수 구조가 포함 된 거의 Haskell 소스를 읽고 일부 C 헤더에서 가져온 정보를 기반으로 이러한 구조가 처리 된 실제 Haskell 파일을 출력합니다. 추가 구성은 Haskell의 C 데이터 액세스를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">&lt;code&gt;i2d&lt;/code&gt; 의 기능은 실질적으로 하나 개의 머신 명령이다; 중간 &lt;code&gt;Rational&lt;/code&gt; 을 통한 기본 변환 은 비교에 의해 외설적으로 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;cost_centres&lt;/code&gt; 목록에 나열된 비용 센터 의 &lt;code&gt;id&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">&lt;code&gt;import A hiding( g )&lt;/code&gt; 모듈에서 &lt;code&gt;B&lt;/code&gt; 는 기술적 오류입니다 ( &lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;하스켈 보고서, 5.3.1&lt;/a&gt; ) 때문에 &lt;code&gt;A&lt;/code&gt; 는 하지 않습니다 수출 &lt;code&gt;g&lt;/code&gt; . 그러나 GHC는 이전 버전과의 호환성을 지원하기 위해 허용합니다. 예를 들어, 최신 버전의 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;g&lt;/code&gt; 를 내보내고 어느 경우 든 &lt;code&gt;B&lt;/code&gt; 가 작동하기 를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ee2a5c41770c7a1baf9d025dcbc42759f0fdd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">&lt;code&gt;import A hiding( g )&lt;/code&gt; 모듈에서 &lt;code&gt;B&lt;/code&gt; 는 기술적 오류입니다 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;하스켈 보고서, 5.3.1&lt;/a&gt; ) 때문에 &lt;code&gt;A&lt;/code&gt; 는 하지 않습니다 수출 &lt;code&gt;g&lt;/code&gt; . 그러나 GHC는 이전 버전과의 호환성을 지원하기 위해이를 허용합니다. 예를 들어, 새로운 버전의 &lt;code&gt;A&lt;/code&gt; 는 수출 할 수 &lt;code&gt;g&lt;/code&gt; 을 , 그리고 당신이 원하는 &lt;code&gt;B&lt;/code&gt; 를 두 경우 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 선언 ( &lt;a href=&quot;#ghci-import-decl&quot;&gt;수입과 범위에 어떤 제어&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; 키워드는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lazyIOExample&lt;/code&gt; 은 당신이 실패 할 높은 가능성을 가지고있는 소켓에서 읽을 필요가 있다면 확실히 모든 응용 프로그램에 적합하지 않은 디스크에서 파일을 읽을 수 게으른 I / O를 사용합니다. 이러한 요구를 해결하기 위해처럼 증분 입력 방법을 사용 &lt;code&gt;incrementalExample&lt;/code&gt; . Handle에서 점진적으로 읽는 방법에 대한 예제는 &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; 구현을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;mapException&lt;/code&gt; 의 기능</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mask_&lt;/code&gt; 는 전과 비동기 예외 방지하는 것입니다 &lt;code&gt;scheduleCallback&lt;/code&gt; 의 누출 것이다 전화, &lt;code&gt;StablePtr&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">&lt;code&gt;mdo&lt;/code&gt; 표기가 명시 적으로 배치하는 부담을 제거 &lt;code&gt;rec&lt;/code&gt; 코드에서 블록을. 명령문에 의해 바인드 된 변수가 이후 명령문에 대해서만 범위에 있는 일반 &lt;code&gt;do&lt;/code&gt; 표현식 과 달리, &lt;code&gt;mdo&lt;/code&gt; 표현식에 바인드 된 변수 는 표현식의 모든 명령문에 대한 범위에 있습니다. 그런 다음 컴파일러는 상호 재귀 적으로 의존하는 최소한의 명령문 세그먼트를 자동으로 식별하여 사용자가 &lt;code&gt;rec&lt;/code&gt; 한정자를 감싸는 것처럼 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; 매개 변수를 반드시 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">&lt;code&gt;nel&lt;/code&gt; 다음 행의 첫 번째 열에 커서를 이동 능력. 캐리지 리턴 다음에 줄 바꿈처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">&lt;code&gt;nubIntOn&lt;/code&gt; 의 기능처럼 동작 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 그렇지 원래 데이터 형식에 비교하지만 데이터 유형으로부터 사용자가 지정한 투영을 수행 제외. 예를 들어, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 는 너브 자로 사용될 수 있고, 통상적으로 고정 된 숫자 타입 효율적.</target>
        </trans-unit>
        <trans-unit id="238764eaf45a1a62c1753a2837a1022054e829ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</target>
        </trans-unit>
        <trans-unit id="0766c52e5da98e96b097f0b2e8a0cc9028ac4ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.15.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">&lt;code&gt;nubIntOn&lt;/code&gt; 의 기능처럼 동작 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 그렇지 원래 데이터 형식에 비교하지만 데이터 유형으로부터 사용자가 지정한 투영을 수행 제외. 예를 들어 &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.15.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하여 문자 및 일반적인 고정 숫자 유형을 효율적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">&lt;code&gt;nubOrdOn&lt;/code&gt; 의 기능처럼 동작 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; 그렇지 원래 데이터 형식에 비교하지만 데이터 유형으로부터 사용자가 지정한 투영을 수행 제외.</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. 대부분의 일반적인 변종 &lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지만, 예를 들면 위해 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 어떤에 사용될 수 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. 대부분의 일반적인 변종 &lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지만, 예를 들면 위해 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 어떤에 사용될 수 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. 대부분의 일반적인 변종 &lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지만, 예를 들면 위해 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 어떤에 사용될 수 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만, 예를 들어 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 는 모든 &lt;code&gt;f&lt;/code&gt; 에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. 대부분의 일반적인 변종 &lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 이 있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있지만, 예를 들면 위해 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 어떤에 사용될 수 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f7df8b96731582ad5998e199bcd7caa6862256" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef6fce0bb77b22860c0010c07608d5a890578fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd6ba4c2792acbb3c2aab713f7ac895331441da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="373d721989cc654150bbf0bfb255a4af1891905b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b92d866131bfc652b2f085c78ccedd7098e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; , but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c77efcf307eb6a39e1b4f69936ca978bcecf7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 및 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만 예를 들어 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 를 모든 &lt;code&gt;f&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09ce2ccedbe6bd5ac1d94120db777fbb8337511f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 및 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만 예를 들어 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 를 모든 &lt;code&gt;f&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d2e43e335cb4eb09e7735f3bdddf48bef57b356" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 및 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만 예를 들어 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 를 모든 &lt;code&gt;f&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52a6515b2ab89354c9fee21d1ff0883f508eeed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 및 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만 예를 들어 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 는 모든 &lt;code&gt;f&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c215bc0ca5c8d4414abd0c0e1f3423af0982dbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; 과 &lt;code&gt;only2&lt;/code&gt; 방법은 &lt;em&gt;지정된 맵의 키의 부분 집합 (비어)와지도를 반환해야합니다&lt;/em&gt; . 값은 임의로 수정할 수 있습니다. &lt;code&gt;only1&lt;/code&gt; 및 &lt;code&gt;only2&lt;/code&gt; 의 가장 일반적인 변형 은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 이지만 예를 들어 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 를 모든 &lt;code&gt;f&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; 명시 적으로 양방향 건설은 기록 구문을 사용할 수 없습니다. rhs &lt;em&gt;expr&lt;/em&gt; 은 다른 데이터 생성자를 구성 할 수 있기 때문에 여러 방정식으로 가드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">&lt;code&gt;qq&lt;/code&gt; quasiquoter는 정의를 참조 할 수있을 것이다 &lt;code&gt;f&lt;/code&gt; 선행 그룹에서 선언하지만 아닌 정의 &lt;code&gt;h&lt;/code&gt; 또는 &lt;code&gt;k&lt;/code&gt; 또는 후속 선언 그룹에서 어떤 정의.</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">&lt;code&gt;recover&lt;/code&gt; 기능은 무효 또는 표현할 수없는 서열의 존재 하에서 계속해서 디코딩하는 데 사용된다. 여기에는 &lt;code&gt;InvalidSequence&lt;/code&gt; 를 반환 하는 &lt;code&gt;encode&lt;/code&gt; 으로 감지 된 항목 과 입력 바이트 시퀀스가 ​​잘린 것으로 나타나는 항목이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 기능은 단순히에서 값을 전달하는 연속을 생성한다.</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">&lt;code&gt;runghc&lt;/code&gt; 명령 줄 외모와 같은 :</target>
        </trans-unit>
        <trans-unit id="cebfe6013064a220b5cba39faaac05a83ca046c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 유형은 외부에서 숨겨져; &lt;code&gt;_this&lt;/code&gt; , &lt;code&gt;_inc&lt;/code&gt; 또는 &lt;code&gt;_display&lt;/code&gt; 를 함수 로 적용하려고 하면 컴파일 타임 오류가 발생합니다. 즉, &lt;em&gt;GHC는 유형이 실존 적으로 정량화 된 변수를 언급하지 않는 필드에 대해서만 레코드 선택기 함수를 정의합니다&lt;/em&gt; . (이 예에서는 레코드 선택기가 정의되지 않을 필드에 밑줄을 사용했지만 이는 프로그래밍 스타일 일뿐입니다. GHC는이를 무시합니다.)</target>
        </trans-unit>
        <trans-unit id="51e3f0a426cb551b465e32dbdd47361e262cdb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sequenceA&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;sequenceA&lt;/code&gt; 및 &lt;code&gt;sequence&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">&lt;code&gt;shows&lt;/code&gt; 함수 출력 앞에 추가 함수 반환 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 기존에 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . 이를 통해 함수 구성을 사용하여 결과를 일정하게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">&lt;code&gt;shows&lt;/code&gt; 함수 출력 앞에 추가 함수 반환 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 기존에 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . 이를 통해 함수 구성을 사용하여 결과를 일정하게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">&lt;code&gt;sprint&lt;/code&gt; 함수는 출력 값의 끝에 느낌표를 추가한다. 다음 명령으로 GHCi 실행 :</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">&lt;code&gt;state hack&lt;/code&gt; 최적화도에 예외를 숨길 수 있습니다 평가 순서에서 비 명백한 변화가 발생할 수 있습니다 &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt; (참조, 예를 들어, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;# 7411를 실행&lt;/a&gt; ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;template-haskell&lt;/code&gt; 라이브러리를 제공 &lt;code&gt;Lift&lt;/code&gt; 많은 일반적인 데이터 형식 인스턴스를. 또한 &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 &lt;code&gt;Lift&lt;/code&gt; 인스턴스를 자동으로 파생 할 수 있습니다 . 자세한 정보는 &lt;a href=&quot;#deriving-lift&quot;&gt;리프트 인스턴스 파생&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc491cbafae8602aedcf7deb49e4b74f8a072567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;deriving_extra#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;deriving_extra#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;template-haskell&lt;/code&gt; 라이브러리를 제공 &lt;code&gt;Lift&lt;/code&gt; 많은 일반적인 데이터 형식 인스턴스를. 또한 &lt;a href=&quot;deriving_extra#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 &lt;code&gt;Lift&lt;/code&gt; 인스턴스를 자동으로 파생 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;deriving_extra#deriving-lift&quot;&gt;리프트 인스턴스 파생&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="979881d56bf63876025a9e6ac559a5d09f689295" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toList&lt;/code&gt; function below lazily transforms a &lt;code&gt;Foldable&lt;/code&gt; structure to a List. Note that this transformation may be lossy, e.g. for a keyed container (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &amp;hellip;) the output stream holds only the values, not the keys. Lossless transformations to/from lists of &lt;code&gt;(key,
 value)&lt;/code&gt; pairs are typically available in the modules for the specific container types.</source>
          <target state="translated">아래 의 &lt;code&gt;toList&lt;/code&gt; 함수는 &lt;code&gt;Foldable&lt;/code&gt; 구조를 List로 느리게 변환합니다 . 이 변환은 손실이있을 수 있습니다. 예를 들어 키가있는 컨테이너 ( &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;HashMap&lt;/code&gt; ,&amp;hellip;)의 경우 출력 스트림은 키가 아닌 값만 보유합니다. &lt;code&gt;(key, value)&lt;/code&gt; 쌍 목록에 대한 무손실 변환 은 일반적으로 특정 컨테이너 유형의 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cedaf35635e98aff14e2be2770e441c0a4ccd4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transformers&lt;/code&gt;-style monad transfomer</source>
          <target state="translated">&lt;code&gt;transformers&lt;/code&gt; 스타일 모나드 transfomer</target>
        </trans-unit>
        <trans-unit id="4db916f09ae9ad82e1c17b85b42a3e324b1b316a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;traverse&lt;/code&gt; and &lt;code&gt;mapM&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;traverse&lt;/code&gt; 및 &lt;code&gt;mapM&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 콤비 예를 들어 식별자와 예약어를 구별 할 수 있습니다. 예약어와 식별자는 모두 일련의 문자입니다. 식별자를 기대할 수있는 특정 예약어를 기대할 때마다 &lt;code&gt;try&lt;/code&gt; 조합기 를 사용해야합니다 . 우리가 작성한다고 가정 해보십시오</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">&lt;code&gt;type role&lt;/code&gt; (활성화 &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt; ) 선언 힘 매개 변수 &lt;code&gt;a&lt;/code&gt; 는 역할의 재현이 아닌 역할 팬텀에 있어야합니다. 그런 다음 GHC는 사용자 제공 역할을 확인하여 약속을 위반하지 않는지 확인합니다. 예를 들어 사용자가 &lt;code&gt;BadIdea&lt;/code&gt; 의 역할을 표현할 수 있다면 좋지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3ab97fc80353826963fc8f16937897a7d19ff2bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;rsquo;s role be representational.</source>
          <target state="translated">The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt; &amp;rsquo;s role be representational.</target>
        </trans-unit>
        <trans-unit id="bbd3777e534f72ef4343d8ae216222c351c56937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 문 용도 &lt;code&gt;(M.&amp;gt;&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4bd8ddd7070927041be90584a981f460d98709" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x &amp;lt;- u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;=)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x &amp;lt;- u&lt;/code&gt; 문 용도 &lt;code&gt;(M.&amp;gt;&amp;gt;=)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163ed70634e5daf67472449520f0d0d1c209a86f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 프라그 만에 사용되는 &lt;code&gt;import&lt;/code&gt; 모듈 루프를 깨고, 선언. &lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;상호 재귀 모듈을 컴파일하는 방법&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 프라그 만에 사용되는 &lt;code&gt;import&lt;/code&gt; 모듈 루프를 깨고, 선언. &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;상호 재귀적인 모듈을 컴파일하는 방법&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c4e367df2b1b94e86aa02176ef763523fb3307a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; annotation must be written in prefix form:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 주석은 접두사 형태로 작성해야합니다 :</target>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;글로벌 패키지 데이터베이스&lt;/em&gt; 예를 들어, 당신의 GHC 설치와 함께 제공, &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">&lt;em&gt;대화 형 옵션은&lt;/em&gt; GHCi 프롬프트에서 입력 한 표현과 명령을 평가할 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">&lt;em&gt;K&lt;/em&gt; 문자열의 나머지 다음에 일치하는 일,</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">&lt;em&gt;로드 옵션&lt;/em&gt; 모듈을로드 할 때 적용</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;사용자 패키지 데이터베이스를&lt;/em&gt; 각 사용자에게 개인. 유닉스 시스템에서는 &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; 이고 Windows에서는 &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; . &lt;code&gt;ghc-pkg&lt;/code&gt; 도구는이 파일이 위치 할 위치를 알고, 그것이 존재하지 않는 경우 (참조를 만듭니다 &lt;a href=&quot;#package-management&quot;&gt;패키지 관리합니다 (GHC-pkg 명령을)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4df33777d071258dc6c9c7cc4bf4b2806b728297" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; type could be further extended with instances of &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;, etc., and could then provide a fully-featured list type, optimised for reuse without space-leaks. If, however, all that's required is space-efficient, re-use friendly iteration, less is perhaps more, and just &lt;code&gt;Foldable&lt;/code&gt; may be sufficient.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; 의&lt;/strong&gt; 유형은 더의 인스턴스로 확장 될 수있다 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 등, 다음 공간 누출없이 재사용에 최적화 된 완벽한 기능을 갖춘 목록 유형을 제공 할 수있다. 그러나 필요한 모든 것이 공간 효율적이고 재사용하기 쉬운 반복이라면 적은 것이 더 &lt;code&gt;Foldable&lt;/code&gt; 만으로 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="941913194462867445681166d58a9caadf6e06c1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; list structure works as an efficient iterator when used just once. When space-leaks via list reuse are not a concern, and/or memoisation is actually desirable, the regular list implementation is likely to be faster. This is not a suggestion to replace all your uses of &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; with a generative alternative.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt; 단 한 번 사용할 때리스트 구조는 효율적인 반복자로 작동합니다. 목록 재사용을 통한 공간 누출이 문제가되지 않고 / 또는 메모가 실제로 바람직한 경우 일반 목록 구현이 더 빠를 수 있습니다. 이것은 &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt; 의 모든 사용을 생성 적 대안 으로 대체하라는 제안이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c7e1c7ee8fcc39fc1932af678408736014433965" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;unFR&lt;/code&gt;&lt;/strong&gt; field of this type is essentially its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; method with the list as its first rather than last argument. Thus we immediately get a &lt;code&gt;Foldable&lt;/code&gt; instance (and a &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function mapping an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; to a regular list).</source>
          <target state="translated">이 유형 의 &lt;strong&gt; &lt;code&gt;unFR&lt;/code&gt; &lt;/strong&gt; 필드는 본질적으로 목록이 마지막 인수가 아닌 첫 번째 인수 인 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 메서드입니다. 따라서 우리는 즉시 얻을 &lt;code&gt;Foldable&lt;/code&gt; 예 (그리고 &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 의 매핑 기능 &lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; 을&lt;/strong&gt; 일반 목록을).</target>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">&lt;strong&gt;GHC-PKG의&lt;/strong&gt; 도구는 쿼리 및 패키지 데이터베이스를 수정하기위한 것입니다. 사용중인 패키지 데이터베이스를 보려면 &lt;code&gt;ghc-pkg list&lt;/code&gt; 를 사용 하십시오 . &lt;strong&gt;ghc-pkg&lt;/strong&gt; 가 알고있는 데이터베이스 스택은 &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt; 환경 변수를 사용하여 수정할 수 있습니다 ( &lt;a href=&quot;#ghc-package-path&quot;&gt;GHC_PACKAGE_PATH 환경 변수&lt;/a&gt; 및 &lt;strong&gt;ghc-pkg&lt;/strong&gt; 명령 행 에서 &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; 옵션 사용) .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">&lt;strong&gt;GV&lt;/strong&gt; 와 &lt;strong&gt;고스트 뷰&lt;/strong&gt; 프로그램은 &quot;감시 파일&quot;옵션이 실행되는 프로그램의 최신 힙 프로파일을 보는 데 사용할 수 있습니다. 이전 섹션에서 설명한대로 증분 힙 프로파일을 생성하기 만하면됩니다. 프로필에서 &lt;strong&gt;gv&lt;/strong&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">ASCII 인코딩은 7 비트 인코딩입니다. 여기서 구현 된 &lt;em&gt;Char7&lt;/em&gt; 인코딩은 유니 코드 코드 포인트를 7 비트로 &lt;em&gt;자르고&lt;/em&gt; 앞에 0을 &lt;em&gt;붙이고&lt;/em&gt; 결과 8 비트를 단일 바이트로 인코딩하여 작동합니다. 코드 포인트 0-127의 경우 이는 ASCII 인코딩에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">Accum 모나드</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">AccumT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">모든 유형</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">이진 클래스</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">ResolvedBCO의 이진 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">빌더 모노 이드</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">빌더 유형</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">C 호출 &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; 은 Haskell 호출 &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">C 코드 생성기는 GHC가 등록되지 않은 모드로 구축 된 경우에만 지원됩니다.이 모드는 GHC 자체를 새로운 플랫폼으로 쉽게 포팅하기 위해 GHC가 출력으로 &quot;휴대용&quot;C 코드를 생성하는 모드입니다. 이 모드는 훨씬 느린 코드를 생성하므로 GHC 버전이 이런 방식으로 빌드되지 않았을 수 있습니다. 그렇다면 네이티브 코드 생성기를 사용할 수 없을 것입니다. &lt;code&gt;ghc --info&lt;/code&gt; 를 호출하여이 정보를 확인할 수 있습니다 ( &lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">사용할 C 컴파일러 (기본값 : &lt;code&gt;gcc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e1af0dbad65022684bd70994a6b169612ac3f0f8" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code if the &lt;code&gt;-cpp&lt;/code&gt; option or &lt;code&gt;-XCPP&lt;/code&gt; extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code if the &lt;code&gt;-cpp&lt;/code&gt; option or &lt;code&gt;-XCPP&lt;/code&gt; extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</target>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">C 전 처리기 &lt;strong&gt;cpp&lt;/strong&gt; 는 &lt;code&gt;-cpp&lt;/code&gt; 옵션 -cpp 옵션이 제공된 경우에만 Haskell 코드를 통해 실행됩니다 . 상당한 양의 조건부 컴파일을 사용하여 대규모 시스템을 구축하지 않는 한 실제로는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">C 프로그램은 Haskell 컴파일러를 사용하여 컴파일됩니다. 이는 C 프로그램에 자동으로 포함되는 &lt;code&gt;HsFFI.h&lt;/code&gt; 에 대한 포함 경로를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">C면 인터페이스</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">GC 자체에서 사용 된 CPU 시간</target>
        </trans-unit>
        <trans-unit id="9d849fe5e03e42e4cfc89679d13718f7c8ec55fb" translate="yes" xml:space="preserve">
          <source>The CPU time used during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">이동하지 않는 동시 GC의 포스트 마크 일시 중지 단계 동안 사용 된 CPU 시간입니다.</target>
        </trans-unit>
        <trans-unit id="6bd9ffd9c0904c0c2f55fc70386db0a7ddaf3815" translate="yes" xml:space="preserve">
          <source>The Chapter &lt;em&gt;does&lt;/em&gt; allow for implementations to move objects around during &lt;code&gt;unsafe&lt;/code&gt; calls as well. So strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">챕터 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;unsafe&lt;/code&gt; 호출 중에도 객체를 이동할 수있는 구현을 허용 합니다. 따라서 엄격하게 Haskell 2010을 준수하는 프로그램은 &lt;code&gt;unsafe&lt;/code&gt; FFI 호출에 힙 할당 참조를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 호출에 대해서도 동일한 작업을 수행하지 않도록 구현할 필요 가 &lt;em&gt;없으므로&lt;/em&gt; Haskell 2010 호환 프로그램은 힙 할당 참조를 &lt;code&gt;unsafe&lt;/code&gt; FFI 호출에 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Char 유형 및 관련 작업</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">바이트 문자열에 대한 Char8 인터페이스는 ByteString 유형에 대한 IsString 인스턴스를 제공하여 문자열 리터럴을 사용하고 암시 적으로 ByteStrings에 압축되도록 할 수 있습니다. 이를 활성화 하려면 &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">제약 종류</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">계속 모나드</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">ContT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">연속 모나드는 연속 통과 스타일 (CPS)로 계산을 나타냅니다. 연속 전달 스타일에서 함수 결과는 반환되지 않지만 대신 다른 함수로 전달되어 매개 변수로 수신됩니다 (계속). 계산은 중첩 된 연속 시퀀스로 구성되며 최종 결과 (종종 &lt;code&gt;id&lt;/code&gt; )로 종료되어 최종 결과를 생성합니다. 연속은 계산의 미래를 나타내는 함수이므로 연속 함수의 조작은 중간에 계산 중단, 계산의 일부 중단, 계산 재시작 및 인터리빙과 같은 계산 미래의 복잡한 조작을 달성 할 수 있습니다. 계산의 실행. 연속 모나드는 CPS를 모나드의 구조에 적응시킵니다.</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">적용 조건. 각 함수 종속성 들어 ⟨tvs⟩는 &lt;sub&gt;좌측 &lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;오른쪽&lt;/sub&gt; , 클래스, S (⟨tvs⟩ 모든 입력 변수 &lt;sub&gt;오른쪽&lt;/sub&gt; ) S (⟨tvs⟩ 나타나야 &lt;sub&gt;왼쪽&lt;/sub&gt; S는 각 유형의 매핑 치환이다) 클래스 선언의 변수를 인스턴스 헤드의 해당 유형으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Cygwin 도구는 Windows 라이브러리 위에 Unix 스타일 API를 제공하여 Unix 소프트웨어의 포트를 창으로 용이하게하는 것을 목표로합니다. 이를 위해 일부 루트 디렉토리 (일반적으로 &lt;code&gt;/&lt;/code&gt; 는 &lt;code&gt;C:\cygwin\&lt;/code&gt; ) 아래에 Unix 스타일 디렉토리 계층 구조를 도입합니다 . 또한 Cygwin API (Cygwin의 GHC로 컴파일 된 Cygwin 도구 및 프로그램 포함)를 기반으로 구축 된 모든 파일은 파일 시스템의 루트로 &lt;code&gt;/&lt;/code&gt; 를 보고 행복하게 유닉스 환경에서 작동하는 것처럼 가장하며 &lt;code&gt;/bin&lt;/code&gt; 및 &lt;code&gt;/usr/include&lt;/code&gt; 과 같은 것을 찾습니다. / include 는 Windows 시스템에서 실제 위치 (명확하게 &lt;code&gt;C:\cygwin\bin&lt;/code&gt; 및 &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; )를 명시 적으로 방해하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">생성자 응용 프로그램을 처리하기위한 Data 클래스</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">동적 인터페이스는 동적 유형에 대한 기본 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">두 가지 유형 및 관련 작업</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">오류 모나드 (예외 모나드라고도 함)</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">ErrorT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">모나드 제외</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">제외 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">예외 유형</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">이 섹션에서 설명하는 FFI 기능은 GHC에만 해당됩니다. 다른 컴파일러를 사용하면 코드를 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa5c3008de574108a3fc529118d05f0ae264146f" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI 라이브러리는 함께 제공되는 라이브러리 문서에 문서화되어 있습니다. 예를 들어 &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign&quot;&gt;외부&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI 라이브러리는 함께 제공되는 라이브러리 설명서에 설명되어 있습니다. 예를 들어 &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;외부&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ed7160bf5541192af12531389c2d242c62248cf" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</target>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">FFI 라이브러리는 FFI와 함께 사용하기 위해 메모리를 할당하는 여러 가지 방법을 제공하며 어떤 방법이 가장 좋은지 항상 명확하지는 않습니다. 이 결정은 특정 컴파일러 / 플랫폼에서 특정 종류의 할당이 얼마나 효율적인지에 따라 영향을받을 수 있으므로이 섹션은 GHC에서 다양한 종류의 할당이 어떻게 수행되는지에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">FFI 사양은 IO가 다양한 장소에 표시 모나드 필요하지만 때로는에 IO 모나드를 포장하는 것이 편리 할 수 있습니다 &lt;code&gt;newtype&lt;/code&gt; 은 따라서 :</target>
        </trans-unit>
        <trans-unit id="f1df7ad812566b24077279b5c70b3b3b84e28607" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;#13693&lt;/a&gt;.</source>
          <target state="translated">The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt; , but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;#13693&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">FFI 사양에서는 &lt;code&gt;hs_exit()&lt;/code&gt; 로 종료 한 후 다시 초기화를 자체적으로 지원하는 구현이 필요 하지만 GHC는 현재이를 지원하지 않습니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;문제 # 13693을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d82e5c0000a3a4523ec1f2606c3f0201a3a2af5" translate="yes" xml:space="preserve">
          <source>The Foldable class represents data structures that can be reduced to a summary value one element at a time. Strict left-associative folds are a good fit for space-efficient reduction, while lazy right-associative folds are a good fit for corecursive iteration, or for folds that short-circuit after processing an initial subsequence of the structure's elements.</source>
          <target state="translated">Foldable 클래스는 한 번에 한 요소 씩 요약 값으로 줄일 수있는 데이터 구조를 나타냅니다. Strict left-associative fold는 공간 효율적인 축소에 적합하며, lazy right-associative fold는 corecursive 반복이나 구조 요소의 초기 하위 시퀀스를 처리 한 후 단락되는 폴드에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c810fb3026eea84c07b1ddbb163add991beb6f3b" translate="yes" xml:space="preserve">
          <source>The GADT return type (&lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe x) -&amp;gt; ...&lt;/code&gt;).</source>
          <target state="translated">GADT 반환 유형 ( &lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe x) -&amp;gt; ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">GC의 동기화 시간은 다른 GC 통계와 함께 호출하여 사용할 &lt;code&gt;getRTSStats()&lt;/code&gt; C에서 함수 또는 &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; 하스켈에서를.</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC API는 이러한 파일을 읽고 쓰는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">GHC RTS는 현재 명시 적 메모리 한계 (RTS 플래그를 통해 설정 됨)를 감지하면 힙 오버 플로우에서만 복구 할 수 있습니다. 초과되었습니다. 현재 운영 체제에서 메모리를 할당하지 못하면 프로그램이 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">패키지를 제어하는 ​​GHC 명령 줄 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">GHC 개발자들이 여기에 있습니다. GHC API로 작업 중이거나 GHC 구현에 대해 궁금한 점이 있으면 언제든지 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">GHC 드라이버는 Haskell 소스 코드 ( &lt;code&gt;.hs&lt;/code&gt; 또는 &lt;code&gt;.lhs&lt;/code&gt; 파일)를 처리 할 때 여러 매크로를 미리 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">GHC 런타임은 독립형 실행 파일이 종료 될 때 차단 된 스레드를 기다릴 필요가 없도록 프로그램 종료를 특수한 경우로 취급합니다. 프로그램과 모든 스레드가 코드가 메모리에서 제거되는 동시에 종료되기 때문에 스레드가 먼저 종료되었는지 확인할 필요는 없습니다. 이 빠르고 느슨한 버전의 &lt;code&gt;hs_exit()&lt;/code&gt; 를 원하면 다음을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6aec65a614d7a8b43aacde5373b850e4763ef9" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; 명령은이 형식으로 패턴 유형을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; 명령은이 형식의 패턴 유형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">GHCi Monad 리프팅 인터페이스.</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">GHCi 디버거는 소스 코드를 수정하거나 재 컴파일하지 않고도 이러한 오류를 신속하게 파악할 수있는 방법을 제공합니다. 한 가지 방법은 예외를 발생시키는 소스 코드의 위치에 중단 점을 설정 한 다음 &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; 를 사용하여 컨텍스트를 설정하는 것입니다. 그러나 &lt;code&gt;head&lt;/code&gt; 는 라이브러리에 있으며 직접 중단 점을 설정할 수 없습니다. 이러한 이유로 GHCi는 &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt; 발생시 평가자가 중지되도록하는 -fbreak-on-exception 플래그 와 &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; 를 제공합니다.&lt;/a&gt;유사하게 작동하지만 포착되지 않은 예외에서만 중지됩니다. 예외에서 멈 추면 GHCi는 중단 점에 도달했을 때와 마찬가지로 작동하며 소스 코드 위치를 표시하지 않는 편차가 있습니다. 이로 인해 이러한 명령은 예외로 이어지는 단계를 기록하기 위해 &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; 와 함께 사용하면 정말 유용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">Get 및 Put 모나드</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">Get 모나드</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">내용을 읽거나 예외가 발생하면 핸들이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7aa13d6fda768933256ad6bc36a2d66a70dfef90" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that called functions also have to assume heap-allocated Haskell values may move around arbitrarily in order to allow for GC.</source>
          <target state="translated">Haskell 2010 보고서는 &lt;code&gt;safe&lt;/code&gt; FFI 호출이 외래 호출이 안전하게 Haskell 코드를 호출 할 수 있도록해야 한다고 지정합니다 . 실제로 이것은 호출 된 함수가 GC를 허용하기 위해 힙 할당 된 Haskell 값이 임의로 움직일 수 있다고 가정해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">Haskell 2010 보고서는 &lt;code&gt;safe&lt;/code&gt; FFI 통화를 통해 외래 통화가 Haskell 코드로 안전하게 전화를 걸 수 있도록 지정 해야합니다. 실제로 이것은 이러한 호출이 진행되는 동안 가비지 수집기가 실행될 수 있어야하며 힙 할당 된 Haskell 값을 임의로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">&lt;code&gt;Show&lt;/code&gt; 의 Haskell 2010 정의 는 렌더링 된 문자열에 결과를 명확하게 구문 분석하는 데 필요한 괄호 만 포함해야한다고 규정합니다. 역사적 이유로, GHC에서 파생 된 &lt;code&gt;Show&lt;/code&gt; 인스턴스는 레코드 구문이 함수 응용 프로그램보다 더 밀접하게 바인딩된다는 사실에도 불구하고 레코드 주위에 괄호를 포함합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 예외에 대한 Haskell 2010 유형 . 모든 I / O 작업은 결과를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다. 또한, 순수 코드에서 발생 볼 것을 포함하여 예외의보다 일반적인 유형에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ce36d06fc25e64c6b77302cc8e5115d7e36509" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9f5848499bd728182625d195bb7424161811e1c" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드의 예외에 대한 Haskell 2010 유형입니다 . 모든 I / O 작업은 결과를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다. 순수 코드에서 발생하는 예외를 포함하여보다 일반적인 유형의 예외는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 예외에 대한 Haskell 2010 유형 . 모든 I / O 작업은 결과를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다. 또한, 순수 코드에서 발생 볼 것을 포함하여 예외의보다 일반적인 유형에 대한 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 예외에 대한 Haskell 2010 유형 . 모든 I / O 작업은 결과를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다. 또한, 순수 코드에서 발생 볼 것을 포함하여 예외의보다 일반적인 유형에 대한 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 예외에 대한 Haskell 2010 유형 . 모든 I / O 작업은 결과를 반환하는 대신 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킬 수 있습니다. 또한, 순수 코드에서 발생 볼 것을 포함하여 예외의보다 일반적인 유형에 대한 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;isAlpha&lt;/code&gt; 의 Haskell 98 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">Haskell FFI는 이미 외국 수입품 및 수출품의 인수 및 결과가 새로운 유형 인 경우 자동으로 포장 해제되도록 지정합니다 (FFI 부록 3.2). GHC는 IO 모나드 자체를 감싸는 새로운 유형을 자동으로 풀어서 FFI를 확장합니다. FFI 사양이 필요로 어디든지 더 정확하게, &lt;code&gt;IO&lt;/code&gt; 의 유형을 GHC는 어떤 newtype은-포장 받아 &lt;code&gt;IO&lt;/code&gt; 의 유형입니다. 예를 들어, 다음 선언은 정상입니다.</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">하스켈 보고서는 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 는 동일한 값을 비교하는 두 값을 &quot;공개&quot;함수와 구별 할 수없는 동등성 관계를 구현할 것으로 예상됩니다. &quot;공개&quot;함수는 구현 세부 사항을 볼 수없는 함수입니다. 예를 들어, 정규화되지 않은 자연수 모듈로 100을 나타내는 형식의 경우 &quot;공개&quot;함수는 1과 201 사이의 차이를 만들지 않습니다. 다음과 같은 속성이있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">하스켈 보고서는 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 는 일반적으로 엄격하지 않은 부분 순서를 구현하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell Report는 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 는 관습 적으로 지수 필드를 정의하고 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell 보고서는 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 는 일반적으로 링을 정의하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">하스켈 보고서에 대한 법률 정의하지 않는다 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 는 관례 적으로 분할 링을 정의하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell 보고서는 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 인스턴스는 관례 적으로 유클리드 도메인을 정의하고 적절한 유클리드 함수 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 가 주어지면 &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 쌍에 대해 다음과 같은 속성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell Report는 &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 는 관습 적으로 지수 필드를 정의하고 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">하스켈 보고서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; . 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 는 동일한 값을 비교하는 두 값을 &quot;공개&quot;함수와 구별 할 수없는 동등성 관계를 구현할 것으로 예상됩니다. &quot;공개&quot;함수는 구현 세부 사항을 볼 수없는 함수입니다. 예를 들어, 정규화되지 않은 자연수 모듈로 100을 나타내는 형식의 경우 &quot;공개&quot;함수는 1과 201 사이의 차이를 만들지 않습니다. 다음과 같은 속성이있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell Report는 &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 는 관습 적으로 지수 필드를 정의하고 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">하스켈 보고서에 대한 법률 정의하지 않는다 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 는 관례 적으로 분할 링을 정의하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell 보고서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 인스턴스는 관례 적으로 유클리드 도메인을 정의하고 적절한 유클리드 함수 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 가 주어지면 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 쌍에 대해 다음과 같은 속성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell 보고서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 및 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 는 일반적으로 링을 정의하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">하스켈 보고서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 에 대한 법률을 정의하지 않습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 는 일반적으로 엄격하지 않은 부분 순서를 구현하고 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Haskell 보고서는 접두사 연산자 &lt;code&gt;%&lt;/code&gt; 에 대해 다음 ID를 보유하도록 요구합니다 .</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">하스켈 보고서는 설명 &lt;code&gt;*&lt;/code&gt; (철자 &lt;code&gt;Type&lt;/code&gt; 및 수입 &lt;code&gt;Data.Kind&lt;/code&gt; 하스켈의 GHC 방언)이 같은 일반 데이터 유형의 종류 &lt;code&gt;Int&lt;/code&gt; 인 . 또한 타입 생성자는 화살표가있는 종류를 가질 수 있습니다. 예를 들어, &lt;code&gt;Maybe&lt;/code&gt; 종류가 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . 박스형은 런타임 표현을 지정하는 종류를 가지고 있습니다. 예를 들어, &lt;code&gt;Int#&lt;/code&gt; 유형 은 &lt;code&gt;TYPE 'IntRep&lt;/code&gt; 종류 이고 &lt;code&gt;Double#&lt;/code&gt; &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; 은 TYPE'DoubleRep 종류 입니다. 이러한 종류는 &lt;code&gt;Int#&lt;/code&gt; 의 런타임 표현이 기계 정수이고 &lt;code&gt;Double#&lt;/code&gt; 의 런타임 표현이라고 말합니다 .기계 배정 밀도 부동 소수점입니다. 반대로, 종류 &lt;code&gt;Type&lt;/code&gt; 은 실제로는 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 의 동의어입니다 . &lt;code&gt;TYPE&lt;/code&gt; 메커니즘 에 대한 자세한 내용은 &lt;a href=&quot;#runtime-rep&quot;&gt;런타임 표현 다형성 섹션에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">하스켈 보고서는 &lt;code&gt;deriving&lt;/code&gt; 조항이 합법적 일 때 정확히 모호 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90561213a1b6d66157821a9e10425e8dc3a64c9d" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, and &lt;code&gt;Ix&lt;/code&gt; for tuples up to size 15.</source>
          <target state="translated">크기 15에 GHC는 62 튜플 유형의 크기를 제한하고 인스턴스 제공까지 하스켈 보고서는 튜플 형식을 제공하기 위해 구현과 동반 표준 인스턴스를 필요로 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; 및 &lt;code&gt;Ix&lt;/code&gt; 튜플 최대 크기에 대한 15.</target>
        </trans-unit>
        <trans-unit id="ac5deab8ae658158332cbfbbabb6e8e4c0757f95" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt; for tuples up to size 15. However, &lt;code&gt;Ix&lt;/code&gt; instances are provided only for tuples up to size 5.</source>
          <target state="translated">The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; , and &lt;code&gt;Show&lt;/code&gt; for tuples up to size 15. However, &lt;code&gt;Ix&lt;/code&gt; instances are provided only for tuples up to size 5.</target>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskell Report는 바인딩 그룹 (최상위 또는 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; )이 강력하게 연결된 구성 요소로 정렬 된 다음 종속성 순서대로 유형을 검사하도록 지정합니다 ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, 섹션 4.5.1&lt;/a&gt; ). 각 그룹의 유형을 검사 할 때 명시적인 유형 서명이있는 그룹의 바인더는 지정된 다형성 유형의 유형 환경에 배치되고 그룹이 일반화 될 때까지 다른 모든 유형은 단일 유형입니다 ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, 섹션 4.5.2&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="8b75c250a4a929abcdfd7f96fd88dc38f5bfcd9e" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskell 보고서는 바인딩 그룹 (최상위 수준 또는 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; )을 강력하게 연결된 구성 요소로 정렬 한 다음 종속성 순서로 유형 검사해야한다고 지정합니다 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell 보고서, 섹션 4.5.1&lt;/a&gt; ). 각 그룹이 유형 검사되므로 명시적인 유형 시그니처를 가진 그룹의 모든 바인더는 지정된 다형성 유형을 사용하여 유형 환경에 배치되고 다른 모든 바인더는 그룹이 일반화 될 때까지 단일 형태입니다 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell 보고서, 섹션 4.5.2&lt;/a&gt; ). .</target>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">패키지의 Haskell 코드는 하나 이상의 아카이브 라이브러리 (예 : &lt;code&gt;libHSfoo.a&lt;/code&gt; ) 또는 단일 공유 객체 (예 : &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; )에 빌드 될 수 있습니다. 단일 공유 객체에 대한 제한은 패키지 시스템이 공유 객체 간 호출이 아닌 상호 객체 간 호출을 수행해야 할 때 컴파일러에 알리는 데 사용되기 때문입니다 (공유 객체 간 호출에는 추가 기능이 필요함) 우회).</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">프로그램이 컴파일되었거나 해석중인 Haskell 구현.</target>
        </trans-unit>
        <trans-unit id="60ce9c55f4fa0cf40f27dcde7ee4087164650d58" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted. On the GHC platform, the value is &quot;ghc&quot;.</source>
          <target state="translated">프로그램이 컴파일되었거나 해석되는 Haskell 구현입니다. GHC 플랫폼에서 값은 &quot;ghc&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3bcb6ef9eb76436588cc0d8da0bf323ce2da12ae" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest)</source>
          <target state="translated">The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus ( &lt;code&gt;*&lt;/code&gt; indicates a rule of interest)</target>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Haskell 보고서 &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;는 &lt;/a&gt; &lt;code&gt;lexp&lt;/code&gt; 비 터미널을 정의 합니다 ( &lt;code&gt;*&lt;/code&gt; 는 관심 규칙을 나타냄).</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Haskell2010 보고서는 &amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="85d12b1c3d53edaed978aecf46c9e3e3b26b841c" translate="yes" xml:space="preserve">
          <source>The I/O SubSystem to use in the program.</source>
          <target state="translated">프로그램에서 사용할 I / O 하위 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">IO 모나드</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">IOArray 타입</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">IOMode 유형</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">IORef 유형</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">ISO / IEC 8859-1 인코딩은 종종 Latin-1로 알려진 8 비트 인코딩입니다. 여기서 구현 된 &lt;em&gt;Char8&lt;/em&gt; 인코딩은 유니 코드 코드 포인트를 8 비트로 &lt;em&gt;자르고&lt;/em&gt; 단일 바이트로 인코딩하여 작동합니다. 코드 포인트 0-255의 경우 ISO / IEC 8859-1 인코딩에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1 인코딩은 종종 Latin-1로 알려진 8 비트 인코딩입니다. 여기서 구현 된 &lt;em&gt;Char8&lt;/em&gt; 인코딩은 유니 코드 코드 포인트를 8 비트로 &lt;em&gt;자르고&lt;/em&gt; 단일 바이트로 인코딩하여 작동합니다. 코드 포인트 0-255의 경우 ISO / IEC 8859-1 인코딩에 해당합니다. Char8 인코딩은 유니 코드 코드 포인트 0-127의 ASCII 인코딩과 같습니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 과 같은 함수를 사용 하여 Char8로 인코딩 된 문자를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 10 진수로 인코딩 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49fa9b80f4fa24e3bcc0042f7b61d0c844f15e6b" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; s as a decimal number with Char8 encoded characters.</target>
        </trans-unit>
        <trans-unit id="6c77ebed88d6a61f3f19c1021d1825a839754219" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1 인코딩은 종종 Latin-1로 알려진 8 비트 인코딩입니다. 여기에서 구현 된 &lt;em&gt;Char8&lt;/em&gt; 인코딩은 유니 코드 코드 포인트를 8 비트로 &lt;em&gt;자르고&lt;/em&gt; 단일 바이트로 인코딩하는 방식으로 작동합니다. 코드 포인트 0-255의 경우 이는 ISO / IEC 8859-1 인코딩에 해당합니다. Char8 인코딩은 유니 코드 코드 포인트 0-127의 ASCII 인코딩과 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 Char8 인코딩 문자를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 10 진수로 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">InputT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1 (ISO8859-1) 인코딩 이 인코딩은 바이트를 처음 256 개의 유니 코드 코드 포인트에 직접 매핑하므로 완전한 유니 코드 인코딩이 아닙니다. &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하여 &lt;code&gt;'\255'&lt;/code&gt; 보다 큰 문자 를 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓰려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1 (ISO8859-1) 인코딩 이 인코딩은 바이트를 처음 256 개의 유니 코드 코드 포인트에 직접 매핑하므로 완전한 유니 코드 인코딩이 아닙니다. &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 인코딩을 사용하여 &lt;code&gt;'\255'&lt;/code&gt; 보다 큰 문자 를 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 쓰려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">목록 데이터 유형 및 해당 조작</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">List 모나드.</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">ListT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">주어진 모나드에 역 추적을 추가하는 ListT 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">MVar 타입</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">가능성 유형 및 관련 작업</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">MaybeT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">수정 된 율리우스 력 날짜는 UT 자정부터 측정 된 요일이있는 요일입니다. UT1을 나타내는 데 사용됩니다. UT1은 지구 회전에 의해 측정 된 시간이며 다양한 워블에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">수정 된 줄리안 데이는 표준 일 수이며 0은 1858-11-17입니다.</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">MonadException 클래스</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">MonadWriter 클래스</target>
        </trans-unit>
        <trans-unit id="51acf2e9a1f450466332b8327436f6eceb7c3f17" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;exts/monomorphism#monomorphism&quot;&gt;Switching off the Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Monomorphism Restriction이 비활성화되어 있습니다 ( &lt;a href=&quot;exts/monomorphism#monomorphism&quot;&gt;Monomorphism Restriction 끄기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Monomorphism Restriction은 비활성화되어 있습니다 ( &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;두려운 Monomorphism Restriction 끄기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">그러나 NT 커널을 사용하면 Win32 API에서이 경로 사전 처리를 옵트 아웃 할 수 있습니다. 경로에서 원하는 네임 스페이스를 명시 적으로 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">패키지 버전 관리 정책 &lt;strong&gt;은 적용되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">패터슨 조건 : 맥락에서 각 클래스 제약 조건 &lt;code&gt;(C t1 ... tn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Prelude : 표준 모듈. Prelude는 명시적인 import 문이 없거나 NoImplicitPrelude 확장이 활성화되어 있지 않으면 기본적으로 모든 Haskell 모듈로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">Put 모나드</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">Put 모나드. 게으른 바이트 스트링을 효율적으로 구성하기위한 모나드.</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">풋 타입</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">PutM 유형입니다. 효율적인 Builder monoid에 대한 Writer 모나드.</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">RTS에는 동작을 제어 할 수있는 많은 옵션이 있습니다. 예를 들어 컨텍스트 전환 간격, 힙의 기본 크기를 변경하고 힙 프로파일 링을 활성화 할 수 있습니다. 이러한 옵션은 다양한 방법으로 런타임 시스템에 전달 될 수 있습니다. 다음 섹션 ( &lt;a href=&quot;#setting-rts-options&quot;&gt;RTS 옵션 설정&lt;/a&gt; )에서는 다양한 방법에 대해 설명하고 다음 섹션에서는 RTS 옵션 자체에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">동시성과 관련된 RTS 옵션은 &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Concurrent Haskell 사용&lt;/a&gt; 및 &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;SMP 병렬 처리를위한 RTS 옵션의 병렬 처리 옵션에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTS는 자체적으로 &lt;code&gt;-H32m -S&lt;/code&gt; 를 snaffle 하고 &lt;code&gt;System.Environment.getArgs&lt;/code&gt; 를 호출 할 때 나머지 인수 &lt;code&gt;-f -h foo bar&lt;/code&gt; 를 프로그램에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">RULES 메커니즘은 공통 목록 기능의 퓨전 (삼림 벌채)을 구현하는 데 사용됩니다. &quot;좋은 소비자&quot;가 &quot;좋은 생산자&quot;에 의해 구성된 중간 목록을 소비하는 경우, 중간 목록은 완전히 제거되어야합니다.</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWS 모나드</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">RWST 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">리더 모나드</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">ReaderT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM 구현은 유효하지 않은 것으로 알려진 트랜잭션을 중단하고 다시 시작해야합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 중간에 발생할 수 있으므로 해제해야하는 자원을 확보하지 않아야합니다 (트랜잭션 중단시 예외 처리기는 무시 됨). 예를 들어 핸들을 사용하여 IO를 수행하는 것이 포함됩니다. 이 잘못하면 임의 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM 구현은 유효하지 않은 것으로 알려진 트랜잭션을 중단하고 다시 시작해야합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 중간에 발생할 수 있으므로 해제해야하는 자원을 확보하지 않아야합니다 (트랜잭션 중단시 예외 처리기는 무시 됨). 예를 들어 핸들을 사용하여 IO를 수행하는 것이 포함됩니다. 이 잘못하면 임의 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">STM 구현은 종종 여러 번 트랜잭션을 실행하므로 IO에 부작용이있는 경우이를 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Safe Haskell &lt;em&gt;안전 언어&lt;/em&gt; ( &lt;code&gt;-XSafe&lt;/code&gt; 로 활성화 )는 다음 속성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt; 플래그 를 전달하여 모듈에 대해 Safe Haskell 검사를 비활성화 할 수 있습니다 . 플러그인을 실행하면 모듈이 안전하지 않은 것으로 표시되어 다운 스트림 모듈이 안전 점검에 실패 할 수 있으므로 소스 플러그인으로 컴파일 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">선택 모나드</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">SelectT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">신호 유형</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">스테이트 모나드</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">StateT 모나드 변압기</target>
        </trans-unit>
        <trans-unit id="19f67896d1f6937e580c15a10e0aa19b08a4f845" translate="yes" xml:space="preserve">
          <source>The SubSystem control interface. These methods can be used to disambiguate between the two operations.</source>
          <target state="translated">SubSystem 제어 인터페이스입니다. 이러한 메서드를 사용하여 두 작업을 명확하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt; 에 의해 작성된 TH 상태</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Typeable 클래스</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">UTC 시간대.</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-16 유니 코드 인코딩 (엔디안을 나타내는 데 바이트 순서 표시를 사용해야 함)</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-16 유니 코드 인코딩 (빅 엔디안)</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 유니 코드 인코딩 (litte-endian)</target>
        </trans-unit>
        <trans-unit id="8c4b2968dfc559f607c84276e6deaa90e4bc09b8" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (little-endian)</source>
          <target state="translated">UTF-16 유니 코드 인코딩 (little-endian)</target>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 유니 코드 인코딩 (엔디안을 나타내려면 바이트 순서 표시를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32 유니 코드 인코딩 (빅 엔디안)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32 유니 코드 인코딩 (litte-endian)</target>
        </trans-unit>
        <trans-unit id="7aac7a838ca04e2d0239351dada786d53acef1d2" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (little-endian)</source>
          <target state="translated">UTF-32 유니 코드 인코딩 (little-endian)</target>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">바이트 순서 표시 (BOM, 바이트 시퀀스 0xEF 0xBB 0xBF)가있는 UTF-8 유니 코드 인코딩입니다. 이 인코딩은 입력시 스트림의 시작 부분에서 BOM 시퀀스가 ​​무시되고 출력시 BOM 시퀀스가 ​​앞에 추가된다는 점을 제외하고는 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">바이트 순서 표시 (BOM, 바이트 시퀀스 0xEF 0xBB 0xBF)가있는 UTF-8 유니 코드 인코딩입니다. 이 인코딩은 입력시 스트림의 시작 부분에서 BOM 시퀀스가 ​​무시되고 출력시 BOM 시퀀스가 ​​앞에 추가된다는 점을 제외하고는 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8 인코딩은 &lt;em&gt;모든&lt;/em&gt; 유니 코드 코드 포인트를 인코딩 할 수 있습니다 . 응용 프로그램에서 실제로 다른 인코딩이 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩에 항상 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5a08465846c2ed90f1e4740e5e95b9f0ebef47" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s unless an application really requires another encoding.</target>
        </trans-unit>
        <trans-unit id="bd2c9a45b06c5bc52330c023a465b428ccfa7702" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8 인코딩은 &lt;em&gt;모든&lt;/em&gt; 유니 코드 코드 포인트를 인코딩 할 수 있습니다 . 응용 프로그램에 실제로 다른 인코딩이 필요한 경우가 아니라면 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩에 항상 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8 인코딩은 모든 유니 코드 코드 포인트를 인코딩 할 수 있습니다. 유니 코드 코드 포인트 0-127의 ASCII 인코딩과 같습니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 UTF-8로 인코딩 된 문자를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 10 진수로 인코딩하는 데에도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51b4cc22b8af376450ca69ff9b57ead5e922d46c" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; s as a decimal number with UTF-8 encoded characters.</target>
        </trans-unit>
        <trans-unit id="56e548216f1a033464f97b8c8251bc89165b536d" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8 인코딩은 모든 유니 코드 코드 포인트를 인코딩 할 수 있습니다. 유니 코드 코드 포인트 0-127의 ASCII 인코딩과 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 UTF-8 인코딩 문자를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 10 진수로 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">현재 로캘의 유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">현재 로케일의 유니 코드 인코딩으로, 임의의 디코딩 할 수없는 바이트를 라운드 트랩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">현재 로캘의 유니 코드 인코딩으로, 디코딩 할 수없는 바이트가 가장 가까운 시각적 일치로 바뀝니다. &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 마샬링 함수에 사용</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">문자의 유니 코드 일반 범주입니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스에 의존하며 , 이는 카테고리가 유니 코드 표준으로 제시된 순서와 동일한 순서로 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">문자의 유니 코드 일반 범주입니다. 이것은 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스에 의존하며 , 이는 카테고리가 유니 코드 표준으로 제시된 순서와 동일한 순서로 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3874853724a4d3f79b5cf848ac2f78cd971528d" translate="yes" xml:space="preserve">
          <source>The Weak Head Normal Form of an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; is a lambda abstraction not a data value, and reuse does not lead to memoisation. Reuse of the iterator above is somewhat contrived, when computing multiple folds over a common list, you should generally traverse a list only &lt;a href=&quot;#multipass&quot;&gt;once&lt;/a&gt;. The goal is to demonstrate that the separate computations of the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; run efficiently in constant space, despite reuse. This would not be the case with the list &lt;code&gt;[1..10000000]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt; 의 Weak Head Normal Form은 데이터 값이 아닌 람다 추상화이며 재사용은 메모로 이어지지 않습니다. 위의 반복자를 재사용하는 것은 다소 인위적인 것입니다. 공통 목록에 대해 여러 접기를 계산할 때 일반적으로 목록을 &lt;a href=&quot;#multipass&quot;&gt;한 번만&lt;/a&gt; 탐색해야합니다 . 목표는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 의 개별 계산이 재사용에도 불구하고 일정한 공간에서 효율적으로 실행 된다는 것을 보여주는 것입니다. &lt;code&gt;[1..10000000]&lt;/code&gt; 목록의 경우에는 해당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Windows 디렉토리</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">작가 모나드</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
