<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="translated">윤초에 신경 쓰지 않는다면 시계 계산에 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;NominalDiffTime&lt;/code&gt; 을 사용 하면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">주문에 신경 쓰지 않으면 대신 &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;비 순서 컨테이너&lt;/a&gt; 패키지 에서 &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">주문에 신경 쓰지 않으면 대신 &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;비 순서 컨테이너&lt;/a&gt; 패키지 에서 &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하지 않는 경우 &lt;code&gt;-threaded&lt;/code&gt; 옵션을 다음 런타임은 여러 OS 스레드를 사용하지 않습니다. 외래 통화는 통화가 돌아올 때까지 실행중인 다른 모든 Haskell 스레드를 차단합니다. &lt;a href=&quot;system-io&quot;&gt;System.IO의&lt;/a&gt; 도서관은 여전히 I / O를하고 여러 스레드가있을 수있다, 다중화 않으며,이 사용하여 런타임에 의해 내부적으로 처리 &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">플래그를 테스트하지 않고 정의되지 않은 상태에서 사용하면 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">플래그를 테스트하지 않고 정의되지 않은 상태에서 사용하면 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">플래그를 테스트하지 않고 정의되지 않은 상태에서 사용하면 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 너무 복잡하다고 생각 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;되면 GHC 팀에게 소리 지르십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57825a77683045fd11cf61c7e2280d83f489c5c5" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 너무 부담 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;스럽다고 생각되면 GHC 팀에 한마디 부탁드립니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="translated">코드에서 이러한 설정을 수정해야한다고 생각되면 기본값 및 설명서는 소스 코드를 참조하십시오. 그러나 나는 이것을 강력히 권합니다.</target>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="translated">명백히 잘못된 코드 레이아웃으로 추적 될 수있는 중대한 성능 회귀 사례를 발견하면 티켓을여십시오.</target>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="translated">&lt;code&gt;-watch&lt;/code&gt; 플래그 를 잊어 버린 경우 에도 &quot;상태&quot;메뉴에서 &quot;감시 파일&quot;을 선택할 수 있습니다. 이제 새 프로파일 &lt;code&gt;FOO.ps&lt;/code&gt; 를 생성 할 때마다 보기가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;#unboxed-tuples&quot;&gt;박스 없음 튜플이&lt;/a&gt; 활성화 튜플 섹션도, 그들을 위해 사용할 수 있도록 같은 것</target>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="translated">인코딩 형식에 대한 특정 요구 사항이있는 경우 인코딩 및 디코딩 프리미티브를 직접 사용할 수 있습니다 ( &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; 및 &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt; 모듈 참조) .</target>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="translated">절대 경로를 사용해야하는 경우 ( makefile 계층에서 무고한 모양의 &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; 를주의하거나 스크립트를 구성해야 함) Cygwin은 Cygwin의 Unix 스타일 경로를 실제 Windows 스타일로 변환 할 수있는 &lt;code&gt;cygpath&lt;/code&gt; 라는 도구를 제공합니다 . 많은 Cygwin 도구는 실제로 절대 Windows 스타일 경로를 허용하므로 ( &lt;code&gt;\\&lt;/code&gt; 를 이스케이프 하거나 &lt;code&gt;\\&lt;/code&gt; 를 &lt;code&gt;/&lt;/code&gt; 로 변환 해야 함을 명심하십시오) 어디에서나 사용하는 것이 좋습니다. 당신은 어떤 종류의 할 사용 도구에 필요한 경우 즉 유닉스 스타일의 경로 (하나의 재미있는 예를 해석하려고에 따라 경로를-맹 글링 &lt;code&gt;:&lt;/code&gt; 당신은 여전히 사용하여 경로를 변환 할 수있는 경로 목록에서 구분 기호로) &lt;code&gt;cygpath&lt;/code&gt; 을 그들이 GHC와 친구들에게 전달되기 직전에.</target>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="translated">&lt;code&gt;/tmp&lt;/code&gt; 의 공간이 부족하여 (또는 설치시 임시 파일이 있어야한다고 생각하는 경우) 문제가 발생 하면 &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; 옵션 옵션을 사용하여 대체 디렉토리를 지정할 수 있습니다. 예를 들어, &lt;code&gt;-tmpdir .&lt;/code&gt; 현재 작업 디렉토리에 임시 파일을 넣으라고합니다.</target>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="translated">특정 인코딩 (예 : UTF-8)이있는 데이터로 작업하고 애플리케이션의 성능이 매우 중요하다는 것을 미리 알고 있다면 바이트 스트링으로 I / O를 수행하고 인코딩 및 인코딩하는 것이 더 빠를 수 있습니다. 이 모듈의 기능을 사용하는 것보다 자신을 해독하십시오.</target>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type Elem = Char&lt;/code&gt; 을 지정하는 서명을 로컬로 정의 하면 상속 된 서명의 &lt;code&gt;head&lt;/code&gt; 를 &lt;code&gt;Char&lt;/code&gt; 를 반환 한 것처럼 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="translated">소스 코드를 변경하고 GHCi가 프로그램을 다시 컴파일하도록하려면 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 명령을 제공하십시오 . 프로그램은 필요에 따라 재 컴파일되며 GHCi는 외부 종속성이 변경되지 않은 경우 실제로 모듈을 다시 컴파일하지 않도록 최선을 다합니다. 이는 일괄 컴파일 설정에서 모듈 재 컴파일을 피하기 위해 사용하는 메커니즘과 동일합니다 ( &lt;a href=&quot;separate_compilation#recomp&quot;&gt;재 컴파일 검사기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="translated">이전 버전의 GHC에서 비 UTF-8 로켈을 사용해야하는 경우 다음과 같이 트랜스 코딩을 직접 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">하위 문자열로 문자열을 반복해서 분리해야하는 경우 (예 : 하위 문자열의 모든 인스턴스에서 중단하려는 경우) 시작 오버 헤드가 더 낮 &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">하위 문자열로 문자열을 반복해서 분리해야하는 경우 (예 : 하위 문자열의 모든 인스턴스에서 중단하려는 경우) 시작 오버 헤드가 더 낮 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="translated">예외 처리기에서 비동기 예외를 다시 마스크 해제해야하는 경우 &lt;code&gt;restore&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="translated">자신 만의 빌더 프리미티브를 작성해야하는 경우 &lt;em&gt;모든 안전 벨트를 끈 상태에서&lt;/em&gt; 코드를 작성하고 있음을 알고 있어야합니다 . 즉, * 이것은 애플리케이션이 버퍼 오버플로 공격에 취약하게 만들 수있는 코드입니다! * &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; 모듈은 인코딩을 철저히 테스트하기위한 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="translated">인터페이스 파일을 GHC가 찾을 수없는 곳으로 리디렉션하면 재 컴파일 검사기가 혼동 될 수 있습니다 (적어도 재 컴파일을 피할 수는 없습니다). 가능하면 대신 &lt;code&gt;-hidir&lt;/code&gt; 및 &lt;code&gt;-hisuf&lt;/code&gt; 옵션을 함께 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="translated">Cygwin 또는 MSYS 셸에서 GHCi를 실행하면 Control-C 동작에 부정적인 영향을 미칩니다. 이러한 환경 중 하나에서 &lt;code&gt;ghcii.sh&lt;/code&gt; 스크립트를 사용하여 GHCi 를 시작해야합니다. 그렇지 않으면 Control-C를 누르면 쉘 프롬프트로 돌아가지만 GHCi 프로세스는 계속 실행됩니다. 그러나 &lt;code&gt;ghcii.sh&lt;/code&gt; 스크립트를 사용하더라도 Control-C를 누르면 GHCi 내부에서 실행중인 프로그램을 중단시키지 않고 GHCi 프로세스가 즉시 종료됩니다. 이 문제는 Cygwin 및 MSYS 쉘 환경이 Control-C 이벤트를 Cygwin이 아닌 하위 프로세스로 전달하지 않기 때문에 발생합니다. Windows 콘솔이 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="baf4b7d8b90c0aee801d209afdb87b81f931a2c9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">링크 할 때 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; 플래그를 적절하게 설정하면 (링크에 &lt;a href=&quot;phases#options-linker&quot;&gt;영향을주는 옵션&lt;/a&gt; 참조 ) 프로그램을 실행할 때 명령 줄에서 RTS 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">당신이 설정 한 경우 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 연결할 때 적절하게 플래그를합니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;옵션 연결에 영향을 미치는&lt;/a&gt; 프로그램을 실행하는 경우), 당신은 RTS에게 명령 행 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="translated">옵션 &quot; &lt;code&gt;!&lt;/code&gt; 를 지정하면 GHC는 형식 동의어를 확장하고 형식 기능 응용 프로그램을 평가하여 형식을 정규화하고 정규화 된 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="translated">명령 행에서 GHCi를 시작한 경우 GHCi의 현재 디렉토리는 시작된 쉘의 현재 디렉토리와 동일합니다. Windows의 &quot;시작&quot;메뉴에서 GHCi를 시작한 경우 현재 디렉토리는 아마도 &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="translated">이 섹션을 참조한 후에도 여전히 문제가 발생하면 &lt;em&gt;버그를&lt;/em&gt; 발견했을 수 있습니다 . 신고하십시오! &lt;a href=&quot;intro#bug-reporting&quot;&gt;버그&lt;/a&gt; 를 신고하는 방법 및 버그에 대해 알고 싶은 사항에 대한 자세한 내용 은 GHC에서 버그보고를 참조하십시오 . 의심스러운 경우 보고서를 보내십시오 &amp;ndash; irate 사용자의 메일을 좋아합니다 :-!</target>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 을 제공하는 경우 다음 을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; 를 공급하는 경우 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="translated">둘 다 제공하는 경우 다음 사항도 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">당신이 생각하는 경우 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 의 배열로 값 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 (이하지 않은), 당신은 비효율적 인 코드를 작성하는 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="translated">GHC가 더 나은 오류 메시지를 생성했다고 생각되면 버그로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="translated">당신이 설정 한 경우 &lt;code&gt;+t&lt;/code&gt; 옵션 GHCi는 성명을 준수 각 변수의 유형을 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;ghc --make&lt;/code&gt; 하고 사용하지 않는 &lt;code&gt;-o&lt;/code&gt; 를 실행 파일 모듈이 들어있는 파일의 이름을 기반으로합니다 들어, 이름 GHC는 선택합니다 &lt;code&gt;Main&lt;/code&gt; . GHC를 사용하면 &lt;code&gt;Main&lt;/code&gt; 모듈을 &lt;code&gt;Main.hs&lt;/code&gt; 파일에 넣을 필요가 없습니다 . 따라서 둘 다</target>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하면 GHC는 다형성 로컬 바인딩에 대해 경고합니다. 경고의 일부로 GHC는 유추 된 유형도보고합니다. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;-T&lt;/code&gt; 다음 플래그를 사용하면 사용 통계에 액세스해야 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b229e3d5ff9a118b7d23643c61f72dbd7947f474" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; 플래그를 사용하는 경우 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats를&lt;/a&gt; 사용하여 통계에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 플래그를 사용하면 프로그램이 완료되면 다음과 같은 내용이 표시됩니다 (정확한 세부 사항은 사용중인 RTS의 종류에 따라 다릅니다. 예를 들어 RTS가 프로파일 링을 위해 컴파일 된 경우 프로파일 링 데이터 만 표시됨) :</target>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 플래그를 사용하면 프로그램이 완료되면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; 플래그를 사용하면 고아 모듈을 작성 중인지 GHC가 경고합니다. 경고처럼, 당신과 경고를 해제 할 수 있습니다 &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; 는&lt;/a&gt; 경고가 발행 된 경우 컴파일이 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0d6aaecc809c7a412ba9777573bc108e4291b9" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; 플래그를 사용하면 GHC는 고아 모듈을 만드는 경우 경고합니다. 경고처럼, 당신과 경고를 해제 할 수 있습니다 &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt; , 그리고 &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; 는&lt;/a&gt; 경고가 발행 된 경우 컴파일이 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="translated">오버로드 된 클래스 메소드에 실제로 적용되는 규칙을 원하는 경우이를 수행하는 유일한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="translated">간결한 다형성을 원하는 경우 주요 해결 방법은 새 유형 래퍼를 사용하는 것입니다. 다음과 &lt;code&gt;id runST&lt;/code&gt; 해결 방법을 사용하여 id runST 예제를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="translated">GHC에서와 같이 라인 버퍼링 된 동작을 원하면 다음과 같이 프로그램을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="translated">후자 유형을 원하면 &lt;code&gt;forall&lt;/code&gt; 을 명시 적으로 작성할 수 있습니다 . 실제로, 순위 2 유형에는 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="translated">프로그램이 종료되기 전에 하위 스레드가 완료되기를 기다리려면이를 직접 프로그래밍해야합니다. 간단한 메커니즘은 각 하위 스레드가 완료 될 때 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 쓰도록 하고 주 스레드가 모든 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 기다렸다가 종료하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="translated">C 콜백에서 Haskell로 일부 데이터를 다시 전달하려면 먼저 위의 예에서와 같이 Haskell의 일부 메모리를 할당하여 데이터를 수신하고 주소를 C로 전달하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Windows 방식으로 하드 링크를 만들려면 대신 &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Windows 방식으로 심볼릭 링크를 만들려면 대신 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외가 발생하는 경우 정리를 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="translated">단계를 수동으로 수행하거나 고유 한 빌드 시스템을 작성하려는 경우 특정 규칙을 따라야합니다. 다른 Haskell 코드에서 사용하기 위해 Haskell 코드를 내보내는 공유 라이브러리를 구축하는 것은 C API를 내보내고 C 코드에서 사용하는 것보다 약간 더 복잡합니다. 잘못하면 일반적으로 링커 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="translated">코스트 센터에 기능 이름과 다른 이름을 지정하려면 주석에 문자열을 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="translated">표준 Haskell 코드에서 어설 션을 사용하려는 경우 다음과 같은 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">프로그램에서 기본 데이터 형식이나 작업을 언급하려면 먼저 &lt;code&gt;GHC.Prim&lt;/code&gt; 을 가져와 범위로 가져와야합니다. 대부분의 이름은 &lt;code&gt;#&lt;/code&gt; 으로 끝나며 이러한 이름을 언급하려면 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; 확장자 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="translated">모든 전처리를 거부하려면 경로에 네임 스페이스를 명시 적으로 사용하십시오. 이 변경으로 인해 원시 장치 (예 : COM 포트)를 열어야하는 경우 장치 네임 스페이스를 명시 적으로 사용해야합니다. (예 : &lt;code&gt;\\.\COM1&lt;/code&gt; ). GHC 및 Haskell 프로그램은 더 이상 레거시 형식의 장치 열기를 더 이상 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="translated">서명에서 엔터티를 다시 내보내려면 서명에 정의 된 모든 엔터티가 내보내 지도록 &lt;code&gt;module SigName&lt;/code&gt; 내보내기 도 포함해야합니다 . 예를 들어 다음 모듈 은 &lt;code&gt;Prelude&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;Int&lt;/code&gt; 를 모두 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">나중에 사용하려면 포인터를 마지막으로 사용한 후 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; 를 터치 해야 배열이 너무 빨리 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">나중에 사용하려면 포인터를 마지막으로 사용한 후 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; 를 터치 해야 배열이 너무 빨리 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="translated">자신 만의 훌륭한 소비자 또는 생산자를 작성하려면 위 기능의 Prelude 정의를 참조하여 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">GHC가 반출 된 모든 최상위 레벨 함수 / 값에 유형 서명이 있는지 확인하지만 반출되지 않은 값은 확인하지 않으려면 &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오. 이 옵션은 &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; 보다 우선 합니다 . 경고의 일부로 GHC는 유추 된 유형도보고합니다. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="translated">GHC가 모든 패턴 동의어에 유형 서명이 있는지 확인하려면 &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt; &lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오. 이 옵션을 &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 경우 내 보낸 패턴 동의어에만 유형 서명이 있어야합니다. GHC는 또한 유추 된 유형을보고합니다. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">모든 최상위 레벨 함수 / 값에 유형 서명이 있는지 GHC가 확인하도록하려면 &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 . 경고의 일부로 GHC는 유추 된 유형도보고합니다. 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">정말 편집증을 느끼고 있다면 &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt; &lt;code&gt;-dcore-lint&lt;/code&gt; &lt;/a&gt; 옵션을 사용하는 것이 좋습니다. GHC 내에서 헤비급 인트라 패스 상태 검사를 켭니다. (그것은 당신의 GHC의 정신 상태를 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;Complex&lt;/code&gt; 확실히 사용 &lt;code&gt;Complex Double&lt;/code&gt; 보다는 &lt;code&gt;Complex Float&lt;/code&gt; (전자는 크게 전문 있지만, 후자는 아니다).</target>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="translated">Cabal을 사용하는 경우 패키지의 노출 또는 숨겨진 상태는 관련이 없습니다. 사용 가능한 패키지는 &lt;code&gt;.cabal&lt;/code&gt; 사양에 나열된 종속성에 따라 결정됩니다 . 패키지의 노출 / 숨김 상태는 &lt;code&gt;ghc&lt;/code&gt; 또는 &lt;code&gt;ghci&lt;/code&gt; 를 직접 사용할 때만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">환경 변수를 빈 문자열로 설정하려면 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;GHC.Generics&lt;/code&gt; 을 , 당신은 사용을 고려해야합니다 &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving의&lt;/a&gt; 많은 유용한 일반적인 기능이 포함되어 패키지를.</target>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">귀하의 경우 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 또한 &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , 인기 정의는</target>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">귀하의 경우 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 또한 &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , 인기 정의는</target>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="translated">당신의 데이터 형식 필드가 하나 하나의 생성자가 있으면 사용 &lt;code&gt;newtype&lt;/code&gt; 이란 선언 대신 &lt;code&gt;data&lt;/code&gt; 선언을. &lt;code&gt;newtype&lt;/code&gt; 은은 대부분의 경우 멀리 최적화 될 것이다.</target>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="translated">프로그램에 여러 모듈이 포함 된 경우 GHC에 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 소스 파일의 이름 만 알려 주면됩니다. GHC는 &lt;code&gt;import&lt;/code&gt; 선언을 검사 하여 프로그램을 구성하는 다른 모듈을 찾고 해당 소스 파일을 찾습니다. 즉, &lt;code&gt;Main&lt;/code&gt; 모듈을 제외 하고 모든 소스 파일은 포함 된 모듈 이름을 따라 이름을 지정해야합니다 (점은 디렉토리 구분 기호로 대체 됨). 예를 들어, 모듈 &lt;code&gt;Data.Person&lt;/code&gt; 이 파일에있을 것입니다 &lt;code&gt;Data/Person.hs&lt;/code&gt; 유닉스 / 리눅스 / 맥, 또는에 &lt;code&gt;Data\Person.hs&lt;/code&gt; Windows에서.</target>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="translated">프로그램에 외부 호출이없고 알려지지 않은 안전하지 않은 기능 (예 : &lt;code&gt;unsafePerformIO&lt;/code&gt; )에 대한 호출이없는 경우, 한 경우를 제외하고는 GHC 시스템에서 충돌이 항상 발생합니다. &lt;code&gt;.hi-boot&lt;/code&gt; 파일 을 사용하지 않는 경우 모듈 소스와 관련하여 올바른 파일 &lt;em&gt;이어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6ef9a1cfc5c74eeeabcdcb897c3ce978bdc728" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; or &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">프로그램의 GC 통계 ( &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS 옵션)가 많은 가비지 수집 (예 : 실행 시간의 20 % 이상)을 수행하고 있음을 나타내면 더 많은 메모리가 도움이 될 수 있습니다. &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 또는 &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS 옵션 ( &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하려면 RTS 옵션&lt;/a&gt; 참조 ). 경험상 &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 를 프로세스가 소비 할 메모리 양으로 설정 하거나 인수없이 &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 를 전달하여 GHC가 값을 계산하도록합니다. 라이브 데이터의 양을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">프로그램의 GC 통계 ( &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS 옵션)가 많은 가비지 수집 (예 : 실행 시간의 20 % 이상)을 수행하고 있음을 &lt;code&gt;-H⟨size⟩&lt;/code&gt; 또는 &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS 옵션 ( &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션&lt;/a&gt; 참조 ) 경험상, &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 를 프로세스가 소비 할 메모리 양으로 설정 하거나 인수없이 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 를 전달하여 GHC가 양을 기준으로 값을 계산하도록하십시오. 라이브 데이터.</target>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="translated">공유 라이브러리가 Haskell API를 내 보내면 다른 Haskell 프로그램에 직접 링크하여 해당 Haskell API를 사용할 수 없습니다. 링커 오류가 발생합니다. 대신 위 섹션에서 설명한대로 패키지로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">⟨n⟩을 생략하면 레벨 2로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="translated">⟨prompt⟩가 &lt;code&gt;&quot;&lt;/code&gt; 로 시작 하면 Haskell 문자열로 구문 분석되고 그렇지 않으면 리터럴 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="translated">⟨size⟩를 생략하면 가비지 콜렉터는 이전 GC의 힙 크기를 ⟨size⟩로 사용합니다. 이는 프로그램의 전체 메모리 요구 사항을 늘리지 않고 더 큰 &lt;code&gt;-A&lt;/code&gt; 값 을 허용하는 효과가 있습니다. 오래 지속되는 많은 양의 데이터를 작성하는 프로그램에있을 수 있으므로 기본 small &lt;code&gt;-A&lt;/code&gt; 값이 차선책 일 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="translated">&lt;code&gt;Set a&lt;/code&gt; 와 같은 유형 생성자의 라이브러리 작성자로서 모듈 사용자가 &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt; 를 작성하지 못하게 하려면 &lt;code&gt;Set&lt;/code&gt; 의 type 매개 변수 역할 을 &lt;code&gt;nominal&lt;/code&gt; 로 설정해야합니다 . 글로</target>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="translated">그러나 (D)가 포함 된 모듈을 컴파일 할 때 확장 &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; 를 활성화하면 GHC는 후속 인스턴스화 문제에 대해 불평하지 않고 대신 (C)를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">어떤 차원에서든 하한이 상한보다 큰 경우 배열은 유효하지만 비어 있습니다. 빈 배열을 인덱싱하면 항상 배열 경계 오류가 발생하지만 &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 는 배열이 구성된 경계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">어떤 차원에서든 하한이 상한보다 큰 경우 배열은 유효하지만 비어 있습니다. 빈 배열을 인덱싱하면 항상 배열 경계 오류가 발생하지만 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 는 배열이 구성된 경계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">어떤 차원에서든 하한이 상한보다 큰 경우 배열은 유효하지만 비어 있습니다. 빈 배열을 인덱싱하면 항상 배열 경계 오류가 발생하지만 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 는 배열이 구성된 경계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 를 사용한 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 평가하여 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2bb6b96d1379082a5862430606e077e4951c8b2d" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 평가되어 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 평가하여 \ (O (n) \)가 아닌 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a830bfeca5ac45c0e56970fbc2cc9313f12b8526" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 평가되어 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 를 사용한 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 평가하여 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b49b973971f72b90b88232bbeeb66a8215462172" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 평가되어 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 를 평가하여 \ (O (n) \)가 아닌 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98de0ed556230c1fbd1808a2934adcaaa69ac02e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 가 사용 된 경우 모든 비교 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 가 평가되어 \ (O (n) \) 대신 \ (O (n \ log n) \) 평가를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="translated">출력에서 아무것도 대체하지 않고 유효하지 않은 입력을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소스에서 어설 션을 무시하십시오. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="translated">코드 레이아웃에 대한 cfg 가중치를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="translated">마크를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="translated">패키지 ⟨pkg⟩ 무시</target>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="translated">인터페이스 파일에서 pragma를 무시하십시오. &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; 에&lt;/a&gt; 의해서만 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4ec85769b7a4182ac16f4a75bfe188c6947b6d" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;code&gt;-O0&lt;/code&gt; only.</source>
          <target state="translated">인터페이스 파일에서 pragma를 무시합니다. &lt;code&gt;-O0&lt;/code&gt; 으로 만 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">설치된 패키지에서 노출 된 플래그를 무시하고 기본적으로 모두 숨 깁니다. 이 플래그를 사용하면 필요한 패키지 ( &lt;code&gt;base&lt;/code&gt; 포함 )를 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 명시 적으로 노출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">설치된 패키지에서 신뢰 플래그를 무시하고 기본적으로 신뢰를 해제하십시오. 이 플래그와 Safe Haskell을 사용하는 경우 &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; 옵션을 사용하여 신뢰해야하는 패키지 ( &lt;code&gt;base&lt;/code&gt; 포함 )를 명시 적으로 신뢰해야합니다 . 이 옵션은 패키지의 노출 / 숨김 상태를 변경하지 않으므로 시스템의 모든 패키지에 &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; 를 적용하는 것과 동일하지 않습니다 . ( &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;안전 하스켈&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="translated">유사한 기술을 사용하여 지정된 반복 횟수에 대한 중단 점을 무시할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="translated">불변 배열 타입.</target>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="translated">인터페이스가 오버로드 된 불변 배열. 이 인터페이스와 함께 사용할 수있는 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 유형은이 모듈에서 내 보낸 배열 유형과 &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array를&lt;/a&gt; 참조하십시오. 모듈을 참조하십시오. diffarray와 같은 다른 패키지도이 인터페이스를 사용하여 배열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="translated">불변의 엄격하지 않은 (박스형) 배열</target>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="translated">불변의 엄격하지 않은 배열</target>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="translated">구현 내부</target>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="translated">구현 세부 사항 외에도 스택의 함수 이름은 버그를 추적하기에 충분한 단서를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="translated">문자 술어 (isLower, isUpper 등) 및 변환 (toUpper, toLower)에 대한 구현입니다. 구현은 가능한 경우 Unix 시스템에서 libunicode를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="translated">구현은 가능한 한 최소한 로컬로 Haskell 프로세스, 파일에 대한 다중 판독기 단일 기록기 잠금을 적용해야합니다. 그건,&lt;em&gt; 입력을 관리하는 동일한 파일에는 많은 핸들이 있거나 출력을 관리하는 파일에는 하나의 핸들 만있을 수 있습니다&lt;/em&gt; . 열려 있거나 반 닫힌 핸들이 출력 할 파일을 관리하는 경우 해당 파일에 새 핸들을 할당 할 수 없습니다. 열린 핸들 또는 반 닫힌 핸들이 입력 파일을 관리하는 경우 출력을 관리하지 않는 경우에만 새 핸들을 할당 할 수 있습니다. 두 파일이 같은지 여부는 구현에 따라 다르지만 예를 들어 절대 경로 이름이 같고 이름이 바뀌지 않은 경우 일반적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 를 사용하여 구현 .</target>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="translated">&lt;em&gt;Chris Okasaki의&lt;/em&gt; / Breadth-First Numbering : 알고리즘 디자인의 작은 연습에서 얻은 교훈에서 채택한 알고리즘을 사용하여 구현&lt;em&gt;&lt;/em&gt; Okasaki ICFP'00 / .</target>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="translated">암시 적 호출 스택</target>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="translated">암시 적 매개 변수 바인딩 선언. 암시 적 바인딩으로 구성된 let 및 where 절에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="translated">암시 적 매개 변수 (참조 &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;암시 적 매개 변수를&lt;/a&gt; 명시 적 타입의 서명이있는 경우) 중단 점의 범위에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">암시 적 매개 변수는 &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]에&lt;/a&gt; 설명 된대로 구현되고 &lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; &lt;/a&gt; 옵션으로 활성화됩니다. . (다음 중 여전히 불완전한 대부분의 문서는 Jeff Lewis가 작성했습니다.)</target>
        </trans-unit>
        <trans-unit id="f3e48b33a4890da92cd70584a377ecd462ba1a72" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">암시 적 매개 변수는 &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]에&lt;/a&gt; 설명 된대로 구현되고 &lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; &lt;/a&gt; 옵션으로 활성화됩니다 . (아직 불완전한 다음 대부분의 문서는 Jeff Lewis 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="translated">암시 적 매개 변수 제한 조건이 모호성을 유발하지 않습니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="218aafacdf8f46f838b7332039de5c3dbbc7cc14" translate="yes" xml:space="preserve">
          <source>Implied by</source>
          <target state="translated">암시</target>
        </trans-unit>
        <trans-unit id="f91e7074a90e49338f31c7b8d7563d1849b2d089" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt; 에 의해 암시되고 그렇지 않으면 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됨 에 . 그렇지 않은 경우는 off</target>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wtyped-holes&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="translated">암시 :</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="translated">&lt;code&gt;hs-boot&lt;/code&gt; 파일로 모듈을 가져 와서 모듈 루프를 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">수입 명세서 및 범위 지정 규칙은 Haskell과 동일합니다. 비 Prelude 유형 또는 클래스를 언급하려면 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="translated">패턴을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="translated">가져 오기 / 내보내기 기능</target>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">중요 사항 : &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 동작은 &quot;Haskell의 비동기 예외&quot;( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ) 문서에 설명 된 동작과 다릅니다 . 본 논문에서 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 비 차단입니다. 그러나 라이브러리 구현 은 대상 스레드가 예외를 수신 할 때까지 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않는 보다 동기적인 디자인을 채택합니다 . 절충은이 논문의 섹션 9에서 논의됩니다. 차단 작업과 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 중단 가능합니다 (서류 5.3 절 참조). 그러나 다른 인터럽트 가능 작업과 달리 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 실제로 차단되지 않더라도 &lt;em&gt;항상&lt;/em&gt; 인터럽트 가능합니다.</target>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">중요 사항 : &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 동작은 &quot;Haskell의 비동기 예외&quot;( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ) 문서에 설명 된 동작과 다릅니다 . 본 논문에서 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 비 차단입니다. 그러나 라이브러리 구현 은 대상 스레드가 예외를 수신 할 때까지 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않는 보다 동기적인 디자인을 채택합니다 . 절충은이 논문의 섹션 9에서 논의됩니다. 차단 작업과 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 중단 가능합니다 (서류 5.3 절 참조). 그러나 다른 인터럽트 가능 작업과 달리 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 실제로 차단되지 않더라도 &lt;em&gt;항상&lt;/em&gt; 인터럽트 가능합니다.</target>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">중요 사항 : &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 동작은 &quot;Haskell의 비동기 예외&quot;( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ) 문서에 설명 된 동작과 다릅니다 . 본 논문에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 비 차단입니다. 그러나 라이브러리 구현 은 대상 스레드가 예외를 수신 할 때까지 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않는 보다 동기적인 디자인을 채택합니다 . 절충은이 논문의 섹션 9에서 논의됩니다. 차단 작업과 마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 중단 가능합니다 (서류 5.3 절 참조). 그러나 다른 인터럽트 가능 작업과 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 실제로 차단되지 않더라도 &lt;em&gt;항상&lt;/em&gt; 인터럽트 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">중요 사항 : &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 동작은 &quot;Haskell의 비동기 예외&quot;( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ) 문서에 설명 된 동작과 다릅니다 . 본 논문에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 비 차단입니다. 그러나 라이브러리 구현 은 대상 스레드가 예외를 수신 할 때까지 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 가 반환되지 않는 보다 동기적인 디자인을 채택합니다 . 절충은이 논문의 섹션 9에서 논의됩니다. 차단 작업과 마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 중단 가능합니다 (서류 5.3 절 참조). 그러나 다른 인터럽트 가능 작업과 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 는 실제로 차단되지 않더라도 &lt;em&gt;항상&lt;/em&gt; 인터럽트 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="translated">중요하게도, GHC는 &lt;strong&gt;절대 &lt;/strong&gt; &lt;code&gt;HasCallStack&lt;/code&gt; 을 유추 &lt;strong&gt;하지 않습니다&lt;/strong&gt; 제약 조건을 명시 적으로 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="translated">구문 &lt;code&gt;:module -M&lt;/code&gt; 을 사용하여 컨텍스트에서 가져 오기를 &lt;em&gt;제거&lt;/em&gt; 할 수 있습니다 . &lt;code&gt;import&lt;/code&gt; 구문 (하스켈 모듈로) 누적이므로,이 범위를 뺄 수있는 유일한 방법이다.</target>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="translated">(아마도) 나쁜 경우에는이 알고리즘의 복잡성이 O (n * m)으로 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="translated">(아마도) 나쁜 경우에는이 함수의 시간 복잡성이 O (n * m)으로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="translated">에서는 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt; 모드 (참조 &lt;a href=&quot;using#modes&quot;&gt;동작 모드&lt;/a&gt; ), 컴파일러는 일반적으로 현재 하스켈 모듈에 의해 요구 된 패키지를 결정하고, 링크 만한다. 그러나 배치 모드에서는 종속성 정보를 사용할 수 없으며 링크 할 때 명시 적 &lt;code&gt;-package&lt;/code&gt; 옵션을 제공해야합니다. 다른 경우에는 &lt;code&gt;-package&lt;/code&gt; 를 사용해야 할 수도 있습니다 . 패키지를 강제로 링크 경우는 패키지에 Haskell 모듈이 포함되어 있지 않은 경우입니다 (예 : C 라이브러리 만 포함 할 수 있음). 이 경우 GHC는 의존성을 발견하지 않으므로 명시 적으로 언급해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="translated">에서 &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt; 는 LHS는 응용 프로그램이 아닙니다; 에서 &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt; 은 LHS 헤드에 패턴 변수를 갖는다. 에서 &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt; 는 LHS는 구성 &lt;em&gt;생성자&lt;/em&gt; 라기보다는, &lt;em&gt;변수&lt;/em&gt; 인자에 적용.</target>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt; , 종류 변수 &lt;code&gt;a&lt;/code&gt; 암시 LHS 형 패턴의 종류에 의해 서명이 결합되어 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;...rhs...&lt;/code&gt; 효과에 대한 로컬 인스턴스가 &lt;code&gt;Eq (f a)&lt;/code&gt; 임의위한 . 그러나 &lt;code&gt;f&lt;/code&gt; 의 호출 사이트 에서 컴파일러 자체는 &lt;code&gt;f&lt;/code&gt; 로 전달할 증거를 생성합니다 . 우리가 호출 예를 들어, &lt;code&gt;f Nothing&lt;/code&gt; 다음 &lt;code&gt;f&lt;/code&gt; 이다 &lt;code&gt;Maybe&lt;/code&gt; 컴파일러는 (전화 사이트에서) 증명해야 &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; Eq a =&amp;gt; Eq (아마도 a)가 유지됩니다. &lt;code&gt;Eq (Maybe a)&lt;/code&gt; 대한 기존 인스턴스 선언에 어필하여 쉽게 수행 할 수 있습니다. &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 형식의 인스턴스</target>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; , 파라미터 &lt;code&gt;p&lt;/code&gt; 는 반면, 처음으로 사용되는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 단순히 애플리케이션의 랩 &lt;code&gt;f&lt;/code&gt; 에 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; , 부모 클래스 또는 형식의 이름</target>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , 유형 생성자의 인수에 대응</target>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , 유형 생성자 unlifted입니까?</target>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">에서는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 숫자는 특정 데이터 생성자와 연관된. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 는 하나의 인덱스이며 해당 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 값을 초과해서는 안됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 의 총 수 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 는 이야. 예를 들어 &lt;code&gt;(#|#)&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 는 2입니다.</target>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; , 부모 클래스 또는 형식의 이름</target>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , 유형 생성자의 인수에 대응</target>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , 유형 생성자 unlifted입니까?</target>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">에서는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 숫자는 특정 데이터 생성자와 연관된. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 는 하나의 인덱스이며 해당 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 값을 초과해서는 안됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 의 총 수 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 는 이야. 예를 들어 &lt;code&gt;(#|#)&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 는 2입니다.</target>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="translated">에서 &lt;code&gt;MetaCons n f s&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; , 생성자의 이름이고 &lt;code&gt;f&lt;/code&gt; 자사의 고 정성, 그리고 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;'True&lt;/code&gt; 생성자가 기록 선택기를 포함하는 경우.</target>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;MetaData n m p nt&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 데이터 타입의 이름이고, &lt;code&gt;m&lt;/code&gt; 은 데이터 타입이 정의 된 모듈이며, &lt;code&gt;p&lt;/code&gt; 데이터 유형을 정의하는 패키지이고, &lt;code&gt;nt&lt;/code&gt; 인 &lt;code&gt;'True&lt;/code&gt; 데이터 유형이 경우 &lt;code&gt;newtype&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="translated">에서 &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt; 필드가 기록 구문을 사용하는 경우, 다음 &lt;code&gt;mn&lt;/code&gt; 입니다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 레코드 이름입니다. 그렇지 않으면 &lt;code&gt;mn&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다. &lt;code&gt;su&lt;/code&gt; 및 &lt;code&gt;ss&lt;/code&gt; 는 필드의 압축 풀기 및 엄격 주석이며 &lt;code&gt;ds&lt;/code&gt; 는 GHC가 필드에 대해 유추하는 엄격입니다.</target>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화 할 , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화 할 , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화합니다 &lt;code&gt;b&lt;/code&gt; ,하지만 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 는 정량화합니다 &lt;code&gt;b&lt;/code&gt; ,하지만 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">에서 &lt;code&gt;Monad&lt;/code&gt; 다음과 같은 상황이 유지되지 않을 경우 인스턴스 선언은 경고 :</target>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">에서 &lt;code&gt;Monoid&lt;/code&gt; 다음과 같은 상황이 유지되지 않을 경우 인스턴스 선언은 경고 :</target>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="translated">에서, &lt;code&gt;f1&lt;/code&gt; 과 &lt;code&gt;f2&lt;/code&gt; 는 입력 변수 &lt;code&gt;b&lt;/code&gt; 최 의해 정량화되지 &lt;code&gt;forall&lt;/code&gt; 그래서 함수의 바디 위에 범위 아니다. 하지도 않는다 &lt;code&gt;b&lt;/code&gt; 의 몸 범위 &lt;code&gt;f3&lt;/code&gt; 는 AS, &lt;code&gt;forall&lt;/code&gt; 밑에서 자리 잡고 &lt;code&gt;Foo&lt;/code&gt; 형 동의어.</target>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">에서 &lt;code&gt;g&lt;/code&gt; 의 정의, 우리는에 인스턴스화합니다 &lt;code&gt;(C alpha)&lt;/code&gt; 와 추론 시도 &lt;code&gt;(C alpha)&lt;/code&gt; 에서 &lt;code&gt;(C a)&lt;/code&gt; 하고 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3a689d248410c565d4fb51360a8de99b622f55fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">에서 &lt;code&gt;g&lt;/code&gt; 의 정의, 우리는에 인스턴스화합니다 &lt;code&gt;(C alpha)&lt;/code&gt; 와 추론 시도 &lt;code&gt;(C alpha)&lt;/code&gt; 에서 &lt;code&gt;(C a)&lt;/code&gt; 하고 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="translated">에서는 &lt;code&gt;kindOf&lt;/code&gt; 상기 &lt;code&gt;k&lt;/code&gt; 개의 변수는 어떤 위치와 입력 위치에 모두 사용된다. 현재 &lt;code&gt;kindOf&lt;/code&gt; 도 받아 들여지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; 대한 규칙 봐 &lt;code&gt;map&lt;/code&gt; 융합을 아직 융합이 발생하지 않는 경우에도 효율적인 프로그램을 줄 것이다 규칙을 작성하는 방법을 볼 수 있습니다. &lt;code&gt;GHC/List.hs&lt;/code&gt; 에서 더 많은 규칙 .</target>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="translated">에서 &lt;em&gt;배치 모드&lt;/em&gt; , GHC는 명령 행에 하나 개 이상의 소스 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="translated">GHC 6.12.3 및 이전 버전에서는 기본값이 모든 RTS 옵션을 처리하는 것이 었습니다. 그러나 RTS 옵션을 사용하면 실행중인 프로그램의 보안 컨텍스트에서 로깅 데이터를 임의의 파일에 쓸 수 있으므로 잠재적 인 보안 문제가 있습니다. 이러한 이유로 GHC 7.0.1 이상은 기본적으로 &lt;code&gt;-rtsopts=some&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="translated">GHC 8.4 이상에서 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 대한 예를 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 리프트에 수정되었습니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 대신 인스턴스를 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 인스턴스입니다. 따라서이 유형은 더 이상 유용하지 않습니다. GHC 8.8에서는 더 이상 사용되지 않으며 GHC 8.10에서는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="translated">GHC에서 &lt;code&gt;Int&lt;/code&gt; 유형은 호스트 아키텍처의 주소 크기를 따릅니다. 즉, 32 비트 시스템에서 32 비트를 보유하고 64 비트 시스템에서 64 비트를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="translated">GHC 버전 6.12에서는 Linux 용 공유 라이브러리 빌드가 지원됩니다 (x86 및 x86-64 아키텍처). GHC 버전 7.0은 Windows ( &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Win32 DLL 빌드 및 사용&lt;/a&gt; 참조 ), FreeBSD 및 OpenBSD (x86 및 x86-64), Solaris (x86) 및 Mac OS X (x86 및 PowerPC)에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="translated">GHC에서 &lt;code&gt;alloca&lt;/code&gt; 는 &lt;code&gt;MutableByteArray#&lt;/code&gt; 사용하여 구현 되므로 할당 및 할당 해제가 빠릅니다. C의 &lt;code&gt;malloc/free&lt;/code&gt; 보다 훨씬 빠르지 만 C의 스택 할당만큼 빠르지는 않습니다 . 가능할 때마다 &lt;code&gt;alloca&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="translated">GHC에서 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 도 &lt;code&gt;MutableByteArray#&lt;/code&gt; 사용하여 구현됩니다 . 메모리가 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 의해 지적되었지만 실제 종료자는 포함되어 있지 않으며 ( &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; 로 추가하지 않는 한 ) GC를 사용하여 할당 해제가 수행되므로 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 은 일반적으로 매우 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="translated">GHC에서 고 정성 선언은 로컬 바인딩과 함께 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="translated">GHC에서 stdout 핸들은 기본적으로 라인 버퍼링됩니다. 그러나 GHCi에서는 일반적으로 인터프리터에서 원하는 것이므로 stdout에서 버퍼링을 해제합니다. 출력이 생성 될 때 출력이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="translated">GHC에서 이것은 1입니다 (탭은 문자 일뿐입니다)</target>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="translated">GHC에서 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 가 생성 한 스레드 는 경량 스레드이며 전적으로 GHC 런타임에 의해 관리됩니다. 일반적으로 Haskell 스레드는 운영 체제 스레드보다 몇 배나 더 효율적입니다 (시간 및 공간 측면에서).</target>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="translated">Haskell 2010에서는 특정 유형의 표현식을 괄호없이 연산자에 대한 인수로 사용할 수 있지만 함수에 대한 인수로는 사용할 수 없습니다. 그들은 포함 &lt;code&gt;do&lt;/code&gt; , 람다 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 표현. 일부 GHC 확장은 다음 유형의 언어 구성도 정의합니다 : &lt;code&gt;mdo&lt;/code&gt; ( &lt;a href=&quot;#recursive-do-notation&quot;&gt;재귀 do-notation&lt;/a&gt; ), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt; Lambda-case&lt;/a&gt; ) 및 &lt;code&gt;proc&lt;/code&gt; ( &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt; ) 과 .</target>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="translated">Haskell 2010에서 이것은 불투명 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="translated">Haskell 98 모드 및 기본적으로 (Haskell 2010 모드는 아님) GHC는 &lt;code&gt;do&lt;/code&gt; 표현식에 사용될 때 레이아웃 규칙에 대해 덜 엄격 합니다. 특히, 중첩 컨텍스트가 &lt;code&gt;do&lt;/code&gt; 표현식 인 경우 중첩 컨텍스트가 엔 클로징 컨텍스트와 동일한 레벨에있을 수 있도록 &quot;중첩 컨텍스트가 엔 클로징 컨텍스트보다 오른쪽으로 들여 써야 함&quot;이라는 제한 사항이 완화됩니다 .</target>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="translated">Haskell 98에서 클래스 선언의 컨텍스트 (수퍼 클래스를 소개 함)는 단순해야합니다. 즉, 각 술어는 유형 변수에 적용된 클래스로 구성되어야합니다. &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; 확장 ( &lt;a href=&quot;#flexible-contexts&quot;&gt;타입 서명의 컨텍스트) 은&lt;/a&gt; 이 제한을 해제하여 클래스 선언의 컨텍스트에 대한 유일한 제한은 클래스 계층 구조가 비순환이어야한다는 것입니다. 따라서 이러한 클래스 선언은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="translated">Haskell 98에서 인스턴스 선언의 헤드는 &lt;code&gt;C (T a1 ... an)&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;C&lt;/code&gt; 는 클래스, &lt;code&gt;T&lt;/code&gt; 는 데이터 형식 생성자, &lt;code&gt;a1 ... an&lt;/code&gt; 는 고유 한 유형 변수입니다. 다중 매개 변수 유형 클래스의 경우,이 규칙은 인스턴스 헤드의 각 매개 변수에 적용됩니다 (아마도 하나만이 양식을 가지고 있고 다른 하나는 유형 변수 인 경우에는 괜찮을 것입니다. 그러나 이것이 바로 규칙입니다).</target>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="translated">Haskell 98에서 인스턴스 선언 컨텍스트의 클래스 제약 조건은 &lt;code&gt;C a&lt;/code&gt; 형식이어야하며 여기서 &lt;code&gt;a&lt;/code&gt; 는 헤드에서 발생하는 형식 변수입니다.</target>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="translated">Haskell 98에서 &lt;code&gt;App&lt;/code&gt; 에 대한 유추 된 종류 는 &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 입니다. 그러나 &lt;code&gt;App&lt;/code&gt; 적합한 또 다른 Haskell 98 종류 는 &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt; 이므로 &lt;code&gt;a&lt;/code&gt; 에 할당 된 종류 는 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 이므로 지나치게 구체적 입니다. 실제로, 종류 서명 ( &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; )이 없으면 더미 생성자를 사용하여 Haskell 컴파일러가 두 번째 종류를 유추해야합니다. 종류 다형성 ( &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; )에서 GHC는 모든 &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 대한 종류를 유추합니다 . (k-&amp;gt; 유형)-&amp;gt; k-&amp;gt; 가장 일반적인 종류 인 &lt;code&gt;App&lt;/code&gt; 유형 입니다 .</target>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="translated">Haskell 98에서 파생 가능한 유일한 클래스는 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; 입니다.&lt;a href=&quot;#deriving-extra&quot;&gt;다양한 언어 확장&lt;/a&gt; 이이 목록을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="translated">Haskell 98에서는 파싱 모나드를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="translated">하스켈에서는 &lt;code&gt;let&lt;/code&gt; 발현은 뒤에 &lt;code&gt;in&lt;/code&gt; . 그러나 GHCi에서, 표현은 &lt;code&gt;IO&lt;/code&gt; 모나드 에서도 해석 될 수 있기 때문에 동반하지 않고 바인딩 &lt;code&gt;let&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; , 위의 예에서와 같이, 된 명령문 은 빈 줄로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">Haskell에서 줄 바꾸기는 항상 &lt;code&gt;'\n'&lt;/code&gt; 문자로 표시됩니다 . 그러나 파일 및 외부 문자 스트림에서 줄 바꾸기는 다음과 같은 다른 문자 순서로 표시 될 수 있습니다. &lt;code&gt;'\r\n'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="translated">Haskell에서 프로그래머가 작성한 형식 서명은 자유 형식 변수 ( Haskell 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;섹션 4.1.2)&lt;/a&gt; 에 대해 암시 적으로 수량화 됩니다. 사 전적으로 범위가 지정된 유형 변수는 다음과 같이이 암시 적 수량화 규칙에 영향을줍니다. 범위에있는 모든 유형 변수는 보편적으로 정량화 &lt;em&gt;되지 않습니다&lt;/em&gt; . 예를 들어, 유형 변수 &lt;code&gt;a&lt;/code&gt; 가 범위 내에 있으면</target>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="translated">Haskell에서 부동 소수점 연산에는 순수한 유형이 있으며 평가 순서는 지정되지 않습니다. 때문에 그래서 엄격하게 말하면 &lt;code&gt;fenv.h&lt;/code&gt; 의 함수를 사용하면 결과를 변경하거나 부동 소수점 연산의 효과를 관찰 할 수 있도록, 사용 &lt;code&gt;fenv.h&lt;/code&gt; 는 정의되지 않은 프로그램의 아무 곳이나 부동 소수점 연산의 동작을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="translated">Haskell에서는 인스턴스 선언에 형식 서명을 쓸 수 없지만 때로는 편리한 경우가 있으며 언어 확장 &lt;a href=&quot;#extension-InstanceSigs&quot;&gt; &lt;code&gt;InstanceSigs&lt;/code&gt; 를&lt;/a&gt; 사용하면 그렇게 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="translated">A의 &lt;em&gt;폐쇄 형 가족&lt;/em&gt; 의 모든 방정식을 주문하고 한 곳에서하고 있습니다. 방정식도 쌍별로 검사되지만 이번에는 방정식이 모든 선행 방정식과 쌍을 이루어야합니다. 물론 단일 방정식 폐쇄 형 제품군은 사소한 주입 방식입니다 (위의 (1), (2) 또는 (3)이 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="translated">A의 &lt;em&gt;소스&lt;/em&gt; 프로그램이 TA가없는 생성자 (A GHC 확장 : 볼이없는 것으로 선언 할 것 &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;없이 생성자와 데이터 유형을&lt;/a&gt; ), 그러나 의미 안녕하세요 부팅 파일에서 &quot;나는 알거나 생성자가 무엇인지 상관하지 않습니다.&quot; 이것이 가장 쉬운 형태이기 때문에 가장 일반적인 형태의 데이터 형식 선언입니다. 당신 &lt;em&gt;은 할&lt;/em&gt; 수 &lt;em&gt;있습니다&lt;/em&gt; 또한 당신이 그렇게 할 경우, 당신은 그것의 실제 정의로 정확하게 그것을 작성해야합니다, 생성자를 쓰기하지만.</target>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="translated">GADT 스타일 데이터 형식 선언에는 데이터 생성자를 고정해야하는 명확한 방법이 없으므로 형식에 대해 &lt;code&gt;Show&lt;/code&gt; 를 파생하면 차이가 발생합니다 . (infix로 선언 된 데이터 생성자는 파생 된 &lt;code&gt;show&lt;/code&gt; 에 의해 infix로 표시됩니다 .) 따라서 GHC는 다음 디자인을 구현합니다. GADT 스타일 데이터 형식 선언으로 선언 된 데이터 생성자는 &lt;code&gt;Show&lt;/code&gt; iff에 의해 접두어로 표시됩니다. ) 두 개의 인수가있다. (c) 프로그래머가 제공 한 고 정성 선언이있다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="translated">클래스 선언에서 모든 클래스 유형 변수는 각 메소드 유형의 사용 가능한 변수에서 ( &lt;a href=&quot;#flexible-contexts&quot;&gt;유형 서명 컨텍스트&lt;/a&gt; 에서 언급 한 의미에서) 도달 가능해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="translated">동시 프로그램 에서 기본 프로세서 아키텍처의 메모리 모델에 따라 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 작업이 다른 스레드에 비 순차적으로 나타날 수 있습니다. 예를 들어, x86에서로드는 상점보다 앞서 이동할 수 있으므로 다음 예제에서</target>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="translated">경우에 따라 동일 제약 조건도 지연 될 수 없습니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="translated">불변을 게으르게 검사하는 형태.</target>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="translated">차후 GHC 릴리스 에서&amp;ldquo;forall-or-nothing&amp;rdquo;규칙에 따라 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;kindOf&lt;/code&gt; 가 모두 거부됩니다. &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부인이 경고 는 실제 변경이 발생하기 전에이를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">다중 스레드 프로그램에서 현재 작업 디렉토리는 프로세스의 모든 스레드간에 공유되는 전역 상태입니다. 따라서 여러 스레드에서 파일 시스템 작업을 수행 할 때는 상대 경로가 아닌 절대 경로를 사용하는 것이 좋습니다 ( &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="translated">패턴 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="translated">필드 펑이있는 패턴 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="translated">레코드 구문이있는 패턴 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="translated">패턴 유형 시그니처 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;렉시 스코프 유형 변수&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="translated">레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="translated">&lt;code&gt;e { x = 1 }&lt;/code&gt; 과 같은 레코드 업데이트 에서 범위에 여러 &lt;code&gt;x&lt;/code&gt; 필드가있는 경우 컨텍스트의 유형은 어떤 레코드 데이터 유형이 의도되었는지 수정하거나 유형 주석을 제공해야합니다. 다음 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="translated">비슷한 방식으로, &lt;code&gt;g&lt;/code&gt; 의 이전 정의 는 이제 유형 오류로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="translated">단일 패턴에서 뷰 패턴 표현식의 왼쪽에 패턴으로 묶인 변수는 범위 내에 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="translated">독립형 GHC 프로그램에서 프로세스를 종료하려면 메인 스레드 만 종료하면됩니다. 따라서 다른 모든 분기 스레드는 기본 스레드와 동시에 종료됩니다 (이 종류의 동작에 대한 용어는 &quot;대조 스레드&quot;).</target>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">엄격한 모나드에서는 각 동작이 언제 실행되는지 알지만 모나드는 반드시 반환 값이나 모나드의 다른 구성 요소 (예 : 상태)에서 엄격하지는 않습니다. 그러나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가하려는 구성 요소에서 엄격한 조치를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7880166b35b3a24c62f866c80bb1e9fca6aab314" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">엄격한 모나드에서는 각 작업이 언제 실행되는지 알지만 모나드는 반환 값이나 상태와 같은 모나드의 다른 구성 요소에서 반드시 엄격한 것은 아닙니다. 그러나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 를 사용하여 평가하려는 구성 요소에서 엄격한 작업을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43015c398315c351d899f4cc070e29bfc23b64c4" translate="yes" xml:space="preserve">
          <source>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</source>
          <target state="translated">인라인 종류 주석이없는 경우 추론 된 배열에는 명시 적으로 바인딩 된 모든 매개 변수와 바로 뒤의 보이지 않는 매개 변수가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="translated">또한 &lt;code&gt;#{stuff}&lt;/code&gt; 는 자체적으로 구분되므로 행의 끝이나 일부 괄호에 배치 할 필요가 없다는 점을 제외하고 &lt;code&gt;#stuff&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="translated">핵심 플러그인 외에도 GHC는 형식 검사기 플러그인을 실험적으로 지원하므로 구속 조건 솔버의 동작을 수정할 수 있습니다. 예를 들어, GHC에 내장 된 이론보다 더 풍부한 유형 수준 산술 표현 이론을 지원하기 위해 컴파일러를 SMT 솔버에 인터페이스 할 수 있습니다 ( &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;유형 수준 내추럴로 계산&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조적 측면에서 동등 할뿐만 아니라 두 인스턴스 도 동일하게 동작하는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 인스턴스를 가지고 있습니다 . 이 유형은 GHC 8.8에서 더 이상 사용되지 않으며 GHC 8.10에서 제거됩니다. 사용자는 &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; 의 변형을 사용하여 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 로 포장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="translated">코어 및 유형 검사기 플러그인 외에도 소스 코드의 다른 표현에 액세스 할 수있는 플러그인을 설치할 수 있습니다. 이 플러그인의 주요 목적은 개발 도구를보다 쉽게 ​​구현할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="translated">DLL을 만드는 것 외에도 &lt;code&gt;-shared&lt;/code&gt; 옵션은 가져 오기 라이브러리를 만듭니다. 가져 오기 라이브러리 이름은 다음과 같이 DLL 이름에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업에서 발생한 예외 외에도 순수한 코드 (부정확 한 예외) 또는 외부 이벤트 (비동기 예외)에 의해 예외가 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서만 발생할 수 있습니다 . 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="translated">프로그램의 시간 및 할당 동작을 프로파일 링하는 것 외에도 시간이 지남에 따른 메모리 사용량 그래프를 생성 할 수도 있습니다. 프로그램이 런타임에 더 많은 메모리를 보유 할 때 공간 누출의 원인을 감지하는 데 유용합니다. 공간 누수로 인해 가비지 수집기 활동이 많아서 실행 속도가 느려지고 프로그램의 메모리가 모두 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 액션에 의해 버퍼에 방금 쓰여진 데이터 외에도 기존 데이터 덩어리를 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 제공 합니다. 또한 다음과 같은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 작업을 제공합니다 . 이전 실행 작업에서 남은 여유 공간이 많은 버퍼를 사용하여이 다음 작업을 실행하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="translated">DWARF 사양에 지정된 일반적인 DIE 외에도 GHC는 태그 및 속성 공간의 공급 업체 확장 성 영역을 사용하여 다양한 기타를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="translated">또한 &lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; RTS 옵션을 사용 하여 다음과 같은 추가 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; 모드 에서 프로세스가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; (-SIGINT)로 종료되면 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외를 발생시킵니다 . 일반적으로이 예외를 포착하지 않고 전파되도록하여 정상적인 순서대로 종료합니다. 알아야 할 한 가지 세부 사항 은 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 호출하는 스레드에서 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외가 &lt;em&gt;동 기적&lt;/em&gt; 으로 발생하는 반면, 일반적으로 &lt;code&gt;SIGINT&lt;/code&gt; 는 예외가 기본 스레드에 &lt;em&gt;비동기 적&lt;/em&gt; 으로 발생하게한다는 것 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="translated">또한 의미하는 데이터 유형은 선택기에 대한 인수에 대한 유형 서명으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="translated">또한 프로파일은 특정 기준을 만족하는 힙 데이터로 제한 될 수 있습니다. 예를 들어, 유형별로 프로파일을 표시하지만 특정 모듈에서 생성 된 데이터에 대해서만 프로파일을 표시하거나 특정 유형의 데이터에 대해 리테이너로 프로파일을 표시 할 수 있습니다. 제한 사항은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="translated">또한 특수 구문 (예 : 패키지 이름, 버전, 종속성)이있는 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt; 를 사용하면 가져 오기 또는 내보내기 목록의 데이터 생성자 이름 앞에 키워드 &lt;code&gt;pattern&lt;/code&gt; 을 붙여 상위 유형 생성자없이 데이터 생성자를 &lt;a href=&quot;#patsyn-impexp&quot;&gt;가져 오거나 내보낼 수 있습니다 (패턴 동의어 가져 오기 및 내보내기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="translated">모든 경우에 (화살표 표기법 제외) 정적 의미론은 예상치 못한 약간이라도 설탕 제거 된 형태의 의미론이어야합니다. 예를 들어, 리터럴 ( &lt;code&gt;368&lt;/code&gt; ) 의 정적 의미 는 &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; 의 정적 의미와 정확히 같습니다 . 에 대한 그것의 좋은 &lt;code&gt;fromInteger&lt;/code&gt; 는 유형의 어떤을 가지고 :</target>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="translated">다른 모든 컨텍스트에서 유형 와일드 카드는 허용되지 않으며 명명 된 와일드 카드는 일반 유형 변수로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="translated">에서 &lt;code&gt;instance&lt;/code&gt; 명시적인 경우 클래스의 선언 &lt;code&gt;type instance&lt;/code&gt; 선언 관련 유형을 지정하지, 디폴트 선언은 기본 클래스 메소드와 마찬가지로 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="translated">다음과 같은 가져 오기 또는 내보내기 목록에서</target>
        </trans-unit>
        <trans-unit id="cc915ffb21811be1dad23381dc586229e4878e9d" translate="yes" xml:space="preserve">
          <source>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class&amp;rsquo;s type variable binders. Here is an example:</source>
          <target state="translated">연관된 유형에서는 유형 패밀리가 최상위 선언 인 것처럼 유형 변수를 정렬하여 클래스 유형 변수 바인더의 가시성을 무시합니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="translated">기본적으로 내장 규칙이 자연 리터럴로 변환하므로 wordToNatural #을 사용할 수 없습니다. 대신이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">일괄 처리 컴파일 모드에서 &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-o ⟨file⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 오브젝트 파일의 이름을 대체 할 수 있으며 &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-ohi ⟨file⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 인터페이스 파일의 이름을 직접 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="translated">다양한 도구를 사용하여 나중에 분석 할 수 있도록 이진 형식의 파일입니다. 그러한 도구 중 하나는 &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; 이며, 이는 이벤트 로그를 해석하여 프로그램의 시각적 병렬 실행 프로파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="translated">이진 형식으로 사용자 정의 이벤트 로그 작성기. 이를 통해 프로그램이 실행되는 동안 이벤트를 실시간으로 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="translated">바인딩 위치에는 유사한 구문 분석 규칙이 있습니다. 다음 예를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;body&lt;/code&gt; 평가를 시작하기 전에 평가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="translated">두 경우 모두, &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 는 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;rec&lt;/code&gt; 블록 전체 와 그 뒤에 나오는 명령문에서 사용할 수 있습니다 . 차이점은 &lt;code&gt;let&lt;/code&gt; 은 비 모노 딕이고, &lt;code&gt;rec&lt;/code&gt; 는 모나 딕이라는 것입니다. (하스켈에서 &lt;code&gt;let&lt;/code&gt; 은 실제로 &lt;code&gt;letrec&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="translated">newtype에서 일부 클래스를 파생 시키려고 할 때 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 도 켜져 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="translated">여러 개의 &lt;code&gt;needle&lt;/code&gt; 인스턴스가 겹치는 경우 첫 번째 바늘 만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; 와 함께 GHC는 더 높은 등급을 지원합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecd1bab6934e5b406a45cc9d86aaae1eda35aa2c" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 확장 과 함께 빈 데이터 선언은 표준 유형 클래스의 인스턴스를 파생시킬 수도 있습니다 ( &lt;a href=&quot;#empty-data-deriving&quot;&gt;빈 데이터 유형에 대한 인스턴스 파생&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; 확장 과 함께 빈 데이터 선언은 표준 유형 클래스의 인스턴스를 파생시킬 수도 있습니다 ( &lt;a href=&quot;#empty-data-deriving&quot;&gt;빈 데이터 유형의 인스턴스 파생&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">대조적으로, &lt;code&gt;g&lt;/code&gt; 를 위해 이것을하는 확실한 방법은 없다 ; 우리는 &lt;code&gt;Eq a&lt;/code&gt; 또는 &lt;code&gt;Eq b&lt;/code&gt; 가 &lt;code&gt;g&lt;/code&gt; 타입 의 제약 조건에서 먼저 나열 되는지 알 수 없습니다 . GHC 릴리스간에 가시적 인 유형의 응용 프로그램을 견고하게하기 위해 &lt;code&gt;g&lt;/code&gt; 와의 사용을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="22f781a5702b84d96719b279819ee7bee564bebe" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">반대로 &lt;code&gt;g&lt;/code&gt; 에 대해이 작업을 수행하는 신뢰할 수있는 방법은 없습니다 . &lt;code&gt;Eq a&lt;/code&gt; 또는 &lt;code&gt;Eq b&lt;/code&gt; 가 &lt;code&gt;g&lt;/code&gt; 유형 의 제약 조건에서 첫 번째로 나열 되는지 알 수 없습니다 . GHC 릴리스간에 가시적 인 유형 적용이 견고 해 지도록하기 위해 &lt;code&gt;g&lt;/code&gt; 와 함께 사용하는 것을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="translated">덤프에서는 억제 할 수있는 모든 항목 (고유 항목 제외)을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="translated">각각의 경우에 적합한 클래스는 &lt;code&gt;deriving&lt;/code&gt; 조항 에서 언급되기 전에 범위 내에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="translated">이전 버전의 GHC에서는 명시 적 컨텍스트가있는 경우 생성자 유형 에서 &lt;code&gt;forall&lt;/code&gt; 을 생략 할 수있었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="translated">두 경우 모두 C는 패키지 트러스트에 대한 유일한 권한입니다. &lt;a href=&quot;#safe-package-trust&quot;&gt;신뢰&lt;/a&gt; 하는 패키지 를 결정하는 것은 클라이언트의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="translated">오류 메시지에서 표현식은 특정 &quot;깊이&quot;로 인쇄되며 깊이를 초과하는 하위 표현식은 타원으로 대체됩니다. 이 플래그는 깊이를 설정합니다. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="4aea9c2bc91c202848f5c9b6db19bf9964c3bd1d" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="translated">실제로 &lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt; 은 기술적 인 이유로 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 없이는 효과가 없습니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;# 5252&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="translated">실제로 &lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt; 은 기술적 인 이유로 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 없이는 효과가 없습니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;문제 # 5252&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="translated">실제로 명령 행에 Haskell 소스 파일이 있고 다른 모드가 지정되지 않은 경우 GHC는 자동으로 make 모드로 전환되므로이 경우에는</target>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리가 자동으로 수행 할 수 있도록 사실, GHCi는 중단 점을 명중하는 명령을 실행하는 방법을 제공합니다 &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="translated">&lt;code&gt;showHelp&lt;/code&gt; 함수에서 GHC는 겹치는 인스턴스가 없으므로 불만없이 &lt;code&gt;MyShow [a]&lt;/code&gt; 인스턴스를 사용합니다 . &lt;code&gt;main&lt;/code&gt; 에서 &lt;code&gt;myshow&lt;/code&gt; 를 호출 할 때 GHC는 &lt;code&gt;Main&lt;/code&gt; 모듈에서 겹치는 인스턴스 선언을 사용하여 &lt;code&gt;MyShow [T]&lt;/code&gt; 제약 조건을 해결합니다 . 결과적으로 프로그램은</target>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 변수를 바인딩하지 않으면 일반적으로 게으른 패턴 바인딩 &lt;code&gt;p = e&lt;/code&gt; 는 no-op 입니다. 고독한 와일드 카드 패턴을 허용하는 동기는 &lt;code&gt;_v = rhs3&lt;/code&gt; 과 크게 다르지 않으므로 경고가 없습니다. &lt;code&gt;_ = x::Int&lt;/code&gt; 와 같은 형식 제약 조건을 추가하는 데 유용 할 수 있습니다 . &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;뱅&lt;/a&gt; 패턴 ( 뱅 패턴 및 Strict Haskell 참조 )은 평가를 강제하지 않으며 &lt;code&gt;seq&lt;/code&gt; 의 대안으로 유용하기 때문에 no-op 가 &lt;em&gt;아닙니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="translated">일반적으로 약한 포인터는 가비지 수집기 뒤에 있지 않은 객체에 대한 참조입니다. 즉, 객체에 대한 약한 포인터의 존재는 해당 객체의 수명에 영향을 미치지 않습니다. 약한 포인터를 참조 해제하면 참조하는 객체가 여전히 존재하는지 여부를 확인하고 객체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="translated">일반적으로 세 가지 종류의 패턴 동의어가 있습니다. 단방향, 양방향 및 명시 적 양방향. 지금까지 제공된 예는 양방향 패턴 동의어의 예입니다. 양방향 동의어는 일반 데이터 생성자와 동일하게 동작합니다. 패턴 컨텍스트에서 값을 분해하고 표현식 컨텍스트에서 값을 구성 할 수 있습니다. 예를 들어, 앞에서 정의한 패턴 동의어 &lt;code&gt;Arrow&lt;/code&gt; 및 &lt;code&gt;Int&lt;/code&gt; 를 사용하여 &lt;code&gt;intEndo&lt;/code&gt; 값을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="translated">일반적으로 &lt;code&gt;ghc -M Foo&lt;/code&gt; 는 다음을 수행합니다. 세트 &lt;code&gt;Foo&lt;/code&gt; 의 각 모듈 &lt;code&gt;M&lt;/code&gt; 과 모든 가져 오기 (전 이적으로)에 대해 Makefile에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="translated">일반적으로 GHC는 유용하다고 가정 할만한 사소한 이유가있을 경우에만 기능을 인라인합니다.</target>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="translated">일반적으로, GHC는 다형성 함수 (단일 형식이없는 것)에서만 다형성 함수를 인스턴스화합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후 가장 최근에로드 된 &quot;대상&quot;모듈의 범위에 자동 가져 오기가 &lt;code&gt;*&lt;/code&gt; -형식으로 추가됩니다 (가능한 경우). 예를 들어 &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; 이고 &lt;code&gt;bar.hs&lt;/code&gt; 에 &lt;code&gt;Bar&lt;/code&gt; 모듈이 포함 된 경우 &lt;code&gt;Bar&lt;/code&gt; 가 해석 되면 범위가 &lt;code&gt;*Bar&lt;/code&gt; 로 설정 되거나 &lt;code&gt;Bar&lt;/code&gt; 가 컴파일 되면 &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi) 로 설정됩니다 &lt;code&gt;Prelude&lt;/code&gt; 가없고 &lt;code&gt;*&lt;/code&gt; 형식 모듈 이없는 경우 자동으로 Prelude를 추가합니다 . 이 자동으로 추가 된 가져 오기는 &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; 로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;#instance-resolution&quot;&gt;인스턴스 확인&lt;/a&gt; 에서 논의 된 바와 같이 , &lt;em&gt;GHC는 타입-클래스 제약 조건을 해결하기 위해 어떤 인스턴스 선언을 사용해야하는지 명확해야합니다&lt;/em&gt; . 또한 GHC는 &lt;em&gt;가장 구체적인&lt;/em&gt; 인스턴스가있는 경우 둘 이상의 인스턴스가 일치하도록하여 인스턴스 확인을 완화하는 방법을 제공합니다 . 또한 가장 구체적인 인스턴스가 있는지 여부에 관계없이 둘 이상의 인스턴스가 일치하도록하여 더 느슨해 질 수 있습니다. 이 섹션은 세부 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="translated">일반적으로 GHC가 Oxford 대괄호 (예 : &lt;code&gt;[| foo bar |]&lt;/code&gt; 내에서 표현식을 볼 경우 GHC는 대괄호 내에서 각 이름을 찾습니다. 이름이 전역 인 경우 (예 : &lt;code&gt;foo&lt;/code&gt; 가 가져 오기 또는 최상위 레벨에서 온 것으로 가정) 선언은) 다음 완전한 이름은 인용에 직접 사용되는 이름이 지역은 (예를 들어, 가정하자 인 경우. &lt;code&gt;bar&lt;/code&gt; 함수 정의에 로컬로 바인딩 &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt; ), 다음 GHC 사용은 &lt;code&gt;lift&lt;/code&gt; (거기에 따라서 GHC는 &lt;code&gt;[| foo bar |]&lt;/code&gt; 에 실제로 &lt;code&gt;[| foo $(lift bar) |]&lt;/code&gt; 포함 하는 척합니다 . 스플 라이스 위치에 포함되지 않은 로컬 이름은 실제로 견적이 처리 될 때 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="translated">일반적으로, 종료 자 사이에 순서 제약 조건이있는 별도의 개체에는 종료자를 사용하지 않는 것이 좋습니다. 순서를 강력하게 표현하려면 &lt;code&gt;MVar&lt;/code&gt; 사용하여 명시적인 동기화가 필요 하지만 런타임에서도 단일 스레드에서 여러 개의 종료자를 순차적으로 실행하기 때문에 (성능상의 이유로) 종료 자와 동기화하면 인위적인 교착 상태가 발생할 수 있습니다. 또 다른 대안은 명시 적 참조 카운팅을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="translated">일반적으로 &lt;code&gt;pluginRecompile&lt;/code&gt; 필드는 다음 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="translated">일반적으로 &lt;code&gt;do&lt;/code&gt; 문에 &lt;code&gt;Monad&lt;/code&gt; 제약 조건이 발생하는 규칙 은 다음과 같습니다. do-expression의 형식이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="translated">일반적으로 이러한 옵션 은 인스트루먼트 된 바이너리가 생성 한 후 &lt;code&gt;.tix&lt;/code&gt; 파일 에서 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">일반적으로 임의 순위 유형에 대한 유형 유추는 결정할 수 없습니다. GHC는 Odersky와 Laufer가 제안한 알고리즘 (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL'96)을 사용하여 프로그래머의 도움을 받아 결정 가능한 알고리즘을 얻습니다. 아직 &quot;일부 도움&quot;에 대한 공식적인 사양은 없지만 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31dba12d8f480c4aabbd58985394adff8da0a17b" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;rsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">일반적으로 임의 순위 유형에 대한 유형 추론은 결정할 수 없습니다. GHC는 Odersky와 Laufer가 제안한 알고리즘 (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL'96)을 사용하여 프로그래머의 도움을 요청하여 결정 가능한 알고리즘을 얻습니다. 아직 &quot;일부 도움&quot;에 대한 공식적인 사양은 없지만 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="translated">일반적으로, &lt;code&gt;case&lt;/code&gt; 표현식 또는 함수 정의의 패턴 에서는 존재 적으로 정량화 된 생성자에서만 패턴 일치를 수행 할 수 있습니다 . 이 제한의 이유는 실제로 구현상의 이유입니다. 유형 검사 바인딩 그룹은 이미 그림을 복잡하게 만드는 실재가없는 악몽입니다. 또한 모듈의 최상위 레벨에서 실존 적 패턴 바인딩은 이해가되지 않습니다. 실존 적으로 정량화 된 유형 &quot;이스케이프&quot;를 방지하는 방법이 명확하지 않기 때문입니다. 따라서 현재 상태에 대한 간단한 제한이 있습니다. 우리는 그것이 얼마나 성가신지를 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="translated">고성능 Haskell 코드 (예 : 숫자 코드)에서 내부 루프에서 썽크를 제거하면 큰 승리를 거둘 수 있습니다. GHC는 프로그래머가 지연 (필요한 평가) 평가 대신 엄격한 (값별 호출) 평가 사용을 지정할 수 있도록 세 가지 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="translated">기본 모드에서 GHC는 다음 버전의 언어 표준에서 데이터 유형 컨텍스트를 제거하기로 결정 했으므로 데이터 유형 컨텍스트를 허용하지 않습니다. 이 동작은 &lt;code&gt;DatatypeContexts&lt;/code&gt; 확장 으로 제어 할 수 있습니다 . &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;데이터 유형 컨텍스트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="translated">기본 모드에서 GHC는 일부 프로그램을 원래보다 약간 더 정의합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="translated">클래스 메소드가 클래스 변수를 먼저 나열하는 방식에 따라 연관된 유형도 클래스 변수를 다른 클래스보다 먼저 나열합니다. 이는 클래스에서 유추 된 변수가 클래스에서 지정된 변수보다 앞에 오며, 이는 내재적으로 바인딩 된 다른 변수보다 앞에옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">많은 상황에서 &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 작업은 &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; 를 사용하여 대체 될 수 있으며 , 이는 기능 적용을 촉진합니다.</target>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">많은 상황에서 &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 작업은 &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; 를 사용하여 대체 될 수 있으며 , 이는 기능 적용을 촉진합니다.</target>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="translated">보다 복잡한 예에서는 예외의 전체 계층 구조를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">대부분의 경우 &lt;code&gt;toLazyByteString&lt;/code&gt; 에서 사용하는 매개 변수 는 좋은 성능을 제공합니다. &lt;code&gt;toLazyByteString&lt;/code&gt; 의 하위 수행 사례는 짧은 (&amp;lt;128 바이트) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 실행 중 입니다. 이 경우 첫 번째 4kb 버퍼에 대한 할당 오버 헤드와 트리밍 비용이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 비용을 지배합니다 . 이 문제를 피할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">대부분의 경우 &lt;code&gt;toLazyByteString&lt;/code&gt; 에서 사용하는 매개 변수 는 좋은 성능을 제공합니다. &lt;code&gt;toLazyByteString&lt;/code&gt; 의 하위 수행 사례는 짧은 (&amp;lt;128 바이트) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 실행 중 입니다. 이 경우 첫 번째 4kb 버퍼에 대한 할당 오버 헤드와 트리밍 비용이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 비용을 지배합니다 . 이 문제를 피할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="translated">대부분의 경우 일반 인스턴스 선언에서와 같이 명시 적 컨텍스트 (예 : 컨텍스트는 &lt;code&gt;(Eq a)&lt;/code&gt; )를 제공해야합니다. 반대로 데이터 형식 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 절에서는 컨텍스트가 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="translated">대부분의 시나리오에서 모든 &lt;code&gt;deriving&lt;/code&gt; 문은 명확하게 형식 클래스 인스턴스를 생성합니다. 그러나 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 확장을 동시에 활성화 하면 파생이 모호해질 수 있습니다. 다음 예를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , &lt;code&gt;where&lt;/code&gt; 또는 최상위 레벨 과 같은 상호 재귀 바인딩 에서 한 선언의 뷰 패턴은 다른 선언에 의해 바인딩 된 변수를 언급하지 않을 수 있습니다. 즉, 각 선언은 독립적이어야합니다. 예를 들어 다음 프로그램은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="translated">종류를 사용하는 방법에 대한 완전한 유연성을 위해서는 종류 시스템을 사용하여 박스형, 리프트 형 ( &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;[Bool]&lt;/code&gt; 과 같은 일반, 일상 형)과 박스형 , 기본형 (박스형 &lt;a href=&quot;#primitives&quot;&gt;및 기본 작업)을 구분해야합니다.&lt;/a&gt; )와 같은 &lt;code&gt;Int#&lt;/code&gt; . 따라서 우리는 소위 다형성 다형성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="translated">내장 제약 조건 해결과의 충돌을 피하기 위해 다음과 같은 사용자 정의 &lt;code&gt;HasField&lt;/code&gt; 인스턴스는 금지됩니다 (인스턴스 헤드에 나타나는 유형 패밀리에 대한 금지와 같은 일반적인 규칙 외에도).</target>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="translated">이를 위해서는 다음과 같은 유형의 실제 정의를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="translated">타입 패밀리가 존재할 때 타입 추론이 결정될 수 있도록하기 위해, 타입 인스턴스 선언의 형성에 대한 추가 제한을 추가 할 필요가있다 (&amp;ldquo; &lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;개방형 함수를 사용한 타입 검사&lt;/a&gt; &amp;rdquo;의 정의 5 (릴리스 된 조건) 참조) . 인스턴스 선언은 일반적인 형식입니다</target>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="translated">그래프를 더 읽기 쉽게 만들기 위해 &lt;code&gt;hp2ps&lt;/code&gt; 는 각 식별자에 대해 음영 처리 된 밴드를 정렬합니다. 기본 정렬 순서는 가장 큰 영역이있는 밴드를 작은 것 위에 쌓는 것입니다. &lt;code&gt;-d&lt;/code&gt; 옵션은 거친 밴드 (가장 큰 표준 편차와 값의 시리즈를 대표하는 사람들이) 부드러운 사람 위에 쌓인되도록합니다.</target>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="translated">여러 개의 CPU를 사용하려면 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션 과 연결되어 있어야합니다 (연결에 &lt;a href=&quot;phases#options-linker&quot;&gt;영향을주는 옵션&lt;/a&gt; 참조 ). 또한 다음 컴파일러 옵션은 병렬 처리에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="translated">값을 정지하기 위하여 &lt;code&gt;it&lt;/code&gt; 각 명령에 구애 됨이 플래그 &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt; &lt;code&gt;-fno-it&lt;/code&gt; &lt;/a&gt; 설정 될 수있다. &lt;code&gt;it&lt;/code&gt; 변수 (참조에 의한 GHCi 처리하는 방법 그림자 선언에 공간 누수의 원인이 될 수있는 &lt;a href=&quot;#ghci-decls&quot;&gt;유형, 클래스와 다른 선언&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="translated">CAPI와 함께 사용될 때 Haskell 유형에 해당하는 C 유형을 GHC에 알리기 위해 &lt;code&gt;CTYPE&lt;/code&gt; pragma를 유형 정의에 사용할 수 있습니다. 유형을 정의하는 헤더도 선택적으로 지정할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">다중 스레드 설정에서 FFI를 사용하려면 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션을 사용해야합니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="translated">순서대로 &lt;code&gt;ghc&lt;/code&gt; 는 다음 위치에서 패키지 환경을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="translated">일반적인 Haskell에서, &lt;code&gt;f&lt;/code&gt; 는 논쟁에서 게으 르며 따라서 &lt;code&gt;x&lt;/code&gt; 에서는 지연됩니다 . 및 &lt;code&gt;g&lt;/code&gt; 는 인수에 엄격하고, 따라서 또한 엄격한이다 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;Strict&lt;/code&gt; 를 사용하면 &lt;code&gt;f&lt;/code&gt; 의 인수가 암시 적 강타를 받기 때문에 둘 다 엄격 해 집니다.</target>
        </trans-unit>
        <trans-unit id="f0c005424bafd0442e357105c93d1f9cfe1f688c" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s argument gets an implicit bang.</source>
          <target state="translated">일반적인 Haskell에서 &lt;code&gt;f&lt;/code&gt; 는 인수에서 게으 르기 때문에 &lt;code&gt;x&lt;/code&gt; 에서 ; 및 &lt;code&gt;g&lt;/code&gt; 는 인수에 엄격하고, 따라서 또한 엄격한이다 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;Strict&lt;/code&gt; 를 사용하면 &lt;code&gt;f&lt;/code&gt; 의 인수가 암묵적으로 강타 되기 때문에 둘 다 엄격 해 집니다.</target>
        </trans-unit>
        <trans-unit id="1405421d283da798715928c97732511b19ea5e87" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;:</source>
          <target state="translated">다른 상황에서 C 함수는 RTS 클로저 유형에 대한 지식이 필요할 수 있습니다. 다음 예제 에서는 &lt;code&gt;ArrayArray##&lt;/code&gt; &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt; 의 각 &lt;code&gt;ByteArray#&lt;/code&gt; (바이트를 &lt;code&gt;CInt&lt;/code&gt; 배열로 해석) 요소의 첫 번째 요소를 합산합니다 .</target>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="translated">그러나 다른 방법으로 독립형 파생은 일반 파생과 동일한 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="translated">다시 말해, &lt;code&gt;check b = unless b retry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="translated">우리의 상황에서 모듈 &lt;code&gt;TCB_Runner&lt;/code&gt; 는 &lt;code&gt;Dangerous&lt;/code&gt; 모듈을 가져 오지 않고 잘 컴파일됩니다 . 따라서 &lt;code&gt;op&lt;/code&gt; 호출에 사용할 인스턴스를 결정할 때 Dangerous 모듈 의 인스턴스 &lt;code&gt;TC [Int]&lt;/code&gt; 가 가장 구체적 이라고 판단하면 안전하지 않습니다. 이렇게하면 신뢰하지 않는 타사 ( Safe Haskell에서 &lt;code&gt;-XSafe&lt;/code&gt; 를 사용하여 컴파일 된)가 작성한 코드가 기존 코드의 동작을 변경 하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="translated">병렬 GC에서 모든 스레드가 복사 한 밸런스 데이터의 양</target>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="translated">병렬 GC에서는 하나의 스레드에서 복사 한 최대 데이터 양입니다. 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="translated">특히 GHC는 다음 DWARF 섹션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="translated">특히 Haskell 공유 라이브러리 &lt;em&gt;는&lt;/em&gt; 패키지로 만들어야합니다. 어떤 모듈이 어떤 공유 라이브러리에 들어가는 지 자유롭게 지정할 수 없습니다. Haskell 공유 라이브러리는 패키지 경계와 일치해야합니다. 그 이유는 GHC가 동일한 공유 라이브러리 (또는 주 실행 가능 바이너리) &lt;em&gt;내의&lt;/em&gt; 기호에 대한 참조를 다른 공유 라이브러리 &lt;em&gt;간의&lt;/em&gt; 기호에 대한 참조와 다르게 처리하기 때문입니다. 해당 모듈이 동일한 공유 라이브러리 또는 별도의 공유 라이브러리에 로컬로 존재하는 경우 GHC는 가져온 각 모듈에 대해 알아야합니다. 이를 수행하는 방법은 패키지를 사용하는 것입니다. &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 을&lt;/a&gt; 사용할 때개별 패키지의 모듈은 별도의 공유 라이브러리에서 온 것으로 가정하고 동일한 패키지 (또는 기본 &quot;기본&quot;패키지)의 모듈은 동일한 공유 라이브러리 (또는 기본 실행 바이너리) 내에있는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="translated">특히 &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="translated">특히, 이것을 인라인 한 후에 는 루프 본체에 &lt;code&gt;f&lt;/code&gt; 를 직접 노출 시켜 재귀 적 케이스에 대해 전문화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="translated">특히 생성자는 보유자 가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="translated">특히, 인스턴스 선언이 인스턴스 선언 &lt;em&gt;헤드&lt;/em&gt; 에 언급 된 유형 또는 클래스의 정의와 동일한 모듈 에있는 경우 ( &quot; &lt;code&gt;=&amp;gt;&lt;/code&gt; &quot; 뒤에있는 부분 ; &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 완화 된 규칙&lt;/a&gt; 참조 ) GHC는 다음을 수행해야합니다. 어쨌든 해당 인터페이스 파일을 방문하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="translated">특히, &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;newtype&lt;/code&gt; 선언에서 생성자 인수는 임의 순위의 다형성 유형일 수 있습니다. 참조 실시 예에서 &lt;a href=&quot;#univ&quot;&gt;예로&lt;/a&gt; . 그럼에도 불구하고 선언 된 유형은 항상 단형입니다. 기본적으로 GHC는 유형 변수를 다형성 유형 ( &lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt; )으로 인스턴스화하지 않기 때문에 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="translated">특히,이 모듈은 &quot;큰&quot;기능 ( &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 는 ) 단순히의 조성물이다 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 가 a로 하였다 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 예외 안전성. 이것들은 다른 모든 스레드가 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 이전에 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 를 수행하는 경우에만 원 자성을 보장합니다 . 그렇지 않으면 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="translated">특히이 모듈의 기능은 다음 법칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9d41d9ff0d0d0895ae2e1959850587fbcb656b74" translate="yes" xml:space="preserve">
          <source>In particular, the occurrence &lt;code&gt;VarE nm1&lt;/code&gt; refers to the binding &lt;code&gt;VarP nm1&lt;/code&gt;, and is not captured by the binding &lt;code&gt;VarP nm2&lt;/code&gt;.</source>
          <target state="translated">특히, 발생 &lt;code&gt;VarE nm1&lt;/code&gt; 결합을 의미 &lt;code&gt;VarP nm1&lt;/code&gt; 및 결합에 의해 포착되지 &lt;code&gt;VarP nm2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e3faed30034bb62c86f00fd56d131c7714b3f69" translate="yes" xml:space="preserve">
          <source>In practice, the FFI should not be used for a task as simple as reading bytes from a &lt;code&gt;MutableByteArray#&lt;/code&gt;. Users should prefer &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; for this.</source>
          <target state="translated">실제로 FFI는 &lt;code&gt;MutableByteArray#&lt;/code&gt; 에서 바이트를 읽는 것처럼 간단한 작업에 사용해서는 안됩니다 . 사용자는 이를 위해 &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d02df75e8eea52729bdf6cd2eb9e25ca0f13738" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;).</source>
          <target state="translated">이전 릴리스에서 GHC는 바이트 코드 인터프리터에서 &lt;code&gt;unsafe&lt;/code&gt; 호출 대신 &lt;code&gt;safe&lt;/code&gt; 외래 호출 을 수행하여 챕터가 제공하는 자유를 이용했습니다 . 이것은 컴파일 될 때 작동했던 일부 패키지가 GHCi (예 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;# 13730&lt;/a&gt; ) 에서 실패한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="391b2886cb4e0d3786c17223969b938c2fef5e88" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue #13730&lt;/a&gt;).</source>
          <target state="translated">이전 릴리스에서 GHC는 바이트 코드 인터프리터에서 &lt;code&gt;unsafe&lt;/code&gt; 호출 대신 &lt;code&gt;safe&lt;/code&gt; 외부 호출 을 수행하여이 장에서 제공하는 자유를 활용합니다 . 이것은 컴파일 할 때 작동 한 일부 패키지가 GHCi에서 실패한다는 것을 의미했습니다 (예 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue # 13730&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ff8d012302e9131b060a6becba0fe4885a49e66" translate="yes" xml:space="preserve">
          <source>In principle you can use &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; without &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; so that the code is suitable to include into a shared library and we do not do that at the moment.</source>
          <target state="translated">원칙적으로 링크 단계에서 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 없이 &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . 즉, 런타임 시스템과 모든 기본 라이브러리를 새 공유 라이브러리에 정적으로 링크해야합니다. 이것은 매우 크지 만 독립형 공유 라이브러리를 만듭니다. 그러나 대부분의 플랫폼에서 모든 정적 라이브러리는 &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 으로 빌드되어 코드가 공유 라이브러리에 포함하기에 적합해야하며 현재는 그렇게하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fd263cf5ce99e2b91836dc4e35a2d6bb18f488af" translate="yes" xml:space="preserve">
          <source>In principle, with a suitable class declaration with a functional dependency, it&amp;rsquo;s possible that this type is not ambiguous; but GHC nevertheless rejects it. The type variables mentioned in the context of the data type declaration must be among the type parameters of the data type.</source>
          <target state="translated">원칙적으로 함수 의존성을 가진 적절한 클래스 선언으로이 유형이 모호하지 않을 수 있습니다. 그럼에도 불구하고 GHC는이를 거부합니다. 데이터 유형 선언과 관련하여 언급 된 유형 변수는 데이터 유형의 유형 매개 변수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="18e2f91b13004cb3ee73758eb6c0f3436fbf8f70" translate="yes" xml:space="preserve">
          <source>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</source>
          <target state="translated">레코드 구성 및 레코드 패턴 일치에서 범위에 공통 필드 이름을 가진 두 개의 서로 다른 데이터 유형이 있더라도 참조되는 필드는 전혀 모호하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="026f7b4f745c03773b13fa4d11e7929e66eb04db" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">간단히 말해서,이 라이브러리의 모든 &quot;캐치&quot;메커니즘은 &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈의 함수에 의해 발생 된 예외를 포착 할 수 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c7c0b572397dc91bfdb2bb7d885052532168e385" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">요컨대,이 라이브러리의 모든 &quot;catching&quot;메커니즘은 &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 모듈의 함수에 의해 발생한 예외를 잡을 수 없으며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="934808fb13fd2c8c5cce75253dd4e268d2a4d578" translate="yes" xml:space="preserve">
          <source>In short, if you compile a module and its interface changes, then all the modules that import that interface &lt;em&gt;must&lt;/em&gt; be re-compiled.</source>
          <target state="translated">즉, 모듈을 컴파일하고 해당 인터페이스가 변경되면 해당 인터페이스를 가져 오는 모든 모듈을 다시 컴파일 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f81140bb54ceba3a8d0fad4549fca0af74b151f4" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;#9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">요컨대, 패턴 동의어에 대해 GADT와 유사한 동작을 원한다면 ( &lt;code&gt;S1&lt;/code&gt; 과 같은 구체적인 데이터 생성자와는 달리 ) 명시 적으로 제공된 동등성을 사용하여 해당 유형을 작성해야합니다. &lt;code&gt;S1&lt;/code&gt; 과 같은 구체적인 데이터 생성자 의 경우 유형 서명을 &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; 또는 &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; ; 둘은 동등합니다. 패턴 동의어는 그렇지 않습니다. 위의 두 경우를 구별하기 위해 두 형식이 다릅니다. ( 이 선택에 대한 논의는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;# 9953&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="32c8b3bf997296fa73e6193137e7fe4e16c83b1a" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Issue #9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">요컨대, 패턴 동의어에 대해 GADT와 유사한 동작을 원한다면 ( &lt;code&gt;S1&lt;/code&gt; 과 같은 구체적인 데이터 생성자와 달리 ) 명시 적으로 제공된 동등성을 사용하여 해당 유형을 작성해야합니다. &lt;code&gt;S1&lt;/code&gt; 과 같은 구체적인 데이터 생성자의 경우 &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; 또는 &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; 로 형식 서명을 작성할 수 있습니다 . 둘은 동일합니다. 패턴 동의어의 경우는 그렇지 않습니다. 위의 두 경우를 구별하기 위해 두 형식이 다릅니다. ( 이 선택에 대한 논의는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;문제 # 9953&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="c2cfc1f8c0043394ab94a925d7089c33080293c8" translate="yes" xml:space="preserve">
          <source>In short, quantifed constraints do not introduce incoherence.</source>
          <target state="translated">요컨대, 정량화 된 구속 조건은 일관성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="eedb3f453802c917804d8787ef3886b3897a16d7" translate="yes" xml:space="preserve">
          <source>In short: GHC does &lt;em&gt;not&lt;/em&gt; propagate kind information from the members of a class instance declaration into the instance declaration head.</source>
          <target state="translated">간단히 말해 GHC는 클래스 인스턴스 선언 멤버의 종류 정보를 인스턴스 선언 헤드로 전파 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="65fcdd4e01ef4cdb5c7448159811829c535afe34" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">어떤 경우에는, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 취소 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 작업을 :</target>
        </trans-unit>
        <trans-unit id="b6129fb34e144fcdfe206a301e6dfcb025a1c2ff" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">어떤 경우에는, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 는 취소 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 작업을 :</target>
        </trans-unit>
        <trans-unit id="7dca494ed5d22b408ce97c79a38cce42379ecc3f" translate="yes" xml:space="preserve">
          <source>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</source>
          <target state="translated">일부 모나드에서는 적용 연산자를 사용하는 것이 모나드 바인드보다 효율적입니다. 예를 들어, 더 많은 병렬 처리를 가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dc076e52a11bd5ce04c056123ea9f1e10b44f69" translate="yes" xml:space="preserve">
          <source>In summary, Safe Haskell consists of the following three language flags:</source>
          <target state="translated">Safe Haskell은 다음 세 가지 언어 플래그로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c0610e4e2f239ff00ac0559246fa585a0148acde" translate="yes" xml:space="preserve">
          <source>In summary, given an &lt;code&gt;mdo&lt;/code&gt; expression, GHC first performs segmentation, introducing &lt;code&gt;rec&lt;/code&gt; blocks to wrap over minimal recursive groups. Then, each resulting &lt;code&gt;rec&lt;/code&gt; is desugared, using a call to &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; as described in the previous section. The original &lt;code&gt;mdo&lt;/code&gt;-expression typechecks exactly when the desugared version would do so.</source>
          <target state="translated">요약하면, &lt;code&gt;mdo&lt;/code&gt; 식이 주어지면 GHC는 먼저 세그먼트 화를 수행 하여 최소 재귀 그룹을 감싸는 &lt;code&gt;rec&lt;/code&gt; 블록을 도입 합니다. 그런 다음 이전 단원에서 설명한대로 &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; 를 호출하여 각 결과 &lt;code&gt;rec&lt;/code&gt; 의 설탕을 제거 합니다. 원래 &lt;code&gt;mdo&lt;/code&gt; -expression 유형은 설탕 이 제거 된 버전이 언제 그렇게하는지 정확하게 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a10dd2ac36a1ae45ee7e6746793e9b0203b43531" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;encodeByteStringWithF&lt;/code&gt;) they will very likely never be.</source>
          <target state="translated">표현력의 측면에서, 기능 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; 을 구성하는 충분할 것이다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서들 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 의. 이 기능의 융합 변형은보다 효율적인 구현을 허용하기 때문에 제공됩니다. 우리의 컴파일러는 아직 충분히 똑똑하지 않습니다. 그리고 사용 된 최적화 중 일부 ( &lt;code&gt;encodeByteStringWithF&lt;/code&gt; 코드 참조)의 경우 최적화 되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="16093d6461ecbdcf12ae1c671e142ce8282ad0b5" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (aka bound) threads are much more expensive than &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (aka unbound) threads, because a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread is tied to a particular OS thread, whereas a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread can be run by any OS thread. Context-switching between a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread and a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread is many times more expensive than between two &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads.</source>
          <target state="translated">성능의 측면에서, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (일명 바인딩) 스레드가 훨씬 더 비싼보다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 때문에, (일명 언 바운드) 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 의 스레드가 특정 OS 스레드에 연결되어있는 반면, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드가 어떤 OS 스레드를 실행할 수 있습니다. 간의 콘텍스트 스위칭 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 의 스레드 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드는 훨씬 더 많은 비용이 둘 개 사이보다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드.</target>
        </trans-unit>
        <trans-unit id="bce56fe3f42df3f84c1b74ed1a9d8786ce76ea2b" translate="yes" xml:space="preserve">
          <source>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as &amp;ldquo;moving&amp;rdquo; the floating point by one bit left (negative) or right (positive). Here are some examples:</source>
          <target state="translated">기본 비트 인코딩과 관련하여 각 16 진 숫자는 4 비트에 해당하며 지수는 부동 소수점을 1 비트 왼쪽 (음수) 또는 오른쪽 (양수)으로 &quot;이동&quot;하는 것으로 생각할 수 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="4c29bd546b673357d6a340429155e16543ce1ef1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 는 일정한 실용적 펑 (순회와 동등해야 &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26bd18f823787461b100c3022f6a3b7c840dc2a6" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수는 정체 실용적 펑 (통과을와 동일해야 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96a50628ee823a13660f1210d45eabd5be493de8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 는 일정한 실용적 펑 (순회와 동등해야 &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b0439badce801cd06d5468b87c04f9c720d7a99" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수는 정체 실용적 펑 (통과을와 동일해야 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca7aaa131ade1d4a8a95415db546c6e55e36ffda" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ModIface&lt;/code&gt; datatype you can find lots of useful information, including the exported definitions and type class instances.</source>
          <target state="translated">에서 &lt;code&gt;ModIface&lt;/code&gt; 의 데이터 타입 내 보낸 정의와 유형 클래스의 인스턴스를 포함하여 유용한 정보를 많이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9e4b692ce0d40c03d30c364c1d3096a5795a987" translate="yes" xml:space="preserve">
          <source>In the above desugarings, the functions &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt; are all methods of the &lt;code&gt;IsList&lt;/code&gt; class, which is itself exported from the &lt;code&gt;GHC.Exts&lt;/code&gt; module. The type class is defined as follows:</source>
          <target state="translated">위의 &lt;code&gt;toList&lt;/code&gt; 에서 &lt;code&gt;fromList&lt;/code&gt; , fromList 및 &lt;code&gt;fromListN&lt;/code&gt; 함수 는 모두 &lt;code&gt;IsList&lt;/code&gt; 클래스의 메소드이며, 자체적으로 &lt;code&gt;GHC.Exts&lt;/code&gt; 모듈 에서 내 보냅니다 . 타입 클래스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4825ce73481d56bef5ff3baeddca3bd6b9d29055" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">전화에서 &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt; 경우, &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 값은 전체 정밀도로 표시됩니다; 만약 &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , 기껏 &lt;code&gt;d&lt;/code&gt; 소수점 숫자 후 나타낸다.</target>
        </trans-unit>
        <trans-unit id="a51c3b2c73eac013b9c52be99faf3b0167ac1d7a" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">전화에서 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt; 경우, &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 값은 전체 정밀도로 표시됩니다; 만약 &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , 기껏 &lt;code&gt;d&lt;/code&gt; 소수점 숫자 후 나타낸다.</target>
        </trans-unit>
        <trans-unit id="20f3428ed1923f90f0f3d4207a60933c2d70d92e" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">전화에서 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt; 경우, &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 값은 전체 정밀도로 표시됩니다; 만약 &lt;code&gt;digs&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , 기껏 &lt;code&gt;d&lt;/code&gt; 소수점 숫자 후 나타낸다.</target>
        </trans-unit>
        <trans-unit id="faf271f3b7e45777b426c7cffb5c33694e0dd460" translate="yes" xml:space="preserve">
          <source>In the caret diagnostics, there is currently no inheritance at all between &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">캐럿 진단에서는 현재 &lt;code&gt;margin&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;fatal&lt;/code&gt; 사이에 상속이 전혀 없습니다 .</target>
        </trans-unit>
        <trans-unit id="df6b03ed8eec1645f1ec33aca8ebc6b982b543ce" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, we append the encodings of the two subcomponents:</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 우리는 두 개의 하위의 인코딩을 추가 :</target>
        </trans-unit>
        <trans-unit id="a978f8a308124dfc5a94e8b84169bed1e73065cf" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, we produce &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; depending on whether the constructor of the value provided is located on the left or on the right:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 의 경우 제공된 값의 생성자가 왼쪽에 있는지 오른쪽에 있는지에 따라 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="ce418c4b3f9c3b015c79b89b8c9bc6967c098d2d" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용될 때 시작 값 (일반적으로 연산자의 왼쪽 ID) 및 목록은 2 진 연산자를 사용하여 왼쪽에서 오른쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="402a6cba8bb6099d8590be06c5b33a8b61bcddf5" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용되면 시작 값 (일반적으로 연산자의 오른쪽 ID)과 목록은 2 진 연산자를 사용하여 오른쪽에서 왼쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="685a71a3a3feec5434325876c2b1603c04dc1092" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용될 때 시작 값 (일반적으로 연산자의 왼쪽 ID) 및 목록은 2 진 연산자를 사용하여 왼쪽에서 오른쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="736cf45d430966ca499dea036acc85e2fd726f3c" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용되면 시작 값 (일반적으로 연산자의 오른쪽 ID)과 목록은 2 진 연산자를 사용하여 오른쪽에서 왼쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d2c4ff0ca5914473682d3bb850acf33cf8e28c10" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용될 때 시작 값 (일반적으로 연산자의 왼쪽 ID) 및 목록은 2 진 연산자를 사용하여 왼쪽에서 오른쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="814e67cd70bc9b16fbc05fe331eda86206bb01d8" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">리스트의 경우, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 은 2 진 연산자에 적용되면 시작 값 (일반적으로 연산자의 오른쪽 ID)과 목록은 2 진 연산자를 사용하여 오른쪽에서 왼쪽으로 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="9d49a0dc9233f8cd0bbb34abc56b57be8989f4d7" translate="yes" xml:space="preserve">
          <source>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type &lt;code&gt;n&lt;/code&gt; (provided it has an &lt;code&gt;fmap&lt;/code&gt;, as well as the comprehension being over an arbitrary monad.</source>
          <target state="translated">변환 이해의 경우 그룹이 임의의 임의의 유형 &lt;code&gt;n&lt;/code&gt; 에 대해 매개 변수화됨을 알 수 있습니다 (여기에는 &lt;code&gt;fmap&lt;/code&gt; 이 있고 이해는 임의 모나드에 대한 것임).</target>
        </trans-unit>
        <trans-unit id="3a3ec5fd8ab5dd582ca482ba430b56b04ee9d354" translate="yes" xml:space="preserve">
          <source>In the case where a module is compiled without one of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag, then M is marked as safe. Otherwise, it is marked as unsafe.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하지 않고 모듈을 컴파일하는 경우 GHC는 모듈이 안전하다고 간주 될 수 있는지 스스로 알아 내려고 시도합니다. 이 안전 유추는 모듈을 신뢰할 수있는 것으로 표시하지 않으며 안전하지 않은 것으로 안전합니다. GHC는 간단한 방법을 사용하여이를 모듈 M에 대해 결정합니다. M이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그에서 오류없이 컴파일되면 M은 안전 으로 표시됩니다. 그렇지 않으면 안전하지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bef7088bfdbcf4a4161af79eaa7b29eb8e585121" translate="yes" xml:space="preserve">
          <source>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</source>
          <target state="translated">패턴 유형 시그니처의 모든 유형 변수가 이미 범위 내에있는 경우 (즉, 엔 클로징 컨텍스트에 의해 바인딩 됨) 문제는 간단합니다. 시그니처는 패턴의 유형을 명백한 방식으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="dd7dd4c533ac4dfdb79170f8873e9bdd1a07434d" translate="yes" xml:space="preserve">
          <source>In the class declaration, nothing constrains the kind of the type &lt;code&gt;a&lt;/code&gt;, so it becomes a poly-kinded type variable &lt;code&gt;(a :: k)&lt;/code&gt;. Yet, in the instance declaration, the right-hand side of the associated type instance &lt;code&gt;b -&amp;gt; b&lt;/code&gt; says that &lt;code&gt;b&lt;/code&gt; must be of kind &lt;code&gt;Type&lt;/code&gt;. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind &lt;code&gt;Type&lt;/code&gt;, as opposed to types of any kind. However, GHC does &lt;em&gt;not&lt;/em&gt; do this.</source>
          <target state="translated">클래스 선언에서 &lt;code&gt;a&lt;/code&gt; 유형의 종류를 제한하는 것은 없으므로 다종 유형 변수 &lt;code&gt;(a :: k)&lt;/code&gt; 됩니다. 그러나 인스턴스 선언에서 연관된 유형 인스턴스 &lt;code&gt;b -&amp;gt; b&lt;/code&gt; 의 오른쪽 은 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;Type&lt;/code&gt; 이어야 한다고 말합니다 . GHC는 이론적으로이 정보를 인스턴스 헤드로 다시 전파하고 해당 인스턴스 선언 이 모든 유형의 유형과 달리 &lt;code&gt;Type&lt;/code&gt; 유형의 유형에만 적용되도록 할 수 있습니다. 그러나 GHC는 &lt;em&gt;이를&lt;/em&gt; 수행 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea0fe630422f6fbaa324604dd0d23443b8c3800" translate="yes" xml:space="preserve">
          <source>In the common case where &lt;code&gt;CProv&lt;/code&gt; is empty, (i.e., &lt;code&gt;()&lt;/code&gt;), it can be omitted altogether in the above pattern type signature for &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CProv&lt;/code&gt; 가 비어 있는 일반적인 경우 (즉, &lt;code&gt;()&lt;/code&gt; )에서는 &lt;code&gt;P&lt;/code&gt; 의 패턴 유형 시그니처에서 모두 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="738595723a083effce19571c75a1705b54ce2cd0" translate="yes" xml:space="preserve">
          <source>In the current GHC implementation, the call stack is only available if the program was compiled with &lt;code&gt;-prof&lt;/code&gt;; otherwise &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; behaves exactly like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;. Entries in the call stack correspond to &lt;code&gt;SCC&lt;/code&gt; annotations, so it is a good idea to use &lt;code&gt;-fprof-auto&lt;/code&gt; or &lt;code&gt;-fprof-auto-calls&lt;/code&gt; to add SCC annotations automatically.</source>
          <target state="translated">현재 GHC 구현에서 호출 스택은 프로그램이 &lt;code&gt;-prof&lt;/code&gt; 로 컴파일 된 경우에만 사용 가능합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; 은 정확히 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 처럼 동작 합니다 . 호출 스택의 항목은 &lt;code&gt;SCC&lt;/code&gt; 주석에 해당 하므로 &lt;code&gt;-fprof-auto&lt;/code&gt; 또는 &lt;code&gt;-fprof-auto-calls&lt;/code&gt; 를 사용하여 SCC 주석을 자동으로 추가 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="acbdce2c4062331f2c3f39e4ae942c4efb63986d" translate="yes" xml:space="preserve">
          <source>In the definition for &lt;code&gt;F&lt;/code&gt;, the two equations are incompatible &amp;ndash; their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type &lt;code&gt;F a&lt;/code&gt; does not simplify; only a type such as &lt;code&gt;F Double&lt;/code&gt; will simplify to &lt;code&gt;Char&lt;/code&gt;. In &lt;code&gt;G&lt;/code&gt;, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, &lt;code&gt;G a&lt;/code&gt; will simplify to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 에 대한 정의 에서 두 방정식은 호환되지 않습니다. 패턴이 서로 다르지 않지만 오른쪽이 일치하지 않습니다. 따라서 GHC가 두 번째 방정식을 선택하기 전에 첫 번째 방정식을 절대 적용 할 수 없는지 확인해야합니다. 따라서 유형 &lt;code&gt;F a&lt;/code&gt; 는 단순화되지 않습니다. &lt;code&gt;F Double&lt;/code&gt; 과 같은 유형 만 &lt;code&gt;Char&lt;/code&gt; 로 단순화됩니다 . 반면에 &lt;code&gt;G&lt;/code&gt; 에서는 두 방정식이 호환됩니다. 따라서 GHC는 두 번째 방정식을 볼 때 첫 번째 방정식을 무시할 수 있습니다. 그래서, &lt;code&gt;G a&lt;/code&gt; 는 로 단순화 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="846c20df94f9314fa1fe586ab3d9172b13b606cb" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type withing generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="translated">&lt;code&gt;gmapQ&lt;/code&gt; &lt;em&gt;x&lt;/em&gt; 콤비 네이터 의 정의 에서 쿼리의 결과 유형에는 용어 인수의 (다형성) 유형이 포함되지 않으므로 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 유형 에서 &lt;code&gt;c&lt;/code&gt; 에 대한 팬텀 유형 생성자를 사용합니다 . &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; 의 정의에서는 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 이 왼쪽 연관 이기 때문에 일반 상수 유형 생성자를 사용하기 때문에 왼쪽 하위 연관 연산을 즉시 하위 항에 접는 데 적합합니다. gmapQr의 정의에는 추가 노력이 필요합니다. 왼쪽 연관 생성자 응용 프로그램과 오른쪽 연관 이진 연산 (예 : &lt;code&gt;(:)&lt;/code&gt; ) 을 중재하기 위해 고차 누적 트릭을 사용합니다.). 쿼리가 &lt;code&gt;r&lt;/code&gt; 유형의 값을 계산하려는 경우 일반 접기를 사용하는 결과 유형은 &lt;code&gt;r -&amp;gt; r&lt;/code&gt; 입니다. 따라서 접기의 결과는 우리가 마침내 올바른 단위를 전달하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="172ded5aaf2bf60400ff8b3fbe797e04c36dee1c" translate="yes" xml:space="preserve">
          <source>In the degenerate case where all the alternatives have zero width, such as the &lt;code&gt;Bool&lt;/code&gt;-like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt;, the unboxed sum layout only has an &lt;code&gt;Int32&lt;/code&gt; tag field (i.e., the whole thing is represented by an integer).</source>
          <target state="translated">&lt;code&gt;Bool&lt;/code&gt; - like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt; 와 같이 모든 대안의 너비가 0 인 퇴화 된 경우 상자의 합계 레이아웃에는 &lt;code&gt;Int32&lt;/code&gt; 태그 필드 만 있습니다 (즉, 모든 것이 표시됩니다) 정수로).</target>
        </trans-unit>
        <trans-unit id="eae7ddef52aa6d501f88a9704bbcc99c4b28932e" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">설명서에서 \ (n \)은 목록의 요소 수이고 \ (d \)는 목록의 고유 요소 수입니다. \ (W \)는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f0778e8d7eb2efc83b2b32dc144b880b32c199c0" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문서에서 \ (n \)은 목록의 요소 수이고 \ (d \)는 목록의 고유 요소 수입니다. \ (W \)는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f8410efb81dbdeacb0d6540b0e647a317447ad44" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">하스켈 이외의 다른 프로그램의 일부로 ghc 컴파일 된 코드를 포함시키려는 경우, RTS는 링크 타임 에 &lt;code&gt;main()&lt;/code&gt; 정의를 제공하지 않을 것 입니다. 링크 할 때 컴파일러에 &lt;code&gt;-no-hs-main&lt;/code&gt; 려면 -no-hs-main을 사용하십시오 . &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;자체 main () 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d261a91a10cc118ec325a4c82debf0de9dec298f" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;Danger&lt;/code&gt; can import module &lt;code&gt;RIO&lt;/code&gt; because &lt;code&gt;RIO&lt;/code&gt; is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;Danger&lt;/code&gt; can make use of the &lt;code&gt;rioReadFile&lt;/code&gt; and &lt;code&gt;rioWriteFile&lt;/code&gt; functions to access permitted file names. The main application then imports both &lt;code&gt;RIO&lt;/code&gt; and &lt;code&gt;Danger&lt;/code&gt;. To run the plugin, it calls &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. The application is safe in the knowledge that the only &lt;code&gt;IO&lt;/code&gt; to ensue will be to files whose paths were approved by the &lt;code&gt;pathOK&lt;/code&gt; test.</source>
          <target state="translated">이 예제에서 &lt;code&gt;RIO&lt;/code&gt; 는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 로 컴파일 되므로 &lt;code&gt;Danger&lt;/code&gt; 는 모듈 &lt;code&gt;RIO&lt;/code&gt; 를 가져올 수 있습니다 . 따라서 &lt;code&gt;Danger&lt;/code&gt; 는 &lt;code&gt;rioReadFile&lt;/code&gt; 및 &lt;code&gt;rioWriteFile&lt;/code&gt; 함수를 사용하여 허용 된 파일 이름에 액세스 할 수 있습니다. 메인 어플리케이션은 &lt;code&gt;RIO&lt;/code&gt; 와 &lt;code&gt;Danger&lt;/code&gt; 를 모두 가져옵니다 . 플러그인을 실행하기 위해 &lt;code&gt;IO&lt;/code&gt; 모나드 내에서 &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; 를 호출합니다 . 응용 프로그램은 경로 &lt;code&gt;pathOK&lt;/code&gt; 테스트에 의해 경로가 승인 된 파일에 대해서만 &lt;code&gt;IO&lt;/code&gt; 가 발생 한다는 사실을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04e6cf746c3b3e5d963876bd4cd89448b3120476" translate="yes" xml:space="preserve">
          <source>In the examples above, all promoted constructors are prefixed with a single quote mark &lt;code&gt;'&lt;/code&gt;. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</source>
          <target state="translated">위의 예에서 모든 승격 된 생성자 앞에 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ) 가 붙습니다 . 이 표시는 GHC에게 데이터 생성자 네임 스페이스에서 유형 (생성자) 네임 스페이스가 아닌 이름을 찾도록 지시합니다. 치다</target>
        </trans-unit>
        <trans-unit id="40ee1ceda8e59fc5b01c325869581e1e58fcdd95" translate="yes" xml:space="preserve">
          <source>In the first application of &lt;code&gt;f&lt;/code&gt;, we had to do some more type reconstruction in order to recover the result type of &lt;code&gt;f&lt;/code&gt;. But after that, we are free to use &lt;code&gt;f&lt;/code&gt; normally.</source>
          <target state="translated">의 첫 번째 응용 프로그램에서 &lt;code&gt;f&lt;/code&gt; , 우리의 결과 유형 복구하기 위해 좀 더 많은 종류의 재건을해야했다 &lt;code&gt;f&lt;/code&gt; . 그러나 그 후에는 정상적으로 &lt;code&gt;f&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="149193862750cd07d67aa98378a43e7fa5bcd8bc" translate="yes" xml:space="preserve">
          <source>In the first example above, &lt;code&gt;_x&lt;/code&gt; is generalised over (and is effectively replaced by a fresh type variable &lt;code&gt;a&lt;/code&gt;). In the second example, &lt;code&gt;_x&lt;/code&gt; is unified with the &lt;code&gt;Bool&lt;/code&gt; type, and as &lt;code&gt;Bool&lt;/code&gt; implements the &lt;code&gt;Show&lt;/code&gt; type class, the constraint &lt;code&gt;Show Bool&lt;/code&gt; can be simplified away.</source>
          <target state="translated">위의 첫 번째 예에서 &lt;code&gt;_x&lt;/code&gt; 는 일반화되고 (신선한 유형 변수 &lt;code&gt;a&lt;/code&gt; 로 효과적으로 대체 됨 ). 두 번째 예에서 &lt;code&gt;_x&lt;/code&gt; 는 &lt;code&gt;Bool&lt;/code&gt; 유형으로 통합 되며 &lt;code&gt;Bool&lt;/code&gt; 이 &lt;code&gt;Show&lt;/code&gt; 유형 클래스를 구현함에 따라 &lt;code&gt;Show Bool&lt;/code&gt; 제약 조건을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6ea9d39cdb3d6f149abc95c32c55d1e377bfe4" translate="yes" xml:space="preserve">
          <source>In the first example, the kind variable &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;invisible&lt;/em&gt; argument to &lt;code&gt;ProxyKInvis&lt;/code&gt;. In other words, a user does not need to instantiate &lt;code&gt;k&lt;/code&gt; explicitly, as kind inference automatically determines what &lt;code&gt;k&lt;/code&gt; should be. For instance, in &lt;code&gt;ProxyKInvis True&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; is inferred to be &lt;code&gt;Bool&lt;/code&gt;. This is reflected in the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;:</source>
          <target state="translated">첫 번째 예에서 종류 변수 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;ProxyKInvis&lt;/code&gt; 에 대한 &lt;em&gt;보이지 않는&lt;/em&gt; 인수 입니다. 즉, 종류 추론이 &lt;code&gt;k&lt;/code&gt; 가 무엇인지 자동으로 결정 하므로 사용자는 &lt;code&gt;k&lt;/code&gt; 를 명시 적으로 인스턴스화 할 필요가 없습니다 . 예를 들어 &lt;code&gt;ProxyKInvis True&lt;/code&gt; 에서 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;Bool&lt;/code&gt; 로 추론됩니다 . 이것은 &lt;code&gt;ProxyKInvis&lt;/code&gt; 의 종류에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4e49151ec338f81e6976a10a88331d5852242bf" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;Haskell file&amp;rdquo; is the main output (usually a &lt;code&gt;.hs&lt;/code&gt; file), &amp;ldquo;compiled Haskell file&amp;rdquo; is the Haskell file after &lt;code&gt;ghc&lt;/code&gt; has compiled it to C (i.e. a &lt;code&gt;.hc&lt;/code&gt; file), &amp;ldquo;C program&amp;rdquo; is the program that outputs the Haskell file, &amp;ldquo;C file&amp;rdquo; is the optionally generated C file, and &amp;ldquo;C header&amp;rdquo; is its header file.</source>
          <target state="translated">다음에서 &quot;Haskell 파일&quot;은 기본 출력 (일반적으로 &lt;code&gt;.hs&lt;/code&gt; 파일)이고 &quot;컴파일 된 Haskell 파일&quot;은 &lt;code&gt;ghc&lt;/code&gt; 가 C (예 : &lt;code&gt;.hc&lt;/code&gt; 파일)로 컴파일 한 후 Haskell 파일입니다 . &quot;C 프로그램&quot;은 Haskell 파일을 출력하는 프로그램 인 경우&amp;ldquo;C 파일&amp;rdquo;은 선택적으로 생성 된 C 파일이고&amp;ldquo;C 헤더&amp;rdquo;는 해당 헤더 파일입니다.</target>
        </trans-unit>
        <trans-unit id="dc1456dc1bb5376e50df9356963ec4ad4e2b367b" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;h&lt;/code&gt; we use the record selectors &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; to extract the polymorphic bind and return functions from the &lt;code&gt;MonadT&lt;/code&gt; data structure, rather than using pattern matching.</source>
          <target state="translated">함수 &lt;code&gt;h&lt;/code&gt; 에서 레코드 선택기 &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;bind&lt;/code&gt; 를 사용하여 패턴 일치를 사용하는 대신 &lt;code&gt;MonadT&lt;/code&gt; 데이터 구조 에서 다형성 바인드 및 리턴 함수를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="3c2ee3eafdcad4b683c78d591fee52c85b813144" translate="yes" xml:space="preserve">
          <source>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</source>
          <target state="translated">향후 GHC는 종속 DLL의 위치 제공과 같은 더 많은 용도로 매니페스트 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c26d49122d64dd0270b09c279fadaf85a7e889c" translate="yes" xml:space="preserve">
          <source>In the last line, we use the promoted constructor &lt;code&gt;'MkCompose&lt;/code&gt;, which has kind</source>
          <target state="translated">마지막 줄은 승진 생성자 사용 &lt;code&gt;'MkCompose&lt;/code&gt; 종류가 있습니다,</target>
        </trans-unit>
        <trans-unit id="6ea81a9e9ab238a60258241f86c06e46f72fec13" translate="yes" xml:space="preserve">
          <source>In the last section we saw that besides a name, a &lt;code&gt;CoreDoPluginPass&lt;/code&gt; takes a pass of type &lt;code&gt;PluginPass&lt;/code&gt;. A &lt;code&gt;PluginPass&lt;/code&gt; is a synonym for &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;. &lt;code&gt;ModGuts&lt;/code&gt; is a type that represents the one module being compiled by GHC at any given time.</source>
          <target state="translated">마지막 섹션에서 우리는 이름 외에 &lt;code&gt;CoreDoPluginPass&lt;/code&gt; 가 &lt;code&gt;PluginPass&lt;/code&gt; 유형의 패스를 취하는 것을 보았습니다 . &lt;code&gt;PluginPass&lt;/code&gt; 는 동의어입니다 &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; . &lt;code&gt;ModGuts&lt;/code&gt; 는 주어진 시간에 GHC에 의해 컴파일되는 하나의 모듈을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e7151264545101799acf59e7b7e571c55db95bd2" translate="yes" xml:space="preserve">
          <source>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint &lt;code&gt;C t&lt;/code&gt;</source>
          <target state="translated">클래스 제약 조건 해결하려고 할 때 중복 결정의 관점에서, 인스턴스 조회는 다음과 같이 작동 &lt;code&gt;C t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53eb63bc56e230d6466f7d38014cd8cc4cf52862" translate="yes" xml:space="preserve">
          <source>In the messages from the compiler, we see that there is no line for &lt;code&gt;D&lt;/code&gt;. This is because it isn&amp;rsquo;t necessary to compile &lt;code&gt;D&lt;/code&gt;, because the source and everything it depends on is unchanged since the last compilation.</source>
          <target state="translated">컴파일러의 메시지에서 &lt;code&gt;D&lt;/code&gt; 에 대한 줄이 없다는 것을 알 수 있습니다 . 이는 &lt;code&gt;D&lt;/code&gt; 를 컴파일 할 필요가 없기 때문입니다. 소스와 소스가 의존하는 모든 것은 마지막 컴파일 이후 변경되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ddeb2139081c601845dbe769a075fe10d73419d8" translate="yes" xml:space="preserve">
          <source>In the olden days, GHC compared the newly-generated &lt;code&gt;.hi&lt;/code&gt; file with the previous version; if they were identical, it left the old one alone and didn&amp;rsquo;t change its modification date. In consequence, importers of a module with an unchanged output &lt;code&gt;.hi&lt;/code&gt; file were not recompiled.</source>
          <target state="translated">예전에는 GHC가 새로 생성 된 &lt;code&gt;.hi&lt;/code&gt; 파일을 이전 버전과 비교했습니다 . 그것들이 동일하다면, 그것은 오래된 것을 그대로 두었고 수정 날짜를 변경하지 않았습니다. 결과적으로 출력 &lt;code&gt;.hi&lt;/code&gt; 파일이 변경되지 않은 모듈의 가져 오기 프로그램은 다시 컴파일되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="374581211f11803a65e2cf204f4183e85b4fceb6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">위의 출력에서 &lt;code&gt;T&lt;/code&gt; 에는 두 가지 종류의 변수 ( &lt;code&gt;k&lt;/code&gt; 및 &lt;code&gt;l&lt;/code&gt; )와 두 가지 종류의 변수 ( &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; )가 있습니다. 참고 &lt;code&gt;k&lt;/code&gt; 는 이다 &lt;em&gt;유추&lt;/em&gt; 변수 &lt;code&gt;l&lt;/code&gt; A는 &lt;em&gt;특정&lt;/em&gt; 변수 (참조 : &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;입력 변수 지정 유추 대를&lt;/a&gt; 유형에 약간 다른 구문을 사용하므로 그 결과,이 표시된다) &lt;code&gt;T @{k} @l a b&lt;/code&gt; . &lt;code&gt;l&lt;/code&gt; 의 응용 프로그램 ( &lt;code&gt;@l&lt;/code&gt; 사용 )은 visible type 응용 프로그램의 표준 구문입니다 ( &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; 참조 ). 적용 &lt;code&gt;k&lt;/code&gt; (함께 &lt;code&gt;@{k}&lt;/code&gt; 그러나 @ {k} )는 유추 된 유형 변수의 가시적 유형 적용을 위해 가상 구문을 사용합니다. 이 구문은 현재 프로그래머에게 노출되지 않지만 그럼에도 불구하고 &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a5a27aca496c351b26fd16433d9f2aacedebfda" translate="yes" xml:space="preserve">
          <source>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</source>
          <target state="translated">이 백서와 이전 구현에서 스택의 값은 단일 인수로 환경의 오른쪽에 짝을 이루었지만 이제 환경과 스택은 별도의 인수입니다.</target>
        </trans-unit>
        <trans-unit id="e4a4ad8ff9e2ea2640cf5cde3b222326c4f733bc" translate="yes" xml:space="preserve">
          <source>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</source>
          <target state="translated">이전 예제에서는 조건식을 사용하여 화살표에 대한 입력을 구성했습니다. 때때로 우리는 다음과 같이 조건부로 다른 명령을 실행하려고합니다.</target>
        </trans-unit>
        <trans-unit id="53458cc6655e7a520b6f10bf393f2ad481ee4cd4" translate="yes" xml:space="preserve">
          <source>In the second declaration, GHC cannot immediately tell that &lt;code&gt;k&lt;/code&gt; should be a dependent variable, and so the declaration is rejected.</source>
          <target state="translated">두 번째 선언에서 GHC는 &lt;code&gt;k&lt;/code&gt; 가 종속 변수 여야 함을 즉시 알 수 없으므로 선언이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e04af78973d3e47e134276ff85a7f3c652f7d13c" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;visible&lt;/em&gt; argument to &lt;code&gt;ProxyKVis&lt;/code&gt;. That is to say, &lt;code&gt;k&lt;/code&gt; is an argument that users must provide explicitly when applying &lt;code&gt;ProxyKVis&lt;/code&gt;. For example, &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; is a well formed type.</source>
          <target state="translated">두 번째 예에서는 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;ProxyKVis&lt;/code&gt; 에 대한 &lt;em&gt;가시적&lt;/em&gt; 인수 입니다. 즉, &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;ProxyKVis&lt;/code&gt; 를 적용 할 때 사용자가 명시 적으로 제공해야하는 인수입니다 . 예를 들어 &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; 는 잘 구성된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="55addee8e051e63bec155782732ce1d09c9a2858" translate="yes" xml:space="preserve">
          <source>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</source>
          <target state="translated">이전 섹션의 간단한 경우, 지정된 변수가 왼쪽에서 오른쪽으로 나타납니다. 그러나 모든 경우가 그렇게 간단한 것은 아닙니다. 미묘한 경우의 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97b005cab59c28efe19b8404620d4586fb6285f7" translate="yes" xml:space="preserve">
          <source>In the threaded and SMP versions of the RTS (see &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), a major GC is automatically performed if the runtime has been idle (no Haskell computation has been running) for a period of time. The amount of idle time which must pass before a GC is performed is set by the &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; option. Specifying &lt;code&gt;-I0&lt;/code&gt; disables the idle GC.</source>
          <target state="translated">RTS의 스레드 및 SMP 버전 ( &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 )에서 일정 기간 동안 런타임이 유휴 상태 (하스켈 계산이 실행 중이 아님) 인 경우 주요 GC가 자동으로 수행됩니다. GC가 수행되기 전에 통과해야하는 유휴 시간은 &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; 옵션으로 설정됩니다 . &lt;code&gt;-I0&lt;/code&gt; 을 지정 하면 유휴 GC가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1694137a8ab9fbad9a236c803a20b15d21740e1f" translate="yes" xml:space="preserve">
          <source>In the unification check in the final bullet, GHC also uses the &amp;ldquo;in-scope given constraints&amp;rdquo;. Consider for example</source>
          <target state="translated">마지막 글 머리 기호의 통일 확인에서 GHC는 또한 &quot;범위 내 주어진 제약&quot;을 사용합니다. 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="588a44eae37ca5b1dac65821d0d9f7a7a8542d81" translate="yes" xml:space="preserve">
          <source>In the unlikely case that modifier characters of some kind are desirable for a user-provided type, a &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; can be provided to process these characters. The resulting modifiers will appear in the &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; for use by the type-specific formatter.</source>
          <target state="translated">사용자가 제공 한 유형에 어떤 종류의 수정 자 문자가 바람직한 경우는 드물지만 이러한 문자를 처리하기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; 를 제공 할 수 있습니다. 결과 수정자는 유형별 포맷터에서 사용하기 위해 &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; 에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="2ad711240568f9303ca209fe831d40e7c3af2733" translate="yes" xml:space="preserve">
          <source>In theory, this mechanism allows arbitrary data to be roundtripped via a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with no loss of data. In practice, there are two limitations to be aware of:</source>
          <target state="translated">이론적으로이 메커니즘을 사용하면 임의의 데이터를 데이터 손실없이 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 통해 라운드 트립 할 수 있습니다 . 실제로 알아야 할 두 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="23cb01df08dfcb7824b863fc014f5bf29ea5fc79" translate="yes" xml:space="preserve">
          <source>In this case the derived instance declaration is of the form</source>
          <target state="translated">이 경우 파생 인스턴스 선언은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="71a288fd8d8656887893d68ab53108d408b426c0" translate="yes" xml:space="preserve">
          <source>In this case the kind parameter &lt;code&gt;k&lt;/code&gt; is actually an implicit parameter of the type family.</source>
          <target state="translated">이 경우 종류 매개 변수 &lt;code&gt;k&lt;/code&gt; 는 실제로 유형 패밀리의 내재 된 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="1458f3d45d7cf8add3f964f47bf5c04fad0f65f0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn&amp;rsquo;t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</source>
          <target state="translated">이 경우, &lt;code&gt;Head&lt;/code&gt; ⟨x be는 오른쪽에 ⟨xs⟩ 값을 지정하지 않기 때문에 패턴에만 사용할 수 없습니다. 그러나 유형을 구성하고 해체하는 방법을 별도로 지정하여 명시 적으로 양방향 패턴 동의어를 정의 할 수 있습니다. 이를 수행하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0936edcab6b0c6b0eac6247ce8f47c52daa2c9a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;g&lt;/code&gt; is desugared to</source>
          <target state="translated">이 경우 &lt;code&gt;g&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="46b676aa5c3c6fb868cf3f9cd7c077e91b44b610" translate="yes" xml:space="preserve">
          <source>In this case, the child thread will receive a &lt;code&gt;NonTermination&lt;/code&gt; exception instead of waiting for the value of &lt;code&gt;r&lt;/code&gt; to be computed.</source>
          <target state="translated">이 경우 자식 스레드는 &lt;code&gt;r&lt;/code&gt; 값 이 계산 되기를 기다리는 대신 &lt;code&gt;NonTermination&lt;/code&gt; 예외를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd24087d75374f112a445bc71400a6456c492b4" translate="yes" xml:space="preserve">
          <source>In this case, we could not simply bind &lt;code&gt;k&lt;/code&gt; on the left-hand side, as &lt;code&gt;k&lt;/code&gt; would become a &lt;em&gt;visible&lt;/em&gt; parameter:</source>
          <target state="translated">이 경우 &lt;code&gt;k&lt;/code&gt; 가 &lt;em&gt;가시적 인&lt;/em&gt; 매개 변수 가 되므로 왼쪽에 &lt;code&gt;k&lt;/code&gt; 를 단순히 바인딩 할 수는 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cc674153a787afcfa95c57ed93cc3673880fbe" translate="yes" xml:space="preserve">
          <source>In this case, we were able to do this with &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;, but operations with more complex types require special lifting functions, which are provided by monad transformers for which they can be implemented. If you use the monad classes of the &lt;code&gt;mtl&lt;/code&gt; package or similar, this lifting is handled automatically by the instances of the classes, and you need only use the generalized methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 로이 작업을 수행 할 수 있었지만보다 복잡한 유형의 작업에는 특수 리프팅 기능이 필요하며이를 구현할 수있는 모나드 변압기가 제공합니다. &lt;code&gt;mtl&lt;/code&gt; 패키지 또는 이와 유사한 모나드 클래스를 사용하는 경우이 리프팅은 클래스 인스턴스에서 자동으로 처리되므로 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 일반 메소드 만 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb4a09f269488c7395d0751f14e5beb2db506fc" translate="yes" xml:space="preserve">
          <source>In this chapter you&amp;rsquo;ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It&amp;rsquo;s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</source>
          <target state="translated">이 장에서는 400 개 이상의 플래그를 포함하여 GHC 명령 줄 구문에 대한 완전한 참조를 제공합니다. 크고 복잡한 시스템이며 많은 세부 정보가 있으므로 시작 방법을 파악하기가 매우 어려울 수 있습니다. 이를 염두에두고이 소개 섹션에서는 Haskell 프로그램을 컴파일하기위한 GHC의 기본 사용법에 대해 간략하게 소개합니다. 다음 섹션에서는 전체 구문을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="a4cb88a5dbcf9e66af97ada60f7fc8018cc84f7c" translate="yes" xml:space="preserve">
          <source>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such &lt;code&gt;-fspec-constr&lt;/code&gt; will transform the above code to:</source>
          <target state="translated">이 코드에서 빈 목록에 대한 초기 검사를 통과하면 재귀 경우이 패턴 일치가 중복됨을 알 수 있습니다. 따라서 &lt;code&gt;-fspec-constr&lt;/code&gt; 은 위 코드를 다음과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b4c5c94cfab7bea6a279520afd17cf54b4f5145f" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;Reader&lt;/code&gt; monad provides access to variable bindings. Bindings are a &lt;code&gt;Map&lt;/code&gt; of integer variables. The variable &lt;code&gt;count&lt;/code&gt; contains number of variables in the bindings. You can see how to run a Reader monad and retrieve data from it with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt;, how to access the Reader data with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;Reader&lt;/code&gt; 모나드는 변수 바인딩에 대한 액세스를 제공합니다. 바인딩은 정수 변수 의 &lt;code&gt;Map&lt;/code&gt; 입니다. 변수 &lt;code&gt;count&lt;/code&gt; 에는 바인딩 의 변수 수가 포함됩니다. 당신은 리더가 모나드 실행으로 데이터를 검색하는 방법을 볼 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt; 와 리더 데이터에 액세스하는 방법, &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2208e92b48546b397d55cc261960cb8033549a" translate="yes" xml:space="preserve">
          <source>In this example we use the operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;, which are defined only for monads that are applications of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. Alternatively one could use monad classes from the &lt;code&gt;mtl&lt;/code&gt; package or similar, which contain methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; with types generalized over all suitable monads.</source>
          <target state="translated">이 예에서는 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 의 응용 프로그램 인 모나드에 대해서만 정의 된 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; 에서 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 작업을 사용합니다 . 또는 &lt;code&gt;mtl&lt;/code&gt; 패키지 또는 이와 유사한 모나드 클래스를 사용할 수 있으며 , 여기에는 모든 적합한 모나드에 대해 일반화 된 유형으로 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;put&lt;/code&gt; 메소드 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="22ae5ddc301afbf76db451d6ae86206a63cdb84b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt; depends on &lt;code&gt;a&lt;/code&gt;. Even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">이 예에서, &lt;code&gt;a&lt;/code&gt; 에 따라 &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 따라 . 비록 어휘 전에 나타나는 &lt;code&gt;j&lt;/code&gt; 와 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; 때문에, 제 정량화 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 에 따라 &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; . 또한 &lt;code&gt;j&lt;/code&gt; 와 &lt;code&gt;k&lt;/code&gt; 는 종속성 조건을 위반하지 않더라도 서로에 대해 재정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3ac2fd6e175d918e681db807d09bc0d9cfd7a0f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;op&lt;/code&gt; is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of &lt;code&gt;op&lt;/code&gt;-used-at-type-Bool to a specialised function, say &lt;code&gt;opBool&lt;/code&gt;, where</source>
          <target state="translated">이 예에서 &lt;code&gt;op&lt;/code&gt; 는 일반적인 최상위 기능이 아닙니다. 클래스 메소드입니다. GHC는 &lt;code&gt;op&lt;/code&gt; -ooled-at-type-Bool 발생을 &lt;code&gt;opBool&lt;/code&gt; 과 같은 특수 함수로 신속하게 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="a54c35f64a11f9102b446b75a06ab15997039209" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside&amp;hellip;</source>
          <target state="translated">이 예에서, &lt;code&gt;reify&lt;/code&gt; 내부 ...</target>
        </trans-unit>
        <trans-unit id="144a6001279409b5fe23e336fea6b41236a7436a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside...</source>
          <target state="translated">이 예에서, &lt;code&gt;reify&lt;/code&gt; inside ...</target>
        </trans-unit>
        <trans-unit id="d1ca7b6071a21a43da3a7e5ebc0b51fe9aa62cd1" translate="yes" xml:space="preserve">
          <source>In this example, all of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are considered kind variables and will always be placed before &lt;code&gt;b&lt;/code&gt;, a lowly type variable. (Note that &lt;code&gt;a&lt;/code&gt; is used in &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind.) Yet, even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">이 예에서 모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; 는 종류 변수로 간주되며 항상 낮은 유형 변수 인 &lt;code&gt;b&lt;/code&gt; 앞에 배치 됩니다. (참고 &lt;code&gt;a&lt;/code&gt; 사용된다 &lt;code&gt;b&lt;/code&gt; 종류의). 그러나, 비록 &lt;code&gt;a&lt;/code&gt; 이전에 전적으로 표시 &lt;code&gt;j&lt;/code&gt; 와 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; 때문에, 제 정량화 &lt;code&gt;a&lt;/code&gt; 에 따라 &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;k&lt;/code&gt; . 또한 &lt;code&gt;j&lt;/code&gt; 와 &lt;code&gt;k&lt;/code&gt; 는 의존성 조건을 위반하지 않더라도 서로에 대해 순서가 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea70ba4f788151f3c14bd89916938adefd9dddbc" translate="yes" xml:space="preserve">
          <source>In this example, the declaration has only one variant. In general, it can be any number.</source>
          <target state="translated">이 예에서 선언에는 변형이 하나만 있습니다. 일반적으로 임의의 숫자가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c73dc37636c8cb640cf041df73293ff0e50794dc" translate="yes" xml:space="preserve">
          <source>In this example, the list &lt;code&gt;output&lt;/code&gt; would take on the value:</source>
          <target state="translated">이 예제에서 목록 &lt;code&gt;output&lt;/code&gt; 은 다음 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0477cc1de77b96d2dcbf9d8cc1e8fbeac11cb261" translate="yes" xml:space="preserve">
          <source>In this example, we inspect all available details of the compiled source code. We don&amp;rsquo;t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</source>
          <target state="translated">이 예에서는 컴파일 된 소스 코드의 사용 가능한 모든 세부 정보를 검사합니다. 우리는 표현을 바꾸지 않고 표준 출력에 세부 사항을 씁니다. 구문 분석, 이름 바꾸기 및 유형 확인 구문 트리의 인쇄 된 표현은 평가 된 스플 라이스 및 준 따옴표뿐만 아니라 출력에도 표시됩니다. 로드 된 인터페이스의 이름도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce7a808f73475173c84b4a7d49aa6676ec3a0955" translate="yes" xml:space="preserve">
          <source>In this example, you cannot say &lt;code&gt;... deriving( Show )&lt;/code&gt; on the data type declaration for &lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt; is a GADT, but you &lt;em&gt;can&lt;/em&gt; generate the instance declaration using stand-alone deriving.</source>
          <target state="translated">이 예에서, 당신은 말할 수 없다 &lt;code&gt;... deriving( Show )&lt;/code&gt; 에 대한 데이터 유형 선언에 &lt;code&gt;T&lt;/code&gt; 있기 때문에, &lt;code&gt;T&lt;/code&gt; 는 GADT,하지만 당신은 &lt;em&gt;할 수&lt;/em&gt; 독립형 유도를 사용하여 인스턴스 선언을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="af62a3290de70aad01a1a52e1391134fd1bf6e1e" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;.</source>
          <target state="translated">이 모드에서 GHC는 다중 모듈 Haskell 프로그램을 자동으로 구축하여 자체 의존성을 파악합니다. 간단한 Haskell 프로그램이 있다면 &lt;strong&gt;make를&lt;/strong&gt; 사용 &lt;strong&gt;하는&lt;/strong&gt; 것보다 훨씬 쉽고 빠를 &lt;strong&gt;것&lt;/strong&gt; 입니다. Make 모드는 &lt;a href=&quot;#make-mode&quot;&gt;ghc &amp;ndash;make 사용에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b4a3b6689dfdb162bbf16479c4e6487fd716f8" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;.</source>
          <target state="translated">이 모드에서 GHC는 다중 모듈 Haskell 프로그램을 자동으로 빌드하여 자체 종속성을 파악합니다. 간단한 Haskell 프로그램이 있다면 &lt;strong&gt;make를&lt;/strong&gt; 사용 &lt;strong&gt;하는&lt;/strong&gt; 것보다 훨씬 쉽고 빠를 &lt;strong&gt;것&lt;/strong&gt; 입니다. Make 모드는 &lt;a href=&quot;#make-mode&quot;&gt;ghc --make 사용에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b5fc6a536a1554868646b6ca60e10360d30c4b" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just &lt;code&gt;Main&lt;/code&gt;). For example, if your &lt;code&gt;Main&lt;/code&gt; module is in a file called &lt;code&gt;Main.hs&lt;/code&gt;, you could compile and link the program like this:</source>
          <target state="translated">이 모드에서 GHC는 하나 이상의 루트 모듈 (보통 &lt;code&gt;Main&lt;/code&gt; )의 종속성을 따라 다중 모듈 Haskell 프로그램을 빌드합니다 . 예를 들어, &lt;code&gt;Main&lt;/code&gt; 모듈이 &lt;code&gt;Main.hs&lt;/code&gt; 파일에 있으면 다음 과 같이 프로그램을 컴파일하고 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28db988427b635ef091ce5edd09284a3efe60154" translate="yes" xml:space="preserve">
          <source>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</source>
          <target state="translated">이 표기법에서 부동 소수점 숫자는 16 진수를 사용하여 기록되므로 숫자는 평소 10이 아닌 16을 사용하여 해석됩니다. 이는 소수점 왼쪽 숫자는 16의 양의 제곱에 해당하고 오른쪽 숫자는 16의 양의 제곱에 해당함을 의미합니다. 부정적인 것들에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="1625565ac67aff08f4fe4a675ec370d8a1444409" translate="yes" xml:space="preserve">
          <source>In this redefinition, we give an explicit kind for &lt;code&gt;(:~~:)&lt;/code&gt;, deferring the choice of &lt;code&gt;k2&lt;/code&gt; until after the first argument (&lt;code&gt;a&lt;/code&gt;) has been given. With this declaration for &lt;code&gt;(:~~:)&lt;/code&gt;, the instance for &lt;code&gt;HTestEquality&lt;/code&gt; is accepted.</source>
          <target state="translated">이 재정의에서, 우리는 &lt;code&gt;(:~~:)&lt;/code&gt; 대한 명시적인 종류를 제공하며 , 첫 번째 인수 ( &lt;code&gt;a&lt;/code&gt; )가 주어질 때까지 &lt;code&gt;k2&lt;/code&gt; 의 선택을 연기합니다 . &lt;code&gt;(:~~:)&lt;/code&gt; 대한이 선언으로 &lt;code&gt;HTestEquality&lt;/code&gt; 에 대한 인스턴스 가 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="241d07916ab9a1a491c806d2158cdc7962a6343f" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is lazy, so that for example the following produces a usable result:</source>
          <target state="translated">이 버전에서는 계산 순서가 느려서 예를 들어 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c84b399cd2cbed2ef45d9909f32f6700a23e3816" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">이 버전에서는 계산 순서가 엄격하지만 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 등 을 사용하여 계산하지 않으면 계산이 상태에서 엄격하지 않습니다 . 동일한 인터페이스의 게으른 버전은 &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="733a7b8597e3bea6d79329500059b7357f9f04c9" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">이 버전에서는 계산 순서가 엄격합니다 (그러나 강제로 실행하지 않는 한 계산은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 등으로). 인터페이스가 동일한 지연 버전에 대해서는&lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt; Control.Monad.Trans.State.Lazy를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d6a029dcaf77ff2149eaa82e23825caa41a60b1" translate="yes" xml:space="preserve">
          <source>In type errors, also print type-synonym-expanded types.</source>
          <target state="translated">형식 오류에서 형식 동의어 확장 형식도 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="9cdca6bb9120edae790472f128bdcd1be571c545" translate="yes" xml:space="preserve">
          <source>In types, an operator symbol like &lt;code&gt;(+)&lt;/code&gt; is normally treated as a type &lt;em&gt;variable&lt;/em&gt;, just like &lt;code&gt;a&lt;/code&gt;. Thus in Haskell 98 you can say</source>
          <target state="translated">종류, 같은 오퍼레이터 기호 &lt;code&gt;(+)&lt;/code&gt; 는 일반적으로 입력으로 취급 &lt;em&gt;변수&lt;/em&gt; 처럼 . 따라서 Haskell 98에서는 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65afe3f89d89dfa50d619b7bc79e59801641ec08" translate="yes" xml:space="preserve">
          <source>In typical use cases it can be imported alongside &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;, e.g.</source>
          <target state="translated">일반적인 사용 사례에서 그것은 함께 가져올 수 있습니다 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; , 예를 들어,</target>
        </trans-unit>
        <trans-unit id="d1e5195c56fb5f6cf6fae4475985c40c8b88fe88" translate="yes" xml:space="preserve">
          <source>In your program, you import a module &lt;code&gt;Foo&lt;/code&gt; by saying &lt;code&gt;import Foo&lt;/code&gt;. In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, GHC will look for a source file for &lt;code&gt;Foo&lt;/code&gt; and arrange to compile it first. Without &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, GHC will look for the interface file for &lt;code&gt;Foo&lt;/code&gt;, which should have been created by an earlier compilation of &lt;code&gt;Foo&lt;/code&gt;. GHC uses the same strategy in each of these cases for finding the appropriate file.</source>
          <target state="translated">프로그램에서 &lt;code&gt;import Foo&lt;/code&gt; 라고 말 하여 모듈 &lt;code&gt;Foo&lt;/code&gt; 를 가져옵니다 . 에서 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 또는 GHCi, GHC는 대한 소스 파일을 찾을 것 &lt;code&gt;Foo&lt;/code&gt; 먼저 컴파일하기 마련. 없이 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; , GHC는의 인터페이스 파일을 찾습니다 &lt;code&gt;Foo&lt;/code&gt; 의 이전 컴파일에 의해 생성되어 있어야합니다, &lt;code&gt;Foo&lt;/code&gt; . GHC는 각각의 경우에 동일한 파일을 찾기 위해 동일한 전략을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e6fb0b72e73092b08131513da6dffeda9e5d2c1b" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current output history on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 현장 해제 . 이 버전은 연속 입력시 현재 출력 기록을 사용합니다. 균일 성 속성을 만족하지 않습니다 ( &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ed82252f8ef32e515385822c367b97c16dae701f" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 현장 해제 . 이 버전은 연속 입력시 현재 상태를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6a76bfe845d96c79100211ad66d5be912f9bcb9e" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 현장 해제 . 이 버전은 연속 입력시 현재 상태를 사용합니다. 균일 성 속성을 만족하지 않습니다 ( &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0bc346f91d9ddc5a0ccbe414514a097c0e2ae594" translate="yes" xml:space="preserve">
          <source>InappropriateType</source>
          <target state="translated">InappropriateType</target>
        </trans-unit>
        <trans-unit id="491a2c5d60825a9925b3d9a2ec49e95b47e7f9c8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples or sums.</source>
          <target state="translated">덧붙여서, &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 가 GHCi와 호환되지 않는다는 이전 요점 은 바이트 코드 컴파일러가 unboxed 튜플이나 합계를 처리 할 수 ​​없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fc5a86ec622c5d2ce4a51514213ff5193a71f6e8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples.</source>
          <target state="translated">우연히도 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 가 GHCi와 호환되지 않는다는 점 은 바이트 코드 컴파일러가 언 박스 튜플을 처리 할 수 ​​없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="04035088cec19a7e2a3af045cabd4c24b2d47171" translate="yes" xml:space="preserve">
          <source>Include preprocessor dependencies</source>
          <target state="translated">전 처리기 종속성 포함</target>
        </trans-unit>
        <trans-unit id="ac7ecb7c530843411667d62a790e5a78d07bb31e" translate="yes" xml:space="preserve">
          <source>Include the memory occupied by threads in a heap profile. Each thread takes up a small area for its thread state in addition to the space allocated for its stack (stacks normally start small and then grow as necessary).</source>
          <target state="translated">스레드가 차지하는 메모리를 힙 프로파일에 포함 시키십시오. 각 스레드는 스택에 할당 된 공간 외에 스레드 상태에 대해 작은 영역을 차지합니다 (일반적으로 스택은 작게 시작한 다음 필요에 따라 커짐).</target>
        </trans-unit>
        <trans-unit id="bf6b5e91451bcaf207fe546e25dfb945b2ef9008" translate="yes" xml:space="preserve">
          <source>Incoherent</source>
          <target state="translated">Incoherent</target>
        </trans-unit>
        <trans-unit id="b38b4aae2bf24bfd05e072f52c00b63da2993ab0" translate="yes" xml:space="preserve">
          <source>IncoherentInstances</source>
          <target state="translated">IncoherentInstances</target>
        </trans-unit>
        <trans-unit id="c456a08558be1da87f0db1872fa8594cdebf4bc0" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">닫힌 유형 패밀리 방정식 간의 비 호환성은 다음 위치에 표시 될 수 있습니다 &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 .</target>
        </trans-unit>
        <trans-unit id="835b6be9a8a369d9816b32613c73aac90a0d27dc" translate="yes" xml:space="preserve">
          <source>Increases the precedence context by one.</source>
          <target state="translated">우선 순위 컨텍스트를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="9fce6bc4b7e5c5a1ab1bd960ce68b81905da42d1" translate="yes" xml:space="preserve">
          <source>Increasing the allocation area size may or may not give better performance (a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion).</source>
          <target state="translated">할당 영역 크기를 늘리면 성능이 향상되거나 향상되지 않을 수 있습니다 (할당 영역이 클수록 캐시 동작이 더 좋지만 가비지 수집이 적고 수준이 낮아짐).</target>
        </trans-unit>
        <trans-unit id="90bbbaecf2c42b5555ebc1a33319be6fd0d0626c" translate="yes" xml:space="preserve">
          <source>Increasing this figure is more likely to result in longer compile times than faster code. The &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is more useful.</source>
          <target state="translated">이 숫자를 늘리면 코드가 빠를수록 컴파일 시간이 길어질 수 있습니다. &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt; 더 유용하다.</target>
        </trans-unit>
        <trans-unit id="4f85c1ee822e61bcfb4fe66d19d113d5f463b45b" translate="yes" xml:space="preserve">
          <source>Incremental array updates</source>
          <target state="translated">증분 배열 업데이트</target>
        </trans-unit>
        <trans-unit id="df1b72108d080551ba84e7f0b92fa55056537617" translate="yes" xml:space="preserve">
          <source>Increments the column number of a source position.</source>
          <target state="translated">소스 위치의 열 번호를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e41e0acce642a9a1ccc70291606c4bb9e436f67f" translate="yes" xml:space="preserve">
          <source>Increments the line number of a source position.</source>
          <target state="translated">소스 위치의 라인 번호를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="3b6b076780f1d62948deeee6a296d893d53b3592" translate="yes" xml:space="preserve">
          <source>Indeed, the bindings can even be recursive.</source>
          <target state="translated">실제로, 바인딩은 재귀적일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="96dc8cbd171c88cf2266f42fcde1d0fd90902e1c" translate="yes" xml:space="preserve">
          <source>Indeed, we can even set breakpoints,</source>
          <target state="translated">실제로 중단 점을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8be4828bc680f1764ecad7e8b3a8f6a6c5c173" translate="yes" xml:space="preserve">
          <source>Indexed</source>
          <target state="translated">Indexed</target>
        </trans-unit>
        <trans-unit id="06793fabc8f42b418a1cb6b931583c1a10698618" translate="yes" xml:space="preserve">
          <source>Indexed data families are introduced by a signature, such as</source>
          <target state="translated">인덱싱 된 데이터 제품군은 다음과 같은 서명으로 소개됩니다.</target>
        </trans-unit>
        <trans-unit id="35f58c1b9b260f98cfc78bcd3803628ca7e2f859" translate="yes" xml:space="preserve">
          <source>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</source>
          <target state="translated">색인화 된 유형 군은 데이터 계열, 개방형 동의어 패밀리 및 폐쇄 형 동의어 패밀리의 세 가지 유형으로 제공됩니다. 그것들은 각각 대수 데이터 타입과 타입 동의어의 인덱스 패밀리 변형입니다. 데이터 패밀리의 인스턴스는 데이터 유형 및 새 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12b44f71b7203449d4ead8607709958c3027d75" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">인덱스 타입 패밀리는 타입 레벨 프로그래밍을 용이하게하기 위해 확장을 형성합니다. 유형 패밀리는 관련 데이터 유형 &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; 및 관련 유형 동의어 &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; 의 일반화입니다 . 유형 패밀리 자체는 Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]에&lt;/a&gt; 설명되어 있습니다. 타입 패밀리는 본질적으로 타입 인덱스 데이터 타입과 타입에 대한 명명 된 함수를 제공하며, 이는 일반적인 프로그래밍과 고도로 매개 변수화 된 라이브러리 인터페이스뿐만 아니라 종속 타입과 마찬가지로 향상된 정적 정보가있는 인터페이스에 유용합니다. 그것들은 또한 기능적 의존성에 대한 대안으로 간주 될 수 있지만, 관계형 기능적 의존성 스타일보다 더 기능적인 유형 레벨 프로그래밍 스타일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c623b2752a83108ab46f6eab2be4ef5e8f114c82" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">인덱싱 된 유형 패밀리는 유형 수준 프로그래밍을 용이하게하는 확장을 형성합니다. 유형 패밀리는 연관된 데이터 유형 &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; 및 연관된 유형 동의어 &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; 의 일반화입니다 . 유형 패밀리 자체는 Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]에&lt;/a&gt; 설명되어 있습니다. 유형 패밀리는 기본적으로 유형에 대한 유형 인덱싱 된 데이터 유형과 명명 된 함수를 제공하며, 이는 일반 프로그래밍 및 고도로 매개 변수화 된 라이브러리 인터페이스뿐만 아니라 종속 유형과 매우 유사한 향상된 정적 정보가있는 인터페이스에 유용합니다. 또한 기능적 종속성의 대안으로 간주 될 수 있지만 기능적 종속성의 관계형 스타일보다 더 기능적인 유형 수준 프로그래밍 스타일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7316d5d3f19bb830a24f91422d22cdab9dd77e21" translate="yes" xml:space="preserve">
          <source>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</source>
          <target state="translated">인덱싱 된 유형 패밀리 또는 줄여서 유형 패밀리는 유형 세트를 나타내는 유형 생성자입니다. 집합 멤버는 형식 패밀리 생성자에 형식 인덱스라는 형식 매개 변수를 제공하여 표시됩니다. 바닐라 매개 변수화 된 유형 생성자와 패밀리 생성자의 차이점은 매개 변수 적으로 다형성 함수와 유형 클래스의 (임시 다형성) 메소드와 매우 유사합니다. 매개 변수 다형성 함수는 모든 유형 인스턴스에서 동일하게 작동하지만 클래스 메소드는 클래스 유형 매개 변수에 따라 동작을 변경할 수 있습니다. 마찬가지로 바닐라 유형 생성자는 모든 유형 인스턴스에 대해 동일한 데이터 표현을 의미하지만 패밀리 생성자는 다양한 유형 색인에 대해 다양한 표현 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b949d0cdd6e23a0ad23263d4ec380e2896eb8d8b" translate="yes" xml:space="preserve">
          <source>IndexedQueue</source>
          <target state="translated">IndexedQueue</target>
        </trans-unit>
        <trans-unit id="8fa14decb45552b922c2f1e05a96dc53620208d3" translate="yes" xml:space="preserve">
          <source>IndexedTaggedQueue</source>
          <target state="translated">IndexedTaggedQueue</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="e8487b7ebf53e6a4c89fb11a42e40edb17475681" translate="yes" xml:space="preserve">
          <source>Indexing ByteStrings</source>
          <target state="translated">바이트 문자열 인덱싱</target>
        </trans-unit>
        <trans-unit id="a877b32121d14e603604359d2ca06dd6d1231f86" translate="yes" xml:space="preserve">
          <source>Indexing lists</source>
          <target state="translated">인덱싱 목록</target>
        </trans-unit>
        <trans-unit id="10dea83b6d35fb66236376830ee8aaca1d2aa47d" translate="yes" xml:space="preserve">
          <source>Indexing streams</source>
          <target state="translated">인덱싱 스트림</target>
        </trans-unit>
        <trans-unit id="9d4cf9835a874b031aa2556ce944d3dfd7d3212c" translate="yes" xml:space="preserve">
          <source>Indexing with predicates</source>
          <target state="translated">술어를 사용한 색인 작성</target>
        </trans-unit>
        <trans-unit id="7bb8fb7fdc165fa4b18dff47b53df0d3155ddd63" translate="yes" xml:space="preserve">
          <source>Indicates a mode in which a file should be locked.</source>
          <target state="translated">파일을 잠글 모드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3355b10b90f7375e78f86318065481808ee2eee6" translate="yes" xml:space="preserve">
          <source>Indicates an &quot;alternate format&quot;. See &lt;code&gt;printf(3)&lt;/code&gt; for the details, which vary by argument spec.</source>
          <target state="translated">&quot;대체 형식&quot;을 나타냅니다. 인수 사양에 따라 자세한 내용 은 &lt;code&gt;printf(3)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">이 RunTH가 완료되었음을 나타내고 다음 메시지는 RunTH (QResult)의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">간접 지정에는 두 개의 특수 디렉토리가 포함 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;..&lt;/code&gt; 및 모든 심볼릭 링크 (및 Windows의 연결 지점). 입력 경로는 기존 파일 또는 디렉토리를 가리킬 필요가 없습니다. 정규화는 기존 파일 또는 디렉토리를 가리키는 경로의 가장 긴 접두사에서 수행됩니다. 기존 파일 또는 디렉토리를 가리 키지 않는 경로의 나머지 부분은 여전히 ​​정규화되지만 존재하지 않는 경로에서는 불가능하므로 대소 문자 표준화 및 간접 제거가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">생성자의 개별 필드 : &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">기본적으로 로컬 바인딩에 대해 다형성 유형이 적습니다.</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">다른 유형의 평등 추론</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">⟨type⟩의 종류를 유추하고 인쇄합니다. 후자는 &lt;code&gt;Either Int&lt;/code&gt; 와 같은 형식 생성자의 부분 응용 프로그램을 포함하여 임의 형식 식일 수 있습니다 . 실제로 &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt; 를 사용하면 형식 동의어의 일부 응용 프로그램 (일반적으로 허용되지 않음)을 작성할 수 있으므로 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">⟨expression⟩의 유형을 유추하고 인쇄하지만 유형 변수 또는 클래스 제약 조건을 다루지 않습니다. 이는 &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용 하고 지정된 유형 변수 (유형 응용 프로그램에 사용 가능)와 유추 된 유형 변수 (사용할 수 없음) 사이의 구별에주의 할 때 유용합니다 . 이 모드는 때때로 쉽게 해결할 수있는 제약 조건 (예 : &lt;code&gt;Show Int&lt;/code&gt; )을 인쇄 하지만 이러한 제약 조건을 해결하면 유형 변수에 영향을 줄 수 있으므로 GHC가 다시 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">가능한 경우 기본 유형 변수 인 ⟨expression⟩의 유형을 유추하고 인쇄합니다. 이 모드에서 유추 된 유형이 대화식 클래스 ( &lt;code&gt;Num&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; 또는 &lt;code&gt;Traversable&lt;/code&gt; )에 의해 제한되는 경우 제한 유형 변수는 &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; 에&lt;/a&gt; 설명 된 규칙에 따라 기본값이 설정됩니다 . 이 모드는 유추 된 유형이 매우 일반적인 경우 (예 : &lt;code&gt;foldr&lt;/code&gt; ) 에보다 유용하며보다 구체적인 인스턴스를 보는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">다형성 유형에 대한 모든 정량자를위한 명시 적 표현을 포함하여 표현 유형을 유추하고 인쇄합니다. 보고 된 유형은 표현식에 지정된 변수에 대해 유추되지만 단형 제한이 적용되지 않은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">무한 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">무한리스트</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">비공식적으로 &lt;code&gt;Strict&lt;/code&gt; 언어 확장 기능은 기본적으로 함수, 데이터 유형 및 바인딩을 엄격하게 전환 하여 변수 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가하여 선택적 게으름을 허용 합니다. 이것은 본질적으로 게으름이 기본값이고 엄격함을 선택적으로 가질 수있는 현재 상황을 역전시킵니다 &lt;code&gt;!&lt;/code&gt; 변수 앞에.</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">비공식적으로 &lt;code&gt;StrictData&lt;/code&gt; 언어 확장은 기본적으로 필드 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가하여 필드를 지연시킬 수 있도록 데이터 유형 선언을 엄격하게 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">비공식적으로 닫힌 표현이 있다면</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">정보 보존</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">수신 된 신호에 대한 정보 ( &lt;code&gt;siginfo_t&lt;/code&gt; 에서 파생 됨 ).</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">프로그램을 실행할만큼 운이 좋은 호스트 시스템의 특성에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">컴퓨터에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">특정 유형의 신호에 특정한 정보 ( &lt;code&gt;siginfo_t&lt;/code&gt; 에서 파생 됨 ).</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">부모로부터 상속 핸들</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">회선 지향 사용자 상호 작용 세션을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">주어진 터미널 항목으로 terminfo 라이브러리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TERM&lt;/code&gt; 환경 변수를 사용하여 terminfo 라이브러리를 초기화하십시오 . &lt;code&gt;TERM&lt;/code&gt; 이 설정되지 않은 경우 일반 최소 엔트리 &lt;code&gt;dumb&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 를&lt;/a&gt; 초기화합니다 . 이것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">모나 딕 타입에 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">인젝 티브 유형 패밀리는 &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; 언어 확장으로 사용 가능 합니다. 이 확장은 &lt;code&gt;-XTypeFamilies&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">주 입성 주석</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">사출 성 주석은 패밀리 헤드 유형 뒤에 추가되며 다음 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">인라인 &lt;code&gt;memcpy&lt;/code&gt; 는 &quot;nn&quot;유사 명령어를 생성하지 않으면 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">n 개의 의사 명령어를 생성하지 않는 인라인 &lt;code&gt;memset&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">입출력</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">입력 기능</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">입력 문자열.</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">텍스트를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">맨 아래 표현식 뒤에 &lt;code&gt;error&lt;/code&gt; 표현식을 삽입하십시오 . 컴파일러를 디버깅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">주어진 위치에 스칼라를 벡터로 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내부에서 &quot; &lt;code&gt;forall&lt;/code&gt; &quot;은 다른 플래그 설정에 관계없이 키워드로 처리됩니다. 또한 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내부 에서 언어 확장 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 가 자동으로 활성화됩니다. 사전 &lt;a href=&quot;#scoped-type-variables&quot;&gt;범위 유형 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 내부의 &quot; &lt;code&gt;forall&lt;/code&gt; &quot;은 다른 플래그 설정에 관계없이 키워드로 취급됩니다. 또한 RULE 내에서 언어 확장 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 가 자동으로 사용됩니다. 사 &lt;a href=&quot;#scoped-type-variables&quot;&gt;전적으로 범위가 지정된 유형 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">스플 라이스 내에서는 가져온 모듈에 정의 된 함수 만 호출 할 수 있으며 동일한 모듈의 다른 곳에 정의 된 함수는 호출 할 수 없습니다. 선언 스플 라이스는 최상위 수준 (다른 선언 제외) 이외의 다른 곳에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">&lt;em&gt;과부하 및 고차 다형성을 이용한 기능적 프로그래밍&lt;/em&gt; 논문 인 Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) ( 1995) 고급 기능성 스쿨.</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">&lt;em&gt;과부하 및 고차 다형성을 통한 기능적 프로그래밍&lt;/em&gt; 논문 인 Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt; ) 1995 년 고급 기능성 프로그래밍 학교에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">^ C를 잡기 위해 표준 시그널 핸들러를 설치하십시오. 이것은 타겟 스레드에서 예외를 던집니다. 현재 대상 스레드는 installSignalHandlers에 전달 된 MVar의 목록 헤드에있는 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">보안 제어판을 사용하여 시스템의 설치 프로그램 감지 기능을 전체적으로 끌 수도 있지만 GHC는 기본적으로 설치 프로그램 감지 기능을 해제 한 사용자에 의존하지 않는 바이너리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">인스턴스 선언은 헤드가 정확히 동일한 경우에만 병합되므로 서명이없는 인스턴스가 겹치지 않는 방식으로 구현 된 경우에도 GHC가 시그니처의 인스턴스가 겹치는 것으로 생각하는 상황에 빠질 수 있습니다. 이것이 당신에게 문제를 낳고 있다면 우리에게 소리를 지르십시오.</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">데이터 및 newtype 패밀리의 인스턴스 선언은 표준 데이터 및 newtype 선언과 매우 유사합니다. 유일한 차이점은 키워드 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 다음에 &lt;code&gt;instance&lt;/code&gt; 있고 유형 인수의 일부 또는 전부가 변수가 아닌 유형일 수 있지만 모든 유형 또는 유형 동의어 패밀리를 포함 할 수는 없다는 것입니다. 그러나 데이터 패밀리는 일반적으로 유형 매개 변수에서 허용되며, 유형 동의어는 클래스 인스턴스 매개 변수에서 유형 동의어가 발생하는 데 필요한대로 완전히 적용되고 자체적으로 허용되는 유형으로 확장되는 한 허용됩니다. 예를 들어, &lt;code&gt;GMap&lt;/code&gt; 의 &lt;code&gt;Either&lt;/code&gt; 인스턴스 는</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">유형 패밀리의 인스턴스 선언은 표준 유형 동의어 선언과 매우 유사합니다. 단 두 가지 차이점은 키워드 &lt;code&gt;type&lt;/code&gt; 다음에 &lt;code&gt;instance&lt;/code&gt; 있고 유형 인수의 일부 또는 전부가 변수가 아닌 유형일 수 있지만 모든 유형 또는 유형 동의어 패밀리를 포함 할 수는 없다는 것입니다. 그러나 데이터 계열은 일반적으로 허용되며 형식 동의어는 완전히 적용되고 허용되는 형식으로 확장되는 한 허용됩니다. 이는 데이터 인스턴스와 정확히 동일한 요구 사항입니다. 예를 들어, &lt;code&gt;Elem&lt;/code&gt; 의 &lt;code&gt;[e]&lt;/code&gt; 인스턴스 는</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">인스턴스 세부 사항</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">인스턴스 조회</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 유사합니다 . 예를 들어 데이터 유형</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 유사합니다 . 예를 들어 데이터 유형</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">인스턴스 세부 사항</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">구성 유형이 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인 사용자 정의 데이터 유형에 대해 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 데이터 선언에서 생성자의 선언 순서는 파생 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 의 순서를 결정합니다 . &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 데이터 타입은 하나의 비교는 두 객체의 정확한 순서를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">인스턴스의 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 모든 열거 형에 대해 유도 될 수있다 (그 유형에는 생성자 필드가 없음). nullary 생성자는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;n-1&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 으로 왼쪽 에서 오른쪽으로 번호가 매겨진 것으로 가정합니다 . 자세한 내용은 &lt;em&gt;Haskell 보고서의&lt;/em&gt; 10 장 을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">인스턴스의 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 모든 열거 형에 대해 유도 될 수있다 (그 유형에는 생성자 필드가 없음). nullary 생성자는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;n-1&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 으로 왼쪽 에서 오른쪽으로 번호가 매겨진 것으로 가정합니다 . 자세한 내용은 &lt;em&gt;Haskell 보고서의&lt;/em&gt; 10 장 을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">구성 유형이 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인 사용자 정의 데이터 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 데이터 선언에서 생성자의 선언 순서는 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 의 순서를 결정합니다 . &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 데이터 타입은 하나의 비교는 두 객체의 정확한 순서를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">의 인스턴스 &lt;code&gt;Monoid&lt;/code&gt; 또한 인스턴스해야 &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">이진 인스턴스는 다음 속성을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">이러한 클래스의 인스턴스는 &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 GHC에 의해 파생 될 수 있으며 일반 인스턴스를 자동으로 정의 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 가 모나드 변환기 인 다음과 같은 법률을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">인스턴스는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">인스턴스는 법을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">대신 두 번역 애플리케이션으로 화살표 (화살표 꼬리)의 단일 형태, 구현은 두 가지 형태로 제공 &lt;code&gt;-&amp;lt;&lt;/code&gt; (제 1 차) 및 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (높은 순서).</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">GHC는 실행 파일을 생성하는 대신이 링커 플래그를 사용하여 공유 객체를 생성합니다. 운영 체제 대상에 따라 ELF DSO, Windows DLL 또는 Mac OS dylib 일 수 있습니다. GHC는이 균일 플래그 아래에 운영 체제 세부 사항을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 소개합니다 . &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용될 때이 매개 변수는 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 인수 를 참조 하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 소개합니다 . &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용될 때이 매개 변수는 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 인수 를 참조 하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 을 재사용하는 대신 별도의 데이터 패밀리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; 을 사용하여 일반적인 리프팅되지 않은 유형의 발생을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">대신 &lt;code&gt;case&lt;/code&gt; 표현식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">대신 &lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 . 어떤이 실행 &lt;code&gt;main&lt;/code&gt; 인수와 범위에는, 예를 들어, 명령 줄 인수, 같은 치료를 받고 :</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 함수를 제공 하여 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">대신, 실제로 원하는 예외 만 정확하게 잡아야합니다. 이 경우 이는 &quot;모든 IO 예외&quot;보다 더 구체적 일 수 있습니다. 권한 오류는 다르게 처리되기를 원할 것입니다. 대신 다음과 같은 것을 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">대신 &lt;code&gt;foo&lt;/code&gt; 를 클래스 작업으로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="translated">지시 &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 사용하기 위하여 인쇄하십시오 &lt;code&gt;Show&lt;/code&gt; 가능한 Show 인스턴스 하십시오.</target>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">위치 독립적 인 실행 파일을 생성하도록 링커에 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">GHC가 값을 인라인하기에 특히 저렴한 것으로 간주하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수 호출 중에 벡터 인수를 전달하기 위해 플랫폼의 기본 벡터 레지스터를 사용하도록 GHC에 지시합니다. 모든 벡터 지원과 마찬가지로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">GHC 드라이버가 일반적으로 &lt;code&gt;/tmp&lt;/code&gt; 또는 다른 위치에 보관하는 임시 파일을 삭제하지 않도록 지시합니다 ( &lt;a href=&quot;#temp-files&quot;&gt;임시 파일 리디렉션&lt;/a&gt; 참조 ). &lt;code&gt;-v&lt;/code&gt; 와 함께 GHC를 실행 하면 어떤 임시 파일이 생성되었는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="translated">호출에서 &lt;code&gt;undef&lt;/code&gt; 대신 가비지로 사용 불능 STG 레지스터를 채우도록 LLVM 코드 생성기에 지시 합니다. 이를 통해 미묘한 코드 생성기 및 런타임 시스템 버그를 쉽게 포착 할 수 있습니다 (예 :&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt; 파악할 수 있습니다 # 11487&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">LLVM 코드 생성기에 불완전한 STG 레지스터를 호출시 &lt;code&gt;undef&lt;/code&gt; 대신 가비지로 채우도록 지시 합니다. 이를 통해 미묘한 코드 생성기 및 런타임 시스템 버그를 쉽게 잡을 수 있습니다 (예 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;이슈 # 11487&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">컴파일러가 값을 인라인하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">생성자 필드의 압축을 풀지 않도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">생성자 필드의 내용을 생성자 자체에 압축 해제하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">단순화기에 &lt;code&gt;error&lt;/code&gt; 를 방출하도록 지시합니다.빈 사례 분석 (하단 및 결과적으로 반환되지 않아야 함)을 계속할 때 표현 . 이는 때때로 세그먼트 결함으로 나타날 수있는 수요 분석 버그를 디버깅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">작업을 수행 할 수있는 리소스가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">INT 결과</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">정수 결과</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">정수 나누기를 지원하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">일체형</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">포인터와의 무손실 변환이 가능한 정수 유형</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">고정 배열과 함께 사용하도록 고안되었습니다. 그렇지 않으면 매우 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">대화식 모드-일반적으로 &lt;code&gt;ghci&lt;/code&gt; 를 실행하여 사용됩니다 . &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용을&lt;/a&gt; 참조하십시오 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ghci&lt;/strong&gt; 로도 사용할 수있는 대화식 모드 . 대화식 모드는 &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용에&lt;/a&gt; 자세히 설명되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">대화식 세션</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러가 생성 한 중간 C 파일.</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">처리 파이프 라인의 중간 결과.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">argv의 내부 인코딩</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">스파크를 실행하기 위해 RTS에서 사용하는 내부 기능.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">내부 구현</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다. 이 모듈의 내용은 플랫폼에 따라 다르므로 Hackage 설명서에 표시된 내용은 시스템에서 실제로 사용 가능한 내용과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">ShortByteString의 내부 표현</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">내부 자료 : ByteString FilePath 지원</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC 내부는 아직 세 번째 평등 관계 &lt;code&gt;(~#)&lt;/code&gt; 입니다. 이기종 ( &lt;code&gt;~~&lt;/code&gt; 같은 )이며 내부적으로 만 사용됩니다. &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 일&lt;/a&gt; 때만 오류 메시지 및 기타 출력에 나타날 수 있습니다. 가 활성화 된 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 버퍼 채우기 기능입니다. 그것들은 채워질 실제 버퍼를 제공 하는 &lt;em&gt;드라이버에&lt;/em&gt; 의해 실행됩니다 . 버퍼로 호출되면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는이를 채우고 드라이버에 신호를 리턴하여 완료되었거나 현재 버퍼를 채우거나 메모리 청크에 대한 참조를 직접 삽입하려고 함을 알려줍니다. 마지막 두 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 드라이버가 다음 버퍼를 채우기 위해 호출 할 수 있는 연속 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 여기서는 거의 모든 사용 사례를 만족시키는 두 가지 드라이버를 제공합니다. 미세 조정에 대한 정보는 &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">내부적으로 빌더는 배열을 하나씩 채우면서 게으른 &lt;code&gt;Text&lt;/code&gt; 를 구성합니다 . 각 버퍼가 채워지면 결과적으로 게으른 &lt;code&gt;Text&lt;/code&gt; 의 새로운 덩어리가되도록 '팝 오프'됩니다 . 이 모든 것은 &lt;code&gt;Builder&lt;/code&gt; 사용자에게 숨겨져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 &lt;code&gt;Word16&lt;/code&gt; UTF-16 코드 단위 의 배열로 표시됩니다 . 생성자의 오프셋 및 길이 필드 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 단위가 &lt;em&gt;아닌&lt;/em&gt; 이러한 단위 입니다.</target>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">내부적으로이 함수는 하위 레벨 버퍼링 추상화에서 한 번에 청크를 읽고 전체 파일을 읽은 후에 청크를 단일 문자열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; 모듈의 내부</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">네이티브 코드와의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">통역사 모나드</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">플래그를 구체적인 값으로 해석</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">옵션 레코드의 변환으로 플래그 해석</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">인터럽트 가능한 작업</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">소개 및 제거 &lt;code&gt;ByteString&lt;/code&gt; 의 들</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">정량화 된 제약 조건을 도입하면 두 가지 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">죽은 STG 레지스터를 쓰레기로 채우는 LLVM 도입</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">직관적으로 이것은 첫 번째와 두 번째 인수가 공변량 인 이중 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">직관적으로 공변량 유형이 &lt;em&gt;생성&lt;/em&gt; 되고 공변량 유형이 사용 &lt;em&gt;됩니다&lt;/em&gt; . Haskell의 대부분 유형은 공변량이지만 함수 유형의 왼쪽은 분산을 뒤집는 점에서 함수 유형이 특별합니다. 함수 타입 인 경우 &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 공변 위치에 표시 (예 &lt;code&gt;CovFun1&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; contravariant 위치에 있고 &lt;code&gt;b&lt;/code&gt; 공변 위치에있다. 만약 마찬가지로, &lt;code&gt;a -&amp;gt; b&lt;/code&gt; contravariant 위치에 표시 (예 &lt;code&gt;CovFun2&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; 이다 공변 위치와 &lt;code&gt;b&lt;/code&gt; contravariant 위치에있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">모든 기능이 유지해야하는 불변량 :</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">입니다 &lt;code&gt;Tricky Nom Age&lt;/code&gt; 에 representationally 동일한 &lt;code&gt;Tricky Nom Int&lt;/code&gt; ? 아니! 전자는 &lt;code&gt;Char&lt;/code&gt; 를 저장 하고 후자는 &lt;code&gt;Bool&lt;/code&gt; 을 저장합니다 . 이에 대한 해결책은 변수를 입력하기 위해 모든 매개 변수가 역할 명목을 갖도록 요구하는 것입니다. 따라서, GHC는 대한 역할 표상을 추론 할 뿐만 역할 명목 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">FilePath가 유효합니까? 예를 들어 이와 같은 파일을 만들 수 있습니까? 이 함수는 유효하지 않은 이름과 유효하지 않은 문자를 검사하지만 일반적으로 파일 시스템에 따라 길이 제한이 초과되었는지 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">경로는 상대적입니까, 아니면 루트에 고정되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">드라이브 요소</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">항목이 디렉토리이거나 마지막 문자가 경로 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">이벤트 추적이 가능합니까?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 IOError . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 를 정의해야 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스)</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 , 당신은 또한을 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스를)</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">문자가 파일 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">캐릭터가 확장 캐릭터입니까?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">핸들이 터미널에 연결되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">이것은 삽입 함수&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;또는 뱅 패턴 이있는&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;의 정의입니까? GHC는이 모호성을 후자에 유리하게 해결합니다. bang-patterns가 활성화 된 상태에서 &lt;code&gt;(!)&lt;/code&gt; 를 정의 하려면 접두사 표기법을 사용하여 정의 해야합니다.</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">고아 모듈입니까? &lt;code&gt;T&lt;/code&gt; 는 동일한 모듈에서 선언 되었기 때문에 분명히 아닙니다 . 그러나 클래스 &lt;code&gt;E&lt;/code&gt; 에 기능적 종속성이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">이 프로그램은 GHC RTS와 연결되어 있습니까? (항상&amp;ldquo;예&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">이 시간대는 여름에만 지속됩니까?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">Proleptic Gregorian 달력에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">Proleptic Julian 일정에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">로 변환되어</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">모나 딕 계산 내에서 예외 처리를 시작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">고정 된 바이트 수로 작동하도록 디코더를 분리하고 더 적은 바이트를 사용하거나 더 많은 바이트를 사용하려고하면 실패합니다. 주어진 디코더가 실패하면 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 도 실패합니다. &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; 의 오프셋 은 입력의 절대 값이 아니라 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 시작에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">컴파일중인 모듈이 -XTrustworthy로 표시되었지만보다 유익한 범위 인 -XSafe로 표시 될 수있는 경우 경고를 발행하십시오. 종속성이 업데이트됨에 따라 Safe Haskell 바운드를 개선 할 수있는 경우 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하다고 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="translated">컴파일중인 모듈이 안전한 것으로 간주되면 경고를 발행합니다. 안전 추론을 사용할 때 모듈의 안전 유형을 확인하는 데 사용해야합니다. 모듈이 명시 적으로 안전하다고 표시되면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하지 않은 것으로 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">사용 된 하나 이상의 사용 된 변수를 바인딩하는 바인딩의 오른쪽에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">유형 수준 함수의 오른쪽에 배치하여 잘못된 경우에 오류를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">또한 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : platform-independent flags 참조&lt;/a&gt; )와 함께 사용하면 생성자에서 엄격한 필드를 언팩하거나 언 박스 할 수 있으며 하나 이상의 간접 레벨이있을 수 있습니다. 제거하십시오. 언 패킹은 단일 생성자 데이터 유형에 대해서만 발생합니다 ( &lt;code&gt;Int&lt;/code&gt; 는 좋은 후보입니다).</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">어떤 방식 으로든 슈퍼 클래스와 메서드를 사용하여 구현할 수 있습니다. 그러나 추상 클래스에 의존하는 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않습니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;# 13086&lt;/a&gt; 참조 ). 이러한 선언은 &lt;code&gt;Constraint&lt;/code&gt; 종류의 유형 동의어로 구현할 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하는 경우이 유형 동의어는 위의 서명의 유효한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">수퍼 클래스 및 메소드 세트를 사용하여 어떤 방식 으로든 구현할 수 있습니다. 그러나 추상 클래스에 따른 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않음, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;이슈 # 13086&lt;/a&gt; 참조 ). 이러한 선언은 종류 &lt;code&gt;Constraint&lt;/code&gt; 유형 동의어에 의해 구현 될 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하면이 형식 동의어는 위의 서명을 올바르게 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">복합 모나드를 구성하기 위해 일련의 모나드 변압기가 적용될 수있는베이스 모나드로 사용될 수 있습니다. 대부분의 모나드 변압기 모듈에는 변압기를 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함됩니다 . 예를 들어 &lt;code&gt;State s&lt;/code&gt; 는 &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">functor 또는 monad 클래스에 의해 매개 변수화 된 함수와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">유효한 구멍 맞춤의 이름과 유형이 맞춤의 의미를 실현하기에 충분하지 않은 경우가 있습니다. 이 플래그는 문서가 사용 가능한 경우 (및 함수가 제공되는 모듈이 &lt;code&gt;-haddock&lt;/code&gt; 플래그 로 컴파일 된 경우) 메시지에 적합한 문서를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">실재적으로 바인딩 된 유형 변수 &lt;em&gt;가&lt;/em&gt; 범위 내에 &lt;em&gt;있지&lt;/em&gt; 않아야 하는 것은 이상해 보입니다 . 일반적으로 이름 바인딩은 동일한 이름의 외부 변수 범위에서 단순히 그림자를 만듭니다 ( '구멍 만들기'). 그러나 이러한 유형 변수를 범위 내로 가져올 수 &lt;em&gt;있는&lt;/em&gt; 방법이 있어야합니다 . 그렇지 않으면 후속 유형 시그니처에서 기존에 바인딩 된 유형 변수의 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용될를. &lt;a href=&quot;#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용되는 RTS 옵션을. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">그것은 진행하기 전에 약한 머리 정상 형태에 각각의 힘을 가한 결과를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 보다 메모리 오버 헤드가 낮으며 힙 조각화에 기여하지 않습니다. 문자열 데이터를 복사하는 비용으로 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 또는 ByteString 에서 변환 할 수 있습니다 . 다른 작업은 거의 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="translated">압축 영역으로 복사되었습니다. &lt;code&gt;ghc-compact&lt;/code&gt; 및 &lt;code&gt;compact&lt;/code&gt; 에 대한 문서 는이 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">윤초를 무시하므로 반드시 고정 된 양의 클럭 시간 일 필요는 없습니다. 예를 들어 윤초가 개입되었는지 여부에 관계없이 23:00 UTC + 2 시간의 NominalDiffTime = 01:00 UTC (+ 1 일)입니다.</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">이다 &lt;em&gt;귀하의 책임&lt;/em&gt; 있는지 확인하기 위해 &lt;code&gt;intLookup&lt;/code&gt; 이 정말의 전문 버전으로 동작 &lt;code&gt;genericLookup&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;루트 세트&lt;/em&gt; 의 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 . &lt;em&gt;groupBy&lt;/em&gt; 보다 약 40 % 빠릅니다 &lt;em&gt;(==)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 개체입니다.</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">라이브러리 작성자가 GHC에게 콜 패턴 전문화를 매우 적극적으로 수행하도록 지시 할 수도 있습니다. 이것은 전문화의 수 또는 코드 크기에 관계없이 전문화하려는 일부 고도로 최적화 된 라이브러리에 필요합니다. 예를 들어, &lt;code&gt;vector&lt;/code&gt; 라이브러리 에서 단순화 된 사용 사례를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">전기에 의해 프로파일을 제한하여 다른 기준으로 하나 이상의 이러한 상태에서 힙을 분류 할 수도 있습니다. 예를 들어, 생산자에 의해 드래그 또는 빈 상태의 힙 부분을 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">런타임 정수 또는 문자열 값을 해당 유형 레벨 리터럴로 변환 할 수도 있습니다. 물론 결과 형식 리터럴은 컴파일 타임에 알 수 없으므로 기존 형식으로 숨겨집니다. 변환을 이용하여 수행 될 수있다 &lt;code&gt;someNatVal&lt;/code&gt; 을 정수와 위해 &lt;code&gt;someSymbolVal&lt;/code&gt; 문자열 :</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">레코드 생성자와 똑같이 동작하는 패턴 동의어를 정의 할 수도 있습니다. 이를 수행하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">내보내기 목록에서 특수 토큰 &lt;code&gt;..&lt;/code&gt; 을 사용하여 현재 번들로 생성 된 모든 생성자를 의미 할 수도 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="translated">&lt;code&gt;qualified&lt;/code&gt; 가 사전 및 사후 양성 위치에 모두 나타나면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">이 제한은 미래에 완화 될 것으로 생각되지만,이 시나리오와 관련된 어려움이 이론적인지 (이러한 의존성이 우리 유형 시스템에 주요 유형이 없음을 의미 할 것임) 또는 단순히 실제적인지 여부는 (작성 당시) 불분명합니다. (GHC의 구현을 고려할 때 이러한 의존성을 추론하는 것은 어렵다). 따라서 GHC는 손쉬운 방법으로 사용자의 도움을 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">현재 &lt;code&gt;Array ix (TVar e)&lt;/code&gt; 로 구현되어 있지만 향후보다 효율적인 구현으로 대체 될 수 있습니다 (그러나 인터페이스는 동일하게 유지됨 ).</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">약한 포인터 객체가 아닌 도달 가능한 객체가 직접 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">확장명 &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma로 사용 가능합니다. (같은 확장자로 &lt;code&gt;mdo&lt;/code&gt; - notation과 &lt;code&gt;do&lt;/code&gt; 표현식 안에서 &lt;code&gt;rec&lt;/code&gt; 블록을 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">이 연산자는 &lt;code&gt;e&lt;/code&gt; 에서 다형성이어야 하며 (명령에 대한 환경 입력과 하위 명령에 대한 환경 입력을 나타냄) 해당하는 고유 특성을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">이 작업은 향후 Haskell 개정판에서 대체 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">내보내거나</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">그것은이 될 괜찮지 &lt;em&gt;전위&lt;/em&gt; (두 선언 (A) 및 (B), 발언권을 포함하여)의 오버랩; 특정 제약 조건이 둘 이상 일치하는 경우에만 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">것이 중요합니다 &lt;code&gt;-O*&lt;/code&gt; 플래그의 조합과 거의 동등 &lt;code&gt;-f*&lt;/code&gt; 플래그. 이러한 이유로 &lt;code&gt;-O*&lt;/code&gt; 및 &lt;code&gt;-f*&lt;/code&gt; 플래그 의 효과 는 명령 행에서 발생하는 순서에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="translated">큽니다. 현재 GHC는 대형 객체를 4KB 블록의 80 % 이상 (즉, 3277 바이트 이상)으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">방정식 함수 정의를 사용하는 대신 사례를 반복해야합니다. 그리고 &lt;code&gt;t&lt;/code&gt; 와의 매칭 이 다른 패턴 안에 깊숙이 묻히면 상황이 더욱 악화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">그것은 사용하는 것보다 더 빠른 없다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 사용하는 것보다 빠르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">항상 모든 일반 표현 유형에 대한 인스턴스를 제공 할 필요는 없지만 인스턴스를 생략하면 함수가 작동 할 데이터 유형 세트가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">종료자가 결국 실행된다는 보장은 없으며 프로그램이 종료 될 때 미해결 종료자를 실행하려고 시도하지 않습니다. 따라서 종료자는 리소스를 정리하는 데 의존해서는 안됩니다. 종료 자와 함께 다른 방법 (예 : 예외 처리기)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">Makefile의 모든 내용을 소스 파일로 옮기는 것은 좋지 않지만 경우에 따라 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma가 올바른 것입니다. (당신이 사용하는 경우 &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt; 하고있는 &lt;code&gt;OPTION&lt;/code&gt; 모듈에 플래그의 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 는 생성에 넣어 얻을 것이다 &lt;code&gt;.hc&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">로드 된 모듈에도 해당 옵션을 적용하지 않고도 대화식 옵션을 변경하는 것이 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">새로운 &lt;code&gt;IsList&lt;/code&gt; 인스턴스를 선언하는 것이 좋습니다 . 따라서리스트 표기법은 완전히 새로운 데이터 유형에 유용합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">GADT 스타일 구문을 사용하여 일반적인 대수 데이터 형식을 선언 할 수 있습니다. GADT를 GADT로 만드는 것은 구문이 아니라 결과 유형이 &lt;code&gt;T a b&lt;/code&gt; 가 아닌 데이터 생성자의 존재입니다 .</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">스플 라이스는 스플 라이스 사이트에 포함되지 않은 이름이 포함 된 표현식으로 확장 될 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">연관된 유형을 정의하는 클래스가 연관된 유형 인스턴스의 기본값을 지정할 수 있습니다. 예를 들어, 이것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">패키지를 사용하면 동일한 이름을 가진 두 개의 모듈을 포함하는 프로그램으로 끝날 수 있습니다. 아마도 &lt;em&gt;숨겨진&lt;/em&gt; 모듈 &lt;code&gt;M&lt;/code&gt; 이있는 패키지 &lt;code&gt;P&lt;/code&gt; 를 사용했고 프로그램에 모듈 &lt;code&gt;M&lt;/code&gt; 이있을 수도 있습니다. 또는 사용한 패키지의 종속성에 일부 중복 모듈이 포함되어있을 수 있습니다. 다른 패키지의 종속성으로 인해 프로그램에 특정 패키지의 여러 버전이 포함되어있을 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">RTS에 자체 정보를 제공하도록 요청할 수 있습니다. 이렇게하려면 &lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 유형을 사용하여 모든 예외를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; 블록을 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 로 연결하는 것이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">형식 또는 클래스 선언에 도입 된 형식 변수간에 복잡한 종속성을 얻을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 가 런타임 통계에서 얼마나 잘 작동 하는지에 대한 약간의 정보를 얻을 수 있습니다 . &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">Haskell로 작성되지 않은 다른 프로그램에서 GHC에 의해 생성 된 공유 라이브러리를로드 할 수 있으므로 플러그인으로 사용하기에 적합합니다. 물론 플러그인을 구성하려면 FFI를 사용하여 C 함수를 내보내고 RTS 초기화에 대한 규칙을 따라야합니다. &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;외부 코드에서 호출 할 수있는 Haskell 라이브러리 만들기를&lt;/a&gt; 참조하십시오 . 특히 Haskell 함수가 호출되기 전에 플러그인을 초기화하기 위해 공유 라이브러리에서 C 함수를 내보내고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt; 를 사용하여 실제 번역을 볼 수 있지만 출력이 매우 장황하다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">디버거를 사용하여 함수 값을 검사 할 수 있습니다. 우리가 중단 점에 있고 함수가 범위 내에 있으면 디버거가 소스 코드를 표시 할 수 없습니다. 그러나 정보를 일부 인수에 적용하고 결과를 관찰하여 일부 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">구문 적으로 CUSK (위의 규칙에 따라)가 있지만 실제로 약간의 추론이 필요한 데이터 유형을 작성할 수 있습니다. 매우 고안된 예로써,</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">소스 파일의 이름을 모듈과 동일하게 가정하면 GHC와 함께 사용할 &lt;code&gt;Makefile&lt;/code&gt; 을 설정하는 것이 합리적 입니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 binary 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 바이너리 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉, &lt;code&gt;C&lt;/code&gt; 에 대한 마지막 누락 인수 는 &lt;code&gt;C&lt;/code&gt; 의 메소드 에서 명목상의 역할로 사용되지 않습니다 . &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉,에 누락 된 마지막 인자 &lt;code&gt;C&lt;/code&gt; 는 의 어떤에서 소액의 역할에서 사용되지 않는 &lt;code&gt;C&lt;/code&gt; 의 방법. ( &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">GHC는 외래 전화를 선점하지 않기 때문에 외래 전화 중 일시적으로 부동 소수점 단위 상태를 수정하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 느립니다. 장점은 C와 호환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을&lt;/a&gt; 통해 인스턴스를 파생시킬 때 추가 언어 확장을 활성화해야하는 경우가 있습니다. 예를 들어 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 구문을 사용하는 간단한 클래스 및 인스턴스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">가능하면이 모듈의 명시 적 상태 관리 기능보다는 &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt; 의보다 안전한 monadic API를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">메모리에 많은 짧은 문자열을 유지해야하는 코드의 내부 표현으로 사용하기에 적합하지만 교환 유형으로 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; . 즉, 일반적으로 퍼블릭 API에서 사용해서는 안됩니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 종류는 일반적으로 인터페이스에 사용하기에 적합하다; 보다 유연하고 광범위한 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">순수한 코드에 사용하기에 적합합니다. IO 컨텍스트에서는 대신 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 객체의 값 또는 종료 자입니다.</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 f 가 최종적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 인라인 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 &lt;em&gt;최적화 된&lt;/em&gt; 버전의 &lt;code&gt;f&lt;/code&gt; 를 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS에 함수를 노출시키는 것입니다. 이러한 함수가 최적화되지 않았다면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 버전 이 궁극적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 INLINE 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 우리는 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;최적화 된&lt;/em&gt; 버전 을 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS 에서 함수를 노출하기 위한 것입니다. 이러한 함수가 최적화되어 있으면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 비동기 예외를 완전히 방지하는 방법이 아니라 비동기 모드에서 폴링 모드로 전환하는 방법 으로 생각하면 유용 합니다. 비동기 예외의 주된 어려움은 일반적으로 어디에서나 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내에서 인터럽트 가능한 작업 (또는 다른 인터럽트 가능한 작업 호출)에 의해서만 비동기 예외가 발생한다는 것입니다. 대부분의 경우 이러한 작업 자체는 I / O 오류와 같은 예외를 발생시킬 수 있으므로 일반적으로 호출자는 작업에서 발생하는 예외를 처리 할 준비가됩니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부의 비동기 예외에 대해 명시 적 폴링을 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; 가&lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 데이터의 가족을 제공하는 데 필요한 자신과 관련된 종류의 반환 &lt;code&gt;TYPE&lt;/code&gt; 등으로, &lt;code&gt;FooKey&lt;/code&gt; 및 &lt;code&gt;BarType&lt;/code&gt; 의 위의 예제를. 확장은 위의 &lt;code&gt;FooKeyBoolC&lt;/code&gt; 및 &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; 와 같은 &lt;code&gt;newtype instance&lt;/code&gt; 선언 에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">각 패키지가 단일 공유 객체 파일로 빌드 될 때 공유 객체에 주목할 필요가 있습니다. 공유 객체에 대한 참조는 추가 간접 비용이 들기 때문에 패키지 내 참조는 패키지 간 참조보다 저렴합니다. 물론 이것은 &lt;code&gt;main&lt;/code&gt; 패키지 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">Haskell 스레드를 강제로 종료하는 것이 항상 가능한 것은 아닙니다. 예를 들어 스레드가 현재 외래 호출을 실행 중일 수 있으므로 외래 호출을 강제로 완료 할 방법이 없습니다. 게다가, 런타임은 최악의 경우 Haskell 코드와 런타임이 메모리에서 제거 될 예정이라고 가정해야합니다 (예를 들어, 이것이 &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt; 이면 &lt;code&gt;hs_exit()&lt;/code&gt; 은 DLL을 언로드하기 전에 정상적으로 호출됩니다). 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 모든 미해결 외래 호출이 리턴 될 때까지 기다려야 자체 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">또한 Haskell 모듈이 컴파일 될 C 코드와 C 파일로 C 코드에 포함되는 C 헤더와 함께 프로그램에 링크 될 추가 C 함수를 포함하는 C 파일을 출력 할 수 있습니다. . 이 두 파일은 &lt;code&gt;#def&lt;/code&gt; 구문이 사용될 때 생성 됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 은 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 는 (참조 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;# 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 이 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 가 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 (참조 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;이슈 # 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">추측하는 것이 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; 및 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 는 비슷한 작업을 수행 하는 것처럼 보일 수 있습니다. 둘 다 사용하여 모듈을 범위로 가져올 수 있습니다. 그러나 매우 중요한 차이점이 있습니다. GHCi는 두 가지 모듈 세트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 또한 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;c&lt;/code&gt; 의 종류로 암시 적으로 선언됩니다 . 따라서 일반적인 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 있음을 유의하십시오 &lt;code&gt;b&lt;/code&gt; 는 암시 적으로 선언 된 &lt;code&gt;c&lt;/code&gt; 의 종류. 따라서 일반 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">실제로 읽은 바이트 수를 반환합니다. 데이터를 읽기 전에 EOF에 도달 한 경우 (또는 &lt;code&gt;count&lt;/code&gt; 가 0 인 경우) 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">이러한 재귀 바인딩은 실제로 다양한 모나드에 대해 의미가 있지만 모든 것은 아닙니다. 특히 이런 의미에서 재귀에는 다음과 같이 &lt;code&gt;Control.Monad.Fix&lt;/code&gt; 에 정의 된 &lt;code&gt;MonadFix&lt;/code&gt; 클래스 의 &lt;code&gt;mfix&lt;/code&gt; 메소드로 캡처 한 기본 모나드에 대한 고정 소수점 연산자가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newPinnedByteArray#&lt;/code&gt; 의해 할당되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">GHCi가 시작된 현재 폴더에 &lt;code&gt;.ghci-history&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">그런 다음 개별 항목과 항목 쌍을 &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 에 적절하게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">GHCi가 각 모듈의 기본 설정을 기록하고 '현재'모듈의 설정을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">원격으로 마운트 된 디스크를 사용하여 빠른 컴퓨터 에서 &lt;em&gt;컴파일&lt;/em&gt; 하는 것이 합리적 입니다. 그런 다음 디스크가 직접 장착 된 느린 시스템에 &lt;em&gt;연결&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 가로&lt;/a&gt; 드 된 모듈에도 적용되는 경우 바람직하지 않습니다 . 컴파일 오류가 발생할 수 있지만 GHC는 플래그가 변경되어 모듈을 다시 컴파일해야한다고 생각하기 때문에 추가 재 컴파일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">단일 생성자 유형 (데이터 생성자가 하나 뿐인 유형 (예 : 튜플은 단일 생성자 유형))에서 함수가 엄격한 경우 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">다음 예제와 같이 새 &lt;code&gt;rec&lt;/code&gt; 키워드를 사용하여 상호 재귀 바인딩을 가질 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">&lt;code&gt;a==b&lt;/code&gt; 또는 &lt;code&gt;p==q&lt;/code&gt; 라고해도 괜찮지 만 &lt;code&gt;a==q&lt;/code&gt; 는 두 &lt;code&gt;Baz1&lt;/code&gt; 생성자 에서 발생하는 두 가지 유형이 같기 때문에 잘못되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">추악하고 느립니다.</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 현재 msbf에서 큰 정수로 변환하여 &lt;code&gt;mpz_export()&lt;/code&gt; 를 호출 하므로 작은 정수에 대해 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 를 호출하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">일부 &lt;code&gt;(x,y)&lt;/code&gt; 의 경우 &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt; 경우 결과 크기가 더 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">아이템 (IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">반복 건설</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">J. Nievergelt와 EM Reingold, &quot; 1973 년 3 월 SIAM 컴퓨팅 저널 2 (1),&quot; &lt;em&gt;경계 균형의 이진 탐색 트리&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">요한 티벨 &amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">드라이브와 나머지 경로를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">경로 요소를 다시 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell의 일반적인 파생 메커니즘&lt;/a&gt; . Haskell (Haskell'2010), pp. 37-48, ACM, 2010에서 세 번째 ACM Haskell 심포지엄의 절차.</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell에 대한 일반적인 파생 메커니즘&lt;/a&gt; . Haskell에 관한 세 번째 ACM Haskell 심포지엄 (Haskell'2010), pp. 37-48, ACM, 2010.</target>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">줄스 헤지스 &quot;역 추적 검색을위한 모나드 변압기&quot;. 에서 &lt;em&gt;MSFP 2014 논문집&lt;/em&gt; . &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;A.hs&lt;/code&gt; 를 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi&lt;/code&gt; 와 객체 파일 &lt;code&gt;A.o&lt;/code&gt; 생성되는 &lt;code&gt;A.hs-boot&lt;/code&gt; 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi-boot&lt;/code&gt; 와 의사 오브젝트 파일 &lt;code&gt;A.o-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">Template Haskell ( &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; ) 의 경우와 마찬가지로 GHC는 두 번째 문자가 따옴표 인 데이터 생성자 앞에 따옴표를 넣으면 혼란스러워집니다. 이 경우 프로모션 견적과 데이터 생성자 사이에 공백을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">타입 추론에서와 마찬가지로, 재귀 타입에 대한 친절한 추론은 &lt;em&gt;단형의&lt;/em&gt; 재귀 만 사용할 수 있습니다 . 이 (고려 된) 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">do-notation을 사용하여 &lt;code&gt;Monad&lt;/code&gt; 인스턴스를 정의하지 않는 것처럼 do-notation을 사용하여 ( &lt;code&gt;ApplicativeDo&lt;/code&gt; 사용시 ) &lt;code&gt;Functor&lt;/code&gt; 또는 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스를 정의하지 않아야 합니다. &lt;code&gt;Monad&lt;/code&gt; 와 관련하여 이러한 인스턴스를 정의하는 올바른 방법 은 &lt;code&gt;Monad&lt;/code&gt; 작업을 직접 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">값 수준 바인딩의 서명과 마찬가지로 패턴 동의어 서명은 둘 이상의 패턴에 적용될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 플러그인과 마찬가지로, &lt;code&gt;-fplugin-opt&lt;/code&gt; 플래그 를 사용하여 지정할 수있는 일부 옵션을 취하고 사용할 수있는 &lt;code&gt;DynFlags&lt;/code&gt; 플러그인을 작성할 수 있습니다 . 위의 &lt;code&gt;DynFlagsPlugin&lt;/code&gt; 코드에서 해당 옵션은 &lt;code&gt;hooksP&lt;/code&gt; 의 &lt;code&gt;opts&lt;/code&gt; 인수 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">x =&amp;gt;만으로 주어진 모드로 파일을 생성합니다. Nothing =&amp;gt; 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">&lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; 를 통한 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.hc&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.hc&lt;/code&gt; 파일은 &lt;a href=&quot;codegens#unreg&quot;&gt;등록되지 않은&lt;/a&gt; 컴파일러에 의해서만 생성됨 ).</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.hi&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.hi&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-hi-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM을&lt;/a&gt; 통해 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.ll&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.ll&lt;/code&gt; 파일은 기본 코드 생성기를 사용할 때 생성되지 않으므로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용하여 파일 을 강제로 생성해야 할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.o&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.o&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-o-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.s&lt;/code&gt; 파일을 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">클래스 중 하나 이상이 &lt;strong&gt;대화 형 클래스 인&lt;/strong&gt; 그룹 만 유지하십시오 (아래에 정의 됨).</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">&lt;code&gt;CPP&lt;/code&gt; 전 처리기 단계 의 출력을 &lt;code&gt;.hscpp&lt;/code&gt; 파일 로 유지 하십시오. &lt;code&gt;.hscpp&lt;/code&gt; 의 모듈이 컴파일 및 C의 전처리를 사용 들어가면 파일은, 생성된다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">주요 인수는 WHNF에 평가됩니다</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">충전 또는 패딩 종류.</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">종류 표현</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="translated">종류 변수는 &lt;em&gt;보이는&lt;/em&gt; 위치 에서도 정량화 할 수 있습니다 . 다음 두 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">예를 들어 종류 평등은 연기 될 수 없다</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">모나드의 Kleisli 화살.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 테일</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 더블 테일</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">LLVM 코드 &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;생성기&lt;/a&gt; 의 LLVM 코드</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">LLVM 코드 생성기</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">디코더에 라벨을 붙입니다. 디코더가 실패하면 오류 메시지 문자열에 새 줄에 레이블이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">라벨링 나무</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">언어 확장 조회</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">언어 확장</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">GHC에 알려진 언어 확장</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">언어 옵션은 두 가지 방법으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">언어 옵션은 명령 행 옵션 &lt;code&gt;-Xblah&lt;/code&gt; 또는 파일 자체 의 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma에 의해 사용 가능합니다. &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;언어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Cabal이 인식하는 언어 옵션은 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma를 사용하여 활성화 할 수도 있으므로 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; ( &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal은 GHC와 Template Haskell의 통합에 내부적으로 사용되는 몇 가지 추가 기능을 제공합니다. 이것은 공개 API의 일부가 아니므로이 모듈에 대한 API 보증은 버전마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 플래그로 설정된 일반 할당 영역에서 큰 개체가 할당되지 않으므로 이러한 개체에 대해 별도의 제한이 있습니다. 큰 개체는 작은 개체보다 훨씬 드물기 때문에 대부분의 프로그램 은 &lt;code&gt;-AL&lt;/code&gt; 한계 보다 &lt;code&gt;-A&lt;/code&gt; 한계에 도달합니다. 그러나 &lt;code&gt;-A&lt;/code&gt; 한계는 &lt;code&gt;-AL&lt;/code&gt; 이며, -AL 한계는 전역이므로 &lt;code&gt;-N&lt;/code&gt; 이 커질수록 &lt;code&gt;-AL&lt;/code&gt; 한계에 먼저 도달 할 가능성이 높아집니다 . 이를 방지하려면 큰 &lt;code&gt;-N&lt;/code&gt; 을 사용할 때 더 큰 &lt;code&gt;-AL&lt;/code&gt; 한계 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">마지막으로 선언의 일반 유형 변수가 온다.</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">마지막으로,이 모든 것은 스톡 파생이 적용되는 &lt;code&gt;Read&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 이외의 클래스에만 적용됩니다 (Haskell 보고서의 섹션 4.3.3.). 표준 클래스 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 의 경우 스톡 방법을 사용하는지 또는 여기에 설명 된 방법을 사용하는지 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">그런 다음 레이아웃 필드는 겹치므로 최종 레이아웃은 가능한 한 작습니다. 예를 들어 상자에없는 합계가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">멀티 웨이 레이아웃은 다른 레이아웃 컨텍스트와 동일한 방식으로 작동하지만 멀티 웨이에서 가드 사이의 세미콜론은 선택 사항입니다. 따라서 모든 보호대를 같은 열에 배치 할 필요는 없습니다. 이것은 가드가 함수 정의 및 대소 문자 표현에서 작동하는 방식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 느리게 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 읽기 완료 후 또는 오류에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">값을 파일에 느리게 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 생성 된 지연의 꼬리으로 사용할 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">오류가 발생해야하는 Haskell 98 사양과 달리 오류가 발생하면 Lazy I / O에서 예외가 발생합니다 (Haskell 98 보고서의 섹션 21.2.2 참조). throw되는 예외는 실패한 IO 작업이 IO 모나드에서 수행되고 &lt;code&gt;System.IO.Error.catch&lt;/code&gt; 또는 &lt;code&gt;Control.Exception.catch&lt;/code&gt; 에 의해 잡힐 수있는 일반적인 IO 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">게으른 RWS 모나드.</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">게으른 리더-라이터 상태 모나드</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">지연 상태 모나드는 계산을 통해 업데이트 가능한 상태를 전달합니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">게으른 상태 모나드.</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">게으른 작가 모나드.</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">구조에 왼쪽 연관 모나 딕 이중 체.</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">좌익</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">왼쪽 수축 (또는 조임)</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">구조의 왼쪽 연관 접힘이지만 연산자를 엄격하게 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">구조의 왼쪽 연관 접힘.</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">생성자 응용 프로그램에 대한 왼쪽 연결 접기 작업</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">좌우 구성</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">Kleisli 화살표의 왼쪽에서 오른쪽으로 구성.</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">레거시 폴드</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">SIMD 벡터 유형의 길이</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">레나르트 콜 모딘</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">레나르트 콜 모딘 로스 패터슨</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 의 CSV 테이블 렌더링 예제에서 이러한 개선 사항을 설명하겠습니다 . &quot;핫 코드&quot;는 테이블 셀의 렌더링으로, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API 의 함수 만 사용하여 다음과 같이 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">먼저 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">간단한 예를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">Hello World 프로그램을 만들어서 컴파일하고 실행 해 봅시다. 먼저 Haskell 코드가 포함 된 &lt;code&gt;hello.hs&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">먼저이 프로그램을 통해 실행이 어떻게 진행되는지 봅시다. 우리는 GHC에게 디버그 정보를 원한다고 말하면서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">예제 GHCi 세션부터 시작하겠습니다. ghci 명령으로 &lt;code&gt;ghci&lt;/code&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">위에서 예제를 가져 와서 독립형 C 프로그램에서 호출 해 봅시다. C 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">퀵 정렬을 실행 예제로 사용합시다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">여기에 표시된 이진 데이터를 디코딩합시다. 이 예에서 값은 리틀 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">먼저 많은 &lt;code&gt;Trade&lt;/code&gt; 를 해독하는 함수를 정의 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">정교하게 인쇄 된 출력의 세부 수준. 레벨 0이 가장 자세하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
