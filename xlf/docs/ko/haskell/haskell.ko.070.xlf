<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="03411ce0e13fe57751c2f82253b492cc9d47c8f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 의 슈퍼 클래스입니다 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 이후 &lt;em&gt;기본-4.11.0.0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="166aed14653edc6f46dcff3c1dae86631ba0a891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 는 입력을 소비하지 않는 파서 &lt;code&gt;p&lt;/code&gt; 에 적용될 때 놀라운 동작을 나타냅니다 . 구체적으로 특별히</target>
        </trans-unit>
        <trans-unit id="ec9986bf04287187f171a448a6e427d2d4d16d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 는 입력을 소비하지 않는 파서 &lt;code&gt;p&lt;/code&gt; 에 적용될 때 놀라운 동작을 나타냅니다 . 구체적으로 특별히</target>
        </trans-unit>
        <trans-unit id="5d16f3693057b662396f898cac3b01fe76debdb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 는 입력을 소비하지 않는 파서 &lt;code&gt;p&lt;/code&gt; 에 적용될 때 놀라운 동작을 나타냅니다 . 구체적으로 특별히</target>
        </trans-unit>
        <trans-unit id="6818107750bfc6c118df69013440ac82805bba52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Only strict in the reference and not the referenced value.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 참조 값이 아닌 참조에만 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="dc20d237e47fdcc6a1702edaefb72cd73590b46d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Prior to &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; this instance was only defined for &lt;code&gt;base-4.8.0.0&lt;/code&gt; and later.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; 이전에는 이 인스턴스가 &lt;code&gt;base-4.8.0.0&lt;/code&gt; 이상 에 대해서만 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7a7733fa013d8d35cc1c5581dc3eef96e5dfd0cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The functions in &lt;code&gt;base-4.12&lt;/code&gt; changed the serialisation in case of a &lt;code&gt;Just 0&lt;/code&gt; precision; this version of &lt;code&gt;text&lt;/code&gt; still provides the serialisation as implemented in &lt;code&gt;base-4.11&lt;/code&gt;. The next major version of &lt;code&gt;text&lt;/code&gt; will switch to the more correct &lt;code&gt;base-4.12&lt;/code&gt; serialisation.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;base-4.12&lt;/code&gt; 의 기능 은 &lt;code&gt;Just 0&lt;/code&gt; 정밀도의 경우 직렬화를 변경했습니다 . 이 버전의 &lt;code&gt;text&lt;/code&gt; 여전히 &lt;code&gt;base-4.11&lt;/code&gt; 에서 구현 된 직렬화를 제공합니다 . 다음 주요 버전의 &lt;code&gt;text&lt;/code&gt; 는보다 정확한 &lt;code&gt;base-4.12&lt;/code&gt; 직렬화로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="77693d6f146c132591a587e160c8af245f51c0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The intrepid user may notice that &lt;code&gt;HasCallStack&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;CallStack&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 대담한 사용자는 &lt;code&gt;HasCallStack&lt;/code&gt; 이 암시 적 매개 변수 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 의 별칭 일뿐 입니다. 이것은 구현 세부 사항이며 &lt;code&gt;CallStack&lt;/code&gt; API의 일부로 간주 &lt;strong&gt;되어서는 안됩니다&lt;/strong&gt; . 향후 구현을 변경하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2533d0f8b23d21f162cecf82e012550c323eb127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The replacement character returned by &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; MUST be within the BMP plane; surrogate code points will automatically be remapped to the replacement char &lt;code&gt;U+FFFD&lt;/code&gt; (&lt;em&gt;since 0.11.3.0&lt;/em&gt;), whereas code points beyond the BMP will throw an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since 1.2.3.1&lt;/em&gt;); For earlier versions of &lt;code&gt;text&lt;/code&gt; using those unsupported code points would result in undefined behavior.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; 에 의해 반환되는 대체 문자 는 BMP 평면 내에 있어야합니다. 대리 코드 포인트는 대체 문자 &lt;code&gt;U+FFFD&lt;/code&gt; ( &lt;em&gt;0.11.3.0부터&lt;/em&gt; )에 자동으로 재 매핑되는 반면 BMP 이외의 코드 포인트는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ( &lt;em&gt;1.2.3.1 이후&lt;/em&gt; ). 지원되지 않는 코드 포인트를 사용하는 이전 버전의 &lt;code&gt;text&lt;/code&gt; 경우 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6af85fbdeb1c1548ecdc703b5c39806483adbef4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This instance is only defined for &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 인스턴스는 &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt; 에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d4e26172ba9fac2189c2280c424438f132a68b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is not needed anymore since &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; became a superclass of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in &lt;em&gt;base-4.11&lt;/em&gt; and this newtype be deprecated at some point in the future.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 은 &lt;em&gt;base-4.11&lt;/em&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 의 수퍼 클래스가되었으며 향후이 시점에서이 새로운 유형이 더 이상 사용되지 않으므로 더 이상 필요하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09bbdeeb23f25384d247711b42a27b30cfbb93e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 중복되며 &lt;em&gt;base-4.11.0.0&lt;/em&gt; 부터 기본 구현 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; &lt;em&gt;갖습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7bee89a50523b2b7f4298406f2f560b7f97e3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 중복되며 &lt;em&gt;base-4.11.0.0&lt;/em&gt; 부터 기본 구현 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; &lt;em&gt;갖습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="53250bceefb8edf3079bcff5effdeb91a06684e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 중복되며 &lt;em&gt;base-4.11.0.0&lt;/em&gt; 부터 기본 구현 &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; &lt;em&gt;갖습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5e33ea116bb722425b17e443f5a6fd673821d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 방법은 중복되며 &lt;em&gt;base-4.11.0.0&lt;/em&gt; 부터 기본 구현 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; &lt;em&gt;갖습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4b182cab3c093432cfb21fa9dafb0c11115dbd3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;. Should it be implemented manually, since &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; is a synonym for (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;), it is expected that the two functions are defined the same way. In a future GHC release &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; will be removed from &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 메서드는 중복되며 &lt;em&gt;base-4.11.0.0&lt;/em&gt; 이후 기본 구현 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 있습니다. 수동으로 구현할 경우 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 는 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 의 동의어 이므로 두 함수가 동일한 방식으로 정의 될 것으로 예상됩니다. 미래에 GHC 릴리스 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 가 에서 제거됩니다 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b87531c422bb43abf588cd19cfb145b4b1af212" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Negation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Negation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35fdc70491666deaadbc15762d73d32a5836699b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중첩 패턴&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39c28848aeb5cab86ac6b199bccbac9933f1e95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Newtypes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Newtypes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0d40e5bd81d1d6957246a1ec75c38216c4704c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No ``-O*``-type option specified:&lt;/strong&gt; This is taken to mean &amp;ldquo;Please compile quickly; I&amp;rsquo;m not over-bothered about compiled-code quality.&amp;rdquo; So, for example, &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;``-O * ''유형 옵션이 지정되지 않았습니다. &quot;&lt;/strong&gt; 빠르게 컴파일하십시오. 컴파일 된 코드 품질에 대해 지나치게 고민하지 않았습니다.&amp;rdquo; 예를 들어, &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15fc39334b9319bc0d7d967925cee84740f69bc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module exports internal implementation details that may change anytime. If you want a more stable API, use &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 모듈은 언제든지 변경 될 수있는 내부 구현 세부 사항을 내 보냅니다. 보다 안정적인 API를 원하면 &lt;a href=&quot;system-process&quot;&gt;System.Process를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2350c93205902e1c98253ef2f7d2621dcc8098cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; : 다소의 관점에서 기록되어야 위 예 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 시기 만에 파일 디스크립터를 해제 확보는 (설명 참조 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 예를 들어).</target>
        </trans-unit>
        <trans-unit id="47f5cf616517b6eba6447338e761bc574ca481fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 위의 예 는 적시에 파일 설명자를 해제 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 로 작성해야합니다 ( 예를 들어 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="f41c2eafe5091226c38a0690d82eb9525b65f556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function is a very big hammer. If you only need an absolute path, &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; is sufficient for removing dependence on the current working directory.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 기능은 매우 큰 망치입니다. 절대 경로 만 필요한 경우 &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; 는 현재 작업 디렉토리에 대한 종속성을 제거하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="615eff90afa4cc9668282159ebd5fba86b0a2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an internal GHC module with an API subject to change. It's recommended use the &lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt; module to import the &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 API는 변경 될 수있는 내부 GHC 모듈입니다. &lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt; 모듈을 사용 하여 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 유형 을 가져 오는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="60f2ee22884b6646412af01b670fedfd33ce75d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike for the unary &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt;, there is currently no support for generically deriving &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 단항 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt; 와 달리 , 일반적으로 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt; 를 파생 시키는 기능은 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8f5608392e60fb88bd92846a796785eb6d245173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pattern matching in case expressions, lambdas, do-notation, etc&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;케이스 표현식, 람다, 표기법 등의 패턴 일치&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba63c80e3e98efdf17dda0cdece96c022afb21de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pick first&lt;/strong&gt;. We can simply select the &lt;strong&gt;first matching axiom&lt;/strong&gt; we encounter. In the above example, this would be &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt;. We&amp;rsquo;d then need to entail &lt;code&gt;A a&lt;/code&gt;, for which we have no matching axioms available, causing the above program to be rejected.</source>
          <target state="translated">&lt;strong&gt;먼저 선택하십시오&lt;/strong&gt; . 우리는 우리가 만나는 &lt;strong&gt;첫 번째 일치 공리를&lt;/strong&gt; 간단히 선택할 수 있습니다 . 위의 예에서 이것은 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 입니다. 우리는 &lt;code&gt;A a&lt;/code&gt; 를 수반 할 필요가 있는데 , 여기에는 일치하는 공리가 없으므로 위의 프로그램이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="a9db9b2d82045af0ef687f46fd582968b70dfaa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflexivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reflexivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b82302cd8a8e37a6d42b327c237c78b4a98d4a8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reject if in doubt&lt;/strong&gt;. An alternative approach would be to check for overlapping axioms, when solving a constraint. When multiple matching axioms are discovered, we &lt;strong&gt;reject the program&lt;/strong&gt;. This approach is a bit conservative, in that it may reject working programs. But it seem much more transparent towards the developer, who can be presented with a clear message, explaining why the program is rejected.</source>
          <target state="translated">&lt;strong&gt;의심스러운 경우 거부하십시오&lt;/strong&gt; . 다른 방법은 구속 조건을 해결할 때 겹치는 공리를 확인하는 것입니다. 여러 개의 일치하는 공리가 발견되면 &lt;strong&gt;프로그램&lt;/strong&gt; 을 &lt;strong&gt;거부합니다&lt;/strong&gt; . 이 접근법은 작업 프로그램을 거부 할 수 있다는 점에서 다소 보수적입니다. 그러나 프로그램이 거부 된 이유를 설명하는 명확한 메시지가 표시 될 수있는 개발자에게는 훨씬 더 투명 해 보입니다.</target>
        </trans-unit>
        <trans-unit id="f0f25f822df506cef863bb9a00c96e4fcc1e4bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Substitutivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Substitutivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e45f773e26962ea2903c38d6204599890b0de4a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symmetry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Symmetry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="174acfc98226e3aa5c79a549f805f6cffd2f76aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Top level bindings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;최상위 바인딩&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75903953dc91115d2e5cd9a4146a4781631d6cb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc186f13791531aa2d22dbaf862de224a352ddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: It's advised to avoid calling this primitive with negative exponents unless it is guaranteed the inverse exists, as failure to do so will likely cause program abortion due to a divide-by-zero fault. See also &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 반대로 존재한다고 보장되지 않으면 음의 지수로이 프리미티브를 호출하지 않는 것이 좋습니다. 그렇지 않으면 0으로 나누기 오류로 인해 프로그램 중단이 발생할 수 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="992f7e50f9c1364f8bae8fe4988cebb6afeb5ae8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The internal implementation of &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; (i.e. which constructors are available) depends on the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; backend used!</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 의 내부 구현 (즉, 사용 가능한 생성자)은 사용 된 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 백엔드 에 따라 다릅니다 !</target>
        </trans-unit>
        <trans-unit id="083d34b27586c0efd3bb96a02d93d956f6452f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: result may become negative if (at least) one argument is &lt;code&gt;minBound&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 하나 이상의 인수가 &lt;code&gt;minBound&lt;/code&gt; 인 경우 결과가 음수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58416cb35befd57e074b001d9d43848b0e5f2ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;hp2ps&lt;/strong&gt; is distributed in &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; in a GHC source distribution. It was originally developed by Dave Wakeling as part of the HBC/LML heap profiler.</source>
          <target state="translated">&lt;strong&gt;hp2ps&lt;/strong&gt; 는 GHC 소스 배포 에서 &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; 로 배포됩니다. 원래 Dave Wakeling이 HBC / LML 힙 프로파일 러의 일부로 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="a2a10c48ea0cdf0ca5edaab63d2e386e55d8c83d" translate="yes" xml:space="preserve">
          <source>= (&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;, &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;)</source>
          <target state="translated">= ( &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt; , &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4b9374aa68561e358ba9277ebf67e9a0b2cac65c" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Pred&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="6a4a112b1856c707441c9370242edae658a769d2" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Pred&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="f3e53936f3c79bf9c4206c8b91a0a0c917161364" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b)</target>
        </trans-unit>
        <trans-unit id="22500a4bcb96fc197f5175e32ffc6ecdc6564339" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b)</target>
        </trans-unit>
        <trans-unit id="98254af121448be337d889b7151e3095f29dfd2e" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b)</target>
        </trans-unit>
        <trans-unit id="87b9b2b6b45827b7ebbf823fd4e6fa2e656b9896" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (a -&amp;gt; &lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt; ( &lt;a href=&quot;text-show#t:ShowS&quot;&gt;a-&lt;/a&gt; &amp;gt; 쇼 )</target>
        </trans-unit>
        <trans-unit id="7e543fa87f892cd0310b1be2e1183e668e09b4b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (ann -&amp;gt; m r)</source>
          <target state="translated">=&amp;gt; (ann-&amp;gt; mr)</target>
        </trans-unit>
        <trans-unit id="3f837c598bd2a2ea0c21ac7ef916a3ba8c291114" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b)</source>
          <target state="translated">=&amp;gt; (e-&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;아마도&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="146ec650c89d3406783a47923e5bcd00b024cf1a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; a -&amp;gt; e)</source>
          <target state="translated">=&amp;gt; (e-&amp;gt; a-&amp;gt; e)</target>
        </trans-unit>
        <trans-unit id="28b8a020a4a70d67b201ecca5ebfe9b3decfac94" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; e' -&amp;gt; e)</source>
          <target state="translated">=&amp;gt; (e-&amp;gt; e '-&amp;gt; e)</target>
        </trans-unit>
        <trans-unit id="d1cff79143a6b98192e6f5c93021392b3bb26523" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (i, i)</source>
          <target state="translated">=&amp;gt; (i, i)</target>
        </trans-unit>
        <trans-unit id="273c01aab4f2aada746f406147099fc43c561169" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (r -&amp;gt; a)</source>
          <target state="translated">=&amp;gt; (r-&amp;gt; a)</target>
        </trans-unit>
        <trans-unit id="98cb27f97fefd7391598e198b2314a4052bd3f10" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (s -&amp;gt; (a, s))</source>
          <target state="translated">=&amp;gt; (s-&amp;gt; (a, s))</target>
        </trans-unit>
        <trans-unit id="40a084ccf2eb50cdea0902780e3641bbeeb218a0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt; (t-&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;문자열&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a913d2dfb1e9cb8a3706aeccb247062382be5958" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt; (t-&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;문자열&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="08f7f76239cb27ca373456dbde8bc8bedbe3e3f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;부울&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="631db25a13c5bd3f3a27fb66e2b126a624973fe7" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;아마 &lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3b4666c0db847e1f4ef59969ccc1e08d98e0fb5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;문자열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83f228b1575a69db7fa34e7e1f31ba1fcc909002" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="9b29c2ad51aea488dc493c38480ca6f86fb32ef5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-bool#t:Bool&quot;&gt;부울&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6eea19132ccdb3f07c5c85871217ec3b42357147" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;문자열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a090ffafec70ef99fa90de5566cfbed70873913" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="c4c85809d4a3a2bbe15915426aa3ae9d49b837b4" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="881da90599e1b286facbeb80f0b5665a56f022f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="c0ed1cf1dee5f53006a4c0bd4c39fd64413da332" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; ema</target>
        </trans-unit>
        <trans-unit id="43faa2c3584d57723d2b7894cdd8de390f7d6ff3" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT의&lt;/a&gt; EMA</target>
        </trans-unit>
        <trans-unit id="ed1c848733ee83ef5cfd6f49ba6a222cc681fb5b" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; r w s a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; rwsa</target>
        </trans-unit>
        <trans-unit id="0d59b61a3690bc45a5667c7d9d686fd7aae890a6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="e04a43f264efe742e62b7c872cf3243a4e74e724" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="46a15491d5a54f8e9623cc81bd3b40c08cc35bc5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="1decabf293013a44ad8fb38d770351c0b3d3eff0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;동적&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c49f72d1d47fd85210f06fe46bd2fbdba18a7f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; FAC</target>
        </trans-unit>
        <trans-unit id="c6dd57371651023369288a8ddebf01f317b257ab" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; FAC</target>
        </trans-unit>
        <trans-unit id="01807040766915893b46814bd7bc992c2c731d87" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="f3e23cdc0abf474625d6acfcfc952ed151e46c12" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; fkac</target>
        </trans-unit>
        <trans-unit id="e4ec523b9e7b9c9afd657cd3f09a05fbaa7be373" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="5b3d889a0b4ee8e84ff7b2d421af97fb78b317dd" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; fkac</target>
        </trans-unit>
        <trans-unit id="998942da66b438367a1103e796eb6fe2d1d3b071" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d97087128e0e8d5868c008414eb04d89f5c495f9" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16402fa4cd4c09cc613611f7301a7d80b85c6647" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="64674fd23e15a8758e1e185aedc3564f71140d67" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="7cc439ff40c5b4dedd82f1f56048dc9dea26eb6f" translate="yes" xml:space="preserve">
          <source>=&amp;gt; [(node, key, [key])]</source>
          <target state="translated">=&amp;gt; [(노드, 키, [키])]</target>
        </trans-unit>
        <trans-unit id="43c78599b734a8beb8eaf6cf4e3c3a77e20137fe" translate="yes" xml:space="preserve">
          <source>=&amp;gt; a</source>
          <target state="translated">=&amp;gt; a</target>
        </trans-unit>
        <trans-unit id="9ed6660105e653b094e0abb01e8f35fac4855dca" translate="yes" xml:space="preserve">
          <source>=&amp;gt; dev</source>
          <target state="translated">=&amp;gt; dev</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="6bb984861a61b745289ffc16ea1e0057086b9c13" translate="yes" xml:space="preserve">
          <source>@&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; bs) = &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [&lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; bs]</source>
          <target state="translated">@ &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; BS) = &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [ &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; BS]</target>
        </trans-unit>
        <trans-unit id="a3f4dc36787602cc5de507d13c594861d488c7eb" translate="yes" xml:space="preserve">
          <source>A &quot;-&amp;gt;&quot; string</source>
          <target state="translated">&quot;-&amp;gt;&quot;문자열</target>
        </trans-unit>
        <trans-unit id="3dbf51df963b10779a311937a8f60e762c73a212" translate="yes" xml:space="preserve">
          <source>A &quot;::&quot; string</source>
          <target state="translated">&quot;::&quot;문자열</target>
        </trans-unit>
        <trans-unit id="300f220bfe895126a57222e655e8c3d3cabdf03a" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&quot;일반&quot;유형 생성자 &quot;Fancier&quot;유형 생성자는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; 를 적절히 사용하여 리턴 됩니다. 현재이 통합 선언에는 파생 인스턴스가 첨부되지 않습니다 (인스턴스를 확인하려면 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="10a841c387fe820bc69427b7c8889b542a6b0766" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&quot;일반&quot;유형 생성자 &quot;Fancier&quot;유형 생성자는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; 를 적절히 사용하여 리턴 됩니다. 현재이 통합 선언에는 파생 인스턴스가 첨부되지 않습니다 (인스턴스를 확인하려면 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="32c1213ff43ed2016bf02de4b047ebc7b374b44b" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&quot;primitive&quot;유형 생성자이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 예 : &lt;code&gt;(-&amp;gt;)&lt;/code&gt; , &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cadfacc5513088f5ce5adc653861e33911e323" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&quot;primitive&quot;유형 생성자이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 예 : &lt;code&gt;(-&amp;gt;)&lt;/code&gt; , &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b95014d55a1a5c44f3c7bc23c6504bed812af75" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; (disk) device which supports block binary read and write operations and may be seekable only to positions of certain granularity (block- aligned).</source>
          <target state="translated">블록 이진 읽기 및 쓰기 작업을 지원하고 특정 단위 (블록 정렬)의 위치에서만 검색 할 수있는 &quot;원시&quot;(디스크) 장치입니다.</target>
        </trans-unit>
        <trans-unit id="40dadc0fe1ae92b18009dce1f8fd8927976b9479" translate="yes" xml:space="preserve">
          <source>A &quot;standard&quot; derived instance</source>
          <target state="translated">&quot;표준&quot;파생 인스턴스</target>
        </trans-unit>
        <trans-unit id="a9c3609906f2647fca409f7da980e584e3ef11e0" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&quot;값&quot;변수 (유형 변수와 반대로 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d2fa3eeda719de99d1617880e4ee077e0acc83a6" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&quot;값&quot;변수 (유형 변수와 반대로 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d099ba358135489de4b98f8bef8e1700327509fb" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;Found hole&lt;/code&gt;&amp;rdquo; error usually terminates compilation, like any other type error. After all, you have omitted some code from your program. Nevertheless, you can run and test a piece of code containing holes, by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by typed holes until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wno-typed-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;Found hole&lt;/code&gt; &quot;오류는 일반적으로 다른 유형 오류와 마찬가지로 컴파일을 종료합니다. 결국, 프로그램에서 일부 코드를 생략했습니다. 그럼에도 불구하고 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 구멍이 포함 된 코드를 실행하고 테스트 할 수 있습니다 . 이 플래그는 런타임까지 유형이 지정된 구멍에서 생성 된 오류를 지연시키고 컴파일 타임 경고로 변환합니다. 이러한 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wno-typed-holes&lt;/code&gt; 에&lt;/a&gt; 의해 완전히 억제 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03ff9cc92a1ea810e41d8095971be93bdf74f086" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;literate Haskell&amp;rdquo; module.</source>
          <target state="translated">&quot;literate Haskell&quot;모듈.</target>
        </trans-unit>
        <trans-unit id="8fe0e5fa44b3983941075b4a786a25d59bed2413" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable topological sort&amp;rdquo; here, we mean that we perform this algorithm (which we call &lt;em&gt;ScopedSort&lt;/em&gt;):</source>
          <target state="translated">여기서 &quot;안정적인 토폴로지 정렬&quot;은이 알고리즘 ( &lt;em&gt;ScopedSort&lt;/em&gt; 라고 &lt;em&gt;함&lt;/em&gt; )을 &lt;em&gt;수행함을&lt;/em&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="65e8bde33d0926b669005135d74a4a27a9f4e93e" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;strict pattern match&amp;rdquo; is any pattern match that can fail. For example, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(x:xs)&lt;/code&gt;, &lt;code&gt;!z&lt;/code&gt;, and &lt;code&gt;C x&lt;/code&gt; are strict patterns, but &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;~(1,2)&lt;/code&gt; are not. For the purposes of &lt;code&gt;ApplicativeDo&lt;/code&gt;, a pattern match against a &lt;code&gt;newtype&lt;/code&gt; constructor is considered strict.</source>
          <target state="translated">&quot;엄격한 패턴 일치&quot;는 실패 할 수있는 패턴 일치입니다. 예를 들어, &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;(x:xs)&lt;/code&gt; , &lt;code&gt;!z&lt;/code&gt; 와 &lt;code&gt;C x&lt;/code&gt; 엄격한 패턴이지만, &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;~(1,2)&lt;/code&gt; 이 아니다. &lt;code&gt;ApplicativeDo&lt;/code&gt; 의 목적 상 , &lt;code&gt;newtype&lt;/code&gt; 생성자 에 대한 패턴 일치 는 엄격한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f547f0739b0d3ec8b58b70d55fe4382a3dcaab7d" translate="yes" xml:space="preserve">
          <source>A '(' character</source>
          <target state="translated">'('문자</target>
        </trans-unit>
        <trans-unit id="70d5a19191116accb71ec443cd4b4fc4796865be" translate="yes" xml:space="preserve">
          <source>A ')' character</source>
          <target state="translated">')'문자</target>
        </trans-unit>
        <trans-unit id="5c59fc97f8f16f9e84989be6184e3be3c12f4c4d" translate="yes" xml:space="preserve">
          <source>A ',' character</source>
          <target state="translated">','문자</target>
        </trans-unit>
        <trans-unit id="8cea7bc9d7fd5c53754fe5fa302c98ab7ebba9d0" translate="yes" xml:space="preserve">
          <source>A ';' character</source>
          <target state="translated">ㅏ ';' 캐릭터</target>
        </trans-unit>
        <trans-unit id="24a06b0596e6f9b715b619a7c1e59cb58205d143" translate="yes" xml:space="preserve">
          <source>A '=' character</source>
          <target state="translated">'='문자</target>
        </trans-unit>
        <trans-unit id="f781f6726d451e5c82ca330b01816e92ba6ee9b1" translate="yes" xml:space="preserve">
          <source>A '[' character</source>
          <target state="translated">'['문자</target>
        </trans-unit>
        <trans-unit id="f989a4679028d9554fb0771f1f50eeed8579ba0d" translate="yes" xml:space="preserve">
          <source>A ']' character</source>
          <target state="translated">']'문자</target>
        </trans-unit>
        <trans-unit id="fa5fc1c81727f1321da12121ae03096bcaacada5" translate="yes" xml:space="preserve">
          <source>A '{' character</source>
          <target state="translated">'{'문자</target>
        </trans-unit>
        <trans-unit id="f0864bd7f5f8f23f2a725f53240aa607578e2ea5" translate="yes" xml:space="preserve">
          <source>A '}' character</source>
          <target state="translated">'}'캐릭터</target>
        </trans-unit>
        <trans-unit id="0d686b1feab210fa1d571b1cf64d0dc555ea4552" translate="yes" xml:space="preserve">
          <source>A (partial) type signature has the following form: &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt;. It consists of three parts:</source>
          <target state="translated">(일부) 유형 서명은 다음 형식을 갖습니다. &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt; . 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f80c2a8ab20b3b616d4d4b2f353d1a0756e8af37" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#safe-language&quot;&gt;safe language&lt;/a&gt; dialect of Haskell that provides stricter guarantees about the code. It allows types and module boundaries to be trusted.</source>
          <target state="translated">코드에 대해보다 엄격한 보증을 제공하는 Haskell 의 &lt;a href=&quot;#safe-language&quot;&gt;안전한 언어&lt;/a&gt; 방언. 형식과 모듈 경계를 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240604f168c64bbbbd9cc3f79b1c96c50e4da4c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#&lt;/code&gt; is followed by optional spaces and tabs, an alphanumeric keyword that describes the kind of processing, and its arguments. Arguments look like C expressions separated by commas (they are not written inside parens). They extend up to the nearest unmatched &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt;, or to the end of line if it occurs outside any &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; and is not preceded by a backslash. Backslash-newline pairs are stripped.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 은 선택적 공간과 탭 처리의 종류를 설명하는 영숫자 키워드 및 인수 이어진다. 인수는 쉼표로 구분 된 C 표현식처럼 보입니다 (괄호 안에 쓰지 않음). &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; 외부에서 발생하는 경우 가장 가까운 일치하지 않는 &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;]&lt;/code&gt; 또는 &lt;code&gt;}&lt;/code&gt; 또는 줄 끝까지 확장 되며 백 슬래시가 앞에 오지 않습니다. 백 슬래시-줄 바꾸기 쌍이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ec7d45efe24e17a78b3531b77507cc5b414969c3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character</source>
          <target state="translated">A &lt;code&gt;:&lt;/code&gt; 캐릭터</target>
        </trans-unit>
        <trans-unit id="4d77aa84dcc8476d8b0a59a06fc9910da40d4c94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 받는 전문 -like 기능 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 의 내부 구조를 활용 모노 이드, &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 피하기 포장에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 어떤 점.</target>
        </trans-unit>
        <trans-unit id="79c191e27824000624b968ce755ce2407b5fc3a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; that describes the error.</source>
          <target state="translated">오류를 설명 하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c8af9e26c7ea200796fafc8da4bdbcb725df4cd0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 받는 전문 -like 기능 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 의 내부 구조를 활용 모노 이드, &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 피하기 포장에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 어떤 점.</target>
        </trans-unit>
        <trans-unit id="f58fb0b6ff8af11490e6db18e3159b3eb14567f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 는 스레드에 대한 핸들을 나타내는 추상 형식입니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 1, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 구현 위에 임의의 전체 순서 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 가 이야. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스는 사용자가 임의의 값으로 변환 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 를 문자열 형성하는 단계; &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 값을 표시하면 동시 프로그램의 동작을 디버깅하거나 진단 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ce7ce3c377d39b823d763d8b4302a42e6c97ffce" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 은 동시 스레드 간의 통신에 이용되는 동기 변수이다. 비어 있거나 가득 찬 상자로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4f02e01c3ad2f55652fc8918f170a9b5f03f08" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; is like a &lt;code&gt;TChan&lt;/code&gt;, with two important differences:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 는 유사한입니다 &lt;code&gt;TChan&lt;/code&gt; 두 가지 중요한 차이가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="db398cefd7bed902dc3f0468dccbf2a712235464" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 없이 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 의 인스턴스 만 항상 같은 newtypes 터플 단일 데이터 생성자 데이터 유형 및 반박 패턴 (같이 일치 패턴이 함께 사용될 수있다 &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d52facfcc17560b0b9fcad065ab617e3ee01a7a6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 없이 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 의 인스턴스 만 항상 같은 newtypes 터플 단일 데이터 생성자 데이터 유형 및 반박 패턴 (같이 일치 패턴이 함께 사용될 수있다 &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2ad78e77b876113c12279bae00129914cb00534" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 은 일반적으로 등가보다 (시간과 공간 모두의 측면에서)보다 효율적으로 될 것이다 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 동일한 엘리먼트 유형. 그러나 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 는 해당 요소 가 엄격하므로 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 에서 제공 하는 엄격하지 않은 것이 필요한 경우 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e1d5b0a46bf9ac13012695d647011268c6839438" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 8 비트 바이트, 또는에서 작업 사용하여 포함 &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; 는 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0361d0a51c1f43d10a9cb740bc7c3263eaf2423" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; represents the result of running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. It unfolds as a sequence of chunks of data. These chunks come in two forms:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 는 실행의 결과 나타냅니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . 일련의 데이터 덩어리로 전개됩니다. 이 청크는 두 가지 형태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a67d6507558e86947578e9d9e53ccc77b5315b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; together with the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; of free bytes. The filled space starts at offset 0 and ends at the first free byte.</source>
          <target state="translated">사용 가능한 바이트 의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; 입니다. 채워진 공간은 오프셋 0에서 시작하여 첫 번째 여유 바이트에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="811beb8fb95b58583e6d93fef1cf1359e8bd2557" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action denotes a computation of a value that writes a stream of bytes as a side-effect. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are strict in their side-effect; i.e., the stream of bytes will always be written before the computed value is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 동작은 부작용으로서 바이트들의 스트림을 기록하는 값의 산출을 나타낸다. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 은 부작용이 엄격합니다. 즉, 바이트 스트림은 항상 계산 된 값이 반환되기 전에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="77ba64f4eea7ca7040ede60a91c0479a0256585a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 8 비트 바이트, 또는에서 작업 사용하여 포함 &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; 는 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3742f257dac22eaeb1f72c5a59a402dd9caed9a3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 8 비트 바이트, 또는에서 작업 사용하여 포함 &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; 는 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87acc03140b6a38efd5eb569210acf530d577e77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; may only represent a monomorphic value; an attempt to create a value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; from a polymorphically-typed expression will result in an ambiguity error (see &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 만 단형 값을 나타낼 수있다; 다형성 형식의 식에서 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 형식의 값을 만들려고 하면 모호성 오류가 발생합니다 ( &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7559ec7e510228d1d09527f56d2e4f26a8324238" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to each input of the comparison function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 때문에 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 는 비교 함수의 각 입력의 함수 인수를 적용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dfe92df845c7b9c6045ec318c8250ac09ae3d416" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to the input of the predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 때문에 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 이 술어의 입력의 함수 인수를 적용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="89f60209ccece04c7a022e1e1c35644383139a1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; list is one which always has at least one element, but is otherwise identical to the traditional list type in complexity and in terms of API. You will almost certainly want to import this module &lt;code&gt;qualified&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 목록은 항상 적어도 하나 개의 요소를 가지고 있지만, 복잡성 및 API의 측면에서 기존 목록 유형에 다른 동일 하나입니다. 당신은 거의 확실이 모듈을 가져올 것이다 &lt;code&gt;qualified&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="344c6ff8d7a2bcd44da8bfd8dc8df57dba6e7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; with the added requirement of a neutral element. Thus any &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, but not the other way around.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 중립 요소의 추가 요건. 따라서 모든 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 이지만 다른 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e35d89b46351c9630145c0b8bbf882d79457fee2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a generalization of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;. Yet unlike the &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; requires the presence of a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) in addition to the associative operator. The requirement for a neutral element prevents many types from being a full Monoid, like &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; (A)의 일반화 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; . 그러나 달리 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 중립 요소 (존재 필요 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 연상 연산자 이외에도 참조). 중립 요소에 대한 요구 사항은 &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; 와 같이 많은 유형이 전체 Monoid가되는 것을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="276d119a24c0525aa19868a36000fbee697e666e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; 받는 전문 -like 기능 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 의 내부 구조를 활용 모노 이드, &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 피하기 포장에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 어떤 점.</target>
        </trans-unit>
        <trans-unit id="8fd75af820d1f54d527c5ea90ed335e09bb6599b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; 받는 전문 -like 기능 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 의 내부 구조를 활용 모노 이드, &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 피하기 포장에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 어떤 점.</target>
        </trans-unit>
        <trans-unit id="031626d15f769e94dae06fe92bad6c13a12414d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 문자의 목록입니다. 하스켈에서 문자열 상수 타입의 값입니다 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d557b82ce614c78066224f253d24d1e9e55d7e4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값에 정의 된 유니 스칼라 값들의 시퀀스이다 &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, 유니 5.2 표준의 정의 D76&lt;/a&gt; . 따라서 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 는 U + D800에서 U + DFFF까지의 값을 포함 할 수 없습니다. Haskell 구현 은이 유효하지 않은 범위의 코드 포인트를 포함하여 모든 유니 코드 코드 포인트 ( &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, 정의 D10&lt;/a&gt; )를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 인정합니다 . 이는 유효한 유니 코드 스칼라 값이 아닌 일부 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값이 있으며이 모듈의 함수가 이러한 경우를 처리해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="493151274c14fd9063bbd993eabc297404d04a97" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값에 정의 된 유니 스칼라 값들의 시퀀스이다 &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, 유니 5.2 표준의 정의 D76&lt;/a&gt; . 따라서 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 는 U + D800에서 U + DFFF까지의 값을 포함 할 수 없습니다. Haskell 구현 은이 유효하지 않은 범위의 코드 포인트를 포함하여 모든 유니 코드 코드 포인트 ( &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, 정의 D10&lt;/a&gt; )를 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값 으로 인정합니다 . 이는 유효한 유니 코드 스칼라 값이 아닌 일부 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값이 있으며이 모듈의 함수가 이러한 경우를 처리해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a2ab4f0a1420ff27eb07a2afba8acbdae44df567" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; represents the version of a software entity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 소프트웨어 엔티티의 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5972d36864fed9ff33b5afd14a95cb4b9c27b6e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 같은 크기의 부호없는 정수형이다 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인 .</target>
        </trans-unit>
        <trans-unit id="f3aa7b36dc316c60d893b5f124b1ba5988ceb7f6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 문자의 목록입니다. 하스켈에서 문자열 상수 타입의 값입니다 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39546383234ce70932952659423f3ad369b9dc5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 는 스레드에 대한 핸들을 나타내는 추상 형식입니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 1, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 구현 위에 임의의 전체 순서 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 가 이야. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스는 사용자가 임의의 값으로 변환 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 를 문자열 형성하는 단계; &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 값을 표시하면 동시 프로그램의 동작을 디버깅하거나 진단 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6daf9cc92f22cab1cda41ec56fc33fa5bcb5c1b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 는 스레드에 대한 핸들을 나타내는 추상 형식입니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 1, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 구현 위에 임의의 전체 순서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 가 이야. &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스는 사용자가 임의의 값으로 변환 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 를 문자열 형성하는 단계; &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 값을 표시하면 동시 프로그램의 동작을 디버깅하거나 진단 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c433ed52817c69814ef408474d7e7f0f19916c6d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; 호출 된 함수의 이름은 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 는 콜 사이트입니다. 이 목록은 가장 최근에 호출 된 함수와 함께 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="e99764c1391b456842912477a01318962af2d4bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 같은 크기의 부호없는 정수형이다 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인 .</target>
        </trans-unit>
        <trans-unit id="c448caa1f3bf73a5f3c86998ff8b234d23f5d613" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 예는 다음과 법률을 충족해야합니다 :</target>
        </trans-unit>
        <trans-unit id="f058fc8709c912eeb2b787983729f79e927817fe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 의 인스턴스는 다음과 같은 법칙을 만족해야한다 :</target>
        </trans-unit>
        <trans-unit id="37bca98687b6539690c105875b7d36949eaf0920" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 바이트와 유니 코드 문자의 시퀀스의 시퀀스 사이의 변환 방식의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="9ccfc506522947e455012faccd5c0641a69d1d0d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; 호출 된 함수의 이름은 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 는 콜 사이트입니다. 이 목록은 가장 최근에 호출 된 함수와 함께 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="95958acad6af1408745c1c860b5d733b2d323753" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; A는 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; . &lt;code&gt;String&lt;/code&gt; 호출 된 함수의 이름은 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 는 콜 사이트입니다. 이 목록은 가장 최근에 호출 된 함수와 함께 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8456cabb368794e2df99a2d1a5a798a5a772942a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 같은 크기의 부호없는 정수형이다 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인 .</target>
        </trans-unit>
        <trans-unit id="4e97ac17514823d55db637532fc8cca228a55594" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; is one in which all the &lt;code&gt;Name&lt;/code&gt; references have been resolved to actual addresses or &lt;code&gt;RemoteHValues&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; 는 모든되는 하나 &lt;code&gt;Name&lt;/code&gt; 참조가 실제 주소 나에 해결 된 &lt;code&gt;RemoteHValues&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9ca692d8226adf018ac8ce128aabc55c560244" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;-style resource handler for &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 에 대한 스타일의 자원 핸들러 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20537f017b881ed432aeb6d8c3c69764ad12389" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance can have any of its values turned into a Template Haskell expression. This is needed when a value used within a Template Haskell quotation is bound outside the Oxford brackets (&lt;code&gt;[| ... |]&lt;/code&gt;) but not at the top level. As an example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; 인스턴스는 템플릿 하스켈 표현으로 바뀌의 값 중 하나를 가질 수 있습니다. Template Haskell 인용에 사용 된 값이 Oxford 대괄호 ( &lt;code&gt;[| ... |]&lt;/code&gt; ) 외부에 바인드 되지만 최상위 레벨에는없는 경우에 필요합니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="8baf8997f83651b56856d51ed22119ab60baf8c6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance must satisfy &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;$(...)&lt;/code&gt; is a Template Haskell splice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; 인스턴스 만족해야 &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; 모두 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;$(...)&lt;/code&gt; 템플릿 하스켈 스플 라이스입니다.</target>
        </trans-unit>
        <trans-unit id="dc2e529d77216b7e230e75736a12096341b81566" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 없이 &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 의 인스턴스 만 항상 같은 newtypes 터플 단일 데이터 생성자 데이터 유형 및 반박 패턴 (같이 일치 패턴이 함께 사용될 수있다 &lt;code&gt;~pat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="01cb4e7f2872a463ecfc84cecc5fd37176ad2686" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 문자의 목록입니다. 하스켈에서 문자열 상수 타입의 값입니다 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c73c4644db1dd430eecd595b2935abcbd70f5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 같은 크기의 부호없는 정수형이다 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 인 .</target>
        </trans-unit>
        <trans-unit id="b5384336a86ebc421cc3fe658790659229a2e63f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; is a method for deciding at run-time which type of interaction to use.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; 의 상호 작용의 유형을 사용하는 런타임에 결정하는 방법이다.</target>
        </trans-unit>
        <trans-unit id="45d218cdb4af63fb065f7347943499e7d49ef9be" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; function takes a monadic action &lt;code&gt;m&lt;/code&gt; as input, and outputs an IO action which performs the underlying impure part of &lt;code&gt;m&lt;/code&gt; and returns the '&lt;code&gt;pure'&lt;/code&gt; part of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; 의 함수 모나드 액션 얻어 &lt;code&gt;m&lt;/code&gt; 입력 등을, 그리고 기본 불순한 부 수행하는 IO 동작 출력 &lt;code&gt;m&lt;/code&gt; 을 상기 '리턴 &lt;code&gt;pure'&lt;/code&gt; 부분 &lt;code&gt;m&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3139966130ea6dafab5ae56d42fa83f1c983bce8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 는 바이트와 유니 코드 문자의 시퀀스의 시퀀스 사이의 변환 방식의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="1a15ba8c0101a0b559f5881de53f7fa0649c9e6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 메시지가에 의해 생성되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 일반적인 파서 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="d7c33b518e905e06246fdc3442ce5bfca419239f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 메시지가에 의해 생성되는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 일반적인 파서 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="c7ef7fe44084ddf44d2e8bb742356ef4d58d6b59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; 메시지에 의해 생성 된 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; 연결자. 인수는 예상되는 항목을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2f54fff1c216809b3a5e0dbc637601d50f8c6c28" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; 된 메시지는 자동으로 생성 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 연결자. 인수가 예기치 않은 입력입니다.</target>
        </trans-unit>
        <trans-unit id="cd574240b0c567cd017058a316ed035f46f6524e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; 의 메시지가에 의해 발생하는 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 예기치 않은 항목을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c19aa3725eed1ff35ec390fbcd0c985fd5b931ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 메시지가에 의해 생성되는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 일반적인 파서 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="c65c2017bc5e0477e9c2b63e9054f9b8989ca0a8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 메시지가에 의해 생성되는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 일반적인 파서 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="fbea807bde10982fba750640fdd252b73cdd256c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; 메시지에 의해 생성 된 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; 연결자. 인수는 예상되는 항목을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a0592092bb04d822c205343ec720a927bd033f59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; 된 메시지는 자동으로 생성 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 연결자. 인수가 예기치 않은 입력입니다.</target>
        </trans-unit>
        <trans-unit id="043b63a3a919975f6460c5dd3c3a8b5b0fcacbb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; 의 메시지가에 의해 발생하는 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; 콤비. 인수는 예기치 않은 항목을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="97982bdf22f3c28d9d65ec6b0247f3758c15fa0c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Builder&lt;/code&gt; is an efficient way to build lazy &lt;code&gt;Text&lt;/code&gt; values. There are several functions for constructing builders, but only one to inspect them: to extract any data, you have to turn them into lazy &lt;code&gt;Text&lt;/code&gt; values using &lt;code&gt;toLazyText&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Builder&lt;/code&gt; 게으른 구축 할 수있는 효율적인 방법입니다 &lt;code&gt;Text&lt;/code&gt; 값을. 빌더를 구성하는 몇 가지 함수가 있지만 검사 할 함수는 하나뿐입니다. 데이터를 추출하려면 &lt;code&gt;toLazyText&lt;/code&gt; 를 사용하여 지연 &lt;code&gt;Text&lt;/code&gt; 값으로 변환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="994c45c3efba13b92d41911d6419360be708120c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DEPRECATED&lt;/code&gt; pragma lets you specify that a particular function, class, or type is deprecated.</source>
          <target state="translated">&lt;code&gt;DEPRECATED&lt;/code&gt; pragma는 특정 함수, 클래스, 또는 유형이 사용되지 않도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="202df593255e09bcdac86158dc3e1eaaeacee3f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HasField x r a&lt;/code&gt; constraint represents the fact that &lt;code&gt;x&lt;/code&gt; is a field of type &lt;code&gt;a&lt;/code&gt; belonging to a record type &lt;code&gt;r&lt;/code&gt;. The &lt;code&gt;getField&lt;/code&gt; method gives the record selector function.</source>
          <target state="translated">&lt;code&gt;HasField x r a&lt;/code&gt; 제약된다는 사실 나타내고, &lt;code&gt;x&lt;/code&gt; 타입 필드이다 레코드 타입에 속하는 &lt;code&gt;r&lt;/code&gt; . &lt;code&gt;getField&lt;/code&gt; 에 있어서, 상기 기록 선택 기능을 제공한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48ba20858c6e487ee442bbf0e918d296f38bac12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Message a&lt;/code&gt; is a message that returns a value of type &lt;code&gt;a&lt;/code&gt;. These are requests sent from GHC to the server.</source>
          <target state="translated">&lt;code&gt;Message a&lt;/code&gt; 메시지입니다 반환하는 형식의 값 . GHC에서 서버로 전송 된 요청입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cb20e68d9cba85e4c2de51bcc3a4286e1b2b4ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ModGuts&lt;/code&gt; holds all of the module&amp;rsquo;s top level bindings which we can examine. These bindings are of type &lt;code&gt;CoreBind&lt;/code&gt; and effectively represent the binding of a name to body of code. Top-level module bindings are part of a &lt;code&gt;ModGuts&lt;/code&gt; in the field &lt;code&gt;mg_binds&lt;/code&gt;. Implementing a pass that manipulates the top level bindings merely needs to iterate over this field, and return a new &lt;code&gt;ModGuts&lt;/code&gt; with an updated &lt;code&gt;mg_binds&lt;/code&gt; field. Because this is such a common case, there is a function provided named &lt;code&gt;bindsOnlyPass&lt;/code&gt; which lifts a function of type &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; to type &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ModGuts&lt;/code&gt; 은 우리가 검토 할 수있는 모듈의 최상위 레벨 바인딩을 모두 보유하고 있습니다. 이러한 바인딩은 &lt;code&gt;CoreBind&lt;/code&gt; 유형 이며 코드 본문에 대한 이름의 바인딩을 효과적으로 나타냅니다. 최상위 모듈 바인딩은의 일부 &lt;code&gt;ModGuts&lt;/code&gt; 필드에서 &lt;code&gt;mg_binds&lt;/code&gt; . 최상위 레벨 바인딩을 조작하는 패스를 구현하면이 필드를 반복하고 &lt;code&gt;mg_binds&lt;/code&gt; 필드 가 업데이트 된 새 &lt;code&gt;ModGuts&lt;/code&gt; 를 반환 하면됩니다 . 일반적인 경우이므로 &lt;code&gt;bindsOnlyPass&lt;/code&gt; 라는 함수가 제공되어 &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; 유형의 함수를 &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; 유형으로 올립니다 .</target>
        </trans-unit>
        <trans-unit id="a70f83cdade171d92c14ec57aaab7b2cf6914937" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MutVar#&lt;/code&gt; behaves like a single-element mutable array.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; 단일 가변 소자 어레이처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="c6337414644ea4c6c26609fea40acca352b7ea57" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Plugin&lt;/code&gt; effectively holds a function which installs a compilation pass into the compiler pipeline. By default there is the empty plugin which does nothing, &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt;, which you should override with record syntax to specify your installation function. Since the exact fields of the &lt;code&gt;Plugin&lt;/code&gt; type are open to change, this is the best way to ensure your plugins will continue to work in the future with minimal interface impact.</source>
          <target state="translated">&lt;code&gt;Plugin&lt;/code&gt; 효과적으로 컴파일러 파이프 라인에 컴파일 패스를 설치하는 기능을 보유하고 있습니다. 기본적으로 아무것도하지 않는 빈 플러그인 &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt; 이 있으며 , 설치 기능을 지정하기 위해 레코드 구문으로 대체해야합니다. &lt;code&gt;Plugin&lt;/code&gt; 유형 의 정확한 필드는 변경 가능하므로 향후 인터페이스에 미치는 영향을 최소화하면서 플러그인이 계속 작동하도록하는 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c79966287c7a0289106cbf652df27cd92d1d3c79" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Reader&lt;/code&gt; to run.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; 를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="42d146b8c1428a840a06c263b2ea3c6508ddd7d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that rewrites a call to the un-specialised function into a call to the specialised one. Moreover, given a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function &lt;code&gt;f&lt;/code&gt;, GHC will automatically create specialisations for any type-class-overloaded functions called by &lt;code&gt;f&lt;/code&gt;, if they are in the same module as the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, or if they are &lt;code&gt;INLINABLE&lt;/code&gt;; and so on, transitively.</source>
          <target state="translated">&lt;code&gt;SPECIALIZE&lt;/code&gt; (a)의 기능과 (b) 다시 쓰기 규칙 (참조의 특화된 버전을 생성하는 효과를 갖는다 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; 받는 통화로 해제 전문 함수 호출을 재 작성) 한 전문화. 또한 함수 &lt;code&gt;f&lt;/code&gt; 에 대한 &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma가 주어지면 GHC는 &lt;code&gt;f&lt;/code&gt; 에 의해 호출되는 모든 type-class- &lt;code&gt;INLINABLE&lt;/code&gt; 대해 &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma 와 동일한 모듈 에 있거나 INLINABLE 인 경우 자동으로 전문화를 작성합니다 . 전 이적으로.</target>
        </trans-unit>
        <trans-unit id="8b980d520829db47b0e6b9e92a84de862c7cc8a1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can optionally be followed with a &lt;code&gt;INLINE&lt;/code&gt; or &lt;code&gt;NOINLINE&lt;/code&gt; pragma, optionally followed by a phase, as described in &lt;a href=&quot;#inline-noinline-pragma&quot;&gt;INLINE and NOINLINE pragmas&lt;/a&gt;. The &lt;code&gt;INLINE&lt;/code&gt; pragma affects the specialised version of the function (only), and applies even if the function is recursive. The motivating example is this:</source>
          <target state="translated">&lt;code&gt;SPECIALIZE&lt;/code&gt; 프라그는 선택적으로 다음 수 &lt;code&gt;INLINE&lt;/code&gt; 또는 &lt;code&gt;NOINLINE&lt;/code&gt; 의 설명대로 선택적 위상이어서 래그, &lt;a href=&quot;#inline-noinline-pragma&quot;&gt;인라인 및 NOINLINE 래그 마를&lt;/a&gt; . &lt;code&gt;INLINE&lt;/code&gt; 의 pragma는 기능 (전용)의 전문 버전에 영향을하고, 함수가 재귀 경우에도 적용됩니다. 동기 부여 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b82be1262e45e02f43857ca0ff6515f9db20126" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function can be put anywhere its type signature could be put. Moreover, you can also &lt;code&gt;SPECIALIZE&lt;/code&gt; an &lt;em&gt;imported&lt;/em&gt; function provided it was given an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition site (&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;SPECIALIZE&lt;/code&gt; 하는 기능에 대한 pragma는 어디의 유형 서명을 넣을 수 넣을 수 있습니다. 또한, 당신은 또한 수 있습니다 &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;em&gt;수입&lt;/em&gt; 함수는이 주어졌다 제공 &lt;code&gt;INLINABLE&lt;/code&gt; 의 정의 사이트 (에서 프라그를 &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE 프라그&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a25c001444e85ab6f7b0766980538a555f7440b7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Span&lt;/code&gt; represents the result of an annotation after a &lt;code&gt;Doc&lt;/code&gt; has been rendered, capturing where the annotation now starts and ends in the rendered output.</source>
          <target state="translated">&lt;code&gt;Span&lt;/code&gt; 후 주석의 결과를 나타내는 &lt;code&gt;Doc&lt;/code&gt; 주석 이제 시작하고 렌더링 된 출력에서 끝나는 캡처 렌더링되었습니다.</target>
        </trans-unit>
        <trans-unit id="9ed158fbad702e89568f4c1dbb871930a8429284" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Stream&lt;/code&gt; instance is responsible for maintaining the &quot;position within the stream&quot; in the stream state &lt;code&gt;s&lt;/code&gt;. This is trivial unless you are using the monad in a non-trivial way.</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 인스턴스는 스트림 상태에서 &quot;스트림 내 위치&quot;유지에 대한 책임 &lt;code&gt;s&lt;/code&gt; . 모나드를 사소한 방식으로 사용하지 않는 한 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6768d45124fc6209d1d55206e3becea75d2017a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;data instance&lt;/code&gt; can use GADT syntax for the data constructors, and indeed can define a GADT. For example:</source>
          <target state="translated">&lt;code&gt;data instance&lt;/code&gt; GADT을 정의 할 수 있습니다 실제로 데이터 생성자에 대한 GADT 구문을 사용하고 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="daba80bb3a6be48bbea57e35e9db17367b1d0d13" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;deriving instance&lt;/code&gt; declaration must obey the same rules concerning form and termination as ordinary instance declarations, controlled by the same flags; see &lt;a href=&quot;#instance-decls&quot;&gt;Instance declarations&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;deriving instance&lt;/code&gt; 선언은 같은 플래그에 의해 제어 일반 인스턴스 선언과 같은 형태 및 종료에 관한 동일한 규칙을 준수해야합니다; &lt;a href=&quot;#instance-decls&quot;&gt;인스턴스 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59db072390d4948ccdd767966bcedd58bf2bcf38" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;hs-boot&lt;/code&gt; file is compiled by GHC, just like a &lt;code&gt;hs&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;hs-boot&lt;/code&gt; 파일은 단지처럼 GHC에 의해 컴파일 &lt;code&gt;hs&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="0ee8809aa12d51318c13f6f45ee2d8d36268a40a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rec&lt;/code&gt;-block tells the compiler where precisely the recursive knot should be tied. It turns out that the placement of the recursive knots can be rather delicate: in particular, we would like the knots to be wrapped around as minimal groups as possible. This process is known as &lt;em&gt;segmentation&lt;/em&gt;, and is described in detail in Section 3.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;. Segmentation improves polymorphism and reduces the size of the recursive knot. Most importantly, it avoids unnecessary interference caused by a fundamental issue with the so-called &lt;em&gt;right-shrinking&lt;/em&gt; axiom for monadic recursion. In brief, most monads of interest (IO, strict state, etc.) do &lt;em&gt;not&lt;/em&gt; have recursion operators that satisfy this axiom, and thus not performing segmentation can cause unnecessary interference, changing the termination behavior of the resulting translation. (Details can be found in Sections 3.1 and 7.2.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; - 블록은 재귀 매듭이 묶여해야 정확하게 컴파일러를 알려줍니다. 재귀 매듭의 배치는 다소 섬세 할 수 있습니다. 특히 매듭을 가능한 한 최소한의 그룹으로 묶기를 원합니다. 이 프로세스는 &lt;em&gt;세그먼테이션&lt;/em&gt; 으로 알려져 있으며 &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell&lt;/a&gt; 에 대한 재귀 적 작업 섹션 3.2에 자세히 설명되어 있습니다. 분할은 다형성을 개선하고 재귀 매듭의 크기를 줄입니다. 가장 중요한 것은 소위 재귀에 대한 이른바 &lt;em&gt;오른쪽 수축&lt;/em&gt; 공리 의 근본적인 문제로 인한 불필요한 간섭을 피하는 것 입니다. 간단히 말해, 관심있는 대부분의 모나드 (IO, 엄격한 상태 등)는 그렇지 &lt;em&gt;않습니다.&lt;/em&gt;이 공리를 만족하는 재귀 연산자를 가지므로 분할을 수행하지 않으면 불필요한 간섭이 발생하여 결과 변환의 종료 동작이 변경 될 수 있습니다. (자세한 내용은 &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Monadic Computations&lt;/a&gt; 의 Value Recursion 3.1 및 7.2.2 섹션에서 확인할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="0bdbd6d30e59c1faa209edf1aa68a5deb84cd963" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;lexically scoped type variable&lt;/em&gt; can be bound by:</source>
          <target state="translated">&lt;em&gt;어휘 범위 형 변수&lt;/em&gt; 에 구속 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="109054251366535f7af799fd6243e0d372229344" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package environment file&lt;/em&gt; is a file that tells &lt;code&gt;ghc&lt;/code&gt; precisely which packages should be visible. It can be used to create environments for &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; that are local to a shell session or to some file system location. They are intended to be managed by build/package tools, to enable &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; to automatically use an environment created by the tool.</source>
          <target state="translated">&lt;em&gt;패키지 환경 파일을&lt;/em&gt; 알려주는 파일입니다 &lt;code&gt;ghc&lt;/code&gt; 패키지를 볼 수 있어야하는 정확하게. 쉘 세션 또는 일부 파일 시스템 위치에 로컬 인 &lt;code&gt;ghc&lt;/code&gt; 또는 &lt;code&gt;ghci&lt;/code&gt; 환경을 작성하는 데 사용할 수 있습니다 . 그것들은 빌드 / 패키지 툴에 의해 관리되도록되어 있으며, &lt;code&gt;ghc&lt;/code&gt; 와 &lt;code&gt;ghci&lt;/code&gt; 가 툴에 의해 생성 된 환경을 자동으로 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c8382233c25160218d5faa2b0244da9d3072c08a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;safe import&lt;/em&gt; extension that specifies that the module being imported must be trusted.</source>
          <target state="translated">&lt;em&gt;가져올&lt;/em&gt; 모듈을 신뢰할 수 있도록 지정 하는 &lt;em&gt;안전한 가져 오기&lt;/em&gt; 확장입니다.</target>
        </trans-unit>
        <trans-unit id="a2030af640ee35ae911effa3c859071e394be43d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;segment&lt;/em&gt; of a given &lt;code&gt;mdo&lt;/code&gt;-expression is a minimal sequence of generators such that no generator of the sequence depends on an outside generator. As a special case, although it is not a generator, the final expression in an &lt;code&gt;mdo&lt;/code&gt;-expression is considered to form a segment by itself.</source>
          <target state="translated">주어진 &lt;code&gt;mdo&lt;/code&gt; - 표현 의 &lt;em&gt;세그먼트&lt;/em&gt; 는 최소한의 생성기 시퀀스이므로 시퀀스의 생성기가 외부 생성기에 의존하지 않습니다. 특별한 경우로서, 생성기는 아니지만 &lt;code&gt;mdo&lt;/code&gt; - expression의 최종 표현식은 자체적으로 세그먼트를 형성하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="19ca4e3b6cf814de306149f6c08ac93ed06475ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stable pointer&lt;/em&gt; is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection, i.e., it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection (ordinary references may be relocated during garbage collection). Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value.</source>
          <target state="translated">&lt;em&gt;안정적인 포인터가&lt;/em&gt; 되지 보장 가비지 수집에 의해 영향을받는 것으로, 즉,이 둘 할당이 해제되지 않습니다도 자체가 쓰레기를 수집하는 동안 변경 안정적인 포인터의 값 (일반 참조 가비지 수집시에 이전 할 수있다하는 하스켈 표현에 대한 참조입니다 ). 결과적으로 안정적인 포인터를 외부 코드로 전달하여 Haskell 값에 대한 불투명 한 참조로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9598916c07779e260b1bef0d4810f6ea9d7267b5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an expression; if the &amp;ldquo;&amp;hellip;&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;입력 된&lt;/em&gt; 표현의 인용은 다음과 같이 기록 &lt;code&gt;[|| ... ||]&lt;/code&gt; 또는 &lt;code&gt;[e|| ... ||]&lt;/code&gt; , 여기서&amp;ldquo;&amp;hellip;&amp;rdquo;은 표현식입니다. &quot;&amp;hellip;&quot;표현식에 &lt;code&gt;a&lt;/code&gt; 유형이 있는 경우 견적은 &lt;code&gt;Q (TExp a)&lt;/code&gt; 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="03966a369ab9f12abf8e596ab2fa4aeb07d6727e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an expression; if the &amp;rdquo;...&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;입력 된&lt;/em&gt; 표현의 인용은 다음과 같이 기록 &lt;code&gt;[|| ... ||]&lt;/code&gt; 또는 &lt;code&gt;[e|| ... ||]&lt;/code&gt; , 여기서&amp;rdquo;...&amp;rdquo;는 표현식입니다. &amp;rdquo;...&amp;rdquo;표현식의 유형이 &lt;code&gt;a&lt;/code&gt; 이면 견적의 유형은 &lt;code&gt;Q (TExp a)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bd2d6413fa23bbe46409864d68196768ad43eda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression.</source>
          <target state="translated">&lt;em&gt;형식화&lt;/em&gt; 발현 접합은 기입 &lt;code&gt;$$x&lt;/code&gt; , 여기서 &lt;code&gt;x&lt;/code&gt; 식별자, 또는 &lt;code&gt;$$(...)&lt;/code&gt; 는이 &quot;...&quot;임의의 표현이다.</target>
        </trans-unit>
        <trans-unit id="04024bbf6ad0e93c59da416e846a98466aa2e965" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression.</source>
          <target state="translated">&lt;em&gt;형식화&lt;/em&gt; 발현 접합은 기입 &lt;code&gt;$$x&lt;/code&gt; , 여기서 &lt;code&gt;x&lt;/code&gt; 식별자, 또는 &lt;code&gt;$$(...)&lt;/code&gt; 는이 &quot;...&quot;임의의 표현이다.</target>
        </trans-unit>
        <trans-unit id="e77214962b033f462a16c20eb7078d49bb12efbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;wrapper&lt;/em&gt; that for any datatype that is in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, performs the conversion between the original value and its &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;-based representation and then invokes the generic instances.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 의 모든 데이터 유형 에 대해 원래 값과 해당 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 기반 표현 간의 변환을 수행 한 후 일반 인스턴스를 호출 하는 &lt;em&gt;랩퍼&lt;/em&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b326e9656587b1adc32b0826a631549e0850098e" translate="yes" xml:space="preserve">
          <source>A C &lt;code&gt;printf(3)&lt;/code&gt;-like formatter. This version has been extended by Bart Massey as per the recommendations of John Meacham and Simon Marlow &lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&lt;/a&gt; to support extensible formatting for new datatypes. It has also been extended to support almost all C &lt;code&gt;printf(3)&lt;/code&gt; syntax.</source>
          <target state="translated">AC &lt;code&gt;printf(3)&lt;/code&gt; 와 유사한 포맷터. 이 버전은 John Meacham 및 Simon Marlow ( &lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726)&lt;/a&gt; 의 권장 사항에 따라 Bart Massey에 의해 확장되어 새로운 데이터 유형에 대한 확장 가능한 형식을 지원합니다. 또한 거의 모든 C &lt;code&gt;printf(3)&lt;/code&gt; 구문 을 지원하도록 확장되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7e0f8ee9d576152373e38d95b4048e53733a3d06" translate="yes" xml:space="preserve">
          <source>A C file not produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러가 생성하지 않은 AC 파일.</target>
        </trans-unit>
        <trans-unit id="0aad97c64c03d205c1227f534babfb0125731f8e" translate="yes" xml:space="preserve">
          <source>A C string is a reference to an array of C characters terminated by NUL.</source>
          <target state="translated">AC 문자열은 NUL로 종료 된 C 문자 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="73ba7d14948cc5309d53b24f871c08ff3a2fc5ec" translate="yes" xml:space="preserve">
          <source>A C template should define a macro or function with name prefixed by &lt;code&gt;hsc_&lt;/code&gt; that handles the construct by emitting the expansion to stdout. See &lt;code&gt;template-hsc.h&lt;/code&gt; for examples.</source>
          <target state="translated">AC 템플릿은 확장을 stdout 으로 &lt;code&gt;hsc_&lt;/code&gt; 을 처리하는 hsc_ 접두사가 붙은 매크로 또는 함수를 정의해야합니다 . 예제는 &lt;code&gt;template-hsc.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6886031497104d24437d52b2978fb1d3195d1677" translate="yes" xml:space="preserve">
          <source>A C wide string is a reference to an array of C wide characters terminated by NUL.</source>
          <target state="translated">AC 와이드 문자열은 NUL로 종료 된 C 와이드 문자 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="fff4ba731434913625d1042847648e899bcdc46f" translate="yes" xml:space="preserve">
          <source>A DynFlags plugin allows you to modify the &lt;code&gt;DynFlags&lt;/code&gt; that GHC is going to use when processing a given (set of) file(s). &lt;code&gt;DynFlags&lt;/code&gt; is a record containing all sorts of configuration and command line data, from verbosity level to the integer library to use, including compiler hooks, plugins and pretty-printing options. DynFlags plugins allow plugin authors to update any of those values before GHC starts doing any actual work, effectively meaning that the updates specified by the plugin will be taken into account and influence GHC&amp;rsquo;s behaviour.</source>
          <target state="translated">DynFlags 플러그인 을 사용하면 주어진 파일 (들)을 처리 할 때 GHC가 사용할 &lt;code&gt;DynFlags&lt;/code&gt; 를 수정할 수 있습니다 . &lt;code&gt;DynFlags&lt;/code&gt; 는 컴파일러 후크, 플러그인 및 예쁜 인쇄 옵션을 포함하여 사용할 자세한 수준에서 정수 라이브러리에 이르기까지 모든 종류의 구성 및 명령 줄 데이터를 포함하는 레코드입니다. DynFlags 플러그인을 사용하면 GHC가 실제 작업을 시작하기 전에 플러그인 작성자가 이러한 값을 업데이트 할 수 있습니다. 즉, 플러그인에서 지정한 업데이트가 고려되어 GHC의 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3e325f82925ec97e39b08ddc2fdbd0f77145b84c" translate="yes" xml:space="preserve">
          <source>A GADT can only be declared using GADT-style syntax (&lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;); the old Haskell 98 syntax for data declarations always declares an ordinary data type. The result type of each constructor must begin with the type constructor being defined, but for a GADT the arguments to the type constructor can be arbitrary monotypes. For example, in the &lt;code&gt;Term&lt;/code&gt; data type above, the type of each constructor must end with &lt;code&gt;Term ty&lt;/code&gt;, but the &lt;code&gt;ty&lt;/code&gt; need not be a type variable (e.g. the &lt;code&gt;Lit&lt;/code&gt; constructor).</source>
          <target state="translated">GADT는 GADT 스타일 구문을 사용해서 만 선언 할 수 있습니다 ( &lt;a href=&quot;#gadt-style&quot;&gt;명시적인 생성자 서명으로 데이터 유형 선언&lt;/a&gt; ). 데이터 선언을위한 이전 Haskell 98 구문은 항상 일반 데이터 형식을 선언합니다. 각 생성자의 결과 유형은 정의 된 유형 생성자로 시작해야하지만 GADT의 경우 유형 생성자에 대한 인수는 임의의 단일 유형일 수 있습니다. 예를 들어, 위의 &lt;code&gt;Term&lt;/code&gt; 데이터 유형에서 각 생성자의 유형은 &lt;code&gt;Term ty&lt;/code&gt; 로 끝나야 하지만 &lt;code&gt;ty&lt;/code&gt; 는 유형 변수 (예 : &lt;code&gt;Lit&lt;/code&gt; 생성자) 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b1c115ed6390536f96008338c3a76d6dc97d17be" translate="yes" xml:space="preserve">
          <source>A Haskell equivalent of the C numeric type will be output. It will be one of &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;LDouble&lt;/code&gt;.</source>
          <target state="translated">C 숫자 유형에 해당하는 Haskell이 출력됩니다. &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt; , &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;LDouble&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="411cbf3d599620cacbd5cc015731fcfe3b92f459" translate="yes" xml:space="preserve">
          <source>A Haskell interface file, probably compiler-generated.</source>
          <target state="translated">아마도 컴파일러가 생성 한 Haskell 인터페이스 파일.</target>
        </trans-unit>
        <trans-unit id="bea884a4fa9bc97a6459261f9e280deaec7399ff" translate="yes" xml:space="preserve">
          <source>A Haskell module.</source>
          <target state="translated">하스켈 모듈.</target>
        </trans-unit>
        <trans-unit id="e5aff74609ec235803608003865846be7a8bd1bc" translate="yes" xml:space="preserve">
          <source>A Map from keys &lt;code&gt;k&lt;/code&gt; to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">키 &lt;code&gt;k&lt;/code&gt; 에서 값 &lt;code&gt;a&lt;/code&gt; 까지의 맵 .</target>
        </trans-unit>
        <trans-unit id="cea3593e9e6a31d8bb148597b7e5fd17de4ea82d" translate="yes" xml:space="preserve">
          <source>A TextDetails represents a fragment of text that will be output at some point in a &lt;code&gt;Doc&lt;/code&gt;.</source>
          <target state="translated">TextDetails는 &lt;code&gt;Doc&lt;/code&gt; 의 어느 시점에 출력 될 텍스트 조각을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fc9ca598a7522d4ced721535fa37974946883f88" translate="yes" xml:space="preserve">
          <source>A TimeZone is a whole number of minutes offset from UTC, together with a name and a &quot;just for summer&quot; flag.</source>
          <target state="translated">TimeZone은 이름과 &quot;단지 여름&quot;플래그와 함께 UTC에서 분 단위로 오프셋 된 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c5ce154a6a02d4026db50fe3f1a5c49edc516fc7" translate="yes" xml:space="preserve">
          <source>A bang only really has an effect if it precedes a variable or wild-card pattern:</source>
          <target state="translated">뱅은 변수 또는 와일드 카드 패턴보다 우선하는 경우에만 실제로 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd93c38550cc32cf4aa813352ba8371915da4f4" translate="yes" xml:space="preserve">
          <source>A bang pattern is allowed in a let or where clause, and makes the binding strict. For example:</source>
          <target state="translated">bang 패턴은 let 또는 where 절에 허용되며 바인딩을 엄격하게 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbe85709a7348f901616c420f38c5dde9ca96cf4" translate="yes" xml:space="preserve">
          <source>A bare kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; enabled). For example:</source>
          <target state="translated">베어 종류 변수 ( &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 활성화 됨). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ba8b165584d313eb61a9a907807491cb2de49845" translate="yes" xml:space="preserve">
          <source>A better method is to keep a global list of all child threads which we should wait for at the end of the program:</source>
          <target state="translated">더 좋은 방법은 프로그램이 끝날 때까지 기다려야 할 모든 자식 스레드의 전체 목록을 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6005fc493cfa098670cf6142c7e4205f8cdf474b" translate="yes" xml:space="preserve">
          <source>A better monoid for Maybe</source>
          <target state="translated">아마도 더 나은 단일체</target>
        </trans-unit>
        <trans-unit id="d6fedf65a2cdf1eec5e505a6812db33c8b5b82ec" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym matching an empty sequence.</source>
          <target state="translated">빈 시퀀스와 일치하는 양방향 패턴 동의어.</target>
        </trans-unit>
        <trans-unit id="4177af688c85d2078a0a8ce62a0441115616a0c4" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the front of a non-empty sequence.</source>
          <target state="translated">비어 있지 않은 시퀀스의 앞을 보는 양방향 패턴 동의어.</target>
        </trans-unit>
        <trans-unit id="81df1a482fca8b73fcc642c85849297fd446593b" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the rear of a non-empty sequence.</source>
          <target state="translated">비어 있지 않은 시퀀스의 뒷면을 보는 양방향 패턴 동의어.</target>
        </trans-unit>
        <trans-unit id="9d4dd551ba4445c410acc2d23a963ba185817d09" translate="yes" xml:space="preserve">
          <source>A bifunctor is a type constructor that takes two type arguments and is a functor in &lt;em&gt;both&lt;/em&gt; arguments. That is, unlike with &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, a type constructor such as &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; does not need to be partially applied for a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, and the methods in this class permit mapping functions over the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value or the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; value, or both at the same time.</source>
          <target state="translated">bifunctor는 두 개의 형식 인수를 취하는 형식 생성자이며 &lt;em&gt;두&lt;/em&gt; 인수 &lt;em&gt;모두&lt;/em&gt; 의 functor입니다 . 즉, &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 달리 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 와 같은 유형 생성자 는 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 인스턴스에 부분적으로 적용 할 필요가 없으며이 클래스의 메소드는 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값 또는 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 값 또는 둘 다에 대한 함수 맵핑을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="de0591af67d2bf9b3b0301e6aff8ce08884f0195" translate="yes" xml:space="preserve">
          <source>A big difference with higher-rank kinds as compared with higher-rank types is that &lt;code&gt;forall&lt;/code&gt;s in kinds &lt;em&gt;cannot&lt;/em&gt; be moved. This is best illustrated by example. Suppose we want to have an instance of &lt;code&gt;HTestEquality&lt;/code&gt; for &lt;code&gt;(:~~:)&lt;/code&gt;.</source>
          <target state="translated">높은 순위 유형에 비해 더 높은 등급의 종류와 큰 차이가 있다는 것입니다 &lt;code&gt;forall&lt;/code&gt; 의 종류가 &lt;em&gt;할 수없는&lt;/em&gt; 이동. 이것은 예를 통해 가장 잘 설명됩니다. &lt;code&gt;(:~~:)&lt;/code&gt; 대한 &lt;code&gt;HTestEquality&lt;/code&gt; 인스턴스를 원한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="018f1834f8f4ba2f827cc9e9d66782e066f8b4db" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">힙을 빠르게 만드는 것의 큰 부분은 비어 있지 않다는 것입니다. 따라서 병합 기능은 추가적인 대소 문자를 피할 수 있습니다. 우리의 전문 버전이 필요하지만,이 활용하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; 을 (같은 빠른 반군-처럼 병합을 통해 접이식 비어 있지 않은 구조 전화를 교대로 할 수있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 때 폴딩, mappend -like 비울 수있는 구조 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="47779d8a6c1ed5651ad2278a9f8963fba26cb6a4" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">힙을 빠르게 만드는 가장 큰 부분은 힙이 비어 있지 않기 때문에 병합 기능이 추가 대소 문자 일치를 피할 수 있다는 것입니다. 하지만이를 활용하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; 의 특수 버전이 필요합니다.이 버전은 비어 있지 않은 구조 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt; )를 접을 때 더 빠른 세미 그룹 유사 병합 호출 과 접을 때 &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 유사 맵 펜드 호출을 번갈아 호출 할 수 있습니다. 비어있을 수있는 구조 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f59eaf213264b07a33c9b86cc594f16cfebf034b" translate="yes" xml:space="preserve">
          <source>A binding group is &lt;em&gt;fully generalised&lt;/em&gt; if and only if</source>
          <target state="translated">바인딩 그룹은 다음 과 같은 경우에만 &lt;em&gt;완전히 일반화&lt;/em&gt; 됩니다</target>
        </trans-unit>
        <trans-unit id="f0ac98b71fc651c5cb7838fb8ecc4183a85e5c4f" translate="yes" xml:space="preserve">
          <source>A biographical heap profile displays the portion of the live heap in each of the four states listed above. Usually the most interesting states are the void and drag states: live heap in these states is more likely to be wasted space than heap in the lag or use states.</source>
          <target state="translated">전기 힙 프로파일은 위에 나열된 네 가지 상태 각각에서 라이브 힙 부분을 표시합니다. 일반적으로 가장 흥미로운 상태는 void 및 drag 상태입니다. 이러한 상태의 라이브 힙은 지연 또는 사용 상태의 힙보다 공간을 낭비 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="798384519287140522d002a35024512e2c520012" translate="yes" xml:space="preserve">
          <source>A bound thread is a haskell thread that is &lt;em&gt;bound&lt;/em&gt; to an operating system thread. While the bound thread is still scheduled by the Haskell run-time system, the operating system thread takes care of all the foreign calls made by the bound thread.</source>
          <target state="translated">바운드 스레드는 운영 체제 스레드에 &lt;em&gt;바인딩 된&lt;/em&gt; 하스켈 스레드입니다 . 바인딩 된 스레드는 여전히 Haskell 런타임 시스템에 의해 예약되어 있지만 운영 체제 스레드는 바인딩 된 스레드가 수행 한 모든 외래 호출을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3f4f07c153a23dab6881d6b97859240ea5495b6b" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 실행하기위한 버퍼 할당 전략 .</target>
        </trans-unit>
        <trans-unit id="3acbb589dc6847927b75f04416af1f081adc5cfc" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 실행하기위한 버퍼 할당 전략 .</target>
        </trans-unit>
        <trans-unit id="b00aec03f8bf511485eb07886b22c54f4f193a13" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in a sequence of bytes of a pre-determined, fixed size.</source>
          <target state="translated">항상 미리 정해진 고정 크기의 바이트 시퀀스를 생성하는 빌더 기본 요소.</target>
        </trans-unit>
        <trans-unit id="218c8868a68984ef2191051e647e5ad44495f1c2" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in sequence of bytes that is no longer than a pre-determined bound.</source>
          <target state="translated">미리 결정된 바인드보다 길지 않은 바이트 시퀀스를 항상 생성하는 빌더 기본 요소.</target>
        </trans-unit>
        <trans-unit id="cee5a68b267e0b9eedc95f3e5e46dbbcbd9d7c7d" translate="yes" xml:space="preserve">
          <source>A canonical proxy type</source>
          <target state="translated">표준 프록시 유형</target>
        </trans-unit>
        <trans-unit id="f9785a9266197868d744526bac75698ed903dbc4" translate="yes" xml:space="preserve">
          <source>A capability has been deleted.</source>
          <target state="translated">기능이 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="23e42267c559ef0543a396aeedf38ba2368048b9" translate="yes" xml:space="preserve">
          <source>A capability has been disabled.</source>
          <target state="translated">기능이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="86896e42132938a37e212fd5cef10f4151fc9477" translate="yes" xml:space="preserve">
          <source>A capability has been enabled.</source>
          <target state="translated">기능이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c58d21d44a4d30e0c00f0ffb699c3dbb7518536" translate="yes" xml:space="preserve">
          <source>A capability has been started.</source>
          <target state="translated">기능이 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="646cfd44f97fd578432c1d7e4ee9f594332ba27b" translate="yes" xml:space="preserve">
          <source>A careful reading of the Haskell 98 Report reveals that fixity declarations (&lt;code&gt;infix&lt;/code&gt;, &lt;code&gt;infixl&lt;/code&gt;, and &lt;code&gt;infixr&lt;/code&gt;) are permitted to appear inside local bindings such those introduced by &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt;. However, the Haskell Report does not specify the semantics of such bindings very precisely.</source>
          <target state="translated">하스켈 98 보고서의주의 깊게 읽어은 고정 인 선언 (계시 &lt;code&gt;infix&lt;/code&gt; , &lt;code&gt;infixl&lt;/code&gt; 및 &lt;code&gt;infixr&lt;/code&gt; 가 ) 지역 바인딩 안에 도입 등 그 표시 허용 &lt;code&gt;let&lt;/code&gt; 하고 &lt;code&gt;where&lt;/code&gt; . 그러나 Haskell 보고서는 이러한 바인딩의 의미를 매우 정확하게 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cad22f831909a841240c57158600100ecb21412" translate="yes" xml:space="preserve">
          <source>A caveat: this encoding strategy may not be reliable across different versions of GHC. When deriving a &lt;code&gt;Generic&lt;/code&gt; instance is free to choose any nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; it chooses, so if GHC chooses &lt;code&gt;(a :+: b) :+: c&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O, O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[O, I]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I]&lt;/code&gt;. However, if GHC chooses &lt;code&gt;a :+: (b :+: c)&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[I, O]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I, I]&lt;/code&gt;. (In practice, the current implementation tries to produce a more-or-less balanced nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">경고 :이 인코딩 전략은 다른 버전의 GHC에서 신뢰할 수 없습니다. 도출되면 &lt;code&gt;Generic&lt;/code&gt; 인스턴스 것은 임의의 중첩을 자유롭게 선택할 &lt;code&gt;:+:&lt;/code&gt; 및 &lt;code&gt;:*:&lt;/code&gt; 이 선택 그렇다면 GHC을 선택한다면 &lt;code&gt;(a :+: b) :+: c&lt;/code&gt; , 다음의 부호화 것 &lt;code&gt;[O, O]&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 것이다 &lt;code&gt;[O, I]&lt;/code&gt; , 및 &lt;code&gt;c&lt;/code&gt; 것이다 &lt;code&gt;[I]&lt;/code&gt; . GHC가 선택한 경우에는, &lt;code&gt;a :+: (b :+: c)&lt;/code&gt; , 다음의 부호화 &lt;code&gt;a&lt;/code&gt; 것이다 &lt;code&gt;[O]&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 것이다 &lt;code&gt;[I, O]&lt;/code&gt; , 및 &lt;code&gt;c&lt;/code&gt; 것 &lt;code&gt;[I, I]&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; . (실제로, 현재 구현은 &lt;code&gt;:+:&lt;/code&gt; 및 &lt;code&gt;:*:&lt;/code&gt; 의 균형 잡힌 중첩을 생성하려고 시도 하므로 루트에서 특정 구성 요소로의 데이터 유형 구조 탐색은 로그가 아닌 로그 방식으로 수행 될 수 있습니다 선형 시간.)</target>
        </trans-unit>
        <trans-unit id="22d4b5245916ddee4003e31bf87953ef290e9b20" translate="yes" xml:space="preserve">
          <source>A class cannot generally have itself as a superclass. So this is illegal</source>
          <target state="translated">클래스는 일반적으로 수퍼 클래스로 가질 수 없습니다. 그래서 이것은 불법입니다</target>
        </trans-unit>
        <trans-unit id="f056b7a04761436a087354198406063da33c9730" translate="yes" xml:space="preserve">
          <source>A class declarations can either be abstract or concrete. An abstract class is one with no superclasses or class methods:</source>
          <target state="translated">클래스 선언은 추상적이거나 구체적 일 수 있습니다. 추상 클래스는 수퍼 클래스 나 클래스 메소드가없는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1b36f377a6bd2fac28e2b563337bb9c2dc25741e" translate="yes" xml:space="preserve">
          <source>A class for categories. Instances should satisfy the laws</source>
          <target state="translated">카테고리를위한 클래스. 인스턴스는 법을 충족해야합니다</target>
        </trans-unit>
        <trans-unit id="6fec2d7334def5a7f37888bee18c8bb561acd718" translate="yes" xml:space="preserve">
          <source>A class for things buildable from static pointers.</source>
          <target state="translated">정적 포인터로 빌드 할 수있는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="16f65e9b0b64e45d51e0bcdd76ca8407c6f3cc52" translate="yes" xml:space="preserve">
          <source>A class method</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="6f3ca3b97f5cb6f003ec47445c70a8cb5a13ebc9" translate="yes" xml:space="preserve">
          <source>A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called. The &lt;code&gt;String&lt;/code&gt; gives information about which method it was.</source>
          <target state="translated">정의가없는 클래스 메소드 (기본 정의 나 적절한 인스턴스의 정의가 아님)가 호출되었습니다. &lt;code&gt;String&lt;/code&gt; 그것이 어떤 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="820008a62ac203372438ae344a8da118e60912d3" translate="yes" xml:space="preserve">
          <source>A class of bifunctors that can be fully evaluated.</source>
          <target state="translated">완전히 평가할 수있는 보조 기능 클래스.</target>
        </trans-unit>
        <trans-unit id="5f62d094b52f200eb67c73fe054a072916deee3f" translate="yes" xml:space="preserve">
          <source>A class of functors that can be fully evaluated.</source>
          <target state="translated">완전히 평가할 수있는 펑터 클래스.</target>
        </trans-unit>
        <trans-unit id="03b36f13be1922d1c74d9e6e0b4b212a81502e1b" translate="yes" xml:space="preserve">
          <source>A class of types that can be fully evaluated.</source>
          <target state="translated">완전히 평가할 수있는 유형의 클래스.</target>
        </trans-unit>
        <trans-unit id="18974c638151613690d5d785bcc282ea54126e16" translate="yes" xml:space="preserve">
          <source>A class, with a list of its visible instances</source>
          <target state="translated">보이는 인스턴스 목록이있는 클래스</target>
        </trans-unit>
        <trans-unit id="cf9b4ce512562f9b4a68069022cc221d559c7dde" translate="yes" xml:space="preserve">
          <source>A closed type family has a complete signature when all of its type variables are annotated and a return kind (with a top-level &lt;code&gt;::&lt;/code&gt;) is supplied.</source>
          <target state="translated">클로즈드 타입 패밀리는 모든 타입 변수에 주석이 달렸을 때 완전한 서명을 가지고 있으며 (최상위 레벨 &lt;code&gt;::&lt;/code&gt; 이 제공 .</target>
        </trans-unit>
        <trans-unit id="5dfadf25c80308dd41216413c27a3be8dce8cf23" translate="yes" xml:space="preserve">
          <source>A closed type family may be declared with no equations. Such closed type families are opaque type-level definitions that will never reduce, are not necessarily injective (unlike empty data types), and cannot be given any instances. This is different from omitting the equations of a closed type family in a &lt;code&gt;hs-boot&lt;/code&gt; file, which uses the syntax &lt;code&gt;where ..&lt;/code&gt;, as in that case there may or may not be equations given in the &lt;code&gt;hs&lt;/code&gt; file.</source>
          <target state="translated">폐쇄 형 패밀리는 방정식없이 선언 될 수 있습니다. 이러한 폐쇄 형 패밀리는 절대로 축소되지 않고 빈 데이터 유형과 달리 반드시 주입 형일 필요는 없으며 인스턴스를 제공 할 수없는 불투명 한 유형 레벨 정의입니다. 이것은 &lt;code&gt;hs-boot&lt;/code&gt; 파일 에서 닫힌 유형 패밀리의 방정식을 생략하는 것과 다릅니다.이 구문 은 &lt;code&gt;hs&lt;/code&gt; 파일에 제공된 방정식이 있거나 없을 수 &lt;code&gt;where ..&lt;/code&gt; 구문을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="5bc12f9a6f357ec15b737234f9f657aacb094303" translate="yes" xml:space="preserve">
          <source>A closed type family may optionally omit its equations, as in the following example:</source>
          <target state="translated">폐쇄 형 패밀리는 다음 예제와 같이 선택적으로 방정식을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="560667c66049aeef765aec3cd394fe9074dbfde4" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations are tried in order, from top to bottom, when simplifying a type family application. In this example, we declare an instance for &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;F Int&lt;/code&gt; simplifies to &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;F Bool&lt;/code&gt; simplifies to &lt;code&gt;Char&lt;/code&gt;, and for any other type &lt;code&gt;a&lt;/code&gt; that is known not to be &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;F a&lt;/code&gt; simplifies to &lt;code&gt;String&lt;/code&gt;. Note that GHC must be sure that &lt;code&gt;a&lt;/code&gt; cannot unify with &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt; in that last case; if a programmer specifies just &lt;code&gt;F a&lt;/code&gt; in their code, GHC will not be able to simplify the type. After all, &lt;code&gt;a&lt;/code&gt; might later be instantiated with &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">폐쇄 형 패밀리의 방정식은 유형 패밀리 응용 프로그램을 단순화 할 때 위에서 아래로 순서대로 시도됩니다. 이 예에서는 대한 인스턴스 선언 &lt;code&gt;F&lt;/code&gt; 를 되도록 &lt;code&gt;F Int&lt;/code&gt; 수 를 단순화 &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;F Bool&lt;/code&gt; 을 단순화 &lt;code&gt;Char&lt;/code&gt; 및 기타 유형의 수 없습니다 알려져 &lt;code&gt;Int&lt;/code&gt; 또는 &lt;code&gt;Bool&lt;/code&gt; , &lt;code&gt;F a&lt;/code&gt; 을 단순화 &lt;code&gt;String&lt;/code&gt; . 참고 GHC이 있는지 확인해야한다는 &lt;code&gt;a&lt;/code&gt; 함께 통합 할 수 &lt;code&gt;Int&lt;/code&gt; 인 또는 &lt;code&gt;Bool&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 마지막 경우; 프로그래머가 &lt;code&gt;F a&lt;/code&gt; 만 지정 하면코드에서 GHC는 유형을 단순화 할 수 없습니다. 결국 &lt;code&gt;a&lt;/code&gt; 는 나중에 &lt;code&gt;Int&lt;/code&gt; 로 인스턴스화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8038c2136e5194f458ce16e855b310af6be8edf" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations have the same restrictions and extensions as the equations for open type family instances. For instance, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side of an equation can be explicitly bound, such as in:</source>
          <target state="translated">폐쇄 형 패밀리 방정식에는 개방형 패밀리 인스턴스 방정식과 동일한 제한 및 확장이 있습니다. 예를 들어 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 활성화하면 방정식의 왼쪽에 사용 된 유형 또는 종류 변수를 다음과 같이 명시 적으로 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55db83fdd426c323b8ba055ddebf0f4927065c0d" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 Console API</source>
          <target state="translated">Win32 콘솔 API와의 인터페이스를위한 FFI 선언 모음</target>
        </trans-unit>
        <trans-unit id="97dfd9521aba56f50c67376cea085b8e6e134f90" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 mapped files.</source>
          <target state="translated">Win32 매핑 된 파일과의 인터페이스를위한 FFI 선언 모음입니다.</target>
        </trans-unit>
        <trans-unit id="0e9e3c664eeffb3c7374565940d3d04f59d623a4" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32.</source>
          <target state="translated">Win32와의 인터페이스를위한 FFI 선언 모음.</target>
        </trans-unit>
        <trans-unit id="15a4c2ec78aa243e78e786440542fa86a3f898c2" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only either part is.</source>
          <target state="translated">조합은 어느 쪽이든 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0e6111313c9398a428339ebfc1488b4234c0e6df" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only if both parts are.</source>
          <target state="translated">두 부품이 모두있는 경우에만 조합이 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1cf4024f647ac4b5f1014ad62fdb4551663a3cfd" translate="yes" xml:space="preserve">
          <source>A command line to execute using the shell</source>
          <target state="translated">쉘을 사용하여 실행할 명령 행</target>
        </trans-unit>
        <trans-unit id="2b42afbfaea58252904aedc72c342409dc5217ec" translate="yes" xml:space="preserve">
          <source>A common example is opening a file:</source>
          <target state="translated">일반적인 예는 파일을 여는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e611ccbbca22d800c83d8e50686983d00ac930b7" translate="yes" xml:space="preserve">
          <source>A common interface to a collection of useful concurrency abstractions.</source>
          <target state="translated">유용한 동시성 추상화 모음에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="158d48aa333ea6c2ec16fe37bdb3bd252bd76bb9" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; is to process input from network sockets, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, and channels (e.g. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 의 일반적인 용도는 네트워크 소켓, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 및 채널 (예 : &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; ) 의 입력을 처리 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="de5703326cbd6c93faef0a72782d20b8fe31e5ee" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 트랜잭션은 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 직접 수행 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 일반적인 사용은 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 트랜잭션 에서 반환 된 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 을 실행하는 것 입니다. 기억해</target>
        </trans-unit>
        <trans-unit id="d6b9bff21670bd6e1dbddd535cfab7c10fd33d82" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 트랜잭션은 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 직접 수행 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 일반적인 사용은 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 트랜잭션 에서 반환 된 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 을 실행하는 것 입니다. 기억해</target>
        </trans-unit>
        <trans-unit id="923f01eefd2602576139719f5c7af323619c5a66" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 의 간결한 표현 .</target>
        </trans-unit>
        <trans-unit id="c5b6f1851ba64e7fbc006018f91e89cc899a277e" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 의 간결한 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="0dc43ee46b5b21f3e78943bd2860ac98eafb0926" translate="yes" xml:space="preserve">
          <source>A compact representation suitable for storing short byte strings in memory.</source>
          <target state="translated">짧은 바이트 문자열을 메모리에 저장하는 데 적합한 컴팩트 한 표현입니다.</target>
        </trans-unit>
        <trans-unit id="4dee1b6583088672899330bd95413844639d24f0" translate="yes" xml:space="preserve">
          <source>A concrete class specifies its superclasses, methods, default method signatures (but not their implementations) and a &lt;code&gt;MINIMAL&lt;/code&gt; pragma. Unlike regular Haskell classes, you don&amp;rsquo;t have to explicitly declare a default for a method to make it optional vis-a-vis the &lt;code&gt;MINIMAL&lt;/code&gt; pragma.</source>
          <target state="translated">구체적 클래스는 수퍼 클래스, 메소드, 기본 메소드 서명 (구현은 아님) 및 &lt;code&gt;MINIMAL&lt;/code&gt; pragma를 지정합니다. 일반적인 Haskell 클래스와 달리 메소드를 &lt;code&gt;MINIMAL&lt;/code&gt; 에 대해 선택적으로 만들기 위해 기본값을 명시 적으로 선언 할 필요가 없습니다. pragma에 .</target>
        </trans-unit>
        <trans-unit id="48e06f28fdc9e894b60b4a1b8a5f1e5767f7a49e" translate="yes" xml:space="preserve">
          <source>A concrete representation of &lt;code&gt;Version&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; 의 구체적인 표현</target>
        </trans-unit>
        <trans-unit id="2cb20f59e5f2e9ba3dec010b3eb3028f911a9a31" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">(단일형) 유형의 구체적인 표현. &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 은 합리적인 효율성의 평등을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="11422484bfa14bcef95a9aa3860b69ba994b65fb" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">(단일형) 유형의 구체적인 표현. &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 은 합리적인 효율성의 평등을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0e1fa2e1fdd32663fb32988ae8b548b810674d4a" translate="yes" xml:space="preserve">
          <source>A concrete type constructor applied to some types.</source>
          <target state="translated">구체적인 유형 생성자는 일부 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bad079c8885ff9572beaf6828f7450891b38608" translate="yes" xml:space="preserve">
          <source>A concrete type literal.:</source>
          <target state="translated">구체적인 유형 리터럴. :</target>
        </trans-unit>
        <trans-unit id="5d4c61340ac65e2aef91e6fee099cfe89ce3d06e" translate="yes" xml:space="preserve">
          <source>A concrete, promotable proxy type, for use at the kind level. There are no instances for this because it is intended at the kind level only</source>
          <target state="translated">종류 수준에서 사용하기위한 구체적이고 승격 가능한 프록시 유형입니다. 종류 수준만을 대상으로하기 때문에 이에 대한 인스턴스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="63ae3dab5a2e143c3ea2383adfe2778d5d710d0b" translate="yes" xml:space="preserve">
          <source>A constraint in the type signature is not used in the code it covers:</source>
          <target state="translated">형식 서명의 제약 조건은 해당 코드에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84193f4f755d1c0b1057183b2a0adc6bf73de7fb" translate="yes" xml:space="preserve">
          <source>A constructor signature may mention type class constraints, which can differ for different constructors. For example, this is fine:</source>
          <target state="translated">생성자 서명은 형식 클래스 제약 조건을 언급 할 수 있으며, 생성자마다 다를 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fe5ae7286a52f71d84c6187f3fe447df9c9228a" translate="yes" xml:space="preserve">
          <source>A contrived addition example. Works only with positive numbers:</source>
          <target state="translated">고려 된 추가 예. 양수로만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0df890da0fb3e9db7fe956f05674d4d8aa062f47" translate="yes" xml:space="preserve">
          <source>A conversion specification begins with the character &lt;code&gt;%&lt;/code&gt;, followed by zero or more of the following flags:</source>
          <target state="translated">변환 스펙은 문자 &lt;code&gt;%&lt;/code&gt; 로 시작합니다 하고 다음 플래그 중 0 개 이상이옵니다.</target>
        </trans-unit>
        <trans-unit id="dd84caa4cb664b8bd50303514ba4d2b0f6763dd8" translate="yes" xml:space="preserve">
          <source>A corresponding Haskell value looks like this:</source>
          <target state="translated">해당 Haskell 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f782e63a1f3f05e6a16c8d7b64076664f462677" translate="yes" xml:space="preserve">
          <source>A cost-centre from GHC's cost-center profiler.</source>
          <target state="translated">GHC 비용 센터 프로파일 러의 비용 센터.</target>
        </trans-unit>
        <trans-unit id="ba083c36a70a7120687138d63b14bdaf702d8dac" translate="yes" xml:space="preserve">
          <source>A cost-centre stack from GHC's cost-center profiler.</source>
          <target state="translated">GHC 비용 센터 프로파일 러의 비용 센터 스택.</target>
        </trans-unit>
        <trans-unit id="50ea9d5bdb5ec17d018609e47a9ec22b64ecd54e" translate="yes" xml:space="preserve">
          <source>A couple of things to notice:</source>
          <target state="translated">주의해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="3dc945323c54ee396119be0717674ee79090c303" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor, and takes into account the line contents to the left of the word.</source>
          <target state="translated">커스텀 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; 커서 왼쪽에있는 단어를 즉시 완성하고 단어 왼쪽에있는 줄 내용을 고려 .</target>
        </trans-unit>
        <trans-unit id="8c0d52f3762ec276383b7f73f082f54d2df5f0bc" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor.</source>
          <target state="translated">커스텀 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; 커서 왼쪽에있는 단어를 즉시 하는 .</target>
        </trans-unit>
        <trans-unit id="5862453396404797aa7de7142dce28109cb9b288" translate="yes" xml:space="preserve">
          <source>A custom pre-processor is run over your Haskell source file only if the &lt;code&gt;-F&lt;/code&gt; option is given.</source>
          <target state="translated">사용자 정의 프리 프로세서는 &lt;code&gt;-F&lt;/code&gt; 인 경우에만 Haskell 소스 파일에서 실행됩니다. 옵션이 제공된 .</target>
        </trans-unit>
        <trans-unit id="1599a4a0a331f022d3d429faece9bf7cf541b2b9" translate="yes" xml:space="preserve">
          <source>A custom pretty printing function can be used, for example, to format tree-like and nested structures in a more readable way.</source>
          <target state="translated">예를 들어, 트리 형 및 중첩 구조를보다 읽기 쉬운 방식으로 형식화하기 위해 사용자 정의 인쇄 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8eb6d3c983aaf3cde12f740cd4904b0498bd294" translate="yes" xml:space="preserve">
          <source>A data constructor</source>
          <target state="translated">데이터 생성자</target>
        </trans-unit>
        <trans-unit id="b5d4cb00190598ddeec4823830bc239b1485a236" translate="yes" xml:space="preserve">
          <source>A data family instance declaration can use the full expressiveness of ordinary &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; declarations:</source>
          <target state="translated">데이터 가족 인스턴스 선언은 보통의 전체 표현력 사용할 수있는 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 이란 선언을 :</target>
        </trans-unit>
        <trans-unit id="f190b4f01195b249d3555778e7d04af0949a28aa" translate="yes" xml:space="preserve">
          <source>A data or type synonym family can be declared as part of a type class, thus:</source>
          <target state="translated">데이터 또는 형식 동의어 패밀리는 형식 클래스의 일부로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fab55b5200474635e47e3680a86e7055016af5b" translate="yes" xml:space="preserve">
          <source>A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the &amp;lsquo;=&amp;rsquo; sign and everything that follows. For example:</source>
          <target state="translated">데이터 유형 선언은 Haskell에서와 같이 전체적으로 제공되거나 '='기호와 그 뒤에 나오는 모든 것을 생략하여 추상적으로 제공 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3df736aafe2d3db3e69d9a2a8f83fab7d3cd7998" translate="yes" xml:space="preserve">
          <source>A data type has no type parameters (e.g., &lt;code&gt;data Nothing = Nothing&lt;/code&gt;).</source>
          <target state="translated">데이터 유형에는 유형 매개 변수가 없습니다 (예 : &lt;code&gt;data Nothing = Nothing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="586827d4266b3d644377c42c18624801ae4ad40a" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in a &lt;a href=&quot;#extension-DatatypeContexts&quot;&gt;&lt;code&gt;DatatypeContexts&lt;/code&gt;&lt;/a&gt; constraint (e.g., &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt;).</source>
          <target state="translated">데이터 유형의 마지막 유형 변수는 &lt;a href=&quot;#extension-DatatypeContexts&quot;&gt; &lt;code&gt;DatatypeContexts&lt;/code&gt; &lt;/a&gt; 제약 조건 에서 사용됩니다 (예 : &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt; )에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="541952865f0bce99dfba54b59c18bf4d90b79e63" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in an &lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt; constraint, or is refined in a GADT. For example,</source>
          <target state="translated">데이터 유형의 마지막 유형 변수는 &lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt; &lt;code&gt;ExistentialQuantification&lt;/code&gt; &lt;/a&gt; 제약 조건에서 사용되거나 GADT에서 구체화됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="21d82223d3ac86e9e0f5a1e86033ba159dc2adca" translate="yes" xml:space="preserve">
          <source>A datatype-generic function comprises two parts:</source>
          <target state="translated">데이터 유형 일반 함수는 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6264b318464960e93f9c184b690473f5a5728225" translate="yes" xml:space="preserve">
          <source>A declaration type signature (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;)</source>
          <target state="translated">선언 형 서명 ( &lt;a href=&quot;#decl-type-sigs&quot;&gt;선언 형 서명&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ee69366de998246ce67952ee9a1a1b3b6c96d4af" translate="yes" xml:space="preserve">
          <source>A declaration type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the definition of the named function. For example:</source>
          <target state="translated">&lt;em&gt;명시 적&lt;/em&gt; 정량화 ( &lt;code&gt;forall&lt;/code&gt; 사용 ) 가있는 선언 유형 시그니처 는 명명 된 함수의 정의에서 명시 적으로 정량화 된 유형 변수의 범위를 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a000f3b48bd252b4ec5f85b4c427ccb663838bd" translate="yes" xml:space="preserve">
          <source>A decoder procuced by running a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 모나드 를 실행하여 얻은 디코더 입니다.</target>
        </trans-unit>
        <trans-unit id="5d17b00ef4a90f5cabfdbf829a677b6db008e640" translate="yes" xml:space="preserve">
          <source>A default declaration is not permitted for an associated &lt;em&gt;data&lt;/em&gt; type.</source>
          <target state="translated">연관된 &lt;em&gt;데이터&lt;/em&gt; 에는 기본 선언이 허용되지 않습니다.&lt;em&gt;&lt;/em&gt; 유형 .</target>
        </trans-unit>
        <trans-unit id="13508033e2c27b5de3214a6e0b6e522b009a007b" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">의 기본 정의 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; 의 측면에서 &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="a5b5443d78a52a0405c2f0d6239820bf3007f82e" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 작업 측면에서 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 의 기본 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="8979aa9d1894c898d3c726fca41fdca65c4a33d5" translate="yes" xml:space="preserve">
          <source>A default element</source>
          <target state="translated">기본 요소</target>
        </trans-unit>
        <trans-unit id="6b0ba2dc21c07d694dd7ceb37775a8c3eee889d5" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 의 정의 는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="a180dbe254c504564dcc326aee311c425f63e9ec" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 의 정의 는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="16de260f1c6cac6529ed6b018b65c836efe37f81" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 의 정의 는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="47d9196fc9df3f1fb6cf5bd564f834d9d06f81f1" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 의 정의 는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc3862240a73ca7ad48aba38069f60afa153c34d" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 의 정의 는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="06c816889d8c0a0e486735490b0238ade51de818" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;&lt;code&gt;do&lt;/code&gt;-notation:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; - &lt;code&gt;safeDiv&lt;/code&gt; 사용한 safeDiv 의 정의 :</target>
        </trans-unit>
        <trans-unit id="c1670eef1322c0d7b707d0ae468ed9e809e67e91" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using guards, but not &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">가드를 사용하지만 &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; 사용하지 않는 &lt;code&gt;safeDiv&lt;/code&gt; 의 정의 :</target>
        </trans-unit>
        <trans-unit id="006a6845e3a856bbfba4df0255e3848a4a860831" translate="yes" xml:space="preserve">
          <source>A definition of &lt;em&gt;trust&lt;/em&gt; (or safety) and how it operates, along with ways of defining and changing the trust of modules and packages.</source>
          <target state="translated">의 정의 &lt;em&gt;신뢰&lt;/em&gt; (안전)과 어떻게 정의하고 모듈과 패키지의 신뢰를 변경하는 방법과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1fb7cf11f58e4e4a3003926053464a1496f9bd2f" translate="yes" xml:space="preserve">
          <source>A deprecated alias of &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용되지 않는 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="c13f98be7b9473c582b30f2dd1c5005c007bdc07" translate="yes" xml:space="preserve">
          <source>A derived instance is derived only for declarations of these forms (after expansion of any type synonyms)</source>
          <target state="translated">파생 인스턴스는 이러한 형식의 선언에 대해서만 파생됩니다 (유형 동의어 확장 후)</target>
        </trans-unit>
        <trans-unit id="fd8f6757bd0323a7730e959138361a06c176f799" translate="yes" xml:space="preserve">
          <source>A description of a custom type error.</source>
          <target state="translated">사용자 정의 유형 오류에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="97496eb0e26835b32d2dfe1ae69ecf8a627e29cb" translate="yes" xml:space="preserve">
          <source>A descriptive string roughly identifying the cost-centre.</source>
          <target state="translated">비용 중심을 대략 식별하는 설명 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1814a528e490de53f22aa61afcafb8d5feeb8d24" translate="yes" xml:space="preserve">
          <source>A different approach is to group the option values in a record of type &lt;code&gt;Options&lt;/code&gt;, and have each flag yield a function of type &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; transforming this record.</source>
          <target state="translated">다른 접근 방법은 그룹 형의 기록에 옵션 값입니다 &lt;code&gt;Options&lt;/code&gt; , 각 플래그 타입의 기능을 얻을 수있는 &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; 이 레코드를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="bbb68a110439919741a19755964df2e6fa3244b4" translate="yes" xml:space="preserve">
          <source>A directory contains a series of entries, each of which is a named reference to a file system object (file, directory etc.). Some entries may be hidden, inaccessible, or have some administrative function (e.g. &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt; under &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt;), but in this standard all such entries are considered to form part of the directory contents. Entries in sub-directories are not, however, considered to form part of the directory contents.</source>
          <target state="translated">디렉토리에는 일련의 항목이 있으며 각 항목은 파일 시스템 객체 (파일, 디렉토리 등)에 대한 명명 된 참조입니다. 일부 항목은 숨겨 지거나 액세스 할 수 없거나 일부 관리 기능 (예 : &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt; 에서 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; )이있을 수 있지만이 표준에서는 이러한 모든 항목이 디렉토리 내용의 일부로 간주됩니다. 그러나 서브 디렉토리의 항목은 디렉토리 내용의 일부로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cea28c5c17737eb22d5290576e72180db68e967" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">리터럴 문자열을 포함하는 높이 1의 문서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 는 다음 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="a7c0af88c561dd3e381e4c0c9eb468d9f9adda7d" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">리터럴 문자열을 포함하는 높이 1의 문서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 는 다음 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="b60445ccdc10943dbfcb65b6302d60eef3c3dd3b" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">리터럴 문자열을 포함하는 높이 1의 문서. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 는 다음 법률을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="688bfb4bbd29b21c2ae8d691c138d77983de8115" translate="yes" xml:space="preserve">
          <source>A document of height and width 1, containing a literal character.</source>
          <target state="translated">리터럴 문자를 포함하는 높이와 너비 1의 문서.</target>
        </trans-unit>
        <trans-unit id="6b6ebd185f2a3b55592691251680ab65322061fe" translate="yes" xml:space="preserve">
          <source>A duplex communications channel (results in creation of a duplex &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;). The standard libraries use this device type when creating &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s for open sockets.</source>
          <target state="translated">이중 통신 채널 (듀플렉스 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 생성시 발생 ) 표준 라이브러리 는 열린 소켓에 대한 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 만들 때이 장치 유형을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="86a3012ad906142a305a738b9de653227862c657" translate="yes" xml:space="preserve">
          <source>A expression quotation is written in Oxford brackets, thus:</source>
          <target state="translated">표현식 인용문은 옥스포드 괄호로 작성되므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e47ffa147be43069d678d8783f87f9374b92f8d" translate="yes" xml:space="preserve">
          <source>A feature or operation which a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; may define.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; 이 정의 할 수 있는 기능 또는 동작 .</target>
        </trans-unit>
        <trans-unit id="14e098e337088120cd46a6eee334387a102be1a6" translate="yes" xml:space="preserve">
          <source>A few caveats apply here. First, it is illegal to export an entity which refers to a locally defined type which itself is not exported (GHC will report an error in this case). Second, signatures which come from dependencies which expose modules cannot be thinned in this way (after all, the dependency itself may need the entity); these requirements are unconditionally exported. Finally, any module reexports must refer to modules imported by the local signature (even if an inherited signature exported the module).</source>
          <target state="translated">여기에 몇 가지 경고가 적용됩니다. 첫째, 자체적으로 내 보내지 않은 로컬로 정의 된 유형을 참조하는 엔티티를 내보내는 것은 불법입니다 (GHC는이 경우 오류를보고합니다). 둘째, 모듈을 노출하는 의존성에서 오는 서명은 이런 방식으로 얇아 질 수 없습니다 (결국 의존성 자체에는 엔티티가 필요할 수 있습니다). 이러한 요구 사항은 무조건 내보내집니다. 마지막으로, 모듈 재수출은 상속 된 서명이 모듈을 내보냈더라도 로컬 서명으로 가져온 모듈을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebd630669cc76942437803b1fb8107b3e2063e84" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">일부 functors 는 기본보다 더 효율적인 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 구현을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4e9bb325d8e94370ab23120a7426d9ee7ea2c654" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">일부 functors 는 기본보다 더 효율적인 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 구현을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="feddbc495dd6f9bc1a1874e911421fb2030f4453" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">일부 functors 는 기본보다 더 효율적인 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 구현을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="412108fee011dff2957aa26fc118a779db7cb3e1" translate="yes" xml:space="preserve">
          <source>A field must be in scope for the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint to be solved. This retains the existing representation hiding mechanism, whereby a module may choose not to export a field, preventing client modules from accessing or updating it directly.</source>
          <target state="translated">해당 &lt;code&gt;HasField&lt;/code&gt; 제약 조건을 해결 하려면 필드의 범위 내에 있어야합니다 . 이것은 기존의 표현 은닉 메커니즘을 유지하므로 모듈은 필드를 내 보내지 않기로 선택하여 클라이언트 모듈이 필드에 직접 액세스하거나 업데이트하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647667c77d993eaf0e249337caf2de0283b2f13c" translate="yes" xml:space="preserve">
          <source>A file created by the preprocessor.</source>
          <target state="translated">전처리기에 의해 생성 된 파일.</target>
        </trans-unit>
        <trans-unit id="10a6f21acebb16166b923fe8816f24879cac7dc7" translate="yes" xml:space="preserve">
          <source>A file descriptor registration cookie.</source>
          <target state="translated">파일 디스크립터 등록 쿠키.</target>
        </trans-unit>
        <trans-unit id="b7ff63f15803ad313bc70e86c0b9af3bd034d57c" translate="yes" xml:space="preserve">
          <source>A file that may be read or written, and also may be seekable.</source>
          <target state="translated">읽거나 쓸 수 있으며 검색 할 수있는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="3fc8729fc9cba21c227493e06ca57c42259f5fbc" translate="yes" xml:space="preserve">
          <source>A file-header pragma must precede the &lt;code&gt;module&lt;/code&gt; keyword in the file.</source>
          <target state="translated">파일 헤더 pragma는 파일에서 &lt;code&gt;module&lt;/code&gt; 키워드 앞에 와야 합니다.</target>
        </trans-unit>
        <trans-unit id="ee69f3557f209a70b6dbd3e30733ef3266ad45c4" translate="yes" xml:space="preserve">
          <source>A finalizer is not always called after its weak pointer's object becomes unreachable. There are two situations that can cause this:</source>
          <target state="translated">약한 포인터의 개체에 도달 할 수없는 경우 종료자가 항상 호출되는 것은 아닙니다. 이를 일으킬 수있는 두 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83751e185497b34efc04696de873a6948bad996" translate="yes" xml:space="preserve">
          <source>A finalizer is represented as a pointer to a foreign function that, at finalisation time, gets as an argument a plain pointer variant of the foreign pointer that the finalizer is associated with.</source>
          <target state="translated">종료자는 종료시에 종료 자와 연관된 외부 포인터의 일반 포인터 변형을 인수로 가져 오는 외부 함수에 대한 포인터로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1df6acc2d101561b7dc4207a365d517cbb075848" translate="yes" xml:space="preserve">
          <source>A fixed-precision integer type with at least the range &lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt;. The exact range for a given implementation can be determined by using &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt; 범위 이상인 고정밀도 정수 유형입니다 . 지정된 구현의 정확한 범위 는 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 를 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5c0b209d881b38e76f482af23564dfb8494b98b" translate="yes" xml:space="preserve">
          <source>A flag to disable Safe Haskell checks:</source>
          <target state="translated">Safe Haskell 검사를 비활성화하는 플래그 :</target>
        </trans-unit>
        <trans-unit id="5e83789a4d462ba5ff17578c25dbd53a56499d15" translate="yes" xml:space="preserve">
          <source>A flexible variation parameterised in a type constructor</source>
          <target state="translated">형식 생성자에서 매개 변수화 된 유연한 변형</target>
        </trans-unit>
        <trans-unit id="ae7acb61d64b5e1b08a76042f669d06cf246bf79" translate="yes" xml:space="preserve">
          <source>A fmap-like operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">경계 크기와 고정 크기의 빌더 기본 요소에 대한 fmap 유사 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="3156de946a16b219e4da74bb691b1f317bcde8a4" translate="yes" xml:space="preserve">
          <source>A frontend plugin allows you to add new major modes to GHC. You may prefer this over a traditional program which calls the GHC API, as GHC manages a lot of parsing flags and administrative nonsense which can be difficult to manage manually. To load a frontend plugin exported by &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt;, we just invoke GHC with the &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; flag as follows:</source>
          <target state="translated">프론트 엔드 플러그인을 사용하면 GHC에 새로운 주요 모드를 추가 할 수 있습니다. GHC는 수동으로 관리하기 어려울 수있는 많은 구문 분석 플래그 및 관리 비센스를 관리하기 때문에 GHC API를 호출하는 기존 프로그램보다이를 선호 할 수 있습니다. &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt; 에서 내 보낸 프론트 엔드 플러그인을로드하기 위해 다음과 같이 &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; 플래그를 사용하여 GHC를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a6ca1012af98c96815c71a4e1c588fc523445abe" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">함수는 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건으로 호출 사이트를 요청할 수 있습니다 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="85ce5ed93025fc855be629c4ba88fa8a1670bc1d" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">함수는 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 제약 조건으로 호출 사이트를 요청할 수 있습니다 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="b827823da9db0cd7f4da87d2bab81acb959e4419" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;HasCallStack&lt;/code&gt; constraint and access it as a Haskell value by using &lt;code&gt;callStack&lt;/code&gt;.</source>
          <target state="translated">함수가 호출하여 그 사이트를 요청할 수 &lt;code&gt;HasCallStack&lt;/code&gt; 의 제약 및이를 이용한 하스켈 값 액세스 &lt;code&gt;callStack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="959c41ee1afd55fc73fec6ad553ce55c337100e6" translate="yes" xml:space="preserve">
          <source>A function that accepts another &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. That string will be assumed to directly follow the string that was passed as input to the original function, and it will in turn be decoded.</source>
          <target state="translated">다른 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 허용하는 함수입니다 . 이 문자열은 원래 함수에 대한 입력으로 전달 된 문자열을 직접 따르는 것으로 가정하여 차례로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="146f819aeac6eebc6c002e437bb527a05441309a" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; and its computed value once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우고 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 와 계산 된 값 으로 연속을 호출 한 다음 호출자에게 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 신호를 사용하여 진행하는 방법을 알려주는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="f9fe9550377f39c1dda07402c3e5dd3c52deb055" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우고 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 사용 하여 연속을 호출 한 다음 호출자에게 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 사용 방법을 알리는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="9a1cfa6ac431e810bfaf7276b3ed3786ed71fd59" translate="yes" xml:space="preserve">
          <source>A function that peeks a field of a C struct will be output. It will have the type &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt;. The intention is that &lt;code&gt;#peek&lt;/code&gt; and &lt;code&gt;#poke&lt;/code&gt; can be used for implementing the operations of class &lt;code&gt;Storable&lt;/code&gt; for a given C struct (see the &lt;code&gt;Foreign.Storable&lt;/code&gt; module in the library documentation).</source>
          <target state="translated">C 구조체의 필드를 들여다 보는 함수가 출력됩니다. &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt; 유형이됩니다 . 의도 즉 &lt;code&gt;#peek&lt;/code&gt; 및 &lt;code&gt;#poke&lt;/code&gt; 는 클래스의 동작을 구현하기 위해 사용될 수있는 &lt;code&gt;Storable&lt;/code&gt; (투시 소정의 C 구조체를위한 &lt;code&gt;Foreign.Storable&lt;/code&gt; 라이브러리 설명서 모듈).</target>
        </trans-unit>
        <trans-unit id="d2ef8a015f90280c78a9e52d4eaee96c355e724d" translate="yes" xml:space="preserve">
          <source>A function to check if the current terminal uses MinTTY. Much of this code was originally authored by Phil Ruffwind and the git-for-windows project.</source>
          <target state="translated">현재 터미널이 MinTTY를 사용하는지 확인하는 기능입니다. 이 코드의 대부분은 원래 Phil Ruffwind와 git-for-windows 프로젝트에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="31ba468a5f0c3b9552cf7091416e0dd2026254a0" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &quot;Generalising Monads to Arrows&quot;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">카운터를 증가시키는 기능. 1998 년 11 월 , 논문 &quot;Johns to Monasers to Arrows&quot;, John Hughes ( &lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt; )에서 발췌 :</target>
        </trans-unit>
        <trans-unit id="05dac60b6df39a2cc430ba2715bb82eb9d50346b" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt;), November 1998:</source>
          <target state="translated">카운터를 증가시키는 기능. 1998 년 11 월 , 논문을 &lt;em&gt;모나드의 일반화에서 화살표로&lt;/em&gt; 가져 오기 , John Hughes ( &lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="cba486e1fb914bff3d0a304947268224d9af2b9a" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">카운터를 증가시키는 기능. 1998 년 11 월 , 논문을 &lt;em&gt;모나드를 모나스 화에서 화살표로&lt;/em&gt; 가져 오기 (John Hughes) ( &lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt; )에서 &lt;em&gt;발췌&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="407bdfca3acdcf3e83644e05bb20353353df0c81" translate="yes" xml:space="preserve">
          <source>A functor with application, providing operations to</source>
          <target state="translated">작업을 제공하는 응용 프로그램이있는 기능</target>
        </trans-unit>
        <trans-unit id="672c26b34e9f1b6a9e0ef2bedd270f00f9598669" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been finished.</source>
          <target state="translated">가비지 컬렉션 패스가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="74eb92ae3094b3fdb42750a32df490044fa7fa7c" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been started.</source>
          <target state="translated">가비지 콜렉션 패스가 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b56072e77298e15569c00276b7c0299340640ae" translate="yes" xml:space="preserve">
          <source>A general library for representation and manipulation of versions.</source>
          <target state="translated">버전의 표현과 조작을위한 일반적인 라이브러리.</target>
        </trans-unit>
        <trans-unit id="3bc20610754970931bb56e207d89ee27df2c440a" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="translated">의 일반화 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수는 , &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; 는 또한 요소의 인덱스에 따라 매핑 기능을 소요하고, 시퀀스의 모든 요소에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4ed89134d2ae1ba346467054c2cbd0888a87f736" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="translated">의 일반화 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수는 , &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; 는 또한 요소의 인덱스에 따라 매핑 기능을 소요하고, 시퀀스의 모든 요소에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="74b0bb9b6108641f8e5517af378b5cb49562a948" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; to an arbitrary &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;. May fail to terminate for some values in some semigroups.</source>
          <target state="translated">임의의 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 으로 &lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 일반화 . 일부 세미 그룹에서 일부 값이 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ff4b7505fb166fcbe7f642bd27c36a8063bf48" translate="yes" xml:space="preserve">
          <source>A generator with side-effects.</source>
          <target state="translated">부작용이있는 발전기.</target>
        </trans-unit>
        <trans-unit id="862450f7f65fc829d17b888581dcf9423b4a7480" translate="yes" xml:space="preserve">
          <source>A generator ⟨g⟩ &lt;em&gt;depends&lt;/em&gt; on a textually following generator ⟨g&amp;rsquo;⟩, if</source>
          <target state="translated">생성기 ⟨g⟩ 는 텍스트 다음 생성기 ⟨g'⟩에 &lt;em&gt;따라 다릅니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="62ae38d3598e1153af86caff741ce7f45b481a95" translate="yes" xml:space="preserve">
          <source>A generic function is defined by creating a class and giving instances for each of the representation types of &lt;code&gt;GHC.Generics&lt;/code&gt;. As an example we show generic serialization:</source>
          <target state="translated">일반 함수는 클래스를 작성하고 &lt;code&gt;GHC.Generics&lt;/code&gt; 의 각 표시 유형에 대한 인스턴스를 제공하여 정의됩니다 . 예를 들어 일반적인 직렬화를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1c195a4fb48a9a5e0bec2f551debfe0bebac3b3f" translate="yes" xml:space="preserve">
          <source>A generic monadic transformation that maps over the immediate subterms</source>
          <target state="translated">직계 하위 항을 매핑하는 일반 모나 딕 변환</target>
        </trans-unit>
        <trans-unit id="2371a81d45c2bb3b8a13c0d110026806d7062e4b" translate="yes" xml:space="preserve">
          <source>A generic query that processes one child by index (zero-based)</source>
          <target state="translated">인덱스별로 하나의 자식을 처리하는 일반 쿼리 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="b30dda47587e5c218c84c8765cbfb57d7c32ee07" translate="yes" xml:space="preserve">
          <source>A generic query that processes the immediate subterms and returns a list of results. The list is given in the same order as originally specified in the declaration of the data constructors.</source>
          <target state="translated">즉시 하위 용어를 처리하고 결과 목록을 반환하는 일반 쿼리입니다. 목록은 원래 데이터 생성자 선언에 지정된 순서대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="51d2a5deead9d5e63a49652af5db4d773df15f2a" translate="yes" xml:space="preserve">
          <source>A generic query with a left-associative binary operator</source>
          <target state="translated">왼쪽 연관 이진 연산자를 사용하는 일반 쿼리</target>
        </trans-unit>
        <trans-unit id="f172406f53434c2c85e3e88b3b734c76fe4cbf1f" translate="yes" xml:space="preserve">
          <source>A generic query with a right-associative binary operator</source>
          <target state="translated">오른쪽 연관 이진 연산자를 사용하는 일반 쿼리</target>
        </trans-unit>
        <trans-unit id="aa8f907ef342f61225b3aaaca537bb6131e08eed" translate="yes" xml:space="preserve">
          <source>A generic transformation that maps over the immediate subterms</source>
          <target state="translated">즉각적인 하위 용어를 매핑하는 일반 변환</target>
        </trans-unit>
        <trans-unit id="263bda9728b8670fff6c73f321e0c1114a53a098" translate="yes" xml:space="preserve">
          <source>A graph where the out-list references unspecified nodes (&lt;code&gt;'c'&lt;/code&gt;), these are ignored.</source>
          <target state="translated">외부 목록이 지정되지 않은 노드 ( &lt;code&gt;'c'&lt;/code&gt; )를 참조하는 그래프 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="547e608af651f4f8ae6ad4968c6a78fb1a5f9911" translate="yes" xml:space="preserve">
          <source>A graph with 3 vertices: (&quot;a&quot;) -&amp;gt; (&quot;b&quot;) -&amp;gt; (&quot;c&quot;)</source>
          <target state="translated">정점이 3 개인 그래프 : ( &quot;a&quot;)-&amp;gt; ( &quot;b&quot;)-&amp;gt; ( &quot;c&quot;)</target>
        </trans-unit>
        <trans-unit id="12b3806c7a4a6d3f01bcf0d2c455af966755af91" translate="yes" xml:space="preserve">
          <source>A group of implicit-parameter bindings may occur anywhere a normal group of Haskell bindings can occur, except at top level. That is, they can occur in a &lt;code&gt;let&lt;/code&gt; (including in a list comprehension, or do-notation, or pattern guards), or a &lt;code&gt;where&lt;/code&gt; clause. Note the following points:</source>
          <target state="translated">암시 적 매개 변수 바인딩 그룹은 최상위 레벨을 제외하고 일반 Haskell 바인딩 그룹이 발생할 수있는 모든 위치에서 발생할 수 있습니다. 즉, &lt;code&gt;let&lt;/code&gt; (목록 이해, do-notation 또는 pattern guard 포함) 또는 &lt;code&gt;where&lt;/code&gt; 절 에서 발생할 수 있습니다 . 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="65051f92e572963e4acdb9bb33b4d2b90e5a8b97" translate="yes" xml:space="preserve">
          <source>A handle managing input from the Haskell program's standard input channel.</source>
          <target state="translated">Haskell 프로그램의 표준 입력 채널에서 입력을 관리하는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="e751926f8fa8be7abe2938c68d0bde4c6028d510" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard error channel.</source>
          <target state="translated">Haskell 프로그램의 표준 오류 채널에 대한 출력을 관리하는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="2d2d9310b94785cb31fe1e4c863bde58a3090d7e" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard output channel.</source>
          <target state="translated">Haskell 프로그램의 표준 출력 채널로 출력을 관리하는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="d7a3e5b5484f784fade78cfdf6ff6413b1996492" translate="yes" xml:space="preserve">
          <source>A handle to a process, which can be used to wait for termination of the process using &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 사용하여 프로세스 종료를 기다리는 데 사용할 수있는 프로세스 핸들 .</target>
        </trans-unit>
        <trans-unit id="703580b3dc907bb3f23c64f76055da6a35b3d742" translate="yes" xml:space="preserve">
          <source>A handler for a decoding error.</source>
          <target state="translated">디코딩 오류 처리기.</target>
        </trans-unit>
        <trans-unit id="e5858ba1a84179526a85d088788e5ed04cd3ca67" translate="yes" xml:space="preserve">
          <source>A handler for an encoding error.</source>
          <target state="translated">인코딩 오류 처리기</target>
        </trans-unit>
        <trans-unit id="a61fb6766aecc9004ee1afd5c6ce82d376d98ad4" translate="yes" xml:space="preserve">
          <source>A handler function to handle previous errors and return to normal execution. A common idiom is:</source>
          <target state="translated">이전 오류를 처리하고 정상 실행으로 돌아가는 핸들러 함수입니다. 일반적인 관용구는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be659a8b5b88eca4628da85b8cd673c423ac389e" translate="yes" xml:space="preserve">
          <source>A heap object is &lt;em&gt;reachable&lt;/em&gt; if:</source>
          <target state="translated">다음과 같은 경우 힙 오브젝트에 &lt;em&gt;도달 할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea694877df8a08ed123b92ef6005435d0a5c6bc8" translate="yes" xml:space="preserve">
          <source>A heap residency census will follow. Since events may only be up to 2^16^ bytes in length a single sample may need to be split among multiple &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; events. The precise format of the census entries is determined by the break-down type.</source>
          <target state="translated">힙 거주 인구 조사가 이어집니다. 이벤트의 길이는 최대 2 ^ 16 ^ 바이트 일 수 있으므로 단일 샘플을 여러 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; 이벤트 로 분할해야 할 수도 있습니다. 인구 조사 항목의 정확한 형식은 분류 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f721eb8b4b3c875c9b3039562674d9428b85321c" translate="yes" xml:space="preserve">
          <source>A helper module that defines some language definitions that can be used to instantiate a token parser (see &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;).</source>
          <target state="translated">토큰 파서를 인스턴스화하는 데 사용할 수있는 일부 언어 정의를 정의하는 도우미 모듈입니다 ( &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="020709edaa36d2287275fd9547b133a13203df95" translate="yes" xml:space="preserve">
          <source>A helper module to parse &quot;expressions&quot;. Builds a parser given a table of operators and associativities.</source>
          <target state="translated">&quot;표현식&quot;을 구문 분석하는 도우미 모듈입니다. 연산자 및 연관성 테이블이 제공된 구문 분석기를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="150ba12f35ac6072514bd31b5f915a96dc42b4c6" translate="yes" xml:space="preserve">
          <source>A helper module to parse lexical elements (tokens). See &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; for a description of how to use it.</source>
          <target state="translated">어휘 요소 (토큰)를 구문 분석하는 도우미 모듈입니다. &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 에 대한 설명은 makeTokenParser 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0383b225a4de83038268fe176e36b5324f8b57bd" translate="yes" xml:space="preserve">
          <source>A hs-boot file is written in a subset of Haskell:</source>
          <target state="translated">hs-boot 파일은 Haskell의 하위 집합으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="beb39b13efdd6752b158de82a3a13e416589e21f" translate="yes" xml:space="preserve">
          <source>A hs-boot file need only contain the bare minimum of information needed to get the bootstrapping process started. For example, it doesn&amp;rsquo;t need to contain declarations for &lt;em&gt;everything&lt;/em&gt; that module &lt;code&gt;A&lt;/code&gt; exports, only the things required by the module(s) that import &lt;code&gt;A&lt;/code&gt; recursively.</source>
          <target state="translated">hs-boot 파일에는 부트 스트랩 프로세스를 시작하는 데 필요한 최소한의 정보 만 포함하면됩니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 모듈 이 내보내는 &lt;em&gt;모든 항목&lt;/em&gt; 에 대한 선언을 포함 할 필요는없고 &lt;code&gt;A&lt;/code&gt; 를 재귀 적으로 가져 오는 모듈에 필요한 것만 선언 하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c6d3cf5164d3e0790c51b498cf4792069b594e1" translate="yes" xml:space="preserve">
          <source>A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory. To take advantage of this you have to write your functions in a lazy streaming style, e.g. classic pipeline composition. The default I/O chunk size is 32k, which should be good in most circumstances.</source>
          <target state="translated">게으른 ByteStrings의 주요 기능은 전체 시퀀스가 ​​메모리에 상주하지 않아도 대규모 또는 무제한 데이터 스트림을 조작 할 수있는 수단입니다. 이를 활용하려면 클래식 파이프 라인 구성과 같은 게으른 스트리밍 스타일로 함수를 작성해야합니다. 기본 I / O 청크 크기는 32k이며 대부분의 환경에서 좋습니다.</target>
        </trans-unit>
        <trans-unit id="325a2bf823d17d06d93a99292962d2fd916a91fe" translate="yes" xml:space="preserve">
          <source>A key for &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;s that can be serialized and used with &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 핵심 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 의 직렬화와 함께 사용할 수 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="036affe5e2067ef8e5a7e25cb46bbfbf0c7d82cb" translate="yes" xml:space="preserve">
          <source>A kind signature is considered to be outermost regardless of redundant parentheses:</source>
          <target state="translated">종류 서명은 중복 괄호에 관계없이 가장 바깥쪽에있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b381dc7ee35453cc6200cb73ab6f7a29da015f" translate="yes" xml:space="preserve">
          <source>A kind variable can also be bound implicitly in a LHS type pattern, as in this example:</source>
          <target state="translated">이 예제에서와 같이 종류 변수는 LHS 유형 패턴에 내재적으로 바인딩 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed1bf023551f5e183a777d4ad8f17c745a4596e" translate="yes" xml:space="preserve">
          <source>A lazier version of Data.List.intersperse. The other version causes space leaks!</source>
          <target state="translated">Data.List.intersperse의 지연 버전. 다른 버전에서는 공간이 누출됩니다!</target>
        </trans-unit>
        <trans-unit id="54d1e3a19df5bd11488b091ae905ebe5fef9f311" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에는 8 비트 바이트가 포함되어 있거나 &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; 의 연산을 사용하여 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2fd64b80af2ff85d7158cad974f3b8d6d3fa1e" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에는 8 비트 바이트가 포함되어 있거나 &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; 의 연산을 사용하여 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f64b98de52b0b6fa53b16083b06816797fde862" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에는 8 비트 바이트가 포함되어 있거나 &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; 의 연산을 사용하여 8 비트 문자를 포함하는 것으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d0c3d1a9e330b475d899c85089d3a45d5191af" translate="yes" xml:space="preserve">
          <source>A leading (or &quot;high&quot;) surrogate code unit (0xD800&amp;ndash;0xDBFF) must always be followed by a trailing (or &quot;low&quot;) surrogate code unit (0xDC00-0xDFFF). A trailing surrogate code unit must always be preceded by a leading surrogate code unit.</source>
          <target state="translated">선행 (또는 &quot;높은&quot;) 서로 게이트 코드 단위 (0xD800&amp;ndash;0xDBFF) 뒤에 항상 후행 (또는 &quot;낮은&quot;) 서로 게이트 코드 단위 (0xDC00-0xDFFF)가 와야합니다. 후행 대리 코드 단위는 항상 선행 대리 코드 단위 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="49f7c0bc99a71677d388689dcc2d6ba4d8f6ecf2" translate="yes" xml:space="preserve">
          <source>A left fold over the elements</source>
          <target state="translated">요소의 왼쪽 접힘</target>
        </trans-unit>
        <trans-unit id="875903e7616532ab0681456be555fa6ab6806498" translate="yes" xml:space="preserve">
          <source>A left fold over the elements with no starting value</source>
          <target state="translated">시작 값이없는 요소의 왼쪽 접힘</target>
        </trans-unit>
        <trans-unit id="13379849e3da0988f874c759315290aea7600c73" translate="yes" xml:space="preserve">
          <source>A less contrived example shows the use of &lt;code&gt;cases&lt;/code&gt; instead of &lt;code&gt;lets&lt;/code&gt; to get stricter code (a good thing):</source>
          <target state="translated">덜 인위적인 예를 보여줍니다 사용 &lt;code&gt;cases&lt;/code&gt; 대신은 &lt;code&gt;lets&lt;/code&gt; 엄격한 코드 (좋은 것)를 얻을 수 :</target>
        </trans-unit>
        <trans-unit id="fd8adda1f5cdce432835cce105d7c84fdbd2dac1" translate="yes" xml:space="preserve">
          <source>A lexer for the haskell language.</source>
          <target state="translated">하스켈 언어의 어휘 분석기.</target>
        </trans-unit>
        <trans-unit id="6b7e5a3a0abc0bd6645cddccc0976a9582cc8903" translate="yes" xml:space="preserve">
          <source>A lexer for the mondrian language.</source>
          <target state="translated">몬드리안 언어의 어휘 분석기.</target>
        </trans-unit>
        <trans-unit id="1726ba2f885b524251e70e59cf6b4178dcd2f11f" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Posix style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">모든 플랫폼에서 Posix 스타일 경로를 사용 하는 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 조작을 위한 라이브러리 . &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath를&lt;/a&gt; 가져 오는 것이 일반적으로 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d22f4e61fa94ecb3258b9cf1c0bad6a5edb3b1fc" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Windows style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">모든 플랫폼에서 Windows 스타일 경로를 사용 하는 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 조작을 위한 라이브러리 . &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath를&lt;/a&gt; 가져 오는 것이 일반적으로 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b736f738e6fcd73b3f446e3ef506bfbfaf5591f3" translate="yes" xml:space="preserve">
          <source>A line recording the dependence of the object file on the source file.</source>
          <target state="translated">소스 파일에 대한 오브젝트 파일의 종속성을 기록하는 행.</target>
        </trans-unit>
        <trans-unit id="dc910a705047942aa6596ecdf81615bb378b5bf0" translate="yes" xml:space="preserve">
          <source>A list containing child cost-centre stacks.</source>
          <target state="translated">하위 비용 중심 스택이 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a5dad55926d22c2d61986b7de9e0d931acff5efa" translate="yes" xml:space="preserve">
          <source>A list of all known keys.</source>
          <target state="translated">알려진 모든 키 목록</target>
        </trans-unit>
        <trans-unit id="a068c69873917f77c92591cc3eed569ea30b4268" translate="yes" xml:space="preserve">
          <source>A list of all supported language extensions can be obtained by invoking &lt;code&gt;ghc --supported-extensions&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt;&lt;code&gt;--supported-extensions&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">지원되는 모든 언어 확장명 목록은 &lt;code&gt;ghc --supported-extensions&lt;/code&gt; 를 호출하여 얻을 수 있습니다 ( &lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt; &lt;code&gt;--supported-extensions&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9020f71c1c4e09df1fb37e8eb8a85e9c837975c2" translate="yes" xml:space="preserve">
          <source>A list of separate command line arguments to the program</source>
          <target state="translated">프로그램에 대한 별도의 명령 행 인수 목록</target>
        </trans-unit>
        <trans-unit id="5f31632c64a2a83d396013e71426f91b56565679" translate="yes" xml:space="preserve">
          <source>A list of the program&amp;rsquo;s cost centres</source>
          <target state="translated">프로그램 비용 센터 목록</target>
        </trans-unit>
        <trans-unit id="73940efd2676f199ed1ac86bfd84a3386d46652a" translate="yes" xml:space="preserve">
          <source>A list of zero or more usernames that are members (gr_mem)</source>
          <target state="translated">멤버 인 0 개 이상의 사용자 이름 목록 (gr_mem)</target>
        </trans-unit>
        <trans-unit id="bb14c26279814204dd8eba9acbc9f2cc037cda91" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 와 융합 될 수있는리스트 프로듀서 . 이 기능은 단지</target>
        </trans-unit>
        <trans-unit id="7609384306d65c392d73d1f946dd577e1543b1ed" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 와 융합 될 수있는리스트 프로듀서 . 이 기능은 단지</target>
        </trans-unit>
        <trans-unit id="3157123a0be7934993229fbac35bb2de4bfc150e" translate="yes" xml:space="preserve">
          <source>A literal POSIX file path</source>
          <target state="translated">리터럴 POSIX 파일 경로</target>
        </trans-unit>
        <trans-unit id="616e39ecf2bde53027e5f642d48b139e07322230" translate="yes" xml:space="preserve">
          <source>A local time together with a time zone.</source>
          <target state="translated">시간대와 함께 현지 시간.</target>
        </trans-unit>
        <trans-unit id="edcfe1b56e989ad66407f462968b76cf02bda336" translate="yes" xml:space="preserve">
          <source>A location in the original program source.</source>
          <target state="translated">원래 프로그램 소스의 위치</target>
        </trans-unit>
        <trans-unit id="8d5a785c724a8eba79d22f8cfdbe656e03ea3ef1" translate="yes" xml:space="preserve">
          <source>A log message from the runtime system.</source>
          <target state="translated">런타임 시스템의 로그 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="2cb40e6b7e0ea76eae404b014920691442447d08" translate="yes" xml:space="preserve">
          <source>A logically uninhabited data type, used to indicate that a given term should not exist.</source>
          <target state="translated">주어진 용어가 존재하지 않아야 함을 나타내는 데 사용되는 논리적으로 무인 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4fae0237e62dbac5cce6d600545ee02ceb780eef" translate="yes" xml:space="preserve">
          <source>A long GC sync can be caused by a mutator thread that is inside an &lt;code&gt;unsafe&lt;/code&gt; FFI call, or running in a loop that doesn&amp;rsquo;t allocate memory and so doesn&amp;rsquo;t yield. To fix the former, make the call &lt;code&gt;safe&lt;/code&gt;, and to fix the latter, either avoid calling the code in question or compile it with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fomit-yields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; FFI 호출 내에 있거나 메모리를 할당하지 않아 루프를 생성하지 않는 루프에서 실행 되는 뮤 테이터 스레드로 인해 긴 GC 동기화가 발생할 수 있습니다 . 전자를 고치려면 &lt;code&gt;safe&lt;/code&gt; 호출 을하고 후자를 고치려면 문제가되는 코드를 피하거나 &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fomit-yields&lt;/code&gt; 로&lt;/a&gt; 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="05cad06e7cb8bda737ea7d67ec36667703119c82" translate="yes" xml:space="preserve">
          <source>A low-level I/O provider where the data is bytes in memory.</source>
          <target state="translated">데이터가 메모리의 바이트 인 저수준 I / O 공급자.</target>
        </trans-unit>
        <trans-unit id="2c87eeefae8a2c24218a0a414358507070126796" translate="yes" xml:space="preserve">
          <source>A low-tech way: grep (search) your interface files for overloaded type signatures. You can view interface files using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option (see &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">최첨단 방법 : 오버로드 된 유형 서명에 대한 인터페이스 파일을 grep (검색)하십시오. &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 옵션을 사용하여 인터페이스 파일을 볼 수 있습니다 (인터페이스 파일 &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;관련 기타 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f6dadb395de3d2b9d69bc143f67ef70d410699b4" translate="yes" xml:space="preserve">
          <source>A lower-case identifier &lt;code&gt;foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;Main.foo&lt;/code&gt;.</source>
          <target state="translated">소문자 식별자 &lt;code&gt;foo&lt;/code&gt; 에 . GHC는 main 함수가 &lt;code&gt;Main.foo&lt;/code&gt; 라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="68062c83cacf82d9a90ab7e0cc7ea387cf2a996a" translate="yes" xml:space="preserve">
          <source>A map of integers to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;a&lt;/code&gt; 에 대한 정수 맵 .</target>
        </trans-unit>
        <trans-unit id="65d761f61d1d8b61018c0927736bc1f2164bec10" translate="yes" xml:space="preserve">
          <source>A masking character; e.g., &lt;code&gt;Just '*'&lt;/code&gt;</source>
          <target state="translated">마스킹 캐릭터; 예 : &lt;code&gt;Just '*'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec043ff4717214a6d38bc8fbb175d1fdb2e2c0b5" translate="yes" xml:space="preserve">
          <source>A maximal set of mutually reachable vertices.</source>
          <target state="translated">상호 도달 가능한 정점의 최대 집합.</target>
        </trans-unit>
        <trans-unit id="11966b51fe1d27560b215138baa79271c17219dd" translate="yes" xml:space="preserve">
          <source>A memory pool.</source>
          <target state="translated">메모리 풀.</target>
        </trans-unit>
        <trans-unit id="068781bc49acfb4cc274e15ab83d09598ea7b38a" translate="yes" xml:space="preserve">
          <source>A minimal &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; definition consists of either &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;. When defining more than this minimal set, one should ensure that the following identities hold:</source>
          <target state="translated">최소 &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; 정의는 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 로 구성됩니다 . 이 최소 세트 이상을 정의 할 때 다음 ID를 보유해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ca5616e71a7726aa5bd2663b7f524e751a256d8" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">최소한의 완전한 정의에는 &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 구현이 포함되어야합니다 . 둘 다 정의하면 기본 정의와 동일하게 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="c69118482cffeb2b76367b869803b6611f4079d3" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">최소한의 완전한 정의에는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 구현이 포함되어야합니다 . 둘 다 정의하면 기본 정의와 동일하게 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a11f1b1fc9f85e87f7328e93a0fe87efd1a62782" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">최소한의 완전한 정의에는 &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 구현이 포함되어야합니다 . 둘 다 정의하면 기본 정의와 동일하게 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8c72a19154aaf8d59b6b3ec9d5c79b6d054c147" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 의 미러 이미지입니다 .</target>
        </trans-unit>
        <trans-unit id="d9728f4924a2cece6cd9f3bd1f1fb2a3d7d63e51" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 의 미러 이미지입니다 .</target>
        </trans-unit>
        <trans-unit id="2014f989a9d241989c62fe055f679a0c74c7b1b5" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 의 미러 이미지입니다 .</target>
        </trans-unit>
        <trans-unit id="11fd433555f19114cd7accfaf208363211897740" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; 의 거울 이미지입니다 .</target>
        </trans-unit>
        <trans-unit id="b38d2272521d203ef9738b678b691090ceb2c2a7" translate="yes" xml:space="preserve">
          <source>A mode that determines the effect of &lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl mode i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl mode i&lt;/code&gt; 의 효과를 결정하는 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="5f6374097118c76813d909ba13b814c9cd41e81e" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; in a package &lt;code&gt;P&lt;/code&gt; is trusted by a client C if and only if:</source>
          <target state="translated">패키지 &lt;code&gt;P&lt;/code&gt; 의 모듈 &lt;code&gt;M&lt;/code&gt; 은 다음 과 같은 경우에만 클라이언트 C에 의해 신뢰됩니다.</target>
        </trans-unit>
        <trans-unit id="79f16cbaafdc9bfd2ba1ca22d71d2c674b761102" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s implementation is included in the final program.</source>
          <target state="translated">모듈의 &lt;code&gt;M&lt;/code&gt; 이다 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 프로그램에서 - 수입은 일반적으로 또한 일반적으로 다른 곳에서 가져옵니다. 그렇지 않은 경우, &lt;code&gt;ghc --make&lt;/code&gt; 자동으로 추가 &lt;code&gt;M&lt;/code&gt; 을 가하도록 컴파일 및 링크하려고 모듈의 집합 &lt;code&gt;M&lt;/code&gt; 의 구현은 최종 프로그램에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="987f7b14a3141b967b7850d7f7657d68e62459f9" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s implementation is included in the final program.</source>
          <target state="translated">모듈의 &lt;code&gt;M&lt;/code&gt; 이다 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 프로그램에서 - 수입은 일반적으로 또한 일반적으로 다른 곳에서 가져옵니다. 그렇지 않은 경우, &lt;code&gt;ghc --make&lt;/code&gt; 자동으로 추가 &lt;code&gt;M&lt;/code&gt; 을 가하도록 컴파일 및 링크하려고 모듈의 집합 &lt;code&gt;M&lt;/code&gt; 의 구현은 최종 프로그램에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="519fe32d3643ce1e03ac2bab30bb1bdcc52d189b" translate="yes" xml:space="preserve">
          <source>A module containing &lt;em&gt;unsafe&lt;/em&gt; operations, for &lt;em&gt;very very careful&lt;/em&gt; use in &lt;em&gt;heavily tested&lt;/em&gt; code.</source>
          <target state="translated">&lt;em&gt;심하게 테스트 된&lt;/em&gt; 코드 에서 &lt;em&gt;매우 신중하게&lt;/em&gt; 사용 하기 위해 &lt;em&gt;안전하지 않은&lt;/em&gt; 작업을 포함하는 모듈 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461ba4ff0cf5d9d0e690d1653b0296554ff09c30" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">개인 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 내부를 포함하는 모듈 . 이것은 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 표현과 저수준 구성 기능을 노출시킵니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 시스템 을 확장하는 모듈은이 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9355e89a95e098cf87e4b9b4d4b0c731bdb2c1ad" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">개인 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 내부를 포함하는 모듈 . 이것은 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 표현과 저수준 구성 기능을 노출시킵니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 시스템 을 확장하는 모듈은이 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6002f28ce7de42f2068e2f04b1e0c26f91c712e" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. As such all the functions in this module are unsafe. The API is also not stable.</source>
          <target state="translated">semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 내부를 포함하는 모듈 입니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 표현과 저수준 구성 함수를 노출시킵니다 . 따라서이 모듈의 모든 기능은 안전하지 않습니다. API도 안정적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bd1a012965931778304a7fe9b5fbe73d7d293aa" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; system will need to use this module while ideally most users will be able to make do with the public interface modules.</source>
          <target state="translated">semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 내부를 포함하는 모듈 입니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 표현과 저수준 구성 함수를 노출시킵니다 . &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 시스템 을 확장하는 모듈 은이 모듈을 사용해야하지만 대부분의 사용자는 공용 인터페이스 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23bf84d5c3edc452896e02cf0360a0e8d1e320af" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 작업을 포함하는 모듈 입니다.</target>
        </trans-unit>
        <trans-unit id="6d9f0c8a370cea074b5aff281e49729218f6c1e7" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; operations, for very very careful use in heavily tested code.</source>
          <target state="translated">심하게 테스트 된 코드에서 매우 신중하게 사용하기 위해 안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 작업을 포함하는 모듈 입니다.</target>
        </trans-unit>
        <trans-unit id="af7a45c55bc3dff94ebe92e041da9cd2e519eb81" translate="yes" xml:space="preserve">
          <source>A module implementing &lt;code&gt;A&lt;/code&gt; would have to export the function &lt;code&gt;double&lt;/code&gt; with a type definitionally equal to the signature. Note that this means you can&amp;rsquo;t implement &lt;code&gt;double&lt;/code&gt; using a polymorphic function &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">구현하는 모듈 &lt;code&gt;A&lt;/code&gt; 는 기능 수출 할 것이다 &lt;code&gt;double&lt;/code&gt; definitionally이 서명에 해당하는 유형을. 이것은 다형성 함수 &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt; 사용하여 &lt;code&gt;double&lt;/code&gt; 을 구현할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6705ee3245e4112a8338653bc894373bc0218c" translate="yes" xml:space="preserve">
          <source>A module name &lt;code&gt;A&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.main&lt;/code&gt;.</source>
          <target state="translated">모듈 이름 . GHC는 주 기능이 &lt;code&gt;A.main&lt;/code&gt; 이라고 가정합니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa8da0aa9a3feddea78d0a337a370d07af5012b" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="translated">모듈 수입 &lt;code&gt;MyNum(..)&lt;/code&gt; 로부터 &lt;code&gt;Example&lt;/code&gt; 다음과 다시 수출 &lt;code&gt;MyNum(..)&lt;/code&gt; 또한 임의의 패턴으로 번들 시노 내보내는 것이다 &lt;code&gt;MyNum&lt;/code&gt; 있는 &lt;code&gt;Example&lt;/code&gt; . 더 자세한 사양은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;위키&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46205c3964ea4b2def4e3d5de0a91193b170cf06" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="translated">모듈 수입 &lt;code&gt;MyNum(..)&lt;/code&gt; 로부터 &lt;code&gt;Example&lt;/code&gt; 다음과 다시 수출 &lt;code&gt;MyNum(..)&lt;/code&gt; 또한 임의의 패턴으로 번들 시노 내보내는 것이다 &lt;code&gt;MyNum&lt;/code&gt; 있는 &lt;code&gt;Example&lt;/code&gt; . 더 완전한 사양은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms&quot;&gt;위키&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11caca4dfe7a2e6647b187af096af9ce16cdb9c3" translate="yes" xml:space="preserve">
          <source>A monad containing an environment of type &lt;code&gt;r&lt;/code&gt;, output of type &lt;code&gt;w&lt;/code&gt; and an updatable state of type &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 유형의 환경 , &lt;code&gt;w&lt;/code&gt; 유형의 출력 및 &lt;code&gt;s&lt;/code&gt; 유형 의 업데이트 가능한 상태를 포함하는 모나드 .</target>
        </trans-unit>
        <trans-unit id="44b463ce5ac795e0357256636d6bb8abafd3b888" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 연산이 첫 번째 인수에서 &lt;em&gt;엄격한&lt;/em&gt; 경우 모나드는 &lt;em&gt;엄격&lt;/em&gt; 하다고합니다 . 기본 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="880b41c9b53dfefef049250c9c1a2e53c78a0d3b" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 연산이 첫 번째 인수에서 &lt;em&gt;엄격한&lt;/em&gt; 경우 모나드는 &lt;em&gt;엄격&lt;/em&gt; 하다고합니다 . 기본 모나드 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 는 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="77a2e0dd83579c01e51b5cfcae453a98e588af94" translate="yes" xml:space="preserve">
          <source>A monad supporting atomic memory transactions.</source>
          <target state="translated">원자 메모리 트랜잭션을 지원하는 모나드.</target>
        </trans-unit>
        <trans-unit id="84ed5327cac92c7ef6e8588da5238de45965557c" translate="yes" xml:space="preserve">
          <source>A monad that can execute GHCi statements by lifting them out of m into the IO monad. (e.g state monads)</source>
          <target state="translated">GHCi 명령문을 m에서 IO 모나드로 들어 올려 실행할 수있는 모나드. (예 : 주 모나드)</target>
        </trans-unit>
        <trans-unit id="2d83f98faa29021325e93148f624ac116d49fdd7" translate="yes" xml:space="preserve">
          <source>A monad that doesn't allow any IO.</source>
          <target state="translated">IO를 허용하지 않는 모나드.</target>
        </trans-unit>
        <trans-unit id="475de8d1c4ced9051885211b80d0128a644d0a1b" translate="yes" xml:space="preserve">
          <source>A monad transformer adding reading an environment of type &lt;code&gt;r&lt;/code&gt;, collecting an output of type &lt;code&gt;w&lt;/code&gt; and updating a state of type &lt;code&gt;s&lt;/code&gt; to an inner monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 유형의 환경을 읽고 &lt;code&gt;w&lt;/code&gt; 유형의 출력을 수집하고 &lt;code&gt;s&lt;/code&gt; 유형 의 상태를 내부 모나드 &lt;code&gt;m&lt;/code&gt; 으로 업데이트하는 모나드 변환기 .</target>
        </trans-unit>
        <trans-unit id="ec0442bcbea355903251a46fae40d37d907ac64e" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에 게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 를 내장 한 모나드 변압기 . &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 의 매개 변수는에 의해 사용되는 내부 상태를 나타냅니다 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산이 특정에 의해 제공된 하나 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드과의 호출에 의해 사용되는 것과 별개 따라서 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a5486c71e41350dc1ca87d78fb4f0bce729afa" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에 게으른 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 를 내장 한 모나드 변압기 . &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 의 매개 변수는에 의해 사용되는 내부 상태를 나타냅니다 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 계산이 특정에 의해 제공된 하나 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드과의 호출에 의해 사용되는 것과 별개 따라서 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601b40dc8531d619de3d6e429600341c4287841e" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="translated">모나드 변환기는 기존 모나드에서 새 모나드를 만들어 기존 모나드의 계산이 새 모나드에 포함될 수 있습니다. 원하는 기능 세트로 모나드를 구성하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 와 같은 기본 모나드로 시작 하여 일련의 모나드 변환기를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b365f46b9cfdefb11fdd9add50d3c78cbda728a5" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="translated">모나드 변환기는 기존 모나드에서 새 모나드를 만들어 이전 모나드의 계산이 새 모나드에 포함될 수 있습니다. 원하는 기능 세트로 모나드를 구성하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 와 같은 기본 모나드로 시작합니다. 하고 일련의 모나드 변환기를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0f7cb8e57886d5e86aabfd267501ad0211c3d9f3" translate="yes" xml:space="preserve">
          <source>A monad transformer that adds exceptions to other monads.</source>
          <target state="translated">다른 모나드에 예외를 추가하는 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="6426c40e7452ced39d0234fd45fc21a33bd3cc41" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is lazy; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; 및 &lt;code&gt;StateT&lt;/code&gt; 를 결합한 모나드 변환기입니다 . 이 버전은 게으르다. 거의 동일한 인터페이스를 가진 고정 공간 버전은 &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2547fe70b78fa47777714df77c0add427abe3628" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is strict; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; 및 &lt;code&gt;StateT&lt;/code&gt; 를 결합한 모나드 변환기입니다 . 이 버전은 엄격합니다. 인터페이스가 동일한 게으른 버전은 &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy를&lt;/a&gt; 참조하십시오 . 출력이 엄격하게 구축되었지만이 트랜스포머로 일정한 공간 동작을 달성 할 수는 없습니다 . 대신 &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a2ee9baf8f5856a19298f4db328fc74a1d39bd" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version uses continuation-passing-style for the writer part to achieve constant space usage. For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; , &lt;code&gt;WriterT&lt;/code&gt; 및 &lt;code&gt;StateT&lt;/code&gt; 를 결합한 모나드 변환기입니다 . 이 버전은 연속 공간 사용을 달성하기 위해 작성기 부분에 연속 전달 스타일을 사용합니다. 동일한 인터페이스의 게으른 버전은 &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="500a320bcd121d2c8283ae8852b2515080dcee31" translate="yes" xml:space="preserve">
          <source>A monad transformer which carries all of the state and settings relevant to a line-reading application.</source>
          <target state="translated">라인 판독 애플리케이션과 관련된 모든 상태 및 설정을 전달하는 모나드 변압기.</target>
        </trans-unit>
        <trans-unit id="f7f92818234c049ae409685d4444b37152111dc8" translate="yes" xml:space="preserve">
          <source>A monoid on applicative functors.</source>
          <target state="translated">적용 펑터에 대한 단일체.</target>
        </trans-unit>
        <trans-unit id="fe60158aa8a2b3958c4da9fb0fee916548d774b6" translate="yes" xml:space="preserve">
          <source>A monoid on arrows.</source>
          <target state="translated">화살표의 모노 이드.</target>
        </trans-unit>
        <trans-unit id="5845b618bce8288ed7fd6ae679531f4a7a5b077f" translate="yes" xml:space="preserve">
          <source>A more precise specification is as follows. The willingness to be overlapped or incoherent is a property of the &lt;em&gt;instance declaration&lt;/em&gt; itself, controlled as follows:</source>
          <target state="translated">보다 정확한 사양은 다음과 같습니다. 중복되거나 일관성이없는 의사는 &lt;em&gt;인스턴스 선언&lt;/em&gt; 자체 의 속성 으로 다음과 같이 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e63911e5dfc97bc3c592219078a690d8ed2ff3" translate="yes" xml:space="preserve">
          <source>A mutable array of bytes that can be passed to foreign functions.</source>
          <target state="translated">외부 함수에 전달할 수있는 가변 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="aaaa00796670cca26a60ac72f4e07d8b337ab183" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드 에서 조작 할 수있는 언 박스 요소가 포함 된 가변 배열 . 형식 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3387c300ae3f8914517cc0cd6aa9b1be1561eb1a" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 에서 조작 할 수있는 unboxed 요소가있는 가변 배열 모나드 . 유형 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6994baa9908c386c8aa2378b6690cc491d3b838a" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 의 가변 변수</target>
        </trans-unit>
        <trans-unit id="86d8cb4c41428c71956a58b3affc3d3a67e5a624" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 가변 변수 모나드</target>
        </trans-unit>
        <trans-unit id="985e8387b10ebbbd6e5ab332eab6588b350aa36d" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 의 가변 변수</target>
        </trans-unit>
        <trans-unit id="a954d6c35420d409169ad1a91fbdf2cc6fa8fd09" translate="yes" xml:space="preserve">
          <source>A name can be quoted with either one or two prefix single quotes:</source>
          <target state="translated">하나 또는 두 개의 접두사 작은 따옴표로 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eac8d924312d7747867fd052a0984825adb6ab0" translate="yes" xml:space="preserve">
          <source>A name whose second character is a single quote (sadly) cannot be quoted in this way, because it will be parsed instead as a quoted character. For example, if the function is called &lt;code&gt;f'7&lt;/code&gt; (which is a legal Haskell identifier), an attempt to quote it as &lt;code&gt;'f'7&lt;/code&gt; would be parsed as the character literal &lt;code&gt;'f'&lt;/code&gt; followed by the numeric literal &lt;code&gt;7&lt;/code&gt;. There is no current escape mechanism in this (unusual) situation.</source>
          <target state="translated">두 번째 문자가 작은 따옴표 (슬프게도) 인 이름은 인용 된 문자로 구문 분석되므로이 방법으로 인용 할 수 없습니다. 예를 들어, 함수가 &lt;code&gt;f'7&lt;/code&gt; (적법한 Haskell 식별자) 인 경우 &lt;code&gt;'f'7&lt;/code&gt; 로 인용하려고 하면 문자 리터럴 &lt;code&gt;'f'&lt;/code&gt; 와 숫자 리터럴 &lt;code&gt;7&lt;/code&gt; 로 구문 분석됩니다 . 이 (비정상적인) 상황에는 현재 탈출 장치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f16e7f677a6d8e62b9e97a39d3de36debfc79cc" translate="yes" xml:space="preserve">
          <source>A name's package, if it exists.</source>
          <target state="translated">존재하는 경우 이름 패키지.</target>
        </trans-unit>
        <trans-unit id="7598a3dc426907ef37ba1a8eb3a99bc5a30b0e87" translate="yes" xml:space="preserve">
          <source>A new chunk of heap has been allocated by the indicated capability set.</source>
          <target state="translated">표시된 기능 세트에 의해 새 힙 청크가 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="6919dce57a8f508bed2b02c9c8ad2d961f4e47dd" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1adb02601e1d9275c9a9312a596d444889d03e7a" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; 의 즉시 함수가 반환, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어, 또는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내용으로 가득했습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ccd9ca2458eb3a684692c3f8141733d7490bf75" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 의 즉시 함수가 반환, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어, 또는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e55cff29c2c9733e10c5a0b338cfcec2b5ad75a2" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="206f440a2076bebff809698fc93d8fc54da5d7ab" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; 의 즉시 함수가 반환, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어, 또는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내용으로 가득했습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c36e2f146526d2510dab34b468a2981631693ee" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 의 즉시 함수가 반환, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어, 또는 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2569960f87e4b3b548288102fd577f9229d2fab8" translate="yes" xml:space="preserve">
          <source>A non-indexed type representation.</source>
          <target state="translated">색인화되지 않은 유형 표현입니다.</target>
        </trans-unit>
        <trans-unit id="e9d1290f4bd898d7ad62e94e9d30ceb6655bd011" translate="yes" xml:space="preserve">
          <source>A non-inlined version of &lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 않은 인라인 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="7f03b8899bb7d9e29bd30f804a030dd4fd076a1a" translate="yes" xml:space="preserve">
          <source>A note on evaluation order: the expression &lt;code&gt;seq a b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; guarantee that &lt;code&gt;a&lt;/code&gt; will be evaluated before &lt;code&gt;b&lt;/code&gt;. The only guarantee given by &lt;code&gt;seq&lt;/code&gt; is that the both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be evaluated before &lt;code&gt;seq&lt;/code&gt; returns a value. In particular, this means that &lt;code&gt;b&lt;/code&gt; may be evaluated before &lt;code&gt;a&lt;/code&gt;. If you need to guarantee a specific order of evaluation, you must use the function &lt;code&gt;pseq&lt;/code&gt; from the &quot;parallel&quot; package.</source>
          <target state="translated">평가 순서에 대한 참고 사항 : &lt;code&gt;seq a b&lt;/code&gt; 표현 은 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 보다 먼저 평가 될 것이라고 보장 하지 &lt;em&gt;않습니다&lt;/em&gt; . 주어진 유일한 보증 &lt;code&gt;seq&lt;/code&gt; 둘 다이다 와 &lt;code&gt;b&lt;/code&gt; 는 전에 평가됩니다 &lt;code&gt;seq&lt;/code&gt; 값을 반환합니다. 특히, 수단 &lt;code&gt;b&lt;/code&gt; 이전에 평가 될 수있다 . 특정 평가 순서를 보장해야하는 경우 &quot;병렬&quot;패키지의 &lt;code&gt;pseq&lt;/code&gt; 함수를 사용해야합니다 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c16b58b80137c1a8cc002192b71e052aeb6a9ce" translate="yes" xml:space="preserve">
          <source>A number of restrictions apply to use of annotations:</source>
          <target state="translated">주석 사용에는 여러 가지 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="711bb74ca36d3d4c1868e4f33ea8af8c9700a708" translate="yes" xml:space="preserve">
          <source>A package database is where the details about installed packages are stored. It is a directory, usually called &lt;code&gt;package.conf.d&lt;/code&gt;, that contains a file for each package, together with a binary cache of the package data in the file &lt;code&gt;package.cache&lt;/code&gt;. Normally you won&amp;rsquo;t need to look at or modify the contents of a package database directly; all management of package databases can be done through the &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">패키지 데이터베이스는 설치된 패키지에 대한 세부 정보가 저장되는 곳입니다. 일반적으로 &lt;code&gt;package.conf.d&lt;/code&gt; 라고하는 디렉토리는 package.cache 파일에있는 패키지 데이터의 이진 캐시와 함께 각 패키지에 대한 파일을 포함 &lt;code&gt;package.cache&lt;/code&gt; . 일반적으로 패키지 데이터베이스의 내용을 직접 보거나 수정할 필요가 없습니다. 패키지 데이터베이스의 모든 관리는 &lt;strong&gt;ghc-pkg&lt;/strong&gt; 도구를 통해 수행 할 수 있습니다 ( &lt;a href=&quot;#package-management&quot;&gt;패키지 관리 (ghc-pkg 명령) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6482c111ff88fbc29ede2ddeea4102525681832" translate="yes" xml:space="preserve">
          <source>A package description consists of a number of field/value pairs. A field starts with the field name in the left-hand column followed by a &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo;, and the value continues until the next line that begins in the left-hand column, or the end of file.</source>
          <target state="translated">패키지 설명은 여러 필드 / 값 쌍으로 구성됩니다. 필드는 왼쪽 열의 필드 이름으로 시작하고 그 뒤에&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo;가 오며, 왼쪽 열에서 시작하는 다음 행 또는 파일 끝까지 값이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f0d41efbca1f6d8a23338adade26a83c1583e8be" translate="yes" xml:space="preserve">
          <source>A package is a library of Haskell modules known to the compiler. GHC comes with several packages: see the accompanying &lt;a href=&quot;../libraries/index&quot;&gt;library documentation&lt;/a&gt;. More packages to install can be obtained from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;.</source>
          <target state="translated">패키지는 컴파일러에 알려진 Haskell 모듈 라이브러리입니다. GHC에는 여러 패키지가 함께 제공됩니다 . 함께 제공되는 &lt;a href=&quot;../libraries/index&quot;&gt;라이브러리 설명서를&lt;/a&gt; 참조하십시오 . 설치할 추가 패키지는 &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3dbde045ae446b9fd85968f7cfc7dbefc9f7710" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="translated">패키지 사양은 Haskell 레코드입니다. 특히 &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; 레코드입니다. GHC으로 분산 카발 패키지의 일부 모듈 Distribution.InstalledPackageInfo에서이.</target>
        </trans-unit>
        <trans-unit id="c877a3844ef3dc7d9601200a6497a731da7b2b16" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="translated">패키지 사양은 Haskell 레코드입니다. 특히, 이는 &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo&lt;/a&gt; 모듈의 Distribution.InstalledPackageInfo.InstalledPackageInfo 레코드입니다 . 이는 GHC와 함께 배포 된 Cabal 패키지의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="8d7ab63973f7143650edb4489cbabd9755f0dae2" translate="yes" xml:space="preserve">
          <source>A pair of an open type family equations is checked by attempting to unify their RHSs. If the RHSs don&amp;rsquo;t unify this pair does not violate injectivity annotation. If unification succeeds with a substitution then LHSs of unified equations must be identical under that substitution. If they are not identical then GHC reports that the type family is not injective.</source>
          <target state="translated">RHS를 통합하여 개방형 패밀리 방정식 쌍을 확인합니다. RHS가 통일하지 않으면이 쌍이 주입 주석을 위반하지 않습니다. 통일이 치환으로 성공하면, 그 치환 하에서 통일 방정식의 LHS는 동일해야합니다. 이들이 동일하지 않은 경우 GHC는 유형 군이 주사제가 아니라고보고합니다.</target>
        </trans-unit>
        <trans-unit id="84d2773400375ccf44e88b72599837fd03633672" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with both a key and the original position of its elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 에 사용하기 위해 키와 해당 요소의 원래 위치로 태그가 지정된 페어링 힙 .</target>
        </trans-unit>
        <trans-unit id="2dd62e14bc9431464958571d2b435d03d28b2f82" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with some key for sorting elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 에서 사용하기 위해 요소 정렬을 위해 일부 키로 태그가 지정된 페어링 힙 .</target>
        </trans-unit>
        <trans-unit id="08959b3dc19b34612dd713a20c89a35536c5c8b1" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with the original position of elements, to allow for stable sorting.</source>
          <target state="translated">안정적인 정렬을 위해 요소의 원래 위치로 태그가 지정된 페어링 힙.</target>
        </trans-unit>
        <trans-unit id="179683aea0f779b8d62f71ce768d02e25c23258e" translate="yes" xml:space="preserve">
          <source>A pairing/concatenation operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">경계 크기와 고정 크기의 빌더 기본 요소에 대한 페어링 / 연결 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="a9abb3b7589ecd20d1d2b93e90cc7db6542915ba" translate="yes" xml:space="preserve">
          <source>A parallel garbage collection has been requested by a capability.</source>
          <target state="translated">기능에 의해 병렬 가비지 콜렉션이 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b720794f2dd0a7c18f79f3dbbf604879cd4d39c" translate="yes" xml:space="preserve">
          <source>A parallel list comprehension has multiple independent branches of qualifier lists, each separated by a &lt;code&gt;|&lt;/code&gt; symbol. For example, the following zips together two lists:</source>
          <target state="translated">병렬 목록 이해에는 여러 개의 한정자 목록 분기가 있으며 각각은 &lt;code&gt;|&lt;/code&gt; 상징. 예를 들어, 다음은 두 목록을 함께 압축합니다.</target>
        </trans-unit>
        <trans-unit id="3fb86b841f661b45cc569b86782f61f203ff3263" translate="yes" xml:space="preserve">
          <source>A parameter to specify the number of lines affected. Some capabilities (e.g., &lt;code&gt;clear&lt;/code&gt; and &lt;code&gt;dch1&lt;/code&gt;) use this parameter on some terminals to compute variable-length padding.</source>
          <target state="translated">영향을받는 줄 수를 지정하는 매개 변수입니다. 일부 기능 (예 : &lt;code&gt;clear&lt;/code&gt; 및 &lt;code&gt;dch1&lt;/code&gt; )은 일부 터미널에서이 매개 변수를 사용하여 가변 길이 패딩을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3c7816b5381405514fd134ab41157f7a1b19dbb1" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 에 대한 파서 는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 취하고 가능한 구문 분석 목록을 &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; 쌍 으로 리턴하는 함수로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ef40a705741b0fa0c05e60da025feb810b08af8" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 에 대한 파서 는 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 취하고 가능한 구문 분석 목록을 &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; 쌍 으로 리턴하는 함수로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="77e31a3f5862591f06987b3fcab3d8cc7ae35a42" translate="yes" xml:space="preserve">
          <source>A parser for versions in the format produced by &lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt; 에서 생성 한 형식의 버전에 대한 파서입니다 .</target>
        </trans-unit>
        <trans-unit id="00189f74465df92aa0eb7c3be6fb9e5d018cbddf" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders called &lt;em&gt;wildcards&lt;/em&gt;. A wildcard is written as an underscore (e.g. &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;) or, if &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; is enabled, any identifier with a leading underscore (e.g. &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;). Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="translated">부분 형식 서명은 &lt;em&gt;와일드 카드&lt;/em&gt; 라는 특수 자리 표시자를 포함하는 형식 서명 입니다. 와일드 카드는 밑줄 (예 :&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;) 또는 &lt;a href=&quot;#extension-NamedWildCards&quot;&gt; &lt;code&gt;NamedWildCards&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 선행 밑줄이있는 식별자 (예 :&amp;ldquo; &lt;code&gt;_foo&lt;/code&gt; &amp;rdquo;,&amp;ldquo; &lt;code&gt;_bar&lt;/code&gt; &amp;rdquo;)로 작성됩니다. 부분 형식 서명은 &lt;a href=&quot;#typed-holes&quot;&gt;형식화 된 구멍&lt;/a&gt; 이 식에 있는 형식 서명 입니다. 컴파일 중에 이러한 와일드 카드 또는 구멍은 구멍 위치에서 어떤 유형이 유추되었는지 설명하는 오류 메시지와 자유 유형 변수의 출처에 대한 정보를 생성합니다. GHC는 기본적으로 이러한 오류 메시지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8d8d03f9fe4fb54a82d09df64d310f7a60062a82" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;) called &lt;em&gt;wildcards&lt;/em&gt;. Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="translated">부분 형식 서명은 &lt;em&gt;와일드 카드&lt;/em&gt; 라고 하는 밑줄 (예 : &quot; &lt;code&gt;_&lt;/code&gt; &quot;, &quot; &lt;code&gt;_foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;_bar&lt;/code&gt; &quot;)로 작성된 특수 자리 표시자를 포함하는 형식 서명 입니다. 부분 유형 서명은 유형이 &lt;a href=&quot;#typed-holes&quot;&gt;지정된 구멍&lt;/a&gt; 이 표현식에 대한 서명을 입력하는 것 입니다. 컴파일 중에 이러한 와일드 카드 또는 구멍은 구멍 위치에서 유추 된 유형과 사용 가능한 유형 변수의 출처에 대한 정보를 설명하는 오류 메시지를 생성합니다. GHC는 기본적으로 이러한 오류 메시지를보고합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ce90625442120850b40e55bce20778556220c5e" translate="yes" xml:space="preserve">
          <source>A pattern</source>
          <target state="translated">패턴</target>
        </trans-unit>
        <trans-unit id="433fae1ea61aa93f2a83f57ff1684a275dd099f0" translate="yes" xml:space="preserve">
          <source>A pattern match failed. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the pattern.</source>
          <target state="translated">패턴 일치에 실패했습니다. &lt;code&gt;String&lt;/code&gt; 패턴의 소스 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="252b18a2db7ed609ee5f049df36aa764455492be" translate="yes" xml:space="preserve">
          <source>A pattern quasiquoter &lt;em&gt;may&lt;/em&gt; generate binders that scope over the right-hand side of a definition because these binders are in scope lexically. For example, given a quasiquoter &lt;code&gt;haskell&lt;/code&gt; that parses Haskell, in the following code, the &lt;code&gt;y&lt;/code&gt; in the right-hand side of &lt;code&gt;f&lt;/code&gt; refers to the &lt;code&gt;y&lt;/code&gt; bound by the &lt;code&gt;haskell&lt;/code&gt; pattern quasiquoter, &lt;em&gt;not&lt;/em&gt; the top-level &lt;code&gt;y = 7&lt;/code&gt;.</source>
          <target state="translated">패턴 준 따옴표 &lt;em&gt;는&lt;/em&gt; 정의의 오른쪽에 걸쳐있는 바인더를 생성 &lt;em&gt;할 수&lt;/em&gt; 있는데,이 바인더는 어휘 범위에 있기 때문입니다. 예를 들어, quasiquoter의 주어진 &lt;code&gt;haskell&lt;/code&gt; 하스켈 파싱 다음 코드에서 &lt;code&gt;y&lt;/code&gt; 의 오른쪽에서 &lt;code&gt;f&lt;/code&gt; 받는 지칭 &lt;code&gt;y&lt;/code&gt; 의해 결합 &lt;code&gt;haskell&lt;/code&gt; 패턴 quasiquoter, &lt;em&gt;하지&lt;/em&gt; 최상위 &lt;code&gt;y = 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac55497c2a5f3f9d1f6ff0844f5381d5d90653d" translate="yes" xml:space="preserve">
          <source>A pattern synonym</source>
          <target state="translated">패턴 동의어</target>
        </trans-unit>
        <trans-unit id="b17af7c644158ae7e89b62cef1f1583e8c015c62" translate="yes" xml:space="preserve">
          <source>A pattern synonym declaration can be either unidirectional, bidirectional or explicitly bidirectional. The syntax for unidirectional pattern synonyms is:</source>
          <target state="translated">패턴 동의어 선언은 단방향, 양방향 또는 명시 적으로 양방향 일 수 있습니다. 단방향 패턴 동의어의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55cb5ca64df4e9f9ca70699a5130d9563eece58c" translate="yes" xml:space="preserve">
          <source>A pattern synonym occurrence in a pattern is evaluated by first matching against the pattern synonym itself, and then on the argument patterns.</source>
          <target state="translated">패턴에서 패턴 동의어 발생은 먼저 패턴 동의어 자체와 일치 한 다음 인수 패턴에서 일치시켜 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6a294e72d5a00c5790ab20aeadfe0fb6770ada67" translate="yes" xml:space="preserve">
          <source>A pattern synonym's argument type.</source>
          <target state="translated">패턴 동의어의 인수 유형</target>
        </trans-unit>
        <trans-unit id="cc5e6ef416da30039d54dd764052a16e266e5fba" translate="yes" xml:space="preserve">
          <source>A pattern synonym's directionality.</source>
          <target state="translated">패턴 동의어의 방향성.</target>
        </trans-unit>
        <trans-unit id="dbbd0987654018a69ab48de461e219d56cbd0973" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type signature.</source>
          <target state="translated">패턴 동의어의 유형 서명입니다.</target>
        </trans-unit>
        <trans-unit id="57cf5046220efabc22f8328901a49323d7f92001" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type. Note that a pattern synonym's &lt;em&gt;fully&lt;/em&gt; specified type has a peculiar shape coming with two forall quantifiers and two constraint contexts. For example, consider the pattern synonym</source>
          <target state="translated">패턴 동의어 유형입니다. 패턴 동의어의 &lt;em&gt;완전히&lt;/em&gt; 지정된 유형은 두 개의 모든 수량 화기와 두 개의 제한 컨텍스트와 함께 고유 한 모양을 갖습니다. 예를 들어 패턴 동의어를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="eb6f155dcdcf6384b306398b26156bf38f28d6e1" translate="yes" xml:space="preserve">
          <source>A pattern type signature (&lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;)</source>
          <target state="translated">패턴 유형 서명 ( &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a7c69d52227bddae63e60e9734e227c6257070e0" translate="yes" xml:space="preserve">
          <source>A pattern variable may optionally have a type signature. If the type of the pattern variable is polymorphic, it &lt;em&gt;must&lt;/em&gt; have a type signature. For example, here is the &lt;code&gt;foldr/build&lt;/code&gt; rule:</source>
          <target state="translated">패턴 변수는 선택적으로 유형 서명을 가질 수 있습니다. 패턴 변수의 유형이 다형성 인 경우 유형 서명이 &lt;em&gt;있어야합니다&lt;/em&gt; . 예를 들어, 다음은 &lt;code&gt;foldr/build&lt;/code&gt; 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="0a9bf5dd0f5b938cd3b48a5e6e85a85c3767d1a0" translate="yes" xml:space="preserve">
          <source>A pattern with a bang at the outermost level is not allowed at the top level of a module.</source>
          <target state="translated">모듈의 최상위 레벨에서는 가장 바깥쪽에 뱅이있는 패턴을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a45544682b3f8a207a4592a867670905952dce9d" translate="yes" xml:space="preserve">
          <source>A periodic reporting of various statistics of spark evaluation.</source>
          <target state="translated">스파크 평가의 다양한 통계를 주기적으로보고합니다.</target>
        </trans-unit>
        <trans-unit id="9808c24500197f32f662437a4166807e09da1b17" translate="yes" xml:space="preserve">
          <source>A permutation phrase is a sequence of elements (possibly of different types) in which each element occurs exactly once and the order is irrelevant. Some of the permutable elements may be optional.</source>
          <target state="translated">순열 구는 각 요소가 정확히 한 번만 발생하고 순서가 관련이없는 일련의 요소 (다른 유형일 수 있음)입니다. 변경 가능한 요소 중 일부는 선택 사항 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbcb4942ca58cf7831c96fb91a0838412cc4bba" translate="yes" xml:space="preserve">
          <source>A pinned byte array is one that the garbage collector is not allowed to move. Consequently, it has a stable address that can be safely requested with &lt;code&gt;byteArrayContents#&lt;/code&gt;. There are a handful of primitive functions in GHC.Prim &amp;lt;GHC-Prim.html&amp;gt; used to enforce or check for pinnedness: &lt;code&gt;isByteArrayPinned#&lt;/code&gt;, &lt;code&gt;isMutableByteArrayPinned#&lt;/code&gt;, and &lt;code&gt;newPinnedByteArray#&lt;/code&gt;. A byte array can be pinned as a result of three possible causes:</source>
          <target state="translated">고정 된 바이트 배열은 가비지 수집기가 이동할 수없는 배열입니다. 따라서 &lt;code&gt;byteArrayContents#&lt;/code&gt; 로 안전하게 요청할 수있는 안정적인 주소를 갖게 됩니다. GHC.Prim &amp;lt;GHC-Prim.html&amp;gt;에는 고 정성을 적용하거나 확인하는 데 사용되는 몇 가지 기본 함수가 있습니다 : &lt;code&gt;isByteArrayPinned#&lt;/code&gt; , &lt;code&gt;isMutableByteArrayPinned#&lt;/code&gt; 및 &lt;code&gt;newPinnedByteArray#&lt;/code&gt; . 바이트 배열은 다음 세 가지 가능한 원인의 결과로 고정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d2f58da1fb581a9ce7c0820def592bde3a97f6" translate="yes" xml:space="preserve">
          <source>A plugin which declares itself impure using &lt;code&gt;ForceRecompile&lt;/code&gt; will always trigger a recompilation of the current module. &lt;code&gt;NoForceRecompile&lt;/code&gt; is used for &amp;ldquo;pure&amp;rdquo; plugins which don&amp;rsquo;t need to be rerun unless a module would ordinarily be recompiled. &lt;code&gt;MaybeRecompile&lt;/code&gt; computes a &lt;code&gt;Fingerprint&lt;/code&gt; and if this &lt;code&gt;Fingerprint&lt;/code&gt; is different to a previously computed &lt;code&gt;Fingerprint&lt;/code&gt; for the plugin, then we recompile the module.</source>
          <target state="translated">&lt;code&gt;ForceRecompile&lt;/code&gt; 을 사용하여 불완전 하다고 선언하는 플러그인 은 항상 현재 모듈의 재 컴파일을 트리거합니다. &lt;code&gt;NoForceRecompile&lt;/code&gt; 은 모듈이 보통 재 컴파일되지 않는 한 재실행 할 필요가없는 &quot;순수한&quot;플러그인에 사용됩니다. &lt;code&gt;MaybeRecompile&lt;/code&gt; 는 계산 &lt;code&gt;Fingerprint&lt;/code&gt; 이 경우 &lt;code&gt;Fingerprint&lt;/code&gt; 이전에 계산에 다른 &lt;code&gt;Fingerprint&lt;/code&gt; 플러그인에 대한, 우리는 모듈을 다시 컴파일.</target>
        </trans-unit>
        <trans-unit id="a3bc90dc2dc45d7f4fd4afcd9ae1bd1af634697a" translate="yes" xml:space="preserve">
          <source>A plugin&amp;rsquo;s installation function (&lt;code&gt;install&lt;/code&gt; in the above example) takes a list of &lt;code&gt;CoreToDo&lt;/code&gt;s and returns a list of &lt;code&gt;CoreToDo&lt;/code&gt;. Before GHC begins compiling modules, it enumerates all the needed plugins you tell it to load, and runs all of their installation functions, initially on a list of passes that GHC specifies itself. After doing this for every plugin, the final list of passes is given to the optimizer, and are run by simply going over the list in order.</source>
          <target state="translated">플러그인 설치 기능 ( 위의 예제에서 &lt;code&gt;install&lt;/code&gt; )은 &lt;code&gt;CoreToDo&lt;/code&gt; 목록을 &lt;code&gt;CoreToDo&lt;/code&gt; 목록을 리턴합니다 . GHC는 모듈 컴파일을 시작하기 전에로드하도록 지시 한 모든 필요한 플러그인을 열거하고 처음에 GHC가 지정하는 패스 목록에서 모든 설치 기능을 실행합니다. 모든 플러그인에 대해이 작업을 수행 한 후 최종 패스 목록이 옵티 마이저에 제공되며 순서대로 목록을 검토하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3c0c15abdc47e8b410d77eeddeb4ff60204efc9" translate="yes" xml:space="preserve">
          <source>A pointer to a foreign function equivalent to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;, which may be used as a finalizer (cf &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;) for storage allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 로 할당 된 스토리지의 종료 자 (cf &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; ) 로 사용될 수있는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 와 동등한 외부 함수에 대한 포인터 .</target>
        </trans-unit>
        <trans-unit id="ed62f36de9a3053add8b5f383c46d4ea22035d53" translate="yes" xml:space="preserve">
          <source>A pointer, but &lt;em&gt;not&lt;/em&gt; to a Haskell value</source>
          <target state="translated">하스켈 값이 &lt;em&gt;아닌&lt;/em&gt; 포인터</target>
        </trans-unit>
        <trans-unit id="12c3c6eef2eab225b82c10e7756d7d1120735999" translate="yes" xml:space="preserve">
          <source>A positive initial counter value denotes availability of units &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; can acquire.</source>
          <target state="translated">양수의 초기 카운터 값은 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; 가 획득 할 수 있는 단위의 가용성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4607e3c8d43d975a9d5043b9fe5325adef419139" translate="yes" xml:space="preserve">
          <source>A possible reason for this is that &lt;code&gt;readLitChar&lt;/code&gt; accepts hex and octal escapes, so it seems inconsistent not to do so for integers too.</source>
          <target state="translated">이에 대한 가능한 이유는 &lt;code&gt;readLitChar&lt;/code&gt; 가 16 진 및 8 진 이스케이프를 허용하므로 정수에 대해서도 그렇게하지 않는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee0df3315cf15090b8170db19c00adae9d086669" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; 메서드 의 가능한 대체 정의입니다 . 이것은 단지에 필요한 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 가 정의되지 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d38c3479f89f023338692e638f45fe5ac188bd2d" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; 메서드에 대한 가능한 대체 정의입니다 . 이것은 단지에 필요한 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 인스턴스 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; 가 정의되지 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d027bf72f3911128c132d8c54e0a8ef6c5c888" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">취할 수있는 여분의 정의 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 의 방법은 사용하여 정의 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5d373fa8bb2d277c322dacc2f2dcc3f3d824b4e2" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">취할 수있는 여분의 정의 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; 의 방법은 사용하여 정의 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="29364a8e8891d9c56243d372544806d4d546619b" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 메소드에 대한 가능한 대체 정의 (GHC 전용). 이것은 단지에만 그렇다하더라도 GHC 필요하고, &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 가 정의되지 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ae1239307d70eba9e18971c894baa48ad11cf4" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC 전용)을 사용하여 정의 된 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 메소드 의 가능한 대체 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="f80e2bb9e234ed027f7e8ba6d593f983b80c8933" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 메소드에 대한 가능한 대체 정의 (GHC 전용). 이것은 단지에만 그렇다하더라도 GHC 필요하고, &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 가 정의되지 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f98f636cd56d17e711ba559f0f71c4bdebdffa1" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC 전용)을 사용하여 정의 된 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 메소드 의 가능한 대체 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="b157127674bef09a54a1bf4952fda41dd1808377" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;M&lt;/code&gt;' always stands for a function in the Kleisli category: The monad type constructor &lt;code&gt;m&lt;/code&gt; is added to function results (modulo currying) and nowhere else. So, for example,</source>
          <target state="translated">접미사 ' &lt;code&gt;M&lt;/code&gt; '은 항상 Kleisli 범주의 함수를 나타냅니다. 모나드 유형 생성자 &lt;code&gt;m&lt;/code&gt; 은 함수 결과 (모듈로 카레)에 추가됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4f57aca0d9a4c899e484cd901e67bacaa13d70b9" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;_&lt;/code&gt;' changes the result type from &lt;code&gt;(m a)&lt;/code&gt; to &lt;code&gt;(m ())&lt;/code&gt;. Thus, for example:</source>
          <target state="translated">접미사 ' &lt;code&gt;_&lt;/code&gt; '는 결과 유형을 &lt;code&gt;(m a)&lt;/code&gt; 에서 &lt;code&gt;(m ())&lt;/code&gt; 으로 변경 합니다. 따라서 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46921428c3bbaa58265d19bfda0ee3268636763a" translate="yes" xml:space="preserve">
          <source>A precise semantics</source>
          <target state="translated">정확한 의미론</target>
        </trans-unit>
        <trans-unit id="47f994aa80408a0bd45b4587fcafe17e6fd888ec" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="translated">버퍼가 리턴되기 전에 트림되어야하는 경우, 술어 &lt;code&gt;trim used allocated&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d580afd63f73de0a796d71c734098f93fa407b93" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="translated">버퍼가 반환되기 전에 트리밍되어야하는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 반환 &lt;code&gt;trim used allocated&lt;/code&gt; 조건 자 트리밍이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b7be90e7ccc0906e803e54dbfc057396ec04901" translate="yes" xml:space="preserve">
          <source>A prefix '&lt;code&gt;m&lt;/code&gt;' generalizes an existing function to a monadic form. Thus, for example:</source>
          <target state="translated">접두사 ' &lt;code&gt;m&lt;/code&gt; '은 기존 함수를 모나드 형식으로 일반화합니다. 따라서 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89ba2753b7a938dad018da0fd6997dc0b76bb953" translate="yes" xml:space="preserve">
          <source>A primitive C-style string, type Addr#</source>
          <target state="translated">원시 C 스타일 문자열, 유형 Addr #</target>
        </trans-unit>
        <trans-unit id="47d0a23e976121bc1cfab9f6f18718ab2b9d2383" translate="yes" xml:space="preserve">
          <source>A process in the process group</source>
          <target state="translated">프로세스 그룹의 프로세스</target>
        </trans-unit>
        <trans-unit id="e2978f6c6d0c2493478216f46bf15eb08160b4e7" translate="yes" xml:space="preserve">
          <source>A program that fails in any other way is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;. A program that terminates successfully without calling &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; explicitly is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다른 방식으로 실패한 프로그램은 마치 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 를 호출 한 것처럼 처리됩니다 . &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 호출하지 않고 성공적으로 종료되는 프로그램은 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 를 호출 한 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="106e5d7fb17753020184a4433ee767b6d5411226" translate="yes" xml:space="preserve">
          <source>A programmer may use &lt;code&gt;forall&lt;/code&gt; in a type to introduce new quantified type variables. These variables may depend on each other, even in the same &lt;code&gt;forall&lt;/code&gt;. However, GHC requires that the dependency be inferrable from the body of the &lt;code&gt;forall&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">프로그래머는 새로운 정량화 된 타입 변수를 도입하기 위해 타입에서 &lt;code&gt;forall&lt;/code&gt; 을 사용할 수 있습니다 . 이 변수들은 같은 &lt;code&gt;forall&lt;/code&gt; 에서도 서로 의존 할 수 있습니다 . 그러나 GHC는 &lt;code&gt;forall&lt;/code&gt; 의 본문에서 종속성을 유추 할 수 있어야합니다 . 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="71ba773b3259e537cc66acd4ec6d24f2384a5425" translate="yes" xml:space="preserve">
          <source>A programmer-defined error value constructed using &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; 를 사용하여 구성된 프로그래머 정의 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="7217616c7698f7547fd2c1e5c701e62f18577563" translate="yes" xml:space="preserve">
          <source>A pun on a qualified field name is expanded by stripping off the module qualifier. For example:</source>
          <target state="translated">규정 된 필드 이름의 펑은 모듈 규정자를 제거하여 확장됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c36208f7850763edf61643d27d80bde39732dac8" translate="yes" xml:space="preserve">
          <source>A qualified name &lt;code&gt;A.foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.foo&lt;/code&gt;.</source>
          <target state="translated">정규화 된 이름 &lt;code&gt;A.foo&lt;/code&gt; . GHC는 주요 기능이 &lt;code&gt;A.foo&lt;/code&gt; 라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c1f854f70933a723bf95a735c3aa4de5afabd5c6" translate="yes" xml:space="preserve">
          <source>A qualified name; dynamically bound</source>
          <target state="translated">정규화 된 이름 동적으로 바인딩</target>
        </trans-unit>
        <trans-unit id="a8f9eb9db19a1818e7c75d1fe1ee9a6205220c54" translate="yes" xml:space="preserve">
          <source>A quantified type representation.</source>
          <target state="translated">정량화 된 유형 표현.</target>
        </trans-unit>
        <trans-unit id="e82bbf975220aa7ab5228dfdba9164c275fc91d4" translate="yes" xml:space="preserve">
          <source>A quasi-quotation can appear in a pattern, type, expression, or declaration context and is also written in Oxford brackets:</source>
          <target state="translated">준 따옴표는 패턴, 유형, 표현 또는 선언 컨텍스트로 표시 될 수 있으며 옥스포드 괄호로도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9598087296773252828f5341b4828654c30bd8a1" translate="yes" xml:space="preserve">
          <source>A quasi-quote has the form &lt;code&gt;[quoter| string |]&lt;/code&gt;.</source>
          <target state="translated">준 따옴표는 &lt;code&gt;[quoter| string |]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1cb587055071e4fb0d1b0454a870959e6f9fa49" translate="yes" xml:space="preserve">
          <source>A quasi-quote is expanded by applying the appropriate parser to the string enclosed by the Oxford brackets. The context of the quasi-quote (expression, pattern, type, declaration) determines which of the parsers is called.</source>
          <target state="translated">옥스포드 브래킷으로 묶인 문자열에 적절한 구문 분석기를 적용하여 준 따옴표를 확장합니다. 준 따옴표 (표현식, 패턴, 유형, 선언)의 컨텍스트에 따라 어떤 구문 분석기가 호출되는지 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="cdcde5d2df86936b559e312ff74aff26f8e4d03f" translate="yes" xml:space="preserve">
          <source>A quasiquote may appear in place of</source>
          <target state="translated">대신 인용 부호가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a001d4fd181336f68b683e872533d57d619d5b7e" translate="yes" xml:space="preserve">
          <source>A question that we often want to ask when debugging a program is &amp;ldquo;how did I get here?&amp;rdquo;. Traditional imperative debuggers usually provide some kind of stack-tracing feature that lets you see the stack of active function calls (sometimes called the &amp;ldquo;lexical call stack&amp;rdquo;), describing a path through the code to the current location. Unfortunately this is hard to provide in Haskell, because execution proceeds on a demand-driven basis, rather than a depth-first basis as in strict languages. The &amp;ldquo;stack&amp;ldquo; in GHC&amp;rsquo;s execution engine bears little resemblance to the lexical call stack. Ideally GHCi would maintain a separate lexical call stack in addition to the dynamic call stack, and in fact this is exactly what our profiling system does (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;), and what some other Haskell debuggers do. For the time being, however, GHCi doesn&amp;rsquo;t maintain a lexical call stack (there are some technical challenges to be overcome). Instead, we provide a way to backtrack from a breakpoint to previous evaluation steps: essentially this is like single-stepping backwards, and should in many cases provide enough information to answer the &amp;ldquo;how did I get here?&amp;rdquo; question.</source>
          <target state="translated">프로그램을 디버깅 할 때 자주 묻는 질문은 &quot;어떻게 여기에 왔습니까?&quot;입니다. 기존의 명령형 디버거는 일반적으로 코드를 통해 현재 위치까지의 경로를 설명하는 활성 함수 호출 스택 ( &quot;어휘 호출 스택&quot;이라고도 함)을 볼 수있는 일종의 스택 추적 기능을 제공합니다. 불행히도, 이는 Haskell에서 제공하기가 어렵습니다. 실행은 엄격한 언어 에서처럼 깊이 우선이 아니라 수요 중심으로 진행되기 때문입니다. GHC 실행 엔진의 &quot;스택&quot;은 어휘 호출 스택과 거의 유사하지 않습니다. 이상적으로 GHCi는 동적 호출 스택 외에 별도의 어휘 호출 스택을 유지해야하며, 실제로 이것이 프로파일 링 시스템에서 수행하는 것과 정확히 일치합니다 ( &lt;a href=&quot;profiling#profiling&quot;&gt;프로파일 링&lt;/a&gt;) 및 기타 Haskell 디버거의 기능 그러나 당분간 GHCi는 어휘 호출 스택을 유지하지 않습니다 (극복해야 할 기술적 과제가 있음). 대신 중단 점에서 이전 평가 단계로 역 추적 할 수있는 방법을 제공합니다. 이는 본질적으로 한 단계 뒤로 거꾸로하는 것과 같으며 많은 경우 &quot;어떻게 여기에 왔습니까?&quot;에 대한 충분한 정보를 제공해야합니다. 질문.</target>
        </trans-unit>
        <trans-unit id="ad0242b7d03d75d9ad4b17787a60e3e615d37d16" translate="yes" xml:space="preserve">
          <source>A quoter is a value of type &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt;, which is defined thus:</source>
          <target state="translated">따옴표는 &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt; 유형의 값으로 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a48ce4817f3e54a0532248a31d1f099d88b1351f" translate="yes" xml:space="preserve">
          <source>A range of bytes in a buffer represented by the pointer to the first byte of the range and the pointer to the first byte &lt;em&gt;after&lt;/em&gt; the range.</source>
          <target state="translated">버퍼의 바이트 범위는 그 범위의 첫번째 바이트와 첫번째 바이트의 포인터에 대한 포인터에 의해 표시되는 &lt;em&gt;이후&lt;/em&gt; 의 범위.</target>
        </trans-unit>
        <trans-unit id="b28c56da049e38013f1fcf4d02dcb6b1f0080a5c" translate="yes" xml:space="preserve">
          <source>A record GADT may have a restricted type for a selector function, which may lead to additional unification when solving &lt;code&gt;HasField&lt;/code&gt; constraints. For example,</source>
          <target state="translated">레코드 GADT는 선택기 함수에 대해 제한된 유형을 가질 수 있으며, 이는 &lt;code&gt;HasField&lt;/code&gt; 제약 조건을 해결할 때 추가적인 통일을 야기 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="b338877827c7ed29adfee9e9d6b0b8e5a63641d8" translate="yes" xml:space="preserve">
          <source>A record selector was applied to a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record selector.</source>
          <target state="translated">적절한 필드가없는 생성자에 레코드 선택기가 적용되었습니다. 이것은 여러 생성자가있는 데이터 유형에서만 발생할 수 있으며 일부 필드는 한 생성자에 있지만 다른 필드에는 없습니다. &lt;code&gt;String&lt;/code&gt; 레코드 선택기의 소스 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c21fec8a784a0df6d796742b5beccbbdfb0d37ed" translate="yes" xml:space="preserve">
          <source>A record update was performed on a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record update.</source>
          <target state="translated">적절한 필드가없는 생성자에서 레코드 업데이트가 수행되었습니다. 이것은 여러 생성자가있는 데이터 유형에서만 발생할 수 있으며 일부 필드는 한 생성자에 있지만 다른 필드에는 없습니다. &lt;code&gt;String&lt;/code&gt; 레코드 업데이트의 소스 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92fb5684ae95209348bfee7f9aea2ce376b9a4d4" translate="yes" xml:space="preserve">
          <source>A redundant constraint within the type signature itself:</source>
          <target state="translated">형식 서명 자체 내의 중복 제약 조건 :</target>
        </trans-unit>
        <trans-unit id="54a410c09496ec54abde3e9710dcb3fcce5da06f" translate="yes" xml:space="preserve">
          <source>A reference to a remote value. These are allocated and freed explicitly.</source>
          <target state="translated">원격 값에 대한 참조입니다. 이들은 명시 적으로 할당되고 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fb2a2acd6cd218a5be6c4d95fa1ad4daf16624a7" translate="yes" xml:space="preserve">
          <source>A reference to a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">a 유형 &lt;code&gt;a&lt;/code&gt; 값에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="0361e89442d5407a746896c1f1424c0385608b9b" translate="yes" xml:space="preserve">
          <source>A rendering style. Allows us to specify constraints to choose among the many different rendering options.</source>
          <target state="translated">렌더링 스타일. 다양한 렌더링 옵션 중에서 선택할 구속 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a7715c19cf7faa5dc45883c88b4e480b883a9aa" translate="yes" xml:space="preserve">
          <source>A retainer is either the system stack, an unevaluated closure (thunk), or an explicitly mutable object.</source>
          <target state="translated">리테이너는 시스템 스택, 평가되지 않은 클로저 (썽크) 또는 명시 적으로 변경 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c17ab32a3bf231aeb0c4cd50ac9f91c26d98d0f8" translate="yes" xml:space="preserve">
          <source>A rewrite rule in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan rule&lt;/em&gt; orphan rule if none of the variables, type constructors, or classes that are free in the left hand side of the rule are declared in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">규칙 왼쪽에있는 변수, 유형 생성자 또는 클래스가 &lt;code&gt;M&lt;/code&gt; 에서 선언되지 않은 경우 모듈 &lt;code&gt;M&lt;/code&gt; 의 다시 쓰기 규칙 은 &lt;em&gt;고아 규칙&lt;/em&gt; 고아 규칙 입니다.</target>
        </trans-unit>
        <trans-unit id="f7576507e849494c245f578b7b08c722c72b9e4b" translate="yes" xml:space="preserve">
          <source>A rich user interface for line input in command-line programs. Haskeline is Unicode-aware and runs both on POSIX-compatible systems and on Windows.</source>
          <target state="translated">명령 행 프로그램의 라인 입력을위한 풍부한 사용자 인터페이스. Haskeline은 유니 코드를 인식하며 POSIX 호환 시스템과 Windows에서 모두 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe62b863adf6df34977b49f0095efaac4aba5e7" translate="yes" xml:space="preserve">
          <source>A right fold over the elements</source>
          <target state="translated">요소에 대한 오른쪽 접기</target>
        </trans-unit>
        <trans-unit id="468cdfbdf06effe43a3aa0fc4e881403e078094b" translate="yes" xml:space="preserve">
          <source>A right fold over the elements with no starting value</source>
          <target state="translated">시작 값이없는 요소를 오른쪽으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="1bd8cdef3742749b47082f965a23008abf9bc15b" translate="yes" xml:space="preserve">
          <source>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope.</source>
          <target state="translated">규칙은 언급 한 변수와 동일한 모듈에있을 필요는 없지만 물론 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4dda8ffe8bacae7a3d13b78da8fc37161b54e971" translate="yes" xml:space="preserve">
          <source>A rule may optionally have a phase-control number (see &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;), immediately after the name of the rule. Thus:</source>
          <target state="translated">규칙은 규칙 이름 바로 다음 &lt;a href=&quot;#phase-control&quot;&gt;단계 제어&lt;/a&gt; 번호 ( 단계 제어 참조 )를 선택적으로 가질 수 있습니다 . 그러므로:</target>
        </trans-unit>
        <trans-unit id="ba8873804ea20a68777a6a79acc2a5e0d1a22d48" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with a mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">나중에 퍼포먼스를 위해 불변 배열을 반환하기 전에 가변 배열을 만들고 작업하는 안전한 방법입니다. 이 함수는 배열을 반환하기 전에 복사를 피합니다 &lt;code&gt;unsafeFreeze&lt;/code&gt; 내부적으로 unsafeFreeze를 사용 하지만이 래퍼는 해당 함수에 대한 안전한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8ed6207609d767c14b5aa06f9aa68c12587a18b1" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with an unboxed mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">박스형의 가변 배열을 만들고 사용하여 나중에 퍼포먼스를 위해 불변 배열을 반환하는 안전한 방법. 이 함수는 배열을 반환하기 전에 복사를 피합니다 &lt;code&gt;unsafeFreeze&lt;/code&gt; 내부적으로 unsafeFreeze를 사용 하지만이 래퍼는 해당 함수에 대한 안전한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b9df3dc079f00f9a8e0de830c01848206acb9ca5" translate="yes" xml:space="preserve">
          <source>A sample (consisting of a list of break-down classes, e.g. cost centres, and heap residency sizes), is to be encoded in the body of one or more events.</source>
          <target state="translated">비용 센터 및 힙 상주 규모와 같은 분류 클래스 목록으로 구성된 샘플은 하나 이상의 이벤트 본문에 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="75c24f2265f3d8c4ccd393f15ae237ff3f6f2a33" translate="yes" xml:space="preserve">
          <source>A scoped type variable stands for a type &lt;em&gt;variable&lt;/em&gt;, and not for a &lt;em&gt;type&lt;/em&gt;. (This is a change from GHC&amp;rsquo;s earlier design.)</source>
          <target state="translated">범위가 지정된 타입 변수는 타입의 약자 &lt;em&gt;변수&lt;/em&gt; A에 대한, 그리고 &lt;em&gt;유형&lt;/em&gt; . (이것은 GHC의 초기 디자인에서 변경된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="f9e8504d9f7ca56788ad83a6712e3deabb56b1fb" translate="yes" xml:space="preserve">
          <source>A sequence of actions produces a value only if all the actions in the sequence do. If one exits, the rest of the sequence is skipped and the composite action exits.</source>
          <target state="translated">일련의 조치는 순서의 모든 조치가 수행하는 경우에만 값을 생성합니다. 하나가 종료되면 나머지 시퀀스는 건너 뛰고 복합 조치가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="627ab33bc11dc284fde08d4bb2c60e4ca6633e05" translate="yes" xml:space="preserve">
          <source>A sequence of actions succeeds, producing a value, only if all the actions in the sequence are successful. If one fails with an error, the rest of the sequence is skipped and the composite action fails with that error.</source>
          <target state="translated">일련의 조치가 성공하여 순서의 모든 조치가 성공한 경우에만 값을 생성합니다. 오류로 실패하면 나머지 시퀀스는 건너 뛰고 복합 오류는 해당 오류로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2df1f1dd397310b516738a6b735261200af88e24" translate="yes" xml:space="preserve">
          <source>A sequence of actions terminates normally, producing a value, only if none of the actions in the sequence throws an exception. If one throws an exception, the rest of the sequence is skipped and the composite action exits with that exception.</source>
          <target state="translated">일련의 조치는 정상적으로 종료되어 순서의 조치가 예외를 처리하지 않는 경우에만 값을 생성합니다. 예외가 발생하면 나머지 시퀀스는 건너 뛰고 복합 예외는 해당 예외와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86877c5118e45e245e3a082f5d36380aaa868a97" translate="yes" xml:space="preserve">
          <source>A sequence of non-space characters, or a sequence of arbitrary characters surrounded by quotes &lt;code&gt;&quot;....&quot;&lt;/code&gt;.</source>
          <target state="translated">비 공백 문자의 순서, 또는 따옴표로 둘러싸인 임의의 일련의 문자 &lt;code&gt;&quot;....&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76595a701ee44ea1c9f930a9c60dd85fa6bdaa4c" translate="yes" xml:space="preserve">
          <source>A sequence of strings, separated by commas. The sequence may be empty.</source>
          <target state="translated">쉼표로 구분 된 일련의 문자열. 시퀀스가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94dd7b6a2c0e4fe592c072a99a09ce1205c850da" translate="yes" xml:space="preserve">
          <source>A sequential garbage collection has been requested by a capability.</source>
          <target state="translated">기능에 의해 순차 가비지 콜렉션이 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9195a974dd24c0ef39d75bed4d1efb9a1d3015e" translate="yes" xml:space="preserve">
          <source>A set of integers.</source>
          <target state="translated">정수 세트.</target>
        </trans-unit>
        <trans-unit id="bb204bd8db13fe7816a94a82e9d47e0712050306" translate="yes" xml:space="preserve">
          <source>A set of signals reserved for use by the implementation. In GHC, this will normally include either &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현에서 사용하도록 예약 된 신호 세트입니다. GHC에서는 일반적으로 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a966b0c2cbc724a4e1636286c1f35ede7a08d8c" translate="yes" xml:space="preserve">
          <source>A set of values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값 집합 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84ea57aa89435041641005d90f97cd8afe4994e" translate="yes" xml:space="preserve">
          <source>A setEnv implementation that allows blank environment variables. Mimics the &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; module from the &lt;code&gt;unix&lt;/code&gt; package, but with support for Windows too.</source>
          <target state="translated">빈 환경 변수를 허용하는 setEnv 구현. &lt;code&gt;unix&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; 모듈을 모방 하지만 Windows도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f4ca239f09f9ab5cacd4dc55290c45509ce3c667" translate="yes" xml:space="preserve">
          <source>A shared mutable variable (&lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;MutVar#&lt;/code&gt;!). (Note: in a non-concurrent implementation, &lt;code&gt;(MVar# a)&lt;/code&gt; can be represented by &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt;.)</source>
          <target state="translated">공유 가능한 가변 변수 ( &lt;code&gt;MutVar#&lt;/code&gt; 와 동일 &lt;em&gt;하지 않음&lt;/em&gt; !) (참고 : 비 동시 구현에서 &lt;code&gt;(MVar# a)&lt;/code&gt; 는 &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt; 로 나타낼 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="a82158df9a5688ce51d763088d1b6426e23f9a62" translate="yes" xml:space="preserve">
          <source>A shortcut for multiple definitions which use &lt;code&gt;#const&lt;/code&gt;. Each &lt;code&gt;value&lt;/code&gt; is a name of a C integer constant, e.g. enumeration value. The name will be translated to Haskell by making each letter following an underscore uppercase, making all the rest lowercase, and removing underscores. You can supply a different translation by writing &lt;code&gt;hs_name = c_value&lt;/code&gt; instead of a &lt;code&gt;value&lt;/code&gt;, in which case &lt;code&gt;c_value&lt;/code&gt; may be an arbitrary expression. The &lt;code&gt;hs_name&lt;/code&gt; will be defined as having the specified &lt;code&gt;type&lt;/code&gt;. Its definition is the specified &lt;code&gt;constructor&lt;/code&gt; (which in fact may be an expression or be empty) applied to the appropriate integer value. You can have multiple &lt;code&gt;#enum&lt;/code&gt; definitions with the same &lt;code&gt;type&lt;/code&gt;; this construct does not emit the type definition itself.</source>
          <target state="translated">&lt;code&gt;#const&lt;/code&gt; 를 사용하는 여러 정의에 대한 바로 가기입니다 . 각 &lt;code&gt;value&lt;/code&gt; 은 C 정수 상수의 이름입니다 (예 : 열거 형 값). 이름은 각 문자를 밑줄 대문자로 만들고 나머지는 모두 소문자로 만들고 밑줄을 제거하여 Haskell로 이름을 변환합니다. 사용자가 작성하여 다른 번역을 제공 할 수 &lt;code&gt;hs_name = c_value&lt;/code&gt; (A)의 대신 &lt;code&gt;value&lt;/code&gt; 케이스되는, &lt;code&gt;c_value&lt;/code&gt; 이 임의의 표현 일 수있다. &lt;code&gt;hs_name&lt;/code&gt; 가 지정된 것으로 정의되는 &lt;code&gt;type&lt;/code&gt; . 정의는 지정된 &lt;code&gt;constructor&lt;/code&gt; (실제로 표현식이거나 비어있을 수 있음)가 적절한 정수 값에 적용됩니다. 여러 개를 가질 수 있습니다 &lt;code&gt;#enum&lt;/code&gt; 같은 &lt;code&gt;type&lt;/code&gt; #enum 정의 ; 이 구문은 형식 정의 자체를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00e25301890375feab76786821b7d4508efb82ce" translate="yes" xml:space="preserve">
          <source>A signature file is denoted by an &lt;code&gt;hsig&lt;/code&gt; file; every required signature must have an &lt;code&gt;hsig&lt;/code&gt; file (even if it is an empty one), including required signatures inherited from dependencies. Signatures can be imported using an ordinary &lt;code&gt;import Sig&lt;/code&gt; declaration.</source>
          <target state="translated">서명 파일은 &lt;code&gt;hsig&lt;/code&gt; 파일 로 표시됩니다 . 모든 필수 서명에는 종속성에서 상속 된 필수 서명을 포함 하여 &lt;code&gt;hsig&lt;/code&gt; 파일 이 있어야 합니다 (빈 파일 인 경우에도). 서명은 일반적인 &lt;code&gt;import Sig&lt;/code&gt; 선언을 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92355b0e296eb8f9e53318fcbdb4d680dbc31d1d" translate="yes" xml:space="preserve">
          <source>A signed integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;intptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 과 무손실로 변환 할 수있는 부호있는 정수 유형입니다 . 이 유형은 C99 유형 &lt;code&gt;intptr_t&lt;/code&gt; 와도 호환되며 해당 유형과 안전하게 마샬링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="948520b277e60dcee21361dd65adb915f2606d36" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99bde5053270918eb2f3d7c1e964f644e4ce138b" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbbe5e3287fe101eaac49bce2bfcb028d8f2b308" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 을 사용하여 비슷한 배열 값 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6c85786bd39c1497a36a8cbe06706b97c38a416" translate="yes" xml:space="preserve">
          <source>A simple choice for the type associated with flags is to define a type &lt;code&gt;Flag&lt;/code&gt; as an algebraic type representing the possible flags and their arguments:</source>
          <target state="translated">플래그와 연관된 유형에 대한 간단한 선택은 유형 &lt;code&gt;Flag&lt;/code&gt; 를 가능한 플래그 및 해당 인수를 나타내는 대수 유형으로 정의하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="385ee26bb3c563691e99d165abb3ca38a355c178" translate="yes" xml:space="preserve">
          <source>A simple day and time aggregate, where the day is of the specified parameter, and the time is a TimeOfDay. Conversion of this (as local civil time) to UTC depends on the time zone. Conversion of this (as local mean time) to UT1 depends on the longitude.</source>
          <target state="translated">일이 지정된 매개 변수이고 시간이 TimeOfDay 인 간단한 요일 및 시간 집계입니다. 현지 시간으로 UTC로 변환하는 것은 시간대에 따라 다릅니다. 이것을 (지역 평균 시간으로) UT1로 변환하는 것은 경도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5071edc607af851a249c97dfb4d0c57e03432a4d" translate="yes" xml:space="preserve">
          <source>A simple example of the new notation is the expression</source>
          <target state="translated">새로운 표기법의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32cefd4bea4e7110a3dca7239bc47887ca83ce67" translate="yes" xml:space="preserve">
          <source>A simple pairing heap.</source>
          <target state="translated">간단한 페어링 힙.</target>
        </trans-unit>
        <trans-unit id="8ad0b83378258a314fc0adf90a8e10c9bc3f1588" translate="yes" xml:space="preserve">
          <source>A simple use of unfoldr:</source>
          <target state="translated">펼치기의 간단한 사용법 :</target>
        </trans-unit>
        <trans-unit id="a1f654f7060b7d2d650700b6c757eab119833574" translate="yes" xml:space="preserve">
          <source>A simpler version of this function is:</source>
          <target state="translated">이 기능의 간단한 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="109ec8484c225e4b238b8dbafe102ddb90cbe663" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;deriving&lt;/code&gt; clause at the end of a datatype.</source>
          <target state="translated">데이터 유형의 끝에 단일 &lt;code&gt;deriving&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="07552ccc8f83d8da8c2ff1373fe5871fc375aea0" translate="yes" xml:space="preserve">
          <source>A single Char fragment</source>
          <target state="translated">단일 Char 조각</target>
        </trans-unit>
        <trans-unit id="c8a470d3f21b5f8bd88b72ca5e212009e6a9ba92" translate="yes" xml:space="preserve">
          <source>A single data constructor.</source>
          <target state="translated">단일 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="8b90ffe9d4585beccabc5b42a63afc7e90a28d58" translate="yes" xml:space="preserve">
          <source>A single fixed-width event emitted during program start-up describing the samples that follow.</source>
          <target state="translated">프로그램 시작시 발생하는 단일 고정 폭 이벤트는 다음 샘플을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dce34a123f3c9357183ae1491a545fbaf2ea2561" translate="yes" xml:space="preserve">
          <source>A single location in the source code.</source>
          <target state="translated">소스 코드의 단일 위치</target>
        </trans-unit>
        <trans-unit id="50f411ba135dec27d6a3801b72dc1838706dca5a" translate="yes" xml:space="preserve">
          <source>A single vertex that is not in any cycle.</source>
          <target state="translated">사이클에없는 단일 정점</target>
        </trans-unit>
        <trans-unit id="97bd9aab1d447685b69723475ad0a956cc38e08e" translate="yes" xml:space="preserve">
          <source>A sink of event-log data.</source>
          <target state="translated">이벤트 로그 데이터 싱크</target>
        </trans-unit>
        <trans-unit id="80976804b592e9e2e94c0bbcedb3e158f3a504b2" translate="yes" xml:space="preserve">
          <source>A size in UTF-16 code units.</source>
          <target state="translated">UTF-16 코드 단위의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="909e2a440c7053acbcd40d2af23d2760c9d12442" translate="yes" xml:space="preserve">
          <source>A skip channel is a pair of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s. The first &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; contains the current value, and a list of semaphores that need to be notified when it changes. The second &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is a semaphore for this particular reader: it is full if there is a value in the channel that this reader has not read yet, and empty otherwise.</source>
          <target state="translated">스킵 채널은 한 쌍의 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 입니다. 첫 번째 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에는 현재 값과 변경시 알려야하는 세마포어 목록이 있습니다. 두 번째 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 는이 특정 리더의 세마포어입니다.이 리더가 아직 읽지 않은 채널에 값이 있으면 가득 차고 그렇지 않으면 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="75b2421aa3377ed4749c4916a0cb0dcfc04c0013" translate="yes" xml:space="preserve">
          <source>A slight variation on &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; that allows a value to be returned (&lt;code&gt;b&lt;/code&gt;) in addition to the modified value of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 약간의 변동 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 값을 허용 (반환되는 &lt;code&gt;b&lt;/code&gt; 의 수정 값 이외에) &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c10ed60508f59cb5a529f1b359642cbe6b858" translate="yes" xml:space="preserve">
          <source>A slightly faster version of &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; that may not be safe to use with multiple threads. The unsafety arises when used like this:</source>
          <target state="translated">여러 스레드에서 사용하기에 안전하지 않을 수 있는 약간 빠른 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 버전입니다 . 안전은 다음과 같이 사용될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="translated">작은 예 :</target>
        </trans-unit>
        <trans-unit id="f3fa3447a8afd4949b9c12f9f8e9147cd390aae9" translate="yes" xml:space="preserve">
          <source>A small word of warning: &lt;a href=&quot;#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; is not friendly to &amp;ldquo;string gaps&amp;rdquo;. In other words, strings such as the following:</source>
          <target state="translated">작은 경고 단어 : &lt;a href=&quot;#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt; 는&amp;ldquo;문자열 간격&amp;rdquo;에 적합하지 않습니다. 즉, 다음과 같은 문자열 :</target>
        </trans-unit>
        <trans-unit id="b896df9db0191f80e6db640a0983ae75b9330707" translate="yes" xml:space="preserve">
          <source>A space character</source>
          <target state="translated">공백 문자</target>
        </trans-unit>
        <trans-unit id="2cf7bf5a17da5fc043fc8f14a663aecfa5439dbc" translate="yes" xml:space="preserve">
          <source>A space efficient, packed, unboxed Unicode text type.</source>
          <target state="translated">공간 효율적이고 압축 된 언 박스 유니 코드 텍스트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b320aab997efd2d7ca1e00ac225c124b5d920ec5" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">공간 효율적인 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 표현으로 많은 효율적인 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="edd5ed41a7ad61d8ccb7e1f320dd68310fe46295" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">많은 효율적인 작업을 지원 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 벡터 의 공간 효율적인 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="e34c30bb293046f1353d1b4c1fb7e4c15767c64f" translate="yes" xml:space="preserve">
          <source>A spanning forest of the graph, obtained from a depth-first search of the graph starting from each vertex in an unspecified order.</source>
          <target state="translated">지정되지 않은 순서로 각 정점에서 시작하는 그래프의 깊이 우선 검색에서 얻은 그래프의 스패닝 포리스트.</target>
        </trans-unit>
        <trans-unit id="4794ea6b46c0b3e368866c3f6657148757943020" translate="yes" xml:space="preserve">
          <source>A spanning forest of the part of the graph reachable from the listed vertices, obtained from a depth-first search of the graph starting at each of the listed vertices in order.</source>
          <target state="translated">나열된 각 정점에서 순서대로 시작하여 그래프의 깊이 우선 검색에서 얻은 나열된 정점에서 도달 가능한 그래프 부분의 스패닝 포리스트.</target>
        </trans-unit>
        <trans-unit id="17409cdf1a726a6b210a04d4446854b3d6bf4233" translate="yes" xml:space="preserve">
          <source>A spark has been GC&amp;rsquo;d before being evaluated.</source>
          <target state="translated">스파크는 평가되기 전에 GC 처리되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc7a9f3b3b4de7ca05232bf75a6a63a5d4979fe6" translate="yes" xml:space="preserve">
          <source>A spark has been added to the spark pool.</source>
          <target state="translated">스파크 풀에 스파크가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="20ef42be18896ca33cf39edd26afbfce8fc5c5ae" translate="yes" xml:space="preserve">
          <source>A spark has been stolen from another capability for evaluation.</source>
          <target state="translated">평가를 위해 다른 기능에서 스파크가 도난당했습니다.</target>
        </trans-unit>
        <trans-unit id="000576d9dd7d866ebbbaf02ec2da581917b4c07a" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">특별한 &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . 컴파일러는이를 인식하고 &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 상황에보다 적합한 오류 메시지를 삽입 할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="73c8066b78af5a513799e5e6e43841a928951845" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">특별한 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; . 컴파일러는이를 인식하고 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 상황에보다 적합한 오류 메시지를 삽입 할 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="b61fe333d2ebb606e68ef9534fb8ee51a3dcbe6f" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">나중에 실행할 계산 만있는 특수한 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d381bfcecd222a40938da33628701d9caa7e0fc9" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3551127e07d1074127cf665da3dc3de8f74d78ac" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7f3343104c8933573bbaff2361f546628d45e8d8" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">나중에 실행할 계산 만있는 특수한 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="addf8bf904a9b53d42ba0004dc6e0c96e5f166b4" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위 컨텍스트 0을 사용하고 일반 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 반환하는 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 의 특수 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="1a0c5e6176b1b7f34e452cb42488bc078090478d" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; where the value is actually a pair of the key and value passed to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">값이 실제로 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt; 에 전달 된 키와 값 의 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 의 특수 버전 :</target>
        </trans-unit>
        <trans-unit id="ed256b1475f3db11a1e053e7393f2e62ac0741a5" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt;, where the key and the value are the same object:</source>
          <target state="translated">키와 값이 동일한 객체 인 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 의 특수 버전 :</target>
        </trans-unit>
        <trans-unit id="88cbeb4d1e4332278f7efaec95990a7cd06ab5a6" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable).</source>
          <target state="translated">반환 된 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 객체는 단순히 버려지는 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt; 의 특수 버전입니다 (그러나 종료자는 가비지 수집기에서 기억하고 키에 도달 할 수 없을 때에도 계속 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="c000f76b0d515b8c303304c303dc38592d07556a" translate="yes" xml:space="preserve">
          <source>A splice can occur in place of</source>
          <target state="translated">스플 라이스 대신에 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cd4cb3a4aa37b46f04784c0f6f0060998bc7f64a" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;ldquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">스플 라이스는 &lt;code&gt;$x&lt;/code&gt; 이며 여기서 &lt;code&gt;x&lt;/code&gt; 는 식별자이거나 &lt;code&gt;$(...)&lt;/code&gt; 이며 여기서&amp;ldquo;&amp;hellip;&amp;rdquo;은 임의의 표현식입니다. &quot;$&quot;와 식별자 또는 괄호 사이에는 공백이 없어야합니다. 이 &quot;$&quot;사용은 &quot;Mx&quot;가 &quot;.&quot;의 의미를 재정의하는 것처럼 중위 연산자로서의 의미를 재정의합니다. 중위 연산자로. 중위 연산자를 원하면 주위에 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="2fc7d08e30e7130abc877e7e166eb7f0bb2f0e91" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;rdquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">스플 라이스는 &lt;code&gt;$x&lt;/code&gt; 로 작성 되며, 여기서 &lt;code&gt;x&lt;/code&gt; 는 식별자이거나 &lt;code&gt;$(...)&lt;/code&gt; . 여기서&amp;rdquo;...&amp;rdquo;는 임의의 표현식입니다. &amp;ldquo;$&amp;rdquo;와 식별자 또는 괄호 사이에는 공백이 없어야합니다. 이와 같이 &quot;$&quot;를 사용하면 &quot;Mx&quot;가 &quot;&quot;의 의미를 재정의하는 것처럼 삽입 연산자로서의 의미를 재정의합니다. &quot; 중위 연산자로. 삽입 연산자를 원하면 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="029020ae6b32756dd16466eb423a1a26ab4457d6" translate="yes" xml:space="preserve">
          <source>A state monad parameterized by the type &lt;code&gt;s&lt;/code&gt; of the state to carry.</source>
          <target state="translated">상태 A는 유형에 의해 파라미터 모나드 &lt;code&gt;s&lt;/code&gt; 캐리에 대한 국가의.</target>
        </trans-unit>
        <trans-unit id="dc96818c8486fd2f0989d60f3799e6dcb782b7f0" translate="yes" xml:space="preserve">
          <source>A state transformer monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 상태 변환기 모나드</target>
        </trans-unit>
        <trans-unit id="584d223e5ba9554539274f317131b078dc9f657c" translate="yes" xml:space="preserve">
          <source>A static form determines a value of type &lt;code&gt;StaticPtr t&lt;/code&gt;, but just like &lt;code&gt;OverloadedLists&lt;/code&gt; and &lt;code&gt;OverloadedStrings&lt;/code&gt;, this literal expression is overloaded to allow lifting a &lt;code&gt;StaticPtr&lt;/code&gt; into another type implicitly, via the &lt;code&gt;IsStatic&lt;/code&gt; class:</source>
          <target state="translated">정적 형식은 &lt;code&gt;StaticPtr t&lt;/code&gt; 유형의 값을 결정 하지만 &lt;code&gt;OverloadedLists&lt;/code&gt; 및 &lt;code&gt;OverloadedStrings&lt;/code&gt; 와 마찬가지로 &lt;code&gt;IsStatic&lt;/code&gt; 클래스 를 통해 &lt;code&gt;StaticPtr&lt;/code&gt; 을 다른 유형으로 암시 적으로 들어 올릴 수 있도록이 리터럴 표현식이 오버로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="29153c897e531a67acff58cc6b01500af3000f33" translate="yes" xml:space="preserve">
          <source>A storable array is an IO-mutable array which stores its contents in a contiguous memory block living in the C heap. Elements are stored according to the class &lt;code&gt;Storable&lt;/code&gt;. You can obtain the pointer to the array contents to manipulate elements from languages like C.</source>
          <target state="translated">저장 가능 어레이는 해당 내용을 C 힙에있는 연속 메모리 블록에 저장하는 IO 변경 가능 어레이입니다. 요소는 &lt;code&gt;Storable&lt;/code&gt; 클래스에 따라 저장됩니다 . C와 같은 언어에서 요소를 조작하기 위해 배열 내용에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f5037287f3893bff45330861345a86eebed76c2" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 구성된 청크 스트림 .</target>
        </trans-unit>
        <trans-unit id="43919f0b621bd7f60ea00562492dbc3adfa8a6aa" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 구성되는 청크 스트림입니다 .</target>
        </trans-unit>
        <trans-unit id="9b113394401941b6890516fb8e3af8a462d1fd40" translate="yes" xml:space="preserve">
          <source>A stream oriented decoding result.</source>
          <target state="translated">스트림 지향 디코딩 결과.</target>
        </trans-unit>
        <trans-unit id="d911f61b4fa0d9284a8e1a6f69a0f61b1e73b5e6" translate="yes" xml:space="preserve">
          <source>A strict left fold over the elements</source>
          <target state="translated">요소에 대해 엄격한 왼쪽 접기</target>
        </trans-unit>
        <trans-unit id="98cd4454f56f48afeffc70d90f58b5920ca58301" translate="yes" xml:space="preserve">
          <source>A strict pair</source>
          <target state="translated">엄격한 쌍</target>
        </trans-unit>
        <trans-unit id="6eccc911da51c833236284b3d32b3123513710ad" translate="yes" xml:space="preserve">
          <source>A strict pattern match in a bind statement prevents &lt;code&gt;ApplicativeDo&lt;/code&gt; from transforming that statement to use &lt;code&gt;Applicative&lt;/code&gt;. This is because the transformation would change the semantics by making the expression lazier.</source>
          <target state="translated">바인드 명령문에서 엄격한 패턴 일치는 &lt;code&gt;ApplicativeDo&lt;/code&gt; 가 해당 명령문을 변환하여 &lt;code&gt;Applicative&lt;/code&gt; 를 사용 하지 못하게 합니다. 변환은 표현을 더 느리게 만들어 의미를 변경하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0814095da0f374f363b2744acbf7641a2610efcb" translate="yes" xml:space="preserve">
          <source>A strict right fold over the elements</source>
          <target state="translated">요소에 대한 엄격한 오른쪽 접기</target>
        </trans-unit>
        <trans-unit id="0ec086694cd0bcf9cc7eaaf131dce1a8c3f470d3" translate="yes" xml:space="preserve">
          <source>A strict variant of foldr1</source>
          <target state="translated">foldr1의 엄격한 변형</target>
        </trans-unit>
        <trans-unit id="37c2878fde673453465a3e32200c82b9e97c2b4d" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="00787a530c1e072ddb6f8e17b643611bd5348b98" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 .</target>
        </trans-unit>
        <trans-unit id="00a8b3473a1ebcbcb0938b14d80dd5227345445f" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="5320390dc6f10cc24227a72c79ba582ebcc655a1" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전 .</target>
        </trans-unit>
        <trans-unit id="493154631c22520a575e67380475a32d6bd2b085" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 의 엄격한 버전</target>
        </trans-unit>
        <trans-unit id="fb8a26929f2fded3b180d5708141aba0e7729a4d" translate="yes" xml:space="preserve">
          <source>A strict version of foldl.</source>
          <target state="translated">foldl의 엄격한 버전.</target>
        </trans-unit>
        <trans-unit id="38c487e511f9d1d69315932a619005a1ef13ecae" translate="yes" xml:space="preserve">
          <source>A strict version of foldl1.</source>
          <target state="translated">foldl1의 엄격한 버전.</target>
        </trans-unit>
        <trans-unit id="3a7a0698bbaa3cecd2768e6bf682a107a5760347" translate="yes" xml:space="preserve">
          <source>A string &lt;code&gt;x&lt;/code&gt; is a caseless match for a string &lt;code&gt;y&lt;/code&gt; if and only if:</source>
          <target state="translated">다음 과 같은 경우에만 문자열 &lt;code&gt;x&lt;/code&gt; 는 문자열 &lt;code&gt;y&lt;/code&gt; 에 대해 대소 문자가 일치 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a89823ddb2e0acf1e32d6f1968848a1d41921ad" translate="yes" xml:space="preserve">
          <source>A string can be thrown as an error.</source>
          <target state="translated">문자열은 오류로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6ae9c82c7d68fe5d1dffcf904a8de12b9166247" translate="yes" xml:space="preserve">
          <source>A string describing the source span enclosing the cost-centre.</source>
          <target state="translated">비용 센터를 포함하는 소스 범위를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1236c4b5dbb424adbd898df93abf13e38ab1cf45" translate="yes" xml:space="preserve">
          <source>A string to pass on standard input to the forked process.</source>
          <target state="translated">분기 된 프로세스에 표준 입력을 전달할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="624066030a645e943a5b155270eb593c7b3b17d0" translate="yes" xml:space="preserve">
          <source>A string with explicit length information in bytes instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">종료 NUL (문자열 중간에 NUL 문자 허용) 대신 명시 적 길이 정보를 바이트 단위로 갖는 문자열.</target>
        </trans-unit>
        <trans-unit id="2356ccf00398e74e586e317a2fe01305d7bf8c72" translate="yes" xml:space="preserve">
          <source>A superclass context for a class &lt;code&gt;C&lt;/code&gt; is allowed if, after expanding type synonyms to their right-hand-sides, and uses of classes (other than &lt;code&gt;C&lt;/code&gt;) to their superclasses, &lt;code&gt;C&lt;/code&gt; does not occur syntactically in the context.</source>
          <target state="translated">클래스에 대한 슈퍼 클래스 컨텍스트 &lt;code&gt;C&lt;/code&gt; 는 자신의 오른쪽 손으로 측면 타입 동의어를 확장 한 후, 경우에 허용하고 (이외의 클래스의 사용 &lt;code&gt;C&lt;/code&gt; 수퍼 클래스로는), &lt;code&gt;C&lt;/code&gt; 는 맥락에서 구문 적으로 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8df258a3806dcb111bd7b1772adfed8e5b1b40a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;, but as a function instead of an operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 의 동의어 이지만 연산자 대신 함수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b99600f4f94d4a88ef68809095d330e12de5939a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;hPut&lt;/code&gt;, for compatibility</source>
          <target state="translated">호환성을 위한 &lt;code&gt;hPut&lt;/code&gt; 의 동의어</target>
        </trans-unit>
        <trans-unit id="f7bdd4682beedebc0801ab80535b56959469b2ec" translate="yes" xml:space="preserve">
          <source>A system-dependent mode. This is also the default mode. On Unix ELF systems this embeds &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt;/&lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; entries into the shared library or executable. In particular it uses absolute paths to where the shared libraries for the rts and each package can be found. This means the program can immediately be run and it will be able to find the libraries it needs. However it may not be suitable for deployment if the libraries are installed in a different location on another machine.</source>
          <target state="translated">시스템 종속 모드. 이것은 또한 기본 모드입니다. Unix ELF 시스템에서는 &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt; / &lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; 항목을 공유 라이브러리 또는 실행 파일에 포함시킵니다. 특히 rts 및 각 패키지의 공유 라이브러리를 찾을 수있는 절대 경로를 사용합니다. 즉, 프로그램을 즉시 실행할 수 있으며 필요한 라이브러리를 찾을 수 있습니다. 그러나 라이브러리가 다른 시스템의 다른 위치에 설치된 경우 배치에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e155fb42dd454dac03073c4506c36df94ce050b3" translate="yes" xml:space="preserve">
          <source>A table of the count of edges from each node.</source>
          <target state="translated">각 노드의 간선 개수 테이블.</target>
        </trans-unit>
        <trans-unit id="e0214aac47583666947c6b02d5dbd5d0f74c69cb" translate="yes" xml:space="preserve">
          <source>A table of the count of edges into each node.</source>
          <target state="translated">각 노드의 가장자리 수 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="9e56547706c1d22e7563bc02015e6d5ea9059fce" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="c5b40ab4ad40ca71821f774d179180ff9dbb3299" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68563c20275c3937fe80971256761864f36ba257" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="d861ca0e3d900bc21406b6b1807bc2b2cf18dc29" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae51b27a95cdff285456cfd64fc7198ed349ffd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="0f49a606d06085ba26fc41ac70ef7f11a81b40cb" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f35d2589fef4b7d60b15566c52bfd61bb4b033fd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 두 맵에있는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="35605a33cfca77541ce0f7a28d4adaaa7f211e60" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 맵에 존재하는 키를 처리하기위한 전술 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22ba35b272e3222b9000490c23cd7a38c265aa2c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="724f196ee83cb8f7d04ef2bfd02c2a5fc6e8942c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="68f6f41d93467c8eca9791eed5e9e6b94541a4bf" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="3768165dc6a607a11a4e4e49c5b342c117fa0f2f" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="9c0f20d68941a262026f0633a3098ddef91196da" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="e901e7cd9f4ef00918e6cc4628a80d9109d39ab6" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="d93c5772a7eda6b6b5cb9d8ee695cda722b263bd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">하나의 맵에는 있지만 다른 하나의 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="e438d5b20c4d0ae49dae9e96e6eb2bd92c80240d" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 맵에는 있지만 다른 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에는없는 키를 다루는 전술 .</target>
        </trans-unit>
        <trans-unit id="c03aaf5092b4ace221cdda40d0db350523640c20" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a13beca0501a32224295f634b47d23e06f1ddb66" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8ba8a10e8973c7adb58835a435c234b5058a0a41" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; WhenMatched f k x y z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a9c18a71365b1b648cf16681fd8c36a0f1c2b1" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMissing f k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; WhenMissing f k x z &lt;/code&gt; 유형의 전술은 &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fa71c38b94fc6a846cbe5d938f6e3e23141ac8bc" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4e05a0a550e141ac884df50db0a9d4c7b208813b" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="788c7aaeca2fa9237bef6f30f44eda24345655ff" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMatched f x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WhenMatched f x y z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8d8ff0b141b2eb58a8bb144bfb707f725b7e036c" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMissing f k x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WhenMissing f k x z&lt;/code&gt; 유형의 전술은 Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt; 유형의 함수를 추상적으로 표현한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ac94aa09dce6e03f7dc40cf67060871ccd2030ef" translate="yes" xml:space="preserve">
          <source>A text format for a type</source>
          <target state="translated">유형의 텍스트 형식</target>
        </trans-unit>
        <trans-unit id="5d64a70b084ed3d99633afca034baca94024378e" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; that specifies how to transate newline characters. The &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; specifies the input and output translation separately, so that for instance you can translate &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; on input, but leave newlines as &lt;code&gt;'\n'&lt;/code&gt; on output.</source>
          <target state="translated">텍스트 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에는 줄 바꿈 문자를 변환하는 방법을 지정하는 관련 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 가 있습니다. &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 는 예를 들어 당신이 번역 할 수 그래서, 별도로 입력 및 출력 변환을 지정하는 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 입력에,하지만 같은 휴가 개행 문자 &lt;code&gt;'\n'&lt;/code&gt; 출력.</target>
        </trans-unit>
        <trans-unit id="e920ef23a8f0e5c9a461f6e5c3a3ecaedd1aa8f0" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;, which is used to decode bytes into Unicode characters when reading, and encode Unicode characters into bytes when writing.</source>
          <target state="translated">텍스트 모드 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에는 연관된 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 이 있으며 , 이는 읽을 때 바이트를 유니 코드 문자로 디코딩하고 쓰는 경우 유니 코드 문자를 바이트로 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afd27d79af07b06b6dd2c8c51dd15b84360a87c3" translate="yes" xml:space="preserve">
          <source>A thread has been created to perform spark evaluation.</source>
          <target state="translated">스파크 평가를 수행하기 위해 스레드가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="513f9205785871fd0e6a34a5a8b00e27eaabc144" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text using lists of packed arrays.</source>
          <target state="translated">묶음 배열 목록을 사용하여 시간과 공간 효율적으로 유니 코드 텍스트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="871d33c09316ac87a1774045ce6be43e65d6fbbd" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">시간과 공간 효율적으로 유니 코드 텍스트를 구현합니다. 대량의 데이터 및 고속 측면에서 성능이 중요한 용도에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="cb913ed9248b4b73bbb05825979d544eb2127ebb" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">대량의 데이터 양 또는 고속 요구 사항 측면에서 고성능 사용에 적합한 압축 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열 목록을 사용하여 시간 및 공간 효율적인 지연 바이트 벡터 구현 . Lazy ByteStrings는 엄격한 바이트 청크의 지연 목록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="87548884e6950ce7611c58d0e6aa6d111ae018da" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">대용량 데이터 또는 고속 요구 사항 측면에서 고성능 사용에 적합한 압축 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 배열 목록을 사용하여 지연 바이트 벡터를 시간 및 공간 효율적으로 구현 합니다. Lazy ByteStrings는 엄격한 바이트 청크의 lazy 목록으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a51040e6bbff0d1db2681967125dbcf0660a785a" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">대량의 데이터 양과 고속 요구 사항 모두에서 고성능 사용에 적합한 팩형 Word8 배열을 사용하여 시간 및 공간 효율적으로 바이트 벡터를 구현합니다. 바이트 벡터는 엄격한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 바이트 배열 로 인코딩되어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 로 유지 되며 C와 Haskell간에 약간의 노력만으로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5048b9a802cb3ce698b367ba1957e1c7c15edd" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">대용량 데이터 양과 고속 요구 사항 모두에서 고성능 사용에 적합한 패킹 된 Word8 배열을 사용하여 바이트 벡터를 시간 및 공간 효율적으로 구현합니다. 바이트 벡터는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 보관 된 엄격한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 바이트 배열 로 인코딩되며 , 적은 노력으로 C와 Haskell간에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe6c6fa0b66fdbc97157d1012689fd665f63f77" translate="yes" xml:space="preserve">
          <source>A timeout registration cookie.</source>
          <target state="translated">타임 아웃 등록 쿠키.</target>
        </trans-unit>
        <trans-unit id="9e5d778e506d2310054d3157a8637a07f1af1107" translate="yes" xml:space="preserve">
          <source>A top-level declaration</source>
          <target state="translated">최상위 선언</target>
        </trans-unit>
        <trans-unit id="c16187723ff5e241fc07ce9bf83e42940dac6da5" translate="yes" xml:space="preserve">
          <source>A topological sort of the graph. The order is partially specified by the condition that a vertex &lt;em&gt;i&lt;/em&gt; precedes &lt;em&gt;j&lt;/em&gt; whenever &lt;em&gt;j&lt;/em&gt; is reachable from &lt;em&gt;i&lt;/em&gt; but not vice versa.</source>
          <target state="translated">토폴로지 종류의 그래프. 순서는 부분적 정점한다는 조건에 의해 지정된 &lt;em&gt;나&lt;/em&gt; 선행 &lt;em&gt;J을&lt;/em&gt; 마다 &lt;em&gt;J는&lt;/em&gt; 로부터 도달 &lt;em&gt;I&lt;/em&gt; 반대로 아니지만.</target>
        </trans-unit>
        <trans-unit id="4693f1c5c0fbb57b8d5c4df19d87586bf13001db" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 질문입니다 . 이 결합자는 내부적으로 비동기 예외에 의존합니다 (즉, 계산에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; 예외 발생). 이 기술은 Haskell 런타임 시스템 내부에서 실행되는 계산에 매우 잘 작동하지만 Haskell이 아닌 코드에서는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에 외부 함수 호출은이 결합 자로 시간 초과 될 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 차단하는 FFI 호출을 래핑하는 데 사용되며 FFI 호출이 반환 될 때까지 시간 초과 이벤트가 전달 될 수 없으므로 결합 자의 목적이 거의 무효화됩니다. 그러나 실제로이 제한은 생각할 수있는 것보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; , Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 과 같은 표준 I / O 함수 가 차단되는 것처럼 보이지만 실제로는 런타임 시스템이 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행 하기 때문에 그렇지 않습니다. 이 결합기를 사용하여 표준 소켓 I / O 또는 파일 I / O를 인터럽트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6efe802c821d7daf17899a761feb1bf7a82692b9" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 문제입니다 . 이 결합기는 내부적으로 비동기 예외에 의존합니다. 이 기술은 Haskell 런타임 시스템 내에서 실행되는 계산에는 매우 효과적이지만 Haskell이 아닌 코드에는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합기로 외부 함수 호출을 시간 종료 할 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 블록, 제한 시간 이벤트가 거의 콤비의 목적을 부정 FFI 호출이 반환까지 전달되지 수 있다는 FFI 호출을 래핑하는 데 사용됩니다. 그러나 실제로이 제한은 소리보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; 와 같은 표준 I / O 기능, Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 이 차단 된 것으로 보이지만 런타임 시스템은 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행하므로 표준 소켓 I / O를 중단 할 수 있기 때문에 실제로는 그렇지 않습니다 또는이 결합기를 사용하는 파일 I / O.</target>
        </trans-unit>
        <trans-unit id="41f5a544b2c86e8b88cd4fa644eb1707b05f6a06" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">까다로운 구현 세부 사항은 &lt;code&gt;IO&lt;/code&gt; 계산 을 중단하는 방법에 대한 문제입니다 . 이 결합기는 내부적으로 비동기 예외에 의존합니다. 이 기술은 Haskell 런타임 시스템 내에서 실행되는 계산에는 매우 효과적이지만 Haskell이 아닌 코드에는 전혀 작동하지 않습니다. 예를 들어, 임의의 C 함수가 비동기 예외를 수신 할 수 없기 때문에이 결합기로 외부 함수 호출을 시간 종료 할 수 없습니다. 때 &lt;code&gt;timeout&lt;/code&gt; 블록, 제한 시간 이벤트가 거의 콤비의 목적을 부정 FFI 호출이 반환까지 전달되지 수 있다는 FFI 호출을 래핑하는 데 사용됩니다. 그러나 실제로이 제한은 소리보다 덜 심각합니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; 와 같은 표준 I / O 기능, Network.Socket.accept 또는 &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 이 차단 된 것으로 보이지만 런타임 시스템은 &lt;code&gt;select(2)&lt;/code&gt; 와 같은 스케줄링 메커니즘을 사용 하여 비동기 I / O를 수행하므로 표준 소켓 I / O를 중단 할 수 있기 때문에 실제로는 그렇지 않습니다 또는이 결합기를 사용하는 파일 I / O.</target>
        </trans-unit>
        <trans-unit id="966e03642cf0118fe092db70abdc7d1b27e6b71d" translate="yes" xml:space="preserve">
          <source>A type</source>
          <target state="translated">유형</target>
        </trans-unit>
        <trans-unit id="b12eefa8f8a22f3c9c1c70d44c19389c8c5386e5" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one, and a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) such that</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 가 연관 기능을 제공하는 경우 ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; )가 어떤 유형의 두 값을 결합 할 것을 &lt;code&gt;a&lt;/code&gt; 하나로하고, 중립 요소 ( &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 해당) 등</target>
        </trans-unit>
        <trans-unit id="900bea671831ed1ce8158cdebd74c597c210974a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one. Where being associative means that the following must always hold:</source>
          <target state="translated">A 형 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 이 연관 기능을 제공하는 경우 ( &lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; )는 타입의 두 값을 결합 할 수 있습니다 그 &lt;code&gt;a&lt;/code&gt; 하나에. 연관성이 있다는 것은 다음을 항상 유지해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c36da43acccbf65c4959f463c0fb381ab69f5fb" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; lets you apply any function from &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;. Furthermore &lt;code&gt;f&lt;/code&gt; needs to adhere to the following:</source>
          <target state="translated">A 형 &lt;code&gt;f&lt;/code&gt; 이 기능 제공하면 펑터이다 &lt;code&gt;fmap&lt;/code&gt; 함수 어떤 종류 주어진 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 는 사용자가 어떠한 기능을 적용 할 수 &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 설정하는 &lt;code&gt;f a&lt;/code&gt; 에 &lt;code&gt;f b&lt;/code&gt; 의 구조 보존 &lt;code&gt;f&lt;/code&gt; . 또한 &lt;code&gt;f&lt;/code&gt; 는 다음을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8dc677defa7be455d6125e7b6e0f1fcd1c4b205" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, lets you apply any function of type &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">A 형 &lt;code&gt;f&lt;/code&gt; 이 기능 제공하면 펑터이다 &lt;code&gt;fmap&lt;/code&gt; 함수 어떤 유형에게 주어진 및 &lt;code&gt;b&lt;/code&gt; 사용하면 유형의 기능을 적용 할 수, &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 설정하는 &lt;code&gt;f a&lt;/code&gt; 에 &lt;code&gt;f b&lt;/code&gt; 의 구조 보존 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5b73b56591ee75fd4320cdb138584a6631c70e7" translate="yes" xml:space="preserve">
          <source>A type application.</source>
          <target state="translated">타입 어플리케이션.</target>
        </trans-unit>
        <trans-unit id="4843d11f8e6edd0b1d5c045f927fdb0d7d055f98" translate="yes" xml:space="preserve">
          <source>A type constructor or class can be any non-reserved operator. Symbols used in types are always like capitalized identifiers; they are never variables. Note that this is different from the lexical syntax of data constructors, which are required to begin with a &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">유형 생성자 또는 클래스는 예약되지 않은 연산자 일 수 있습니다. 유형에 사용 된 기호는 항상 대문자 식별자와 같습니다. 그들은 결코 변수가 아닙니다. 이것은 데이터 생성자의 어휘 구문과 다르며, &lt;code&gt;:&lt;/code&gt; 은 : 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2957975b2e2a0d72a85cca6ba60d8dc7b412130f" translate="yes" xml:space="preserve">
          <source>A type context can include equality constraints of the form &lt;code&gt;t1 ~ t2&lt;/code&gt;, which denote that the types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</source>
          <target state="translated">타입 컨텍스트는 &lt;code&gt;t1 ~ t2&lt;/code&gt; 형식의 등식 제약 조건을 포함 할 수 있으며 , 이는 타입 &lt;code&gt;t1&lt;/code&gt; 과 &lt;code&gt;t2&lt;/code&gt; 가 동일해야 함을 나타냅니다 . 유형 패밀리가 존재하는 경우 일반적으로 두 유형이 동일한 지 여부를 로컬에서 결정할 수 없습니다. 따라서 함수 시그니처의 컨텍스트에는 다음 예와 같이 등식 제한 조건이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb43eef001aa96d23cb8f2b1045baf5a1fc027f" translate="yes" xml:space="preserve">
          <source>A type family can also be declared with a &lt;code&gt;where&lt;/code&gt; clause, defining the full set of equations for that family. For example:</source>
          <target state="translated">유형 패밀리는 &lt;code&gt;where&lt;/code&gt; 절로 선언하여 해당 패밀리에 대한 전체 방정식 세트를 정의 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ca042aa66fa2759abc533fbf4e600be254b35ae" translate="yes" xml:space="preserve">
          <source>A type family to compute Boolean equality.</source>
          <target state="translated">부울 동등성을 계산하기위한 유형 군입니다.</target>
        </trans-unit>
        <trans-unit id="8eff1fa8083a3c76f23688ec0faf2770e8f9b619" translate="yes" xml:space="preserve">
          <source>A type is &amp;ldquo;rigid&amp;rdquo; if it is completely known to the compiler at its binding site. The easiest way to ensure that a variable a rigid type is to give it a type signature. For more precise details see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;Simple unification-based type inference for GADTs&lt;/a&gt;. The criteria implemented by GHC are given in the Appendix.</source>
          <target state="translated">바인딩 사이트의 컴파일러에 완전히 알려진 유형은 &quot;견고한&quot;유형입니다. 변수에 엄격한 유형을 지정하는 가장 쉬운 방법은 유형 서명을 제공하는 것입니다. 보다 정확한 세부 사항은 &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;GADT에 대한 단순 통합 기반 유형 유추를&lt;/a&gt; 참조하십시오 . GHC에 의해 구현 된 기준은 부록에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6dc84a99a51911e396803e6f137d1ec9e7ecb5" translate="yes" xml:space="preserve">
          <source>A type or data family, with a list of its visible instances. A closed type family is returned with 0 instances.</source>
          <target state="translated">보이는 인스턴스 목록이있는 유형 또는 데이터 패밀리. 닫힌 유형 패밀리는 0 개의 인스턴스와 함께 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a858ee617d52cf82c99429cf69589bf7daf3b44" translate="yes" xml:space="preserve">
          <source>A type or kind variable explicitly bound using &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; but not used on the left hand side will generate an error, not a warning.</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 을&lt;/a&gt; 사용하여 명시 적 으로 바인딩 되었지만 왼쪽에 사용되지 않은 유형 또는 종류 변수 는 경고가 아니라 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13dc503b524051e73bf1854416495a7c476690ef" translate="yes" xml:space="preserve">
          <source>A type representing a number of UTF-16 code units.</source>
          <target state="translated">많은 UTF-16 코드 단위를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fac7b1b31387a5dce83f6207988f33acc423d8c4" translate="yes" xml:space="preserve">
          <source>A type signature may occur in any pattern; this is a &lt;em&gt;pattern type signature&lt;/em&gt;. For example:</source>
          <target state="translated">형식 서명은 어떤 패턴으로도 발생할 수 있습니다. 이것은 &lt;em&gt;패턴 유형 서명&lt;/em&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8682a8a15f37e1952f2bed70e4a76505ad01ea0d" translate="yes" xml:space="preserve">
          <source>A type variable applied to some types:</source>
          <target state="translated">일부 유형에 적용되는 유형 변수 :</target>
        </trans-unit>
        <trans-unit id="9bfcbaf65cc2630df1737c174af7d766948febae" translate="yes" xml:space="preserve">
          <source>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</source>
          <target state="translated">밑줄로 시작하는 유형 변수는 유형 또는 데이터 인스턴스 선언에서 특별히 처리되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ca958f1089d3d1582d1c30aba329c8223832dd9" translate="yes" xml:space="preserve">
          <source>A type variable.</source>
          <target state="translated">타입 변수.</target>
        </trans-unit>
        <trans-unit id="297b034e775e243ef7a125f9be96bd9336678f08" translate="yes" xml:space="preserve">
          <source>A typed expression splice can occur in place of an expression; the spliced expression must have type &lt;code&gt;Q (TExp a)&lt;/code&gt;</source>
          <target state="translated">식 대신에 형식화 된 식 스플 라이스가 발생할 수 있습니다. 스 플라이 싱 된 표현식은 유형 &lt;code&gt;Q (TExp a)&lt;/code&gt; 를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="fff5bdf005b35f179294ba275419d126af32c8a0" translate="yes" xml:space="preserve">
          <source>A typical heap object may be in one of the following four states at each point in its lifetime:</source>
          <target state="translated">일반적인 힙 객체는 수명의 각 시점에서 다음 4 가지 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e00c4c8e7f8a62193a99b6e6434c24bc66d1ce8" translate="yes" xml:space="preserve">
          <source>A typical use is to prevent resource leaks in lazy IO programs, by forcing all characters from a file to be read. For example:</source>
          <target state="translated">일반적으로 파일의 모든 문자를 읽도록하여 지연 IO 프로그램에서 리소스 누수를 방지합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb52c77586fd9d5d1d5e06c0781fa29b45252709" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; for recovery looks like this:</source>
          <target state="translated">복구 에 &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; 를 사용하는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5fa8bc47ca59ba407ee77bfa4f457f11af6f63d" translate="yes" xml:space="preserve">
          <source>A unique &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; object Used when the strings are dynamically allocated, eg from binary deserialisation</source>
          <target state="translated">고유 한 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 객체 문자열이 동적으로 할당 될 때 사용됩니다 (예 : 이진 역 직렬화)</target>
        </trans-unit>
        <trans-unit id="6e0b23e86250bf5ded8e24685820d0cba5c52892" translate="yes" xml:space="preserve">
          <source>A unique identifier used to refer to the cost-centre</source>
          <target state="translated">비용 중심을 나타내는 데 사용되는 고유 식별자</target>
        </trans-unit>
        <trans-unit id="e2b058205e0073a16e899cb4a51295d96e6d2af1" translate="yes" xml:space="preserve">
          <source>A unique local name</source>
          <target state="translated">고유 한 현지 이름</target>
        </trans-unit>
        <trans-unit id="1f67274a4c72a292a8769f67401cc21d34e5f22d" translate="yes" xml:space="preserve">
          <source>A use of &lt;code&gt;MkSet&lt;/code&gt; as a constructor (e.g. in the definition of &lt;code&gt;makeSet&lt;/code&gt;) gives rise to a &lt;code&gt;(Eq a)&lt;/code&gt; constraint, as you would expect. The new feature is that pattern-matching on &lt;code&gt;MkSet&lt;/code&gt; (as in the definition of &lt;code&gt;insert&lt;/code&gt;) makes &lt;em&gt;available&lt;/em&gt; an &lt;code&gt;(Eq a)&lt;/code&gt; context. In implementation terms, the &lt;code&gt;MkSet&lt;/code&gt; constructor has a hidden field that stores the &lt;code&gt;(Eq a)&lt;/code&gt; dictionary that is passed to &lt;code&gt;MkSet&lt;/code&gt;; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to &lt;code&gt;elem&lt;/code&gt;, so that the type of &lt;code&gt;insert&lt;/code&gt; itself has no &lt;code&gt;Eq&lt;/code&gt; constraint.</source>
          <target state="translated">의 사용 &lt;code&gt;MkSet&lt;/code&gt; (의 정의에 예를 들어 생성자로 &lt;code&gt;makeSet&lt;/code&gt; 은 )는에 상승 제공 &lt;code&gt;(Eq a)&lt;/code&gt; 당신이 기대하는 것처럼, 제약. 새로운 기능은 &lt;code&gt;MkSet&lt;/code&gt; 의 패턴 일치 ( &lt;code&gt;insert&lt;/code&gt; 정의에서와 같이 )가 &lt;code&gt;(Eq a)&lt;/code&gt; 컨텍스트를 &lt;em&gt;사용할 수 있다는&lt;/em&gt; 것 입니다. 구현 용어로 &lt;code&gt;MkSet&lt;/code&gt; 생성자는 &lt;code&gt;MkSet&lt;/code&gt; 에 전달 된 &lt;code&gt;(Eq a)&lt;/code&gt; 사전을 저장하는 숨겨진 필드 를 갖습니다 . 따라서 패턴 일치시 해당 사전이 일치하는 오른쪽에 사용 가능해집니다. 이 예에서, 동등 사전은 다음에 대한 호출에 의해 생성 된 동등 제한 조건을 만족시키는 데 사용됩니다. &lt;code&gt;elem&lt;/code&gt; &lt;code&gt;insert&lt;/code&gt; 자체 의 유형에 &lt;code&gt;Eq&lt;/code&gt; 제한 조건 이 없도록 elem .</target>
        </trans-unit>
        <trans-unit id="c1353efcd4777e1aa99c83066c3c4fd8238bee7d" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">디버깅 목적으로 유용한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; - like 함수입니다.</target>
        </trans-unit>
        <trans-unit id="86295d409cfd9cf7cbef34ae7b547dcc96dc0f25" translate="yes" xml:space="preserve">
          <source>A useful default. In particular:</source>
          <target state="translated">유용한 기본값입니다. 특히:</target>
        </trans-unit>
        <trans-unit id="f8c74a72bfde3e2ebcf4f91dbf953debbfc38d10" translate="yes" xml:space="preserve">
          <source>A useful idiom permitted by the above rules is as follows. If one allows overlapping instance declarations then it&amp;rsquo;s quite convenient to have a &amp;ldquo;default instance&amp;rdquo; declaration that applies if something more specific does not:</source>
          <target state="translated">위의 규칙에서 허용되는 유용한 관용구는 다음과 같습니다. 겹치는 인스턴스 선언을 허용하는 경우보다 구체적인 내용이없는 경우 적용되는&amp;ldquo;기본 인스턴스&amp;rdquo;선언을 사용하는 것이 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a0a8e93d7731f26de07f8a99cabb013a2ca2c78f" translate="yes" xml:space="preserve">
          <source>A useful option to alert you when interfaces change is &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; option. It will run &lt;code&gt;diff&lt;/code&gt; on the changed interface file, before and after, when applicable.</source>
          <target state="translated">인터페이스 변경시 경고하는 유용한 옵션은 &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; 옵션입니다. 적용 가능한 전후에 변경된 인터페이스 파일에서 &lt;code&gt;diff&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="48bece416cc59f93fda6101dbf5899713474b8a5" translate="yes" xml:space="preserve">
          <source>A user could provide, for example, a &lt;code&gt;GSerialize UInt&lt;/code&gt; instance so that a &lt;code&gt;Serialize IntHash&lt;/code&gt; instance could be easily defined in terms of &lt;code&gt;GSerialize&lt;/code&gt;.</source>
          <target state="translated">사용자는 예를 들면, 제공 할 수 &lt;code&gt;GSerialize UInt&lt;/code&gt; 인스턴스가되도록 &lt;code&gt;Serialize IntHash&lt;/code&gt; 인스턴스 용이의 관점에서 정의 될 수 &lt;code&gt;GSerialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dd220d0ff116d56be2881c3c2eda319a7be24bc" translate="yes" xml:space="preserve">
          <source>A user log message (from, e.g., &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt;).</source>
          <target state="translated">사용자 로그 메시지 (예 : &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5483fab05ffacd5a3f560ae7afd7921c21d6c2" translate="yes" xml:space="preserve">
          <source>A user marker (from &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt;).</source>
          <target state="translated">사용자 마커 ( &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4bf4989d597f060b1f221f4d9b40f8cbdd26cf10" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; is an object encapsulated together with its type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 유형의 값은 해당 유형과 함께 캡슐화 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5e578226b20de3d07741dafad66454d118f3458d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5e81410f386c89f452d754e65a825472786597c7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f136bc98f2d8137b486a143123edbe9b3241275" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd6a3283ff99f274500f801cf1370f639df9d9c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="afb41f27d10d971b0c644adebd15549eb369a006" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239d8e1787a28722de24cac0f475ff48393d312a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cdd07d411abaf19b949230fd787b91d7248467" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="a20081f01fcf352f0cfcb6c5a5c6d192ad5b3810" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 외부 코드에서 호출 가능한 함수에 대한 포인터입니다. 유형 &lt;code&gt;a&lt;/code&gt; 는 일반적으로 &lt;em&gt;외부 유형&lt;/em&gt; 이며, 인수가 0 개 이상인 함수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6305ddbae16f3512160787cb992d3e58bee68afe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 유형의 값은 다른 외부 함수에 의해 리턴되거나 다음과 같은 정적 주소 가져 오기로 가져온 외부 함수에 대한 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be954ea62342aa30dc2f597f01c234102f416fd" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90894fbb07b5d90eacb70ed7f8519e1d7af5b5d4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="5f741bc04d3ebabbc8052c3e8ced2a6bbb1b0a05" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">입력 값 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 객체에 대한 포인터 나 또는 유형의 하스켈 값으로부터 정렬 화 될 수 객체 배열 나타내고 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e06d2b58f261c19e13fe9c8981e6d1218570c7c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 유형의 값은 수행 될 때 a 유형 &lt;code&gt;a&lt;/code&gt; 값을 리턴하기 전에 일부 I / O를 수행하는 계산입니다 .</target>
        </trans-unit>
        <trans-unit id="65e2250aafb04e86e024b91238925a6bb2963b39" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;StablePtr a&lt;/code&gt; is a stable pointer to a Haskell expression of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StablePtr a&lt;/code&gt; 유형의 값 은 a 유형 &lt;code&gt;a&lt;/code&gt; Haskell 표현식에 대한 안정적인 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="013a61726b4b56a72c4ddab274465f1e28f21c9f" translate="yes" xml:space="preserve">
          <source>A variable is &lt;em&gt;closed&lt;/em&gt; if and only if</source>
          <target state="translated">다음 과 같은 경우에만 변수가 &lt;em&gt;닫힙니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0624bb33a678b07c2a300b904ae61401b2b3e3" translate="yes" xml:space="preserve">
          <source>A variable is called &lt;em&gt;dynamically bound&lt;/em&gt; when it is bound by the calling context of a function and &lt;em&gt;statically bound&lt;/em&gt; when bound by the callee&amp;rsquo;s context. In Haskell, all variables are statically bound. Dynamic binding of variables is a notion that goes back to Lisp, but was later discarded in more modern incarnations, such as Scheme. Dynamic binding can be very confusing in an untyped language, and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables.</source>
          <target state="translated">변수는 함수의 호출 컨텍스트에 의해 &lt;em&gt;바인드&lt;/em&gt; 될 때 &lt;em&gt;동적으로 바인드&lt;/em&gt; 됩니다.&lt;em&gt;&lt;/em&gt; 되고 호출자의 컨텍스트에 의해 &lt;em&gt;바인드&lt;/em&gt; 될 때 &lt;em&gt;정적으로 바인드&lt;/em&gt; 됩니다. Haskell에서 모든 변수는 정적으로 바인딩됩니다. 변수의 동적 바인딩은 Lisp으로 돌아가는 개념이지만 나중에 Scheme과 같은 더 현대적인 화신에서 버려졌습니다. 동적 바인딩은 형식화되지 않은 언어에서 매우 혼동 될 수 있으며 불행히도 형식화 된 언어, 특히 Haskell과 같은 Hindley-Milner 형식의 언어는 변수의 정적 범위 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e557c6a254bde2fa9fce694bac49fbabbe6203a2" translate="yes" xml:space="preserve">
          <source>A variable is regarded as &amp;ldquo;used&amp;rdquo; if</source>
          <target state="translated">변수는&amp;ldquo;사용 된&amp;rdquo;것으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="ef00f1720266eda76457e7e8274afd0d351d58ec" translate="yes" xml:space="preserve">
          <source>A variable-length event encoding a heap sample broken down by,</source>
          <target state="translated">힙 샘플을 인코딩하는 가변 길이 이벤트는</target>
        </trans-unit>
        <trans-unit id="b96521844e19dff99bc29450ed4b5c3e48d9657d" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a heap profile sample broken down by,</source>
          <target state="translated">힙 프로파일 샘플을 인코딩하는 가변 길이 패킷은</target>
        </trans-unit>
        <trans-unit id="d2629ff819bfa2b3bc89a988e7b72caf2ad22ebf" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a profile sample.</source>
          <target state="translated">프로필 샘플을 인코딩하는 가변 길이 패킷입니다.</target>
        </trans-unit>
        <trans-unit id="661a750d420cf956ff31ac1cd27a77853ed3578e" translate="yes" xml:space="preserve">
          <source>A variable-length packet produced once for each cost centre,</source>
          <target state="translated">각 코스트 센터마다 한 번씩 생산되는 가변 길이 패킷</target>
        </trans-unit>
        <trans-unit id="5d1f67f8c131ae27aed80d2e73f0a9a08edfca88" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 변형인수가 반대 .</target>
        </trans-unit>
        <trans-unit id="bdb2d179c96dfc9014b723ecd18ad20eb9df0287" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">첫 번째 계산의 반환 값이 필요하지 않은 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f484ec182618f59bc6a03fa556e1dfe4602922b2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="1a806f7ef066f93f4459cf71c970f146b042ce14" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught (c.f. &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;). If the exception does not match the predicate, it is re-thrown.</source>
          <target state="translated">발견 된 예외를 선택하기 위해 예외 술어를 사용하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 의 변형 (cf &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; ). 예외가 술어와 일치하지 않으면 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="980dc5b1188b883f4b0698253298fdcc03f22555" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="4ec6ceddfeaaf45a25f723cacb495b1ccc3c2250" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="d552c9d4da515c75912002c65ae5ebd55983c353" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="2be03be1f4f972f3e16388053b30f3f14523b03b" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="3d7eba7d8d00a5efd27077394673889a22d85d24" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">새로운 상태에서 계산이 엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="f8879cc31acc8932b5c49885c6d29e918117f2f5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 비 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d4bfbfcd281f231983e2d29e27a74b95a66a32" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 비 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c2bc37d962248156836e2639fc6b4dadc3fba3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; that is strict in the accumulator.</source>
          <target state="translated">누산기에 엄격한 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="18749169ab66a243e5d3ff1e282a5a0fa0dd77c7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="c779c916890acc8970f5fe31251b940c218fccc0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddfd37c7061963e7b77b06bdb4fbd084e4a8097" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7defbd1e72da7e4dd78ff7b670071a5b458cf24a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ee1d48660b932b3bb180c1aaef20eee11c73c0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">인수가 반대 인 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 변형 .</target>
        </trans-unit>
        <trans-unit id="d32ebdebb4f9a3837e2e7d4648c8bd7eceb6c9f2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">스택 추적을 생성하지 않는 &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f23407f9c31b9d9550363e44222113e312af065d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="228eb2d34fa954a72d817265f3ac30a2c4d0f77c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0680130bb0f4b8f4cbc7c8b028930fd44a3af9ce" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="0ec4492419779cfaef51be94d2b8f28e80c4545f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="491efa58eb1f11c0cb3815ae8f348ca0c034ce84" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="47d036c06686a27eae150f0188962179aa6b3b53" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="da53c6399c31d81bfdb2f650d84ca62634038b07" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 변형 .</target>
        </trans-unit>
        <trans-unit id="73f171fdb5237d901b1c481374b6861edf14fa56" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">스택 추적을 생성하지 않는 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="47f3f2679bc0ad75bdf30646c6761ef6c4b68243" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가 없으므로 비어 있지 않은 구조에만 적용 할 수있는 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="477f918f68cdb05044cf99fdb58a555808faeff3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">기본 사례가없는 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 변형으로 비어 있지 않은 구조에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6911589d252df6b0d320b35e4685df9e30028055" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">첫 번째 계산의 반환 값이 필요하지 않은 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="add459265a4128073f2963ebb449fbb05ec6cb08" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 은 프로그래머에게 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 라는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="022677c1577a85e404387475e8f412822a05da7e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString 의 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 는 빈 케이스 검사를 생략하므로 ByteString이 비어 있지 않다는 증거를 프로그래머에게 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b4ffb4fe31d0195b8acddfad454298b4604216b" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 은 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d777dc5f4859f53e852d78b2a883751d3a5e477" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 는 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e791ecae2adcb55aa4c85c7e30c588765957cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 은 빈 케이스 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd0eca831b19e2193bae89b92f0b4e215f8baf4c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 는 프로그래머에게 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 라는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d61fdfe5cc2564d603aac91be2fa83ba8aa2a7c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 이므로 프로그래머는 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06fb91e894a0b25610b75a5af5b9808209630d25" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략하므로 프로그래머는 ByteString이 비어 있지 않다는 증거를 제공 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdce50acace32ba6eb0fe5af8f10f59503ea5260" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="416bf67712d94a4092fa1366ed0a1243511ca321" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteStrings에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 는 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="73173fcba7dc4f1755bea5939f3721c98a85b2cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">비어 있지 않은 ByteString에 대한 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 은 빈 케이스에 대한 검사를 생략합니다. 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; , 프로그래머는 ByteString 비 비어 별도의 증거를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="91ba6eac709468119bb502dc4a786ac25beaa443" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 에 대한 검사를 생략 하는 다양한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 는 프로그래머가 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;길이&lt;/a&gt; xs 증명을 제공해야 할 의무가 있습니다.</target>
        </trans-unit>
        <trans-unit id="011da0f3d1d6c75639ffb6db3b663d10df8596d2" translate="yes" xml:space="preserve">
          <source>A version can be tagged with an arbitrary list of strings. The interpretation of the list of tags is entirely dependent on the entity that this version applies to.</source>
          <target state="translated">임의의 문자열 목록으로 버전에 태그를 지정할 수 있습니다. 태그 목록의 해석은이 버전이 적용되는 엔티티에 전적으로 의존합니다.</target>
        </trans-unit>
        <trans-unit id="ecaf2ca21f3f2373e5185cd515851b6e67ee803a" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="60ffeb4910a01e5cd6d72fcebc814ef710471656" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0b08df2ea8c4c791467734758ae49b0aa839c743" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ef5e78e2ce5a1352cca108846156255775dd7108" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ff76e55acfcccd02a15d736db81fe96146722925" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="28577cb8a660e56c217a279acfd2976c3b7454ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 의 기능 시도는 가치 넣어 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 이 성공적으로, 또는 인 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01dc8f0973fefa88de9a13d12ee694150980b61d" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ed2b50c296f40c959a6e33c87f8de3078552d7bb" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 함수를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 빈 없었다, 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5433d7bb6120760452598bf6c542c3024a31c810" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 버전 . &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 함수를 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 는 IF &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 빈 없었다, 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 내용으로 가득했습니다 . 후 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 는 비어 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e30f3fd19a32279f9ca43fcf5051a4b725b4afb0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">다시 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; 의 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2433a0ad5e90f34ad9f4bf45621e0ceb170fdea6" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">재 시도하지 않는 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; 버전입니다 . 대신 값을 사용할 수 없으면 &lt;code&gt;Nothing&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4fc561502aa5288942ce875d139d9631abcf512c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</source>
          <target state="translated">인수가 바뀌는 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 버전 . 핸들러 코드가 더 짧은 상황에서 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3e44a662ef33517cd5d56bc8e42cf32ad0c3d0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; with the arguments swapped around (see &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">인수가 교체 된 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 버전 ( &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e66efe0c3f15c8fafbf44d9ce27299363bc807ef" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; that forces the (pair) result of the function.</source>
          <target state="translated">함수의 (쌍) 결과를 강제하는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 버전 .</target>
        </trans-unit>
        <trans-unit id="bef2aa5115f3db1a79e2efec0dfffeeae204b525" translate="yes" xml:space="preserve">
          <source>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</source>
          <target state="translated">수직 막대는 분리를 나타내며, 즉 두면 중 하나가 필요합니다. 쉼표는 연결을 나타냅니다. 즉, 양쪽이 필요합니다. 연결은 분리보다 더 강력하게 결속됩니다.</target>
        </trans-unit>
        <trans-unit id="edf34a57d05a3c5d4ea50057dd0ce34f6a6b36fa" translate="yes" xml:space="preserve">
          <source>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">사전 값 표현을 옵티 마이저에게 저렴하게 만드는 매우 실험적인 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="7c65e4b2cb887d618e9c4063061a15033cdc0051" translate="yes" xml:space="preserve">
          <source>A violation of the &amp;ldquo;forall-or-nothing&amp;rdquo; rule looks like this:</source>
          <target state="translated">&quot;전부 또는 무관 용&quot;규칙 위반은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5feb9baead6354d4dfbb9ad7fa5678327d72c84" translate="yes" xml:space="preserve">
          <source>A visible type application is preceded with an &lt;code&gt;@&lt;/code&gt; sign. (To disambiguate the syntax, the &lt;code&gt;@&lt;/code&gt; must be preceded with a non-identifier letter, usually a space. For example, &lt;code&gt;read@Int 5&lt;/code&gt; would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</source>
          <target state="translated">보이는 유형의 응용 프로그램 앞에는 &lt;code&gt;@&lt;/code&gt; 기호가 있습니다. 구문을 명확하게 나타내려면 &lt;code&gt;@&lt;/code&gt; 앞에 공백이 아닌 식별자 문자가 있어야합니다. 예를 들어 &lt;code&gt;read@Int 5&lt;/code&gt; 는 구문 분석하지 않습니다. 함수의 전체 다형성 유형이 알려질 때마다 사용할 수 있습니다. 함수가 식별자 (일반적인 경우) 인 경우 식별자에 형식 서명이 제공된 경우에만 해당 형식이 알려진 것으로 간주됩니다. 식별자에 형식 서명이 없으면 보이는 형식 응용 프로그램을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7aecd3b32383a90db727ba6bc951dd96bb7555b" translate="yes" xml:space="preserve">
          <source>A way of creating ByteStrings outside the IO monad. The &lt;code&gt;Int&lt;/code&gt; argument gives the final size of the ByteString.</source>
          <target state="translated">IO 모나드 외부에서 ByteString을 작성하는 방법입니다. &lt;code&gt;Int&lt;/code&gt; 인수는 ByteString의 최종 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ae700162fd083eb51a2e5484581b63431c6cf961" translate="yes" xml:space="preserve">
          <source>A weak pointer expresses a relationship between two objects, the &lt;em&gt;key&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt;: if the key is considered to be alive by the garbage collector, then the value is also alive. A reference from the value to the key does &lt;em&gt;not&lt;/em&gt; keep the key alive.</source>
          <target state="translated">약한 포인터는 &lt;em&gt;키&lt;/em&gt; 와 &lt;em&gt;값&lt;/em&gt; 의 두 개체 간의 관계를 나타냅니다 . 가비지 수집기가 키를 살아있는 것으로 간주하면 값도 살아 있습니다. 값에서 키로의 참조는 키를 유지 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0a7ed1da2479162371079b8163cabf26c83c98" translate="yes" xml:space="preserve">
          <source>A weak pointer may also have a finalizer of type &lt;code&gt;IO ()&lt;/code&gt;; if it does, then the finalizer will be run at most once, at a time after the key has become unreachable by the program (&quot;dead&quot;). The storage manager attempts to run the finalizer(s) for an object soon after the object dies, but promptness is not guaranteed.</source>
          <target state="translated">약한 포인터는 &lt;code&gt;IO ()&lt;/code&gt; 유형의 종료 자를 가질 수도 있습니다 . 만약 그렇다면, 프로그램이 키에 접근 할 수 없게 된 후 ( &quot;데드&quot;) 파이널 라이저는 최대 한 번 실행됩니다. 스토리지 관리자는 오브젝트가 종료 된 직후 오브젝트에 대한 종료자를 실행하려고하지만 프롬프트가 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a955a161a9eee216cd6b80d8d47df1c807c9be34" translate="yes" xml:space="preserve">
          <source>A weak pointer object with a key and a value. The value has type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">키와 값을 가진 약한 포인터 객체. 값의 유형은 &lt;code&gt;v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b5c16f462f6b8ca64b6aee48fd180f321af7cba" translate="yes" xml:space="preserve">
          <source>A whole String fragment</source>
          <target state="translated">전체 문자열 조각</target>
        </trans-unit>
        <trans-unit id="1306d902863c6c0a77b6f4d1230a385868937f62" translate="yes" xml:space="preserve">
          <source>A wide character string with explicit length information in &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt;s instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">종료 NUL (문자열 중간에 NUL 문자 허용) 대신 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt; s 에 명시 적 길이 정보가있는 넓은 문자열.</target>
        </trans-unit>
        <trans-unit id="987253a26575543a06fc7e055fbc0251b63eb205" translate="yes" xml:space="preserve">
          <source>A word begins either at the start of the line or after an unescaped whitespace character.</source>
          <target state="translated">줄의 시작 부분이나 이스케이프 처리되지 않은 공백 문자 다음에 단어가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="98bca88a2b006e940b1f7f785915d961c11c9f72" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">출력 유형 &lt;code&gt;w&lt;/code&gt; 에 의해 매개 변수화 된 라이터 모나드 가 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="07ef82639a79658d53d1fcd5bfce5876d5b9adb5" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by:</source>
          <target state="translated">다음에 의해 매개 변수화 된 작성자 모나드 :</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="882edca3292f207f02c04f0e4d828075132b5c5b" translate="yes" xml:space="preserve">
          <source>ADDATTRS</source>
          <target state="translated">ADDATTRS</target>
        </trans-unit>
        <trans-unit id="d37db076be2c745cf98c9bb60cf88dbf2626e6b7" translate="yes" xml:space="preserve">
          <source>AM/PM symbols</source>
          <target state="translated">AM / PM 기호</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="e95867ec94d8c275a2d1d9afac6a1d2ffb7fd390" translate="yes" xml:space="preserve">
          <source>ASCII (Char7)</source>
          <target state="translated">ASCII (Char7)</target>
        </trans-unit>
        <trans-unit id="2f934a30b8b57fba10b2b745dc320b339724b1b7" translate="yes" xml:space="preserve">
          <source>ASCII &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; are all numbers:</source>
          <target state="translated">ASCII &lt;code&gt;'0'&lt;/code&gt; ~ &lt;code&gt;'9'&lt;/code&gt; 는 모두 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="cae061a530cef71c477f974034de1fd1d9b43ecb" translate="yes" xml:space="preserve">
          <source>ATOM</source>
          <target state="translated">ATOM</target>
        </trans-unit>
        <trans-unit id="09116156619580f2fa8233d5bca8cf8644f9c359" translate="yes" xml:space="preserve">
          <source>Abandon evaluation of a statement after a breakpoint</source>
          <target state="translated">중단 점 후 명령문의 포기 평가</target>
        </trans-unit>
        <trans-unit id="c38c6ea6c11538ed82fd288d53c904871944106f" translate="yes" xml:space="preserve">
          <source>Abandons the current evaluation (only available when stopped at a breakpoint).</source>
          <target state="translated">현재 평가를 중단합니다 (중단 점에서 중지 된 경우에만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="f07c8230701366b843cd68845fafa5d65a1de2d9" translate="yes" xml:space="preserve">
          <source>About validity:</source>
          <target state="translated">유효성에 관하여 :</target>
        </trans-unit>
        <trans-unit id="05edf0d68cd3c84475eb832e7d283639e6bdeca9" translate="yes" xml:space="preserve">
          <source>Above, except that if the last line of the first argument stops at least one position before the first line of the second begins, these two lines are overlapped. For example:</source>
          <target state="translated">위의 경우, 첫 번째 인수의 마지막 행이 두 번째 행의 첫 번째 행이 시작되기 전에 하나 이상의 위치를 ​​중지하면이 두 행이 겹칩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef82336eb495d4e5324f732f879ad3b7c7dd9b61" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7dc34cb7ea60a4e1ddaf0a591cdafbc0e403cf" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d972269377ed5359cdd2dcc108f0e3936d78b1" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">위와 겹치지 않습니다. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 는 연관성이 있으며 ID는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="88874691ade84811a148df43dee3e898c7993db4" translate="yes" xml:space="preserve">
          <source>Above, without dovetailing.</source>
          <target state="translated">위의 더브 테일링없이.</target>
        </trans-unit>
        <trans-unit id="ffc84c11cb600f5730c837f24132ad44932f0e4a" translate="yes" xml:space="preserve">
          <source>Above; if there is no overlap it &quot;dovetails&quot; the two</source>
          <target state="translated">위; 겹치지 않으면 두 &quot;더브 테일&quot;</target>
        </trans-unit>
        <trans-unit id="2c7fe8b95b08b1e64796580d91044372f5603e8d" translate="yes" xml:space="preserve">
          <source>Absolute cursor movements</source>
          <target state="translated">절대 커서 이동</target>
        </trans-unit>
        <trans-unit id="44530d6a736fdaae47537dfbad7f8dda6f90c1ca" translate="yes" xml:space="preserve">
          <source>Absolute intervals</source>
          <target state="translated">절대 간격</target>
        </trans-unit>
        <trans-unit id="05675a8df55f00a801d7267f15ceae258c856842" translate="yes" xml:space="preserve">
          <source>Absolute value.</source>
          <target state="translated">절대 값.</target>
        </trans-unit>
        <trans-unit id="be11481292069bbf4e5d32f6f22e3e0ba35a6c06" translate="yes" xml:space="preserve">
          <source>AbsoluteSeek</source>
          <target state="translated">AbsoluteSeek</target>
        </trans-unit>
        <trans-unit id="d18ae99534459c5602deda227d35dbfc2f1e9957" translate="yes" xml:space="preserve">
          <source>AbsoluteTime</source>
          <target state="translated">AbsoluteTime</target>
        </trans-unit>
        <trans-unit id="434cecc208a8b4bb275114bca8d90f1c47541833" translate="yes" xml:space="preserve">
          <source>AbsoluteTime is TAI, time as measured by a clock.</source>
          <target state="translated">AbsoluteTime은 시계로 측정 한 TAI 시간입니다.</target>
        </trans-unit>
        <trans-unit id="667a8cf10407b19099b8b8a8c853533598abd554" translate="yes" xml:space="preserve">
          <source>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., &lt;code&gt;type T = ...&lt;/code&gt; to be accepted.) For example, the following are all valid implementations of the T above:</source>
          <target state="translated">추상 데이터 형식은 데이터 선언뿐만 아니라 새로운 형식 및 형식 동의어로도 구현할 수 있습니다 (예 : 형식 동의어를 완전히 정의해야한다는 제한이 있습니다 (예 : &lt;code&gt;type T = ...&lt;/code&gt; ). 예를 들어, 다음은 위 T의 모든 유효한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="beb8fcf15e248371df65aec656beac0bfea7c0b8" translate="yes" xml:space="preserve">
          <source>Abstract representation of vertices.</source>
          <target state="translated">꼭짓점의 추상 표현.</target>
        </trans-unit>
        <trans-unit id="f326ddf7104d3df6fa13479c593c244c4623b73c" translate="yes" xml:space="preserve">
          <source>Abstract syntax definitions for Template Haskell.</source>
          <target state="translated">Template Haskell에 대한 추상 구문 정의.</target>
        </trans-unit>
        <trans-unit id="71b7aef56068b7e751389cca7071da4abd7a1c80" translate="yes" xml:space="preserve">
          <source>Accept leading and trailing whitespace?</source>
          <target state="translated">선행 및 후행 공백을 허용합니까?</target>
        </trans-unit>
        <trans-unit id="95d34f3b555d7e27b1e17d75f2e37485b204658e" translate="yes" xml:space="preserve">
          <source>Accept leading whitespace?</source>
          <target state="translated">선행 공백을 허용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="bc52205c7ec889cf4cba765533bcd4e5d13957bc" translate="yes" xml:space="preserve">
          <source>Acceptable data</source>
          <target state="translated">허용되는 데이터</target>
        </trans-unit>
        <trans-unit id="3a8a3f0706793232d22f7100e8ea68a2faa1f5f0" translate="yes" xml:space="preserve">
          <source>Access to GHC's call-stack simulation</source>
          <target state="translated">GHC의 콜 스택 시뮬레이션에 액세스</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="f9fce24b3c49b79586973841924c190bcf8769f7" translate="yes" xml:space="preserve">
          <source>Accessing arrays</source>
          <target state="translated">배열에 액세스</target>
        </trans-unit>
        <trans-unit id="aff0bc5a5aaa0b373eac340c6aadb774a3a23049" translate="yes" xml:space="preserve">
          <source>Accessing the pointer to the array contents</source>
          <target state="translated">배열 내용에 대한 포인터 액세스</target>
        </trans-unit>
        <trans-unit id="3efd139cf44f823a7b553a058c94da8090307f52" translate="yes" xml:space="preserve">
          <source>Accessors to GHC RTS flags. Descriptions of flags can be seen in &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC User's Guide&lt;/a&gt;, or by running RTS help message using &lt;code&gt;+RTS --help&lt;/code&gt;.</source>
          <target state="translated">GHC RTS 플래그에 대한 접근 자 플래그에 대한 설명은 &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC 사용자 안내서&lt;/a&gt; 또는 다음을 사용하여 RTS 도움말 메시지를 실행하여 볼 수 있습니다. &lt;code&gt;+RTS --help&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7edca54ae2bf350d49cd477266ad9dd7d55aedcd" translate="yes" xml:space="preserve">
          <source>According to [1]:</source>
          <target state="translated">[1]에 따르면 :</target>
        </trans-unit>
        <trans-unit id="2d6dfb6165d33d7dc1b66480f6a0d421d69dd337" translate="yes" xml:space="preserve">
          <source>According to the GMP documentation, the underlying function &lt;code&gt;mpz_nextprime()&lt;/code&gt; &quot;uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small.&quot;</source>
          <target state="translated">GMP 문서에 따르면 기본 함수 &lt;code&gt;mpz_nextprime()&lt;/code&gt; 은 확률 론적 알고리즘을 사용하여 소수를 식별합니다. 실질적인 목적을 위해 복합적인 통과 가능성은 극히 적습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="a91ad95de89488856c8210673c103c15b4491b35" translate="yes" xml:space="preserve">
          <source>According to the rules above &lt;code&gt;X&lt;/code&gt; has a CUSK. Yet, the kind of &lt;code&gt;k&lt;/code&gt; is undetermined. It is thus quantified over, giving &lt;code&gt;X&lt;/code&gt; the kind &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">위의 규칙에 따라 &lt;code&gt;X&lt;/code&gt; 에는 CUSK가 있습니다. 그러나 &lt;code&gt;k&lt;/code&gt; 의 종류 는 결정되지 않았습니다. 따라서 &lt;code&gt;X&lt;/code&gt; 가 모든 &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt; 대한 종류를 제공하여 정량화 됩니다. 프록시 k-&amp;gt; 유형 .</target>
        </trans-unit>
        <trans-unit id="3d5e0f0e68219f2793950ff4f739b0707416bc38" translate="yes" xml:space="preserve">
          <source>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level &lt;code&gt;forall&lt;/code&gt;, the kind variable was bound there, too. That is, in &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; was bound by the same &lt;code&gt;forall&lt;/code&gt; as the &lt;code&gt;a&lt;/code&gt;. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank &lt;code&gt;forall&lt;/code&gt;, include it explicitly.</source>
          <target state="translated">따라서, 높은 등급의 맥락에서 종류 정량화 규칙은 약간 변경되었습니다. GHC 7에서 최상위 변수가 아닌 &lt;code&gt;forall&lt;/code&gt; 에 바인딩 된 변수의 종류에서 종류 변수가 처음으로 언급 된 경우, 종류 변수도 여기에 바인딩되었습니다. ,는 것을 &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt; 상기 &lt;code&gt;k&lt;/code&gt; 동일 구속 된 &lt;code&gt;forall&lt;/code&gt; 는 AS . 그러나 GHC 8에서 한 유형에서 언급 된 모든 종류의 변수는 최 외곽 레벨에 바인딩됩니다. 당신은 더 높은 순위에 결합 된 하나의 원하는 경우 &lt;code&gt;forall&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 명시 적으로 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb0023c7c1fa4cd60dd0df32c9589498220f1d0" translate="yes" xml:space="preserve">
          <source>Accordingly, the type environment seen by &lt;code&gt;reify&lt;/code&gt; includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</source>
          <target state="translated">따라서 &lt;code&gt;reify&lt;/code&gt; 로 보는 유형 환경 에는 직전 선언 그룹의 끝까지 모든 최상위 선언이 포함되지만 더 이상 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82bedfe88009972d90237d52b7f414b23e6d5eb6" translate="yes" xml:space="preserve">
          <source>Accum</source>
          <target state="translated">Accum</target>
        </trans-unit>
        <trans-unit id="50b4f3d88aa3c9059e12c063f7c950d2f9b4b778" translate="yes" xml:space="preserve">
          <source>Accum operations</source>
          <target state="translated">누적 작업</target>
        </trans-unit>
        <trans-unit id="cd4bf7ea6fd4060189e1e1baaa24ebb42d7660ad" translate="yes" xml:space="preserve">
          <source>AccumT</source>
          <target state="translated">AccumT</target>
        </trans-unit>
        <trans-unit id="50412c7500ef5d04ef8c2e37d60a2b1db38c9207" translate="yes" xml:space="preserve">
          <source>Accumulating maps</source>
          <target state="translated">누적지도</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="6347206826a895475f5f91774a889e897ffc7d63" translate="yes" xml:space="preserve">
          <source>Action &lt;code&gt;askString&lt;/code&gt; requests user to enter a string, and passes it to the continuation. &lt;code&gt;askString&lt;/code&gt; takes as a parameter a continuation taking a string parameter, and returning &lt;code&gt;IO ()&lt;/code&gt;. Compare its signature to &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; definition.</source>
          <target state="translated">조치 &lt;code&gt;askString&lt;/code&gt; 은 사용자에게 문자열을 입력하도록 요청하고 연속으로 전달합니다. &lt;code&gt;askString&lt;/code&gt; 은 매개 변수로 문자열 매개 변수를 가져 와서 &lt;code&gt;IO ()&lt;/code&gt; 를 리턴하는 연속을 취합니다 . 서명을 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; 정의와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2f1b38e49644d95f7b46650e509c991d77060f8" translate="yes" xml:space="preserve">
          <source>Action to be executed</source>
          <target state="translated">실행할 조치</target>
        </trans-unit>
        <trans-unit id="f5278c8649d913f335c11a62f866017db4429c6b" translate="yes" xml:space="preserve">
          <source>Actions on directories</source>
          <target state="translated">디렉토리에 대한 조치</target>
        </trans-unit>
        <trans-unit id="696ed90b8efd0baea13c573b2e7c286d011d6b3c" translate="yes" xml:space="preserve">
          <source>Actions on files</source>
          <target state="translated">파일에 대한 조치</target>
        </trans-unit>
        <trans-unit id="7083b72c48cfaf651eebc9aa10754311beefc8de" translate="yes" xml:space="preserve">
          <source>Activate cross-compilation mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;).</source>
          <target state="translated">크로스 컴파일 모드를 활성화합니다 ( &lt;a href=&quot;#hsc2hs-cross&quot;&gt;크로스 컴파일&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="583d9a705b86bbdfe3e1d9047b3ea1485ccadeeb" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를가 심볼릭 링크를 의미한다. 이 경우 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보는 가리키는 파일의 정보 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d65523818024ea88107f6287927f036ddf6afd4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를가 심볼릭 링크를 의미한다. 이 경우 가리키는 파일 정보 대신 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb8dd245b9cb57f179bf3b4b88042343c063795" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; 하지만 심볼릭 링크를 따르지 않는 (따라서 링크 자체에 대한 권한을 변경).</target>
        </trans-unit>
        <trans-unit id="00b98c6571c6f97fdd25d5e837fe03213c325e22" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; 경우를 제외하고 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 이 심볼릭 링크를 의미한다. 이 경우 심볼릭 링크 자체 의 &lt;code&gt;FileStatus&lt;/code&gt; 정보는 가리키는 파일의 정보 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbcea92f66c4289d12fcd3463f6bb4e3fab3bda6" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">역할을 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; 하지만 심볼릭 링크를 따르지 않는 (따라서 링크 자체에 대한 권한을 변경).</target>
        </trans-unit>
        <trans-unit id="6a6c3ff29419f1c7034849f1db0a070b794f9ad2" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setFileSize&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 대신 파일 설명자를 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="49be567080d7b410e84b47729961520e4de920c4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setFileSize&lt;/code&gt; 로 작동 하지만 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 대신 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d4b7078adb2d96736d050720e01d8ae82392b27c" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역할을 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; 하지만 대신 파일 디스크립터를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f40c80358e12a1e2aaf02b1148d6c20fcfd4ba45" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역할을 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; 하지만 대신 파일 디스크립터를 사용 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="fce17679436ea260fadec4591a677de22164d0f8" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;hsc2hs&lt;/code&gt; does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code.</source>
          <target state="translated">실제로 &lt;code&gt;hsc2hs&lt;/code&gt; 는 Haskell 파일을 직접 출력하지 않습니다. 헤더를 포함하는 C 프로그램을 작성하고 자동으로 컴파일되어 실행됩니다. 이 프로그램은 Haskell 코드를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="eb4c8a6633849d6709d07c9f3e63104f63a51077" translate="yes" xml:space="preserve">
          <source>Add a finalizer that will run in the Q monad after the current module has been type checked. This only makes sense when run within a top-level splice.</source>
          <target state="translated">현재 모듈의 유형을 확인한 후 Q 모나드에서 실행될 종료자를 추가하십시오. 이것은 최상위 스플 라이스 내에서 실행될 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0de177dcddf4173fd744c404b8ba61f96637ed" translate="yes" xml:space="preserve">
          <source>Add a finalizer to an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (GHC only). See &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; and &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; for more about finalizers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 마무리 기를 추가하십시오 (GHC 만 해당). &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; 및 &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; 참조 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="87eb63d6dca38f792891dceb6d3068ba951d4549" translate="yes" xml:space="preserve">
          <source>Add a line to the history unless it matches the previously recorded line.</source>
          <target state="translated">이전에 기록 된 라인과 일치하지 않는 한 라인을 히스토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="aaca03fa0d32c5a3d402a6fb5fcc0ded2bb915ec" translate="yes" xml:space="preserve">
          <source>Add a line to the history, and remove all previous entries which are the same as it.</source>
          <target state="translated">히스토리에 행을 추가하고 동일한 이전 항목을 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7fd5dfa46b0f645d5db42f20504f6c3caf7358" translate="yes" xml:space="preserve">
          <source>Add a trailing file path separator if one is not already present.</source>
          <target state="translated">후행 파일 경로 구분 기호가 없으면 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f1a8ca3a641a6b0ef6dbe461171ca7f604eb5a" translate="yes" xml:space="preserve">
          <source>Add additional top-level declarations. The added declarations will be type checked along with the current declaration group.</source>
          <target state="translated">최상위 선언을 추가하십시오. 추가 된 선언은 현재 선언 그룹과 함께 유형 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="cecd1aea8fe88c39fcc8f71681a3e087791c984b" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 에 해당하는 확장이 이미있는 경우에도 확장을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="34878ebb3f1e96601aafa913d00d7bd263cdc36c" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이미 확장이있는 경우에도 확장을 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 과 동일). .</target>
        </trans-unit>
        <trans-unit id="89357b09335d29d387cf17547863b974b8decc59" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 에 해당하는 확장이 이미있는 경우에도 확장을 추가하십시오 ..</target>
        </trans-unit>
        <trans-unit id="12e0f266814b31f57d2a4d4f2e065ebded03e6c4" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이미 확장이있는 경우에도 확장을 추가하십시오 ( &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 과 동일). .</target>
        </trans-unit>
        <trans-unit id="88bd486d89c4fede722e2d2391a03c0fd1f29c23" translate="yes" xml:space="preserve">
          <source>Add entries to the Static Pointer Table</source>
          <target state="translated">정적 포인터 테이블에 항목 추가</target>
        </trans-unit>
        <trans-unit id="573b000c455e2582361374a0f2d5ce932b4443a5" translate="yes" xml:space="preserve">
          <source>Add months (clipped to last day), then add days</source>
          <target state="translated">몇 달 (마지막 날까지)을 추가 한 다음 일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="11f2dacfd6ba9147a205050f051361aedae62583" translate="yes" xml:space="preserve">
          <source>Add months (rolling over to next month), then add days</source>
          <target state="translated">월을 추가하고 (다음 달로 롤오버) 일을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="b015364a9bf90321fb61c3a98f1cdc612fdf7a8d" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.</source>
          <target state="translated">해당 월의 마지막 날을 지난 날에 마지막 날로 클리핑하여 월을 추가하십시오. 예를 들어, 2005-01-30 + 1 개월 = 2005-02-28입니다.</target>
        </trans-unit>
        <trans-unit id="1ce9d4dd3c00c35abdeda445f12f814c42604388" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month rolling over to the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.</source>
          <target state="translated">해당 월의 마지막 날을지나 다음 달로 넘어가는 월을 추가하십시오. 예를 들어 2005-01-30 + 1 개월 = 2005-03-02입니다.</target>
        </trans-unit>
        <trans-unit id="45aa2700c673ebfa0acebc5efea925be3a17cb6f" translate="yes" xml:space="preserve">
          <source>Add one to the given number using the state monad:</source>
          <target state="translated">상태 모나드를 사용하여 주어진 숫자에 하나를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ad0277793f67d2e393175d08b52db34131c5ef10" translate="yes" xml:space="preserve">
          <source>Add signed integers reporting overflow. First member of result is the sum truncated to an &lt;code&gt;Int#&lt;/code&gt;; second member is zero if the true sum fits in an &lt;code&gt;Int#&lt;/code&gt;, nonzero if overflow occurred (the sum is either too large or too small to fit in an &lt;code&gt;Int#&lt;/code&gt;).</source>
          <target state="translated">오버플로를보고하는 부호있는 정수를 추가하십시오. 결과의 첫 번째 멤버는 &lt;code&gt;Int#&lt;/code&gt; 잘린 합계입니다 . 실제 합계가 &lt;code&gt;Int#&lt;/code&gt; 맞는 경우 두 번째 멤버는 0이고 오버플로가 발생한 경우 0이 아닙니다 (합계가 너무 크거나 너무 작아서 &lt;code&gt;Int#&lt;/code&gt; 에 맞지 않음).</target>
        </trans-unit>
        <trans-unit id="b0fcd5e56314036018a9f0cac00e78ef55a1787b" translate="yes" xml:space="preserve">
          <source>Add some helper code that starts up and shuts down the Haskell RTS:</source>
          <target state="translated">Haskell RTS를 시작하고 종료하는 도우미 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="985586c7f3031f00d6269e644d3adc10e6ea07bc" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS option when running the program to see timing stats, which will help to tell you whether your program got faster by using more CPUs or not. If the user time is greater than the elapsed time, then the program used more than one CPU. You should also run the program without &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; for comparison.</source>
          <target state="translated">프로그램을 실행할 때 &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS 옵션을 추가하여 타이밍 통계를 확인하면 더 많은 CPU를 사용하여 프로그램이 더 빨라 졌는지 여부를 알려주는 데 도움이됩니다. 사용자 시간이 경과 시간보다 큰 경우 프로그램은 둘 이상의 CPU를 사용했습니다. 또한 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; without없이 프로그램을 실행해야합니다. 비교를 위해 .</target>
        </trans-unit>
        <trans-unit id="343b1a229f6a10110d459f27e6591278cc0810b3" translate="yes" xml:space="preserve">
          <source>Add the global package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt;&lt;code&gt;-no-global-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the global package database should be loaded.</source>
          <target state="translated">현재 스택 위에 글로벌 패키지 데이터베이스를 추가하십시오. 이 옵션은 &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt; &lt;code&gt;-no-global-package-db&lt;/code&gt; &lt;/a&gt; 뒤에 사용 되어 글로벌 패키지 데이터베이스를로드 할 스택의 위치를 ​​지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dc1f25cbb780084188d4ff897a81d5104622f0" translate="yes" xml:space="preserve">
          <source>Add the global package db to the stack.</source>
          <target state="translated">글로벌 패키지 db를 스택에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fe975763255492732af82ca06ecb5eda5e5fa904" translate="yes" xml:space="preserve">
          <source>Add the package database ⟨file⟩ on top of the current stack.</source>
          <target state="translated">현재 스택 위에 패키지 데이터베이스 ⟨file⟩을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6134bf2d1b2295efc8fa6b7e828ec4d22ba2e38e" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt;&lt;code&gt;-no-user-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the user&amp;rsquo;s package database should be loaded.</source>
          <target state="translated">현재 스택 위에 사용자의 패키지 데이터베이스를 추가하십시오. 이 옵션은 &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt; &lt;code&gt;-no-user-package-db&lt;/code&gt; &lt;/a&gt; 이후에 사용할 수 있습니다 하여 스택에서 사용자 패키지 데이터베이스를로드 할 위치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d336c4a71c8e660819935f8d9b591c05d3839d" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package db to the stack.</source>
          <target state="translated">스택에 사용자 패키지 db를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f0c714c0819e829fa65b99edbce416f762fa1cd5" translate="yes" xml:space="preserve">
          <source>Add the user's package db to the stack.</source>
          <target state="translated">사용자의 패키지 db를 스택에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="52e83704b0c13e474a873f78d2503ff9d5058a2e" translate="yes" xml:space="preserve">
          <source>Add two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">두 개의 추가 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="42140a41e27de0c19e086f86091f816243e8209e" translate="yes" xml:space="preserve">
          <source>Add two non-negative numbers. Errors out on overflow.</source>
          <target state="translated">음수가 아닌 두 개의 숫자를 추가하십시오. 오버플로시 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e2856c1714aa39e0ac4378840b55f10a1492a342" translate="yes" xml:space="preserve">
          <source>Add two vectors element-wise.</source>
          <target state="translated">요소별로 두 개의 벡터를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d21ffb0b2e887326fe4eaccd172c45b78c0f6321" translate="yes" xml:space="preserve">
          <source>Add unsigned integers reporting overflow. The first element of the pair is the result. The second element is the carry flag, which is nonzero on overflow. See also &lt;code&gt;plusWord2#&lt;/code&gt;.</source>
          <target state="translated">오버 플로우를보고하는 부호없는 정수를 추가하십시오. 쌍의 첫 번째 요소가 결과입니다. 두 번째 요소는 캐리 플래그이며 오버플로시 0이 아닙니다. &lt;code&gt;plusWord2#&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4224f11c255c4982dd554902608b0a229771245f" translate="yes" xml:space="preserve">
          <source>Add unsigned integers, with the high part (carry) in the first component of the returned pair and the low part in the second component of the pair. See also &lt;code&gt;addWordC#&lt;/code&gt;.</source>
          <target state="translated">리턴 된 쌍의 첫 번째 구성 요소에 높은 부분 (이동)과 쌍의 두 번째 구성 요소에 낮은 부분이있는 부호없는 정수를 추가하십시오. &lt;code&gt;addWordC#&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7bc6acbb336def5a2fed21adc84cf2eba8c8695" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th clipped to Feb 28th if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.</source>
          <target state="translated">필요한 경우 2 월 29 일을 2 월 28 일로 클리핑하여 월과 일을 일치하는 연도를 추가하십시오. 예를 들어 2004-02-29 + 2 년 = 2006-02-28입니다.</target>
        </trans-unit>
        <trans-unit id="00a5a0f630ddf36709167f1d67babdf5ba438d3b" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th rolled over to Mar 1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.</source>
          <target state="translated">필요한 경우 2 월 29 일이 3 월 1 일로 롤오버되어 월과 일이 일치하는 연도를 추가하십시오. 예를 들어 2004-02-29 + 2 년 = 2006-03-01입니다.</target>
        </trans-unit>
        <trans-unit id="b78eacb0dc09583fbc5860e25537c0fbd17b2217" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the directory search list for &lt;code&gt;#include&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 파일 의 디렉토리 검색 목록에 ⟨dir⟩ 추가</target>
        </trans-unit>
        <trans-unit id="3af3cf99d9bd473db5a8f166f611704c815a0e2a" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the list of directories searched for libraries</source>
          <target state="translated">라이브러리를 검색 한 디렉토리 목록에 ⟨dir⟩ 추가</target>
        </trans-unit>
        <trans-unit id="22a6f927fd045f27916f2841389ceb5619f2f520" translate="yes" xml:space="preserve">
          <source>Add ⟨file⟩ to the package db stack.</source>
          <target state="translated">패키지 DB 스택에 ⟨file⟩을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fd862d70f0a0e1b3f98b9cfd9a82f7a12719414c" translate="yes" xml:space="preserve">
          <source>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces the module to be loaded as byte-code.</source>
          <target state="translated">target 모듈⟩을 현재 대상 세트에 추가하고 다시로드를 수행하십시오. 모듈에 대해 일반적으로 사전 컴파일 된 코드는 사용 가능한 경우로드되거나 그렇지 않으면 모듈이 바이트 코드로 컴파일됩니다. &lt;code&gt;*&lt;/code&gt; 접두사를 사용하면 모듈이 바이트 코드로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c0d264184b29e5240b822c85a976bae183083b" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가 하면 규칙적인 게으른 동작이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="320069f40befc715427528e74af5fccc8e33c273" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가 하면 규칙적인 게으른 동작이 나타납니다. 일반적인 규칙은 &lt;code&gt;~&lt;/code&gt; 로 비활성화하지 않는 한 가장 바깥 쪽 패턴에 암시 적 뱅을 추가하는 것입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="d83058e490d2d8e416a97aa6b2da12e694c423cc" translate="yes" xml:space="preserve">
          <source>Adding a new kind of pure computation to an applicative functor.</source>
          <target state="translated">새로운 유형의 순수한 계산을 적용 펑터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3e22ec51f6417f07ed5484e9c1f31e458834a41e" translate="yes" xml:space="preserve">
          <source>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</source>
          <target state="translated">형식 서명을 추가하면 결과가 크게 바뀝니다! 이것은 조심해야 할 반 직관적 인 현상입니다.</target>
        </trans-unit>
        <trans-unit id="99385bb5ea9d50b509bba76a80c6d5cf02fdad9b" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">옵션&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;는로드하는 동안 유형 오류를 경고로 바꿉니다. 따라서 일부 정의에 유형 오류가 있더라도 올바른 모듈 부분을 사용할 수 있습니다. 실제로, &quot;-fdefer-type-errors&quot;플래그는로드 전에 설정되고 플래그가 이미 설정되지 않은 경우로드 후에 설정 해제됩니다. 추가 동기 및 세부 사항 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;은 런타임&lt;/a&gt; 에 유형 오류 연기를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="00f220c3a56210a9843d04890d61a40e6f8811dd" translate="yes" xml:space="preserve">
          <source>Addition of type-level naturals.</source>
          <target state="translated">타입 레벨 내츄럴 추가.</target>
        </trans-unit>
        <trans-unit id="1d55c4561961d726b476a4d113ce4ac1271e1f3d" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">추가 &lt;code&gt;Integer&lt;/code&gt; 연산</target>
        </trans-unit>
        <trans-unit id="452f31724597f25fbb7b21a77fe4b6fccc9c9f11" translate="yes" xml:space="preserve">
          <source>Additional arguments to the pre-processor can be passed in using the &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt;&lt;code&gt;-optF ⟨option⟩&lt;/code&gt;&lt;/a&gt; option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</source>
          <target state="translated">프리 프로세서에 대한 추가 인수는 &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt; &lt;code&gt;-optF ⟨option⟩&lt;/code&gt; &lt;/a&gt; 옵션 을 사용하여 전달할 수 있습니다 . 이들은 3 개의 표준 입력 및 출력 인수 다음에 명령 행에서 ⟨cmd⟩에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ba84f116cccb8aaddf33910d85c19273f9b5c33d" translate="yes" xml:space="preserve">
          <source>Additional conversion operations to &lt;code&gt;Integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; 추가 변환 조작</target>
        </trans-unit>
        <trans-unit id="05dd2fde350699cecd8602584538e2a5301a7997" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시퀀스를 해체하기위한 추가 기능은 통해 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cf2915563496656545c5e0888c8da42599eb5f8" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">시퀀스 분해를위한 추가 기능 은 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33810ea2f256277dbeeee354b4b9748e64cd54e7" translate="yes" xml:space="preserve">
          <source>Additional generic representation type constructors</source>
          <target state="translated">추가 일반 표현 유형 생성자</target>
        </trans-unit>
        <trans-unit id="fefa8177b546e09c697ef3ccda7dfb9a8468dadd" translate="yes" xml:space="preserve">
          <source>Additional submodules</source>
          <target state="translated">추가 서브 모듈</target>
        </trans-unit>
        <trans-unit id="d5fc75cb6b2328204ad6e4f5c7b8aa1503974318" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;ghc-pkg list&lt;/code&gt; reminds you that there are broken packages and suggests &lt;code&gt;ghc-pkg check&lt;/code&gt;, which displays more information about the nature of the failure:</source>
          <target state="translated">또한 &lt;code&gt;ghc-pkg list&lt;/code&gt; 은 패키지가 손상되었음을 &lt;code&gt;ghc-pkg check&lt;/code&gt; 제안합니다 . 이는 실패의 특성에 대한 자세한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4dc57812bc7acb080b8b1b3c9a8dc29f687921a8" translate="yes" xml:space="preserve">
          <source>Additionally, any files specified with &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; flags will be read after the standard files, allowing the use of custom .ghci files.</source>
          <target state="translated">또한 &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt; 플래그로 지정된 파일 은 표준 파일 다음에 읽혀 지므로 사용자 지정 .ghci 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8273902569bf382d8f68303982acb32861c6cbb8" translate="yes" xml:space="preserve">
          <source>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</source>
          <target state="translated">또한 함수 정의에서 이전 커리 인수와 일치하여 바인딩 된 변수는 다음 인수의 뷰 패턴 표현식에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f89673843f1be6757860a64501f5bc027e357960" translate="yes" xml:space="preserve">
          <source>Additionally, the following flags are accepted by &lt;code&gt;ghc-pkg&lt;/code&gt;:</source>
          <target state="translated">또한 다음 플래그는 &lt;code&gt;ghc-pkg&lt;/code&gt; 에 의해 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6098dd57b05f9b5adb478e7eb1c70e1499221dae" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="translated">또한 Safe Haskell 제한을 우회 할 수 있으므로 &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;주석&lt;/a&gt; 사용 이 금지됩니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;# 10826&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea07a4f598cd1862ca91a8d811d4455a836c0db0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;Issue #10826&lt;/a&gt; for details.</source>
          <target state="translated">또한 Safe Haskell 제한을 우회 할 수 있으므로 &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;주석&lt;/a&gt; 사용 은 금지됩니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;문제 # 10826&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7d071e5cf6b03c15819e3ffdf6a64a0ef17bfa" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduce memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">또한이 구현은 비트 맵을 트리의 잎에 배치합니다. 크기는 기계어 (32 또는 64 비트)의 자연스러운 크기이며 밀도가 높은 세트 (예 : 많은 값이 서로 가까이있을 가능성이있는 세트)의 메모리 풋 프린트 및 실행 시간을 크게 줄입니다. 무증상은이 최적화의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9433cfd346f8c54358a2f7edce3cb77efb148924" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduces the memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">또한이 구현은 비트 맵을 트리의 잎에 배치합니다. 크기는 기계어 (32 또는 64 비트)의 자연스러운 크기이며 밀도가 높은 세트 (예 : 많은 값이 서로 가까이있을 수있는 세트)의 메모리 풋 프린트 및 실행 시간을 크게 줄입니다. 무증상은이 최적화의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bf2d76785594ad916dd8c2e5e99f51e13db7893" translate="yes" xml:space="preserve">
          <source>Additionally, unless &lt;code&gt;-hide-all-packages&lt;/code&gt; is specified &lt;code&gt;ghc&lt;/code&gt; will also look for the package environment in the following locations:</source>
          <target state="translated">또한 &lt;code&gt;-hide-all-packages&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;ghc&lt;/code&gt; 는 다음 위치에서 패키지 환경을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2aa983ad06fdb2dac09d7b6232814da70747e9ee" translate="yes" xml:space="preserve">
          <source>Additive</source>
          <target state="translated">Additive</target>
        </trans-unit>
        <trans-unit id="0d42cec26dbc762aafe43e05a50f969d0b7505d7" translate="yes" xml:space="preserve">
          <source>Addr</source>
          <target state="translated">Addr</target>
        </trans-unit>
        <trans-unit id="e78f3509a8a9919b87bca8268eb67a1992a398dd" translate="yes" xml:space="preserve">
          <source>Addr#</source>
          <target state="translated">Addr#</target>
        </trans-unit>
        <trans-unit id="9693f97edb3f213e60bf04638a2964d95c0a8e70" translate="yes" xml:space="preserve">
          <source>AddrRep</source>
          <target state="translated">AddrRep</target>
        </trans-unit>
        <trans-unit id="e1bcdaba63c737122befb027c96355aebd956e8a" translate="yes" xml:space="preserve">
          <source>Address range information necessary for efficient lookup in debug information.</source>
          <target state="translated">디버그 정보를 효율적으로 조회하는 데 필요한 주소 범위 정보.</target>
        </trans-unit>
        <trans-unit id="2bea019ec2ca9ce8cba25638cef6e4ebf912a40d" translate="yes" xml:space="preserve">
          <source>Adds a core plugin to the compilation pipeline.</source>
          <target state="translated">컴파일 파이프 라인에 핵심 플러그인을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f141d838836915fbdfd335ae66e883d10b2bee58" translate="yes" xml:space="preserve">
          <source>Adds a location description and maybe a file path and file handle to an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;. If any of the file handle or file path is not given the corresponding value in the &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; remains unaltered.</source>
          <target state="translated">위치 설명과 파일 경로 및 파일 핸들을 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 에 추가 합니다. 파일 핸들 또는 파일 경로가 제공되지 않으면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 의 해당 값 이 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="14518bca79b10a8d6a6afac2dc2d74ba60c9789a" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">모든 &lt;em&gt;통화 사이트에&lt;/em&gt; 자동 &lt;code&gt;SCC&lt;/code&gt; 주석을 추가합니다 . 이는 스택 추적을 생성하기 위해 프로파일 링을 사용할 때 특히 유용합니다. 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; 함수 또는 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS 플래그 ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 지나치게 관심이있는 영혼에 대한 RTS 옵션&lt;/a&gt; )를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4dd58b10c5df43531b5419e150eab3428f317659" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">모든 &lt;em&gt;호출 사이트에&lt;/em&gt; 자동 &lt;code&gt;SCC&lt;/code&gt; 주석을 추가합니다 . 이는 스택 추적을 생성 할 목적으로 프로파일 링을 사용할 때 특히 유용합니다. 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt; 함수 또는 &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS 플래그 ( &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 과도하게 관심있는 영혼을위한 RTS 옵션&lt;/a&gt; )를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd2a08806dfb482db344074817b7f6e5c01441" translate="yes" xml:space="preserve">
          <source>Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt; or &lt;code&gt;hide&lt;/code&gt; command, unless it is overridden by a later &lt;code&gt;--package-db&lt;/code&gt;, &lt;code&gt;--user&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; option.</source>
          <target state="translated">패키지 데이터베이스 스택에 ⟨file⟩을 추가합니다. 또한, ⟨file⟩ 또한 의해 수정 데이터베이스 될 것 &lt;code&gt;register&lt;/code&gt; , &lt;code&gt;unregister&lt;/code&gt; , &lt;code&gt;expose&lt;/code&gt; 또는 &lt;code&gt;hide&lt;/code&gt; 가 나중에 의해 대체되지 않는 한, 명령 &lt;code&gt;--package-db&lt;/code&gt; , &lt;code&gt;--user&lt;/code&gt; 또는 &lt;code&gt;--global&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6b704187610182fd9bd374b8590aaa1ef187a2e9" translate="yes" xml:space="preserve">
          <source>Adjacency list representation of a graph, mapping each vertex to its list of successors.</source>
          <target state="translated">각 정점을 후속 작업 목록에 매핑하는 그래프의 인접 목록 표시</target>
        </trans-unit>
        <trans-unit id="b54a06cdf203c292a9600afc8f4877852335267a" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array</source>
          <target state="translated">배열의 크기를 조정</target>
        </trans-unit>
        <trans-unit id="90ae8e7c61f1d870875dbba75294d0ee30d78240" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array in the given pool.</source>
          <target state="translated">주어진 풀에서 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0f13658ace97bdbb476bffd14472478597823d14" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array including an extra position for the end marker.</source>
          <target state="translated">끝 마커의 추가 위치를 포함하여 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8f64f3b151b220c78b035080db416951b86c9133" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array with an end marker in the given pool.</source>
          <target state="translated">주어진 풀에서 종료 마커가있는 배열의 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="22c056b1203c0d0dbe4975dcb12541b083750969" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size of the required type.</source>
          <target state="translated">풀에있는 요소의 저장 영역을 필요한 유형의 지정된 크기로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b78d30e021c76a4d2cd9b8d7c83d0401635e998" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size.</source>
          <target state="translated">풀에있는 요소의 저장 영역을 지정된 크기로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="483b6c748f94c6096a813d4e1202da0abec1197a" translate="yes" xml:space="preserve">
          <source>Administration: errors, locations and IO</source>
          <target state="translated">관리 : 오류, 위치 및 IO</target>
        </trans-unit>
        <trans-unit id="e796c7c730ff7dabd900a81e118126dd63495d56" translate="yes" xml:space="preserve">
          <source>Advance a pointer into an array by the given number of elements</source>
          <target state="translated">주어진 요소 수만큼 배열로 포인터를 전진</target>
        </trans-unit>
        <trans-unit id="260fc09cb1bd463d426655ad971e67b80c27f04d" translate="yes" xml:space="preserve">
          <source>Advances the given address by the given offset in bytes.</source>
          <target state="translated">주어진 오프셋만큼 바이트 단위로 주어진 주소를 전진시킵니다.</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="1f3b7ab3442ed00e15ed0541b2686cab5245f648" translate="yes" xml:space="preserve">
          <source>Advice parameter for &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; 조작에 대한 조언 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="641791da837ed200728e9e50c3a7a04bddd511ba" translate="yes" xml:space="preserve">
          <source>AdviceDontNeed</source>
          <target state="translated">AdviceDontNeed</target>
        </trans-unit>
        <trans-unit id="ea4292d4f711440375ee49d21953e80b5e52f970" translate="yes" xml:space="preserve">
          <source>AdviceNoReuse</source>
          <target state="translated">AdviceNoReuse</target>
        </trans-unit>
        <trans-unit id="74d7e2511ff18bffd6e754606fb5eef4017e56ae" translate="yes" xml:space="preserve">
          <source>AdviceNormal</source>
          <target state="translated">AdviceNormal</target>
        </trans-unit>
        <trans-unit id="81df8c0f743f838767314197c10a01806cad2ee1" translate="yes" xml:space="preserve">
          <source>AdviceRandom</source>
          <target state="translated">AdviceRandom</target>
        </trans-unit>
        <trans-unit id="ccfd39209774bc0bd28a1949494a57c9a708ab38" translate="yes" xml:space="preserve">
          <source>AdviceSequential</source>
          <target state="translated">AdviceSequential</target>
        </trans-unit>
        <trans-unit id="42c90330aa2e9c8f79a56b93334f2cee6565ec83" translate="yes" xml:space="preserve">
          <source>AdviceWillNeed</source>
          <target state="translated">AdviceWillNeed</target>
        </trans-unit>
        <trans-unit id="ed7d231de2d15caa7608638f366b36b040083e12" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;ldquo;</source>
          <target state="translated">&amp;ldquo;각 클래스 제약 조건 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; &amp;rdquo;다음에&amp;ldquo;또는 각 정량화 된 제약 조건 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &amp;rdquo;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="962b02c7a62413f64f2ece2fa9269c59c618e145" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;rdquo;</source>
          <target state="translated">&quot;각 클래스 제약 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 에 대해&quot;뒤에 &quot; 또는 각 수량화 된 제약 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &quot;을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5b0f8ce28395257ee72603489cfcfd39f2ac90c3" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, the current context is set to:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후 현재 컨텍스트는 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="07383eb16f1578a01af993380c0758317c77da4a" translate="yes" xml:space="preserve">
          <source>After analysing this declaration, GHC will discover that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; can be kind-polymorphic, with &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;c :: k2&lt;/code&gt;. We thus infer the following kind:</source>
          <target state="translated">이 선언을 분석 한 후 GHC는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; 및 &lt;code&gt;c :: k2&lt;/code&gt; 와 함께 친절한 다형성이 될 수 있음을 발견합니다 . 따라서 우리는 다음과 같은 종류를 유추합니다.</target>
        </trans-unit>
        <trans-unit id="43eb39a82773f2a643009be434c6a85d6547dd46" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 은 기본 바이트 버퍼를 원래 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 내용이 변경되어 참조 투명성 이 손상 됩니다. 공유로 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 ByteString )에도 이러한 변경 사항이 반영됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명도가 손상됩니다. 이를 피하려면 &lt;code&gt;useAsCString&lt;/code&gt; 을 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 그러면 원래 ByteString 의 사본이 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f34b11d2d5cf5b9fa61ceda45199281dda85ee6f" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 은 기본 바이트 버퍼를 원래 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 ByteString 의 내용이 변경되어 참조 투명성 이 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 됩니다. 공유로 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 ByteString )에도 이러한 변경 사항이 반영됩니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 피하려면 &lt;code&gt;useAsCStringLen&lt;/code&gt; 을 사용 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . 그러면 원래 ByteString 의 사본이 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="82a058ea48e1049a3153e84c6e2e32200ba90877" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 C에서 또는 poke를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 내용이 변경되어 참조 투명도가 깨집니다. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;useAsCString&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0cb3d574900104a74408c8731d7eda427531f654" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 은 원본 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 기본 바이트 버퍼를 공유합니다 . 따라서 수정 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 어느 C에서, 또는 포크를 이용하여 내용 발생할 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 참조 투명성을 깨고 변화. 공유에 의해 생성 된 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 을 통해 생성 된 것)도 이러한 변경 사항을 반영합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 수정하면 참조 투명성이 손상됩니다. 이를 방지하기 위해 사용 &lt;code&gt;useAsCStringLen&lt;/code&gt; 원본의 복사본을 만들고, &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="6923804e768f3da3c4e34a50b537baa1cecaa53f" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;f&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">동의어를 확장 한 후 &lt;code&gt;f&lt;/code&gt; 는 다음과 같은 합법적 (GHC) 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e94a959addb55b4d2ce5f3c538f5e0b4451a9198" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;foo&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">동의어를 확장 한 후 &lt;code&gt;foo&lt;/code&gt; 는 유효한 (GHC에서) 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="06d0d43c4a9a4534a91da534db4a4831101176f7" translate="yes" xml:space="preserve">
          <source>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn&amp;rsquo;t detected simply by kind checking:</source>
          <target state="translated">형식 동의어를 확장 한 후 GHC는 형식에 대한 유효성 검사를 수행하여 단순히 종류 검사로 감지되지 않는 다음과 같은 잘못된 형식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0449647915398655b7a878613d9a9af3cfaf3fda" translate="yes" xml:space="preserve">
          <source>After running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action there are three possibilities for what comes next:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 조치를 실행 한 후 다음에 올 가능성이 세 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4bbb708c55cef458c6b0bed0fa5801c96a405ff" translate="yes" xml:space="preserve">
          <source>After starting &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</source>
          <target state="translated">대상에서 &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; 를 시작 하고 임시 폴더 (로드 할 필요한 라이브러리를 복사 할 위치)와 포트를 제공 한 후 프록시가 연결할 수 있도록 수신 대기합니다.</target>
        </trans-unit>
        <trans-unit id="8f8861d66315ce749c004b7e24b472e22e1345c7" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve finished invoking our Haskell functions, we can call &lt;code&gt;hs_exit()&lt;/code&gt;, which terminates the RTS.</source>
          <target state="translated">Haskell 함수 호출을 완료 한 후 &lt;code&gt;hs_exit()&lt;/code&gt; 호출 하면 RTS가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa08ab3cb629ae0630f4dccf9a63999f34ccc01" translate="yes" xml:space="preserve">
          <source>Again, if &lt;code&gt;C&lt;/code&gt; contains no class methods, the instance context will be redundant, so GHC will instead generate &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt;.</source>
          <target state="translated">다시 &lt;code&gt;C&lt;/code&gt; 에 클래스 메소드가 없으면 인스턴스 컨텍스트가 중복되므로 GHC는 대신 &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="80611142c1da75771c803bc1306de5dd47e954cb" translate="yes" xml:space="preserve">
          <source>Alexander Berntsen 2014</source>
          <target state="translated">알렉산더 베른 슨 2014</target>
        </trans-unit>
        <trans-unit id="0f9d329fecfee776bcba1d14e6bca4840fae8ece" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;#12717&lt;/a&gt;</source>
          <target state="translated">서명에 지정된 대수 데이터 유형은 패턴 동의어를 사용하여 구현할 수 없습니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;# 12717&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="70df90ba28c32aa3934681405622b497740ae050" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Issue #12717&lt;/a&gt;</source>
          <target state="translated">서명에 지정된 대수 데이터 형식은 패턴 동의어를 사용하여 구현할 수 없습니다. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;문제 # 12717&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="a995fe628ebfb0ac7cc0c0b98a66a1d60308575a" translate="yes" xml:space="preserve">
          <source>Algebraic properties:</source>
          <target state="translated">대수 속성 :</target>
        </trans-unit>
        <trans-unit id="00fe36cee0a001e71e45449595c2a673824d1b79" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="308d7f644aaa00a5665368fb713217dcb84b51ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="9cdf35744dcefb67854cfd9303dbe37b27518062" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="107c8c77b99ddea22e0d4483b070454ccd2a71ae" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="23f78602884a7b538f91b984806e37d22c871f3b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">에 대한 별칭 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="0c1b2d82c320084f6a2ecaa9b2bb2ee948dec368" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; 별명 .</target>
        </trans-unit>
        <trans-unit id="60cc1b8e67da53fd1ea040fa3bfb7016cc924b7f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 의 별칭 .</target>
        </trans-unit>
        <trans-unit id="dc75b7adfd72cadf1d0c28de54a66b5886fa0528" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt;. Returns True if its parameter is 1# and False if it is 0#.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt; 별명입니다 . 매개 변수가 1 #이면 True를, 0 #이면 False를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5417a2480ca72a7d0a8e8c2b271f31533da5d02" translate="yes" xml:space="preserve">
          <source>Align functions at given boundary.</source>
          <target state="translated">주어진 경계에서 기능을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="309cb56d1cbd5360ce8e4fa89688161c57474b68" translate="yes" xml:space="preserve">
          <source>Align functions to multiples of the given value. Only valid values are powers of two.</source>
          <target state="translated">주어진 값의 배수에 함수를 정렬합니다. 유효한 값만 2의 거듭 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="be7cbc9171e2709ef932f92879b2fa92b735095e" translate="yes" xml:space="preserve">
          <source>All are based directly on their similarly-named &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; counterparts.</source>
          <target state="translated">모두 비슷한 이름의 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 대응을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="a6cd8f76353135f8eca4c08f035ed3722d4ad99a" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where &lt;code&gt;n&lt;/code&gt; is the number of bits in the type.</source>
          <target state="translated">모든 산술은 모듈로 2 ^ n으로 수행되며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 유형의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5c996c3cc62dedfc6f0f7accd3202c5cbe66b76c" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; raise an error on negative arguments.</source>
          <target state="translated">모든 산술은 모듈로 2 ^ n으로 수행되며, 여기서 n은 유형의 비트 수입니다. 이 중 하나가 아닌 명백한 결과는 즉 &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; 해야 &lt;em&gt;하지&lt;/em&gt; 부정적 인수에 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0cb70b7dc62c8932f9a5fdafd462f49e1a9ac846" translate="yes" xml:space="preserve">
          <source>All data that is read will be decoded as UTF-8.</source>
          <target state="translated">읽은 모든 데이터는 UTF-8로 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="63944b6a06201ae38dfb9a4d0c8e79dcd222ae47" translate="yes" xml:space="preserve">
          <source>All formats</source>
          <target state="translated">모든 형식</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
