<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d5507b0f18decf38efebb2baf95899e32741bd94" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="77bf20d91ceb476f6b9ea2842825823e4604ec77" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="24fb42bb11b50fc7ce69ee30065d1973f47224a8" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</source>
          <target state="translated">8 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a1f3a811131d09d0335cf08bcb0dc990d07652" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">큰 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="05432a5fd8c339fe215b088dc62e9c4db0f5ad4f" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="de8130999c3da1a518c6762523cf34aa16e35e31" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="0a6451dcfee7930103c165c01294315d2a6e1e29" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</source>
          <target state="translated">16 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="e47596a84833c882daecf2ad7d965729fc04eb6e" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; using 2 nibbles (hexadecimal digits).</source>
          <target state="translated">2 니블 (16 진수)을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f3c21864f38f632a39e1c67bfff3991e7e21b64" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 빅 엔디안 형식으로 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="e3547c43fa7a25fd14c5cb90f254957678c4920d" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Little endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fd3f074d457c33976db0851c5799ea77a0e354" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="70de18b4c581fc3ead7fa0c2d7edf18811db5502" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native host order.</source>
          <target state="translated">기본 호스트 순서 로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4c199d06aaa7e0f8ae4b8d7d339534925fc711d" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 빅 엔디안 형식으로 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="110f0a6326198f1f16294034cc9bda201684e613" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 리틀 엔디안 형식으로 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e3fa4b66c04bb7d1aa9610293690a81749f7a6" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native host order and host endianness. Values written this way are not portable to different endian machines, without conversion.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 . 이 방법으로 작성된 값은 변환없이 다른 엔디 언 머신으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c486f39e022239360aadec78edcbd84b8104b3f9" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native host order. Values encoded this way are not portable to different endian machines, without conversion.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 고유 호스트 순서로 인코딩하십시오 . 이 방법으로 인코딩 된 값은 변환없이 다른 엔디 언 머신으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4aa216110f68f4aefcb2b995cef482fa886e846e" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 네이티브 호스트 순서와 호스트 엔디안으로 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="5c6ed9394caa84c980d605e1aafe3e67fe08b0ba" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; using 4 nibbles.</source>
          <target state="translated">니블 4 개를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="fb5af823493b5832be87a33f468f44386fac2659" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 를 네이티브 호스트 순서 및 호스트 엔디안으로 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="efea09c0269185b4b3f24edfc6fafffae2cecf8f" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</source>
          <target state="translated">8 개의 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="712881f2d6292fa3cc9fda5d7f12910320862a3e" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 를 네이티브 호스트 순서 및 호스트 엔디안으로 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="98ea0d6d775f03613a3c6945d463056b62066541" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</source>
          <target state="translated">16 개의 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="0f72bcca8071b7d103c5906e4c46ea6082f351c2" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; using 2 nibbles (hexadecimal digits).</source>
          <target state="translated">2 개의 니블 (16 진수)을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="6ccf6e425b5b21f2f52878ed729b70f32a03ea62" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Big endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="402755f6cbcb2ee0c9cf1d7d0c124651f9de2ff2" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="02b2505af0b35f23ba983e185d7fdaa5b2abe28a" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">네이티브 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="445f1f5aba78e7464e522a9c0102ac7bd7abdf15" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; using 4 nibbles.</source>
          <target state="translated">니블 4 개를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="ad039b54722a5a6082c9c5ba587922590d688e99" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Big endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="14f037f1470656ef667fda01f211a04b7aac854d" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Little Endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="a046c39e2ffe9d7170545917e3ce63c848cece48" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">네이티브 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="7083296bae0699e6577bbbc3ff5b9eada373d98c" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</source>
          <target state="translated">8 개의 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="3f0dd56fc239baea7cf6aeb82a1fb2303c45ca5a" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Big endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="b05ccf8ddbf56fb9e5ab34f06e659a892a9fb8a0" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="e7f6f321f342f6c75dec3581cf7d28f4c897ecf9" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">네이티브 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="1ccf9b684d21cb244df1628210fe3c7ad8bdda44" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</source>
          <target state="translated">16 개의 니블을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e1c2f1b17afb5893fa06cac13620c6305ab428d1" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; using 2 nibbles (hexadecimal digits).</source>
          <target state="translated">니블 2 개 (16 진수)를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e2dd5a89e80eefeb2ca6b2a09b68ed59f9e60c29" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 빅 엔디안 형식으로 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="f52207abcde1a04fbdc9ff35529e075ff05935b1" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 little endian 형식으로 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="ed39eccab9a59a93f4a62cdae9f1da0a03795fe0" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서와 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="37c66581a891d9d2fc686612796458dfe37347b8" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native host order.</source>
          <target state="translated">기본 호스트 순서 로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a439ed5c8e1b7fbddb0aec689f6189ffd98cce4b" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="62ca91a5838111f968750fa4f25c98f1b043cc90" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Little Endian 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="dc733b84b9c6644425002e0fa3dadbc365d0147b" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native host order and host endianness. Values written this way are not portable to different endian machines, without conversion.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안 으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 . 이 방법으로 작성된 값은 변환없이 다른 엔디안 머신으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="983ae67e153cf5fc0adbdc4ce9f42f3e87bb18a7" translate="yes" xml:space="preserve">
          <source>Encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native host order. Values encoded this way are not portable to different endian machines, without conversion.</source>
          <target state="translated">기본 호스트 순서 로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 . 이러한 방식으로 인코딩 된 값은 변환없이 다른 엔디안 머신으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7e56de8587325adb822aafd3ad0008419a05a05" translate="yes" xml:space="preserve">
          <source>Encode a list of values from left-to-right with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 을 사용하여 왼쪽에서 오른쪽으로 값 목록을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="52680765f8cb407781abe2bb95b3b01bf0ac66c6" translate="yes" xml:space="preserve">
          <source>Encode a list of values in the Put monad. The default implementation may be overridden to be more efficient but must still have the same encoding format.</source>
          <target state="translated">Put 모나드에 값 목록을 인코딩하십시오. 기본 구현은 더 효율적으로 재정의 될 수 있지만 여전히 동일한 인코딩 형식을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac4d7d6613a49fc30249c64b85339a83d4efa2d" translate="yes" xml:space="preserve">
          <source>Encode a list of values represented as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 로 표시되는 값 목록을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="a36c7ba2dba11a42c819a6c8af11aa4a580b2a49" translate="yes" xml:space="preserve">
          <source>Encode a list of values represented as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 폴더 로 표시된 값 목록을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="3cb80ca4fae88d7af160291637be0b60ac0fbe16" translate="yes" xml:space="preserve">
          <source>Encode a pair by encoding its first component and then its second component.</source>
          <target state="translated">첫 번째 구성 요소와 두 번째 구성 요소를 인코딩하여 쌍을 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="9b4dc855c8520e328527e36870470d7b176ddbc9" translate="yes" xml:space="preserve">
          <source>Encode a signed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; according to &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;&lt;/code&gt; and optionally requested precision.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;&lt;/code&gt; 및 선택적으로 요청 된 정밀도 에 따라 서명 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed6eb34f4b4cf25e990c7d99f27115fc07ed1871" translate="yes" xml:space="preserve">
          <source>Encode a signed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; according to &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;&lt;/code&gt; and optionally requested precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a468228b2ecbd7096265f5e4c24a662e719aef" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is encoded in host order, host endian form, for the machine you're on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or int sized machines, without conversion.</source>
          <target state="translated">단일 기본 시스템 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 당신이하고있는 기계, 호스트 순서, 호스트 엔디안 형식으로 인코딩됩니다. 64 비트 시스템에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 시스템에서 4 바이트입니다. 이 방법으로 인코딩 된 값은 변환없이 다른 엔디 언 또는 int 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07ddfcedbad4c3903c9f8baf226fa7b40803cbf6" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s is encoded in host order, host endian form, for the machine you are on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or integer sized machines, without conversion.</source>
          <target state="translated">단일 기본 시스템 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의이 호스트 순서로 인코딩, 호스트 엔디 언 형태는 기계 당신은에 있습니다. 64 비트 시스템에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 시스템에서 4 바이트입니다. 이 방법으로 인코딩 된 값은 변환없이 다른 엔디 언 또는 정수 크기의 시스템으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d1362011cdbdd4ae2c3179bd1b99581e3d7495d" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is encoded in host order, host endian form, for the machine you're on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">단일 기본 머신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 당신이하고있는 기계, 호스트 순서, 호스트 엔디안 형식으로 인코딩됩니다. 64 비트 시스템에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 시스템에서 4 바이트입니다. 이 방법으로 인코딩 된 값은 변환없이 다른 엔디 언 또는 워드 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ece10ce9953c6ed58448ecd9e9a621f8fcc7752" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s is encoded in host order, host endian form, for the machine you are on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">단일 기본 머신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의이 호스트 순서로 인코딩, 호스트 엔디 언 형태는 기계 당신은에 있습니다. 64 비트 시스템에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 시스템에서 4 바이트입니다. 이 방법으로 인코딩 된 값은 변환없이 다른 엔디 언 또는 워드 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02efd15e348f5d31db2110ffb035aea2264744fb" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is encoded in host order, host endian form, for the machine you're on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or int sized machines, without conversion.</source>
          <target state="translated">단일 네이티브 머신 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 . &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 당신이하고있는 기계, 호스트 순서, 호스트 엔디안 형식으로 인코딩됩니다. 64 비트 컴퓨터에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 컴퓨터에서는 4 바이트입니다. 이 방식으로 인코딩 된 값은 변환없이 다른 endian 또는 int 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="060d0f91967e6833bd03d9f720a6997d060eecc5" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s is encoded in host order, host endian form, for the machine you are on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or integer sized machines, without conversion.</source>
          <target state="translated">단일 네이티브 머신 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 . &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의이 호스트 순서로 인코딩, 호스트 엔디 언 형태는 기계 당신은에 있습니다. 64 비트 컴퓨터에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 컴퓨터에서는 4 바이트입니다. 이러한 방식으로 인코딩 된 값은 변환없이 다른 엔디안 또는 정수 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9e63256da19a6c703950f8fc9a426f1efd3ce46" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is encoded in host order, host endian form, for the machine you're on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">단일 네이티브 컴퓨터 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 . &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 당신이하고있는 기계, 호스트 순서, 호스트 엔디안 형식으로 인코딩됩니다. 64 비트 컴퓨터에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 컴퓨터에서는 4 바이트입니다. 이러한 방식으로 인코딩 된 값은 변환없이 다른 엔디안 또는 단어 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65984467f82bedb4536b0cfd090237a93f024ea2" translate="yes" xml:space="preserve">
          <source>Encode a single native machine &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s is encoded in host order, host endian form, for the machine you are on. On a 64 bit machine the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an 8 byte value, on a 32 bit machine, 4 bytes. Values encoded this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">단일 네이티브 머신 인코딩 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 를. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 의이 호스트 순서로 인코딩, 호스트 엔디 언 형태는 기계 당신은에 있습니다. 64 비트 컴퓨터에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 는 8 바이트 값이고 32 비트 컴퓨터에서는 4 바이트입니다. 이러한 방식으로 인코딩 된 값은 변환없이 다른 엔디안 또는 단어 크기의 컴퓨터로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6983fe28a05ea17871e3e37244b8fff0a1a6de40" translate="yes" xml:space="preserve">
          <source>Encode a single signed byte as-is.</source>
          <target state="translated">단일 부호있는 바이트를 그대로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="eadd08112f8d09e24c196f8618105247237461cc" translate="yes" xml:space="preserve">
          <source>Encode a single unsigned byte as-is.</source>
          <target state="translated">부호없는 단일 바이트를 그대로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="2ab8d13229d792d7032c2d8dffeaabfc039aa2a9" translate="yes" xml:space="preserve">
          <source>Encode a value in the Put monad.</source>
          <target state="translated">Put 모나드에 값을 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="295eee5eda3dfb1cdafe4f73f2fab92721d77178" translate="yes" xml:space="preserve">
          <source>Encode a value using binary serialisation to a lazy ByteString.</source>
          <target state="translated">이진 직렬화를 사용하여 값을 게으른 ByteString으로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="ca5d12fcad4675a27ee1a0f8c6cd20af5c7a065b" translate="yes" xml:space="preserve">
          <source>Encode a value with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 으로 값을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="816b95d1ae7b699a928b4e934e3b69bf3deda236" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">인 코드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 제 이용 가치 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 위한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값과 상기 제 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 를 위해 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="9a1858f223015d2a34d17553b36246894fb278ba" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">인 코드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 제 이용 가치 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 위한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 값과 상기 제 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 를 위해 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="a20e4c0260c34eabcda6737eaca75397190fe586" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 빅 엔디안 형식으로 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c363b1cea1b9334505a0e76647586bbfb117b6" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="2afa695117a27359f39f00a5d5edd1f7a269d4a4" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">큰 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0b070b434519b10bf41e9c539c59214733388f8" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="cddeb450b2b4e00c4e4b63eb4f576681a94d3b96" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">큰 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="a34b4ace3553ece51c60c38e8cf31e6083d2066d" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 를 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="b45a3f592ff26715863ce4de58b1836a398bf501" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</target>
        </trans-unit>
        <trans-unit id="d520489fda806347c1fc745b5771901fd2d9d36c" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; value using the first &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values and the second &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; values.</target>
        </trans-unit>
        <trans-unit id="988b1343a9e3131c6916f0fac27dc20a4818c642" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in big endian format.</target>
        </trans-unit>
        <trans-unit id="6a60db99b2e1a233ced440ab963f1ee351c0879a" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; in little endian format.</target>
        </trans-unit>
        <trans-unit id="8ab4b55ed842d32e51e89d7abd505b7dea3b67e2" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in big endian format.</target>
        </trans-unit>
        <trans-unit id="89d8a00daaf7278d0a5c46e4a795448b84ac3b73" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; in little endian format.</target>
        </trans-unit>
        <trans-unit id="645aea83e39ff9baad2e6f019e97fdac12020e81" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in big endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in big endian format.</target>
        </trans-unit>
        <trans-unit id="ae3dd13d6ddaef6b42177f65733e8f3e687df1d8" translate="yes" xml:space="preserve">
          <source>Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in little endian format.</source>
          <target state="translated">Encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; in little endian format.</target>
        </trans-unit>
        <trans-unit id="734c97b3bab50170f831f09db84db97f76726007" translate="yes" xml:space="preserve">
          <source>Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</source>
          <target state="translated">16 니블을 사용하여 IEEE &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="58ee0d970e194ca48821f050f6d3d589d99fce99" translate="yes" xml:space="preserve">
          <source>Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</source>
          <target state="translated">8 개의 니블을 사용하여 IEEE &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="8a7cde0922837691efb9ea2758cd4d7fe5b765fc" translate="yes" xml:space="preserve">
          <source>Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</source>
          <target state="translated">Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; using 16 nibbles.</target>
        </trans-unit>
        <trans-unit id="5884c4a44c8e4ba871b0804a115c719334f7c22f" translate="yes" xml:space="preserve">
          <source>Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</source>
          <target state="translated">Encode an IEEE &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; using 8 nibbles.</target>
        </trans-unit>
        <trans-unit id="c988172a402a6d55b3e1cec74295bdd51feadcad" translate="yes" xml:space="preserve">
          <source>Encode each byte of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; using its fixed-width hex encoding.</source>
          <target state="translated">고정 너비 16 진 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 각 바이트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="4d747d4b3e668d03e5b26568421bbf6ff1c830b5" translate="yes" xml:space="preserve">
          <source>Encode each byte of a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; using its fixed-width hex encoding.</source>
          <target state="translated">고정 폭 16 진 인코딩을 사용하여 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 각 바이트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="50e8df369613004661e233b3150a712b1b125e87" translate="yes" xml:space="preserve">
          <source>Encode text to a ByteString &lt;code&gt;&lt;a href=&quot;../binary-0.8.7.0/data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using UTF-8 encoding.</source>
          <target state="translated">UTF-8 인코딩을 사용하여 텍스트를 ByteString &lt;code&gt;&lt;a href=&quot;../binary-0.8.7.0/data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="5d82ee4a70f3c101adbcce10273dabe5bf257062" translate="yes" xml:space="preserve">
          <source>Encode text to a ByteString &lt;code&gt;&lt;a href=&quot;../binary-0.8.8.0/data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using UTF-8 encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24eeb5caad506acc65db2f597ad86a426c5b090" translate="yes" xml:space="preserve">
          <source>Encode text using UTF-8 encoding and escape the ASCII characters using a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8 인코딩을 사용하여 텍스트를 인코딩하고 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 을 사용하여 ASCII 문자를 이스케이프하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2aa7ceb9cf7b097bb29afde43f62c84129f056c" translate="yes" xml:space="preserve">
          <source>Encode text using UTF-8 encoding.</source>
          <target state="translated">UTF-8 인코딩을 사용하여 텍스트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="4f778249ad913d8903fa8e30ff5beab5df190501" translate="yes" xml:space="preserve">
          <source>Encode text using big endian UTF-16 encoding.</source>
          <target state="translated">빅 엔디안 UTF-16 인코딩을 사용하여 텍스트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="cffe1cdf6650f44bb3d69562eabcbee35f12ac4b" translate="yes" xml:space="preserve">
          <source>Encode text using big endian UTF-32 encoding.</source>
          <target state="translated">빅 엔디안 UTF-32 인코딩을 사용하여 텍스트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="b79cfbbb486c5edaf80b30dad4573a8f560a52d1" translate="yes" xml:space="preserve">
          <source>Encode text using little endian UTF-16 encoding.</source>
          <target state="translated">리틀 엔디안 UTF-16 인코딩을 사용하여 텍스트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="30f47ea13d701fb0848435569da3b44a624ee2f1" translate="yes" xml:space="preserve">
          <source>Encode text using little endian UTF-32 encoding.</source>
          <target state="translated">리틀 엔디안 UTF-32 인코딩을 사용하여 텍스트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="d7329fd2e51a31101515e82c495c178a56a6d904" translate="yes" xml:space="preserve">
          <source>Encode the least 7-bits of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; using the ASCII encoding.</source>
          <target state="translated">ASCII 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 의 최소 ​​7 비트를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="65b6e928feeb3ecc32dc7a285943574c8043022d" translate="yes" xml:space="preserve">
          <source>Encode the least 7-bits of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; using the ASCII encoding.</source>
          <target state="translated">Encode the least 7-bits of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; using the ASCII encoding.</target>
        </trans-unit>
        <trans-unit id="5629ccc7bab757e312c896d21953efdb17f0d62a" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">큰 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="cac14e5d174e2e3d136dc629f772d7cf8b8c29ee" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="5d97094ed35ff2254ceb3044617a15498976d087" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">고유 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="f100612fb6229f9609b9da07fb8c9bcc7629adc5" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="3cd54b9d6c3e24dd48274894a0e494dc895b5a3e" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="275549ff4d16e08f8f38d088615c4683b9db3c59" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="e3f2f7db49cd435a9c1b9208c153c406f75e8865" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="e87eb3bdf58daa3f9e898524ae95529e81f64b53" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="1f0bd65d7a38151e79459228eed2053dc4bebcd5" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="818630ea4202156c74ab646ef4acdd130a0960a0" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="f94074f3e3de7899535b8f5be4c54510830ccb1b" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="946f004554ffd3b01043149d1399ade28820c183" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">고유 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 을 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="c8558c84b81ad99d7e8becbb5986f2484d25183b" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="0a0e7b91b4dcd673faa71a534c3d4d60d19c1c00" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="3989971f4f1f09b2e687b1c68d4495a6e986c38e" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">고유 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="efa885bc0ab0f549bb33ab63f9730ed6d68778c7" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">빅 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="29250053443101258403c48776c24a24c17df7f0" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">리틀 엔디안 형식으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 인코딩</target>
        </trans-unit>
        <trans-unit id="41552969da89bfde3a0bbc340f161b7509e292a2" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">기본 호스트 순서 및 호스트 엔디안으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 를 인코딩 합니다.</target>
        </trans-unit>
        <trans-unit id="a47395e1c4ad92c62d0ebb55cc13116a731c5caf" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="fb4874e22971124eb3bbe6fe9b8a923c6c1aad92" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="cc0a2a82cf1add3ccd71c95124bf1c6fda6e18fc" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="6c4f671291e7414a2bef669632c0138c5183c9e8" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="fef858ae12902bb7a112479524819f643cd75d2f" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="182802b73a0463674481e76e6191af4f6287c178" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="7a69831ea2f25e7b8d86896bc9255392a3e3e158" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="bd4e934d8e298351f881f8f916b6cde40ada6b50" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="93797d052a60f76a9684e30ca3eb2a52edbe698a" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="31a191f895a5d929c6915541d4ee1ca1343362dd" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="de3ba13865820411c6e0ca1049af9fae86aef917" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="b7ba51ae1fc742e39791b024ba0048ea5065e1c8" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="0aa025369305610fcc9bbb6bee031445a4d5fdba" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="96e8fc85735f03e10cd5f524e5f3712b0ce86421" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="d157a26640e8f0e7a0d608ab91e98d5dba14152a" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="14a505698f0bdc78abb1f61fe12f29c9b5a42162" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in big endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; s in big endian format.</target>
        </trans-unit>
        <trans-unit id="a667351f3074855f275a37252d70cada4d3d1e68" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in little endian format.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; s in little endian format.</target>
        </trans-unit>
        <trans-unit id="b23a9e65b1ea847f0763c2c2147c2fb42231d152" translate="yes" xml:space="preserve">
          <source>Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;s in native host order and host endianness.</source>
          <target state="translated">Encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; s in native host order and host endianness.</target>
        </trans-unit>
        <trans-unit id="5089e4a874aae297eb0b00a478a1b4bc7a6a789b" translate="yes" xml:space="preserve">
          <source>Encoding Text to ByteStrings</source>
          <target state="translated">텍스트를 ByteString으로 인코딩</target>
        </trans-unit>
        <trans-unit id="79f2d7c39657d6a65cd03f2d06e10ed7d7e13d60" translate="yes" xml:space="preserve">
          <source>Encoding Text using ByteString Builders</source>
          <target state="translated">ByteString Builders를 사용하여 텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="841dba880fd6eb57eaecb641d27407305c1f6429" translate="yes" xml:space="preserve">
          <source>Encoding and decoding errors are always detected and reported, except during lazy I/O (&lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt;), where a decoding error merely results in termination of the character stream, as with other I/O errors.</source>
          <target state="translated">지연 I / O ( &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; )를 제외하고 인코딩 및 디코딩 오류는 항상 감지 및보고됩니다. 여기서 디코딩 오류로 인해 다른 I / O 오류와 마찬가지로 문자 스트림이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8a145ae5bc2628ee4f2687bb51fe872ddd6d02" translate="yes" xml:space="preserve">
          <source>Encoding as UTF-8</source>
          <target state="translated">UTF-8로 인코딩</target>
        </trans-unit>
        <trans-unit id="753be8523292b47d27e2730dd2ca1228ffe0ba3b" translate="yes" xml:space="preserve">
          <source>Encoding positive integers as hexadecimal numbers using lower-case ASCII characters. The shortest possible representation is used. For example,</source>
          <target state="translated">소문자 ASCII 문자를 사용하여 양의 정수를 16 진수로 인코딩합니다. 가능한 가장 짧은 표현이 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="015792365f0898e93a1de286fdb2953224cbe957" translate="yes" xml:space="preserve">
          <source>Encoding single signed bytes as-is.</source>
          <target state="translated">단일 부호있는 바이트를 그대로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="280e5e71232d43700ed2a3d47e96e3c1695951c0" translate="yes" xml:space="preserve">
          <source>Encoding single unsigned bytes as-is.</source>
          <target state="translated">부호없는 단일 바이트를 그대로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dda76ca073f8bb497b391abdae7ec301f4b4b0f7" translate="yes" xml:space="preserve">
          <source>Encoding the bytes of fixed-width types as hexadecimal numbers using lower-case ASCII characters. For example,</source>
          <target state="translated">고정 너비 유형의 바이트를 소문자 ASCII 문자를 사용하여 16 진수로 인코딩합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="11840c3369b647cd4a9c1b1f9b819d015789e1d4" translate="yes" xml:space="preserve">
          <source>End Simple MAPI-session</source>
          <target state="translated">간단한 MAPI 세션 종료</target>
        </trans-unit>
        <trans-unit id="4708b3fa5453d8a1cdd3846f92491cf6dd4b63e9" translate="yes" xml:space="preserve">
          <source>EndOfFile</source>
          <target state="translated">EndOfFile</target>
        </trans-unit>
        <trans-unit id="00970a05f650b06b47f9ab3ddb566bfd82b7c750" translate="yes" xml:space="preserve">
          <source>EndOfLine</source>
          <target state="translated">EndOfLine</target>
        </trans-unit>
        <trans-unit id="f4112c54a28a76be92dd5b2f113f6ad2150348ff" translate="yes" xml:space="preserve">
          <source>Ending an annotation.</source>
          <target state="translated">주석을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="66860744d813ef040d496b71a45d7d542ff19965" translate="yes" xml:space="preserve">
          <source>Endo</source>
          <target state="translated">Endo</target>
        </trans-unit>
        <trans-unit id="f72216773e3a3df470d6d1615a05c4fbd2d1e497" translate="yes" xml:space="preserve">
          <source>Enforcing strict type safety at compile time</source>
          <target state="translated">컴파일 타임에 엄격한 유형 안전 강화</target>
        </trans-unit>
        <trans-unit id="18d376d4deea55e77009ce7a05bc2312dc4560af" translate="yes" xml:space="preserve">
          <source>Enocode/Decode mutibyte charactor using Win32 API.</source>
          <target state="translated">Win32 API를 사용하여 멀티 바이트 문자를 Enocode / Decode합니다.</target>
        </trans-unit>
        <trans-unit id="c7afe4ea6d828d944d100d6f9b7b8dcc8b7f1fa6" translate="yes" xml:space="preserve">
          <source>Enqueue a bit. This works by shifting the queue right one bit, then setting the most significant bit as requested.</source>
          <target state="translated">조금 대기열에 넣습니다. 이것은 대기열을 오른쪽으로 한 비트 이동 한 다음 요청에 따라 최상위 비트를 설정하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="222da4bf0c88432288f763fe13cde48dc73f78ab" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;&lt;a href=&quot;data-char#v:isLetter&quot;&gt;isLetter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt; are equivalent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#v:isLetter&quot;&gt;isLetter&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:isAlpha&quot;&gt;isAlpha&lt;/a&gt;&lt;/code&gt; 가 동일한 지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2995c08772c9e1c4dd0b1af0d23e586ed37706a" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;n&lt;/code&gt; many elements are available, and then use &lt;code&gt;f&lt;/code&gt; to write some elements into the memory.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 요소를 사용할 수 있는지 확인한 다음 &lt;code&gt;f&lt;/code&gt; 를 사용 하여 일부 요소를 메모리에 씁니다.</target>
        </trans-unit>
        <trans-unit id="93b18736d5081aa8c6ede68225214442c3eec30b" translate="yes" xml:space="preserve">
          <source>Ensure that all untrusted code is imported as a &lt;a href=&quot;#safe-imports&quot;&gt;safe import&lt;/a&gt; and that the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;#safe-package-trust&quot;&gt;flag&lt;/a&gt;) is used with packages from untrusted sources being marked as untrusted.</source>
          <target state="translated">모든 신뢰할 수없는 코드가로 수입되어 있는지 확인 &lt;a href=&quot;#safe-imports&quot;&gt;안전한 수입&lt;/a&gt; 하고 있음을 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그 (참조 &lt;a href=&quot;#safe-package-trust&quot;&gt;플래그를&lt;/a&gt; 신뢰할 수없는 출처에서 패키지와 함께 사용)를 신뢰할 수없는 것으로 표시된다.</target>
        </trans-unit>
        <trans-unit id="b9d56604e7671e16d3f563dd3e82fe7e54a5990a" translate="yes" xml:space="preserve">
          <source>Ensure that there are at least &lt;code&gt;n&lt;/code&gt; free bytes for the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 대해 최소 &lt;code&gt;n&lt;/code&gt; 개의 사용 가능 바이트 가 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c53ae562e91c4c501f92cf95566d4bd6e871f10" translate="yes" xml:space="preserve">
          <source>Ensure that there are at least &lt;code&gt;n&lt;/code&gt; many elements available.</source>
          <target state="translated">사용 가능한 요소가 적어도 &lt;code&gt;n&lt;/code&gt; 개 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0af74831d06739115781598a1020a4b548bfd721" translate="yes" xml:space="preserve">
          <source>Ensures that the suspensions under evaluation by the current thread are unique; that is, the current thread is not evaluating anything that is also under evaluation by another thread that has also executed &lt;code&gt;&lt;a href=&quot;ghc-io#v:noDuplicate&quot;&gt;noDuplicate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 스레드에서 평가중인 서스펜션이 고유한지 확인하십시오. 즉, 현재 스레드는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:noDuplicate&quot;&gt;noDuplicate&lt;/a&gt;&lt;/code&gt; 도 실행 한 다른 스레드에 의해 평가중인 항목을 평가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6aaa26bc536ec36d8980fc44ae8078a4d12fa476" translate="yes" xml:space="preserve">
          <source>Ensures that the suspensions under evaluation by the current thread are unique; that is, the current thread is not evaluating anything that is also under evaluation by another thread that has also executed &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:noDuplicate&quot;&gt;noDuplicate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 스레드에서 평가중인 서스펜션이 고유한지 확인하십시오. 즉, 현재 스레드는 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:noDuplicate&quot;&gt;noDuplicate&lt;/a&gt;&lt;/code&gt; 도 실행 한 다른 스레드에 의해 평가중인 항목을 평가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="c9c4f2efb477721f7ada4876507def206f990d00" translate="yes" xml:space="preserve">
          <source>Enumerate processes using Process32First and Process32Next</source>
          <target state="translated">Process32First 및 Process32Next를 사용하여 프로세스 열거</target>
        </trans-unit>
        <trans-unit id="fe83140b3e01ec4aa706a5a295ae6abd3470bab5" translate="yes" xml:space="preserve">
          <source>Enumerations of &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt; (e.g. &lt;code&gt;['a'..'z']&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Integer&lt;/code&gt; 및 &lt;code&gt;Char&lt;/code&gt; 열거 형 (예 : &lt;code&gt;['a'..'z']&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="6f5e71e71e29733b06d021985981b03479853e7b" translate="yes" xml:space="preserve">
          <source>Environment Strings</source>
          <target state="translated">환경 문자열</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="e746894bcb0da4fa5b65dec632c54a168ccc7747" translate="yes" xml:space="preserve">
          <source>EpochTime</source>
          <target state="translated">EpochTime</target>
        </trans-unit>
        <trans-unit id="afcfba63ae8c7c116df2f46471e75a3359724931" translate="yes" xml:space="preserve">
          <source>Eq</source>
          <target state="translated">Eq</target>
        </trans-unit>
        <trans-unit id="024d606ca7f5b6a5020eab3615d0ef3313c25417" translate="yes" xml:space="preserve">
          <source>Eq1</source>
          <target state="translated">Eq1</target>
        </trans-unit>
        <trans-unit id="0a8d730034e04185b7ca3ae8c71b1e717cdccf65" translate="yes" xml:space="preserve">
          <source>Eq2</source>
          <target state="translated">Eq2</target>
        </trans-unit>
        <trans-unit id="7a9900d84e1403f9c455cfd34c5bb3f62971e633" translate="yes" xml:space="preserve">
          <source>Equality</source>
          <target state="translated">Equality</target>
        </trans-unit>
        <trans-unit id="dd932b5c22b6fac63dce314620bdab9a740d54d2" translate="yes" xml:space="preserve">
          <source>Equality constraints can also appear in class and instance contexts. The former enable a simple translation of programs using functional dependencies into programs using family synonyms instead. The general idea is to rewrite a class declaration of the form</source>
          <target state="translated">동등 제약 조건은 클래스 및 인스턴스 컨텍스트에도 나타날 수 있습니다. 전자는 기능적 종속성을 사용하는 프로그램을 대신 가족 동의어를 사용하는 프로그램으로 간단하게 변환 할 수 있습니다. 일반적인 아이디어는 폼의 클래스 선언을 다시 작성하는 것입니다</target>
        </trans-unit>
        <trans-unit id="67252bcc828e69acf9480ba5a7ff926382fa5470" translate="yes" xml:space="preserve">
          <source>Equality constraints; e.g. &lt;code&gt;ord True&lt;/code&gt; gives rise to an insoluble equality constraint &lt;code&gt;Char ~ Bool&lt;/code&gt;, which can be deferred.</source>
          <target state="translated">평등 제약; 예를 들어 &lt;code&gt;ord True&lt;/code&gt; 는 불용성 평등 제약 &lt;code&gt;Char ~ Bool&lt;/code&gt; 을 발생 시키며 이는 연기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d92f07e210fc007fc6c4cb74e6030a1cb502ad3a" translate="yes" xml:space="preserve">
          <source>Equality of constructors</source>
          <target state="translated">생성자의 평등</target>
        </trans-unit>
        <trans-unit id="f5ff16eadf101b0bcfe8309c969f2d55e963d450" translate="yes" xml:space="preserve">
          <source>Equality of two &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s. If you call &lt;code&gt;System.Directory.canonicalizePath&lt;/code&gt; first this has a much better chance of working. Note that this doesn't follow symlinks or DOSNAM~1s.</source>
          <target state="translated">두 개의 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 가 동일합니다. &lt;code&gt;System.Directory.canonicalizePath&lt;/code&gt; 를 먼저 호출하면 작업 가능성이 훨씬 높아집니다. 이것은 심볼릭 링크 또는 DOSNAM ~ 1을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad75f68260f94bce3877de28af5c0b5e93a0db1c" translate="yes" xml:space="preserve">
          <source>Equality of two &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s. If you call &lt;code&gt;System.Directory.canonicalizePath&lt;/code&gt; first this has a much better chance of working. Note that this doesn't follow symlinks or DOSNAM~1s.</source>
          <target state="translated">두 개의 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 가 동일합니다. &lt;code&gt;System.Directory.canonicalizePath&lt;/code&gt; 를 먼저 호출하면 작업 가능성이 훨씬 높아집니다. 이것은 심볼릭 링크 또는 DOSNAM ~ 1을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28c9f6ed6a6738230006d38e856551b5666d9115" translate="yes" xml:space="preserve">
          <source>Equality on &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; that does not require that the types of the arguments match.</source>
          <target state="translated">인수 유형이 일치하지 않아도되는 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 의 동일성</target>
        </trans-unit>
        <trans-unit id="1f57c35e09cef44fb38e7acf20e2c72b6579104c" translate="yes" xml:space="preserve">
          <source>Equality on &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; that does not require that the types of the arguments match.</source>
          <target state="translated">인수 유형이 일치하지 않아도되는 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 의 동일성</target>
        </trans-unit>
        <trans-unit id="2a6aa35f8013684cff4ad26bb51395662e2921e2" translate="yes" xml:space="preserve">
          <source>Equality operators</source>
          <target state="translated">평등 연산자</target>
        </trans-unit>
        <trans-unit id="98643c6066d5f22cae71ce8b985feead0064db50" translate="yes" xml:space="preserve">
          <source>EqualityT</source>
          <target state="translated">EqualityT</target>
        </trans-unit>
        <trans-unit id="45de971d824fe3e849e875891b71d1111691e1c8" translate="yes" xml:space="preserve">
          <source>Equations</source>
          <target state="translated">Equations</target>
        </trans-unit>
        <trans-unit id="1be8b8d468eacba7d12d48c32f39b3f8bb53844d" translate="yes" xml:space="preserve">
          <source>Equipped with this guaranteed to be non-empty data structure, we can combine values using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; of our choosing. We can try the &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Max&quot;&gt;Max&lt;/a&gt;&lt;/code&gt; instances of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; which pick the smallest, or largest number respectively:</source>
          <target state="translated">비어 있지 않은 데이터 구조를 보장이 장착, 우리는 사용하여 값 결합 할 수 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 우리의 선택에의합니다. 가장 작은 숫자 또는 가장 큰 숫자를 각각 선택하는 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Max&quot;&gt;Max&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ab39d71e2233de54bc6c355380c3c9f96c02e36" translate="yes" xml:space="preserve">
          <source>Equivalence</source>
          <target state="translated">Equivalence</target>
        </trans-unit>
        <trans-unit id="3a71b2c82131485fcbda2a2cc630d1c446facacb" translate="yes" xml:space="preserve">
          <source>Equivalence Relations</source>
          <target state="translated">동등성 관계</target>
        </trans-unit>
        <trans-unit id="15fb20d5041620de529d540a5907d9bfb084f5a6" translate="yes" xml:space="preserve">
          <source>Equivalence relations are &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;, because you can apply the contramapped function to each input to the equivalence relation.</source>
          <target state="translated">등가 관계는 각 입력에 등가 관계를 적용 할 수 있기 때문에 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e0a17cc88967d4bc91912b0297baf9041f8a6d3" translate="yes" xml:space="preserve">
          <source>Equivalence relations are expected to satisfy three laws:</source>
          <target state="translated">동등성 관계는 다음 세 가지 법을 충족시킬 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="881f23d22c221433312c2bae30cb0ee2cc8acae8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt; ReaderT k (ReaderT x (MaybeT f)) &lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt; ReaderT k (ReaderT x (MaybeT f)) &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b45705d685bf19551f2d63e2de12728a889d2851" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt; ReaderT k (ReaderT x (ReaderT y (MaybeT f))) &lt;/code&gt;</source>
          <target state="translated">상당 &lt;code&gt; ReaderT k (ReaderT x (ReaderT y (MaybeT f))) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0708116639e47eadf2274507cf6cf38d16e968d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#v:word2Int-35-&quot;&gt;word2Int#&lt;/a&gt; . &lt;a href=&quot;ghc-integer-gmp-internals#v:bigNatToWord&quot;&gt;bigNatToWord&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf712fcbf260af1603149a967b9adaa1f8284c5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#v:word2Int-35-&quot;&gt;word2Int#&lt;/a&gt; . &lt;a href=&quot;ghc-integer-gmp-internals#v:bigNatToWord&quot;&gt;bigNatToWord&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#v:word2Int-35-&quot;&gt;word2Int#&lt;/a&gt; . &lt;a href=&quot;ghc-integer-gmp-internals#v:bigNatToWord&quot;&gt;bigNatToWord&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;a href=&quot;ghc-integer-gmp-internals#v:bigNatToWord&quot;&gt;bigNatToWord&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="906bbfdfac46546b457ced747c0a691073231d2c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ReaderT Key (ReaderT x (ReaderT y (MaybeT f)))&lt;/code&gt; 와 동일 (ReaderT x (ReaderT y (MaybeT f)))</target>
        </trans-unit>
        <trans-unit id="3d60b7c4dc5a57d332d9f48b3f3cd21fe42b4773" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;ReaderT k (ReaderT x (MaybeT f))&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;ReaderT k (ReaderT x (MaybeT f))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13f6fba897c7e0b2ab37c14a299d3729c84096bf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;\x -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt; x ()&lt;/code&gt;.</source>
          <target state="translated">당량 &lt;code&gt;\x -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt; x ()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05a351c6cc888eec691303c0ff94b661ae11b8ec" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;\x -&amp;gt; &lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt; x ()&lt;/code&gt;.</source>
          <target state="translated">Equivalent to &lt;code&gt;\x -&amp;gt; &lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt; x ()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cef6b7d8e5475105537180bb4c447ea38b08587" translate="yes" xml:space="preserve">
          <source>Erase</source>
          <target state="translated">Erase</target>
        </trans-unit>
        <trans-unit id="d0f7d3ea9b25f957e7dacf60a72d1119835befe7" translate="yes" xml:space="preserve">
          <source>ErrCode</source>
          <target state="translated">ErrCode</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="f54c5e2e6bb107cd0b387e03051c9312af598081" translate="yes" xml:space="preserve">
          <source>Error handling types</source>
          <target state="translated">오류 처리 유형</target>
        </trans-unit>
        <trans-unit id="38a2998cc83b4215b89f0b96917e58d59fdfae52" translate="yes" xml:space="preserve">
          <source>Error messages</source>
          <target state="translated">오류 메시지</target>
        </trans-unit>
        <trans-unit id="c2b00462bab8d44263c68877ef507452d68e3572" translate="yes" xml:space="preserve">
          <source>Error operations</source>
          <target state="translated">오류 연산</target>
        </trans-unit>
        <trans-unit id="779dde82828bf4f8960a376f01324829ef99bc79" translate="yes" xml:space="preserve">
          <source>ErrorCall</source>
          <target state="translated">ErrorCall</target>
        </trans-unit>
        <trans-unit id="ef367152f80f2e35230bf8ad27669a634ddd3298" translate="yes" xml:space="preserve">
          <source>ErrorList</source>
          <target state="translated">ErrorList</target>
        </trans-unit>
        <trans-unit id="8232c64535a7ea041a276a2bb3e8bb3f6e9161c9" translate="yes" xml:space="preserve">
          <source>ErrorMessage</source>
          <target state="translated">ErrorMessage</target>
        </trans-unit>
        <trans-unit id="235ef823e9943d1f3f30f8b899d5c9bdad3f3814" translate="yes" xml:space="preserve">
          <source>ErrorOnCodingFailure</source>
          <target state="translated">ErrorOnCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dc18b43615220b6ff75baf381cdb2b68d93926a" translate="yes" xml:space="preserve">
          <source>ErrorT</source>
          <target state="translated">ErrorT</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="d939ff3b4cb782382d61f9a09384c51db343fbff" translate="yes" xml:space="preserve">
          <source>Errors are reported &lt;em&gt;lazily&lt;/em&gt; (when attempting to solve a constraint), rather than &lt;em&gt;eagerly&lt;/em&gt; (when the instances themselves are defined). Consider, for example</source>
          <target state="translated">오류가보고 &lt;em&gt;느리게&lt;/em&gt; 보다는, (제약 조건을 해결하기 위해 시도 할 때) &lt;em&gt;열심히&lt;/em&gt; (인스턴스 자신이 정의 된 경우). 예를 들어</target>
        </trans-unit>
        <trans-unit id="3f8a28883b809e9afa35470a86f86e3e24cdbf2b" translate="yes" xml:space="preserve">
          <source>Esa Ilari Vuokko &amp;lt;ei@vuokko.info&amp;gt;</source>
          <target state="translated">에사 일 라리 뷰코 &amp;lt;ei@vuokko.info&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7ac544e7340762ce97c0d16f40c4ca9025ca9fec" translate="yes" xml:space="preserve">
          <source>Essential invariants:</source>
          <target state="translated">필수 불변량 :</target>
        </trans-unit>
        <trans-unit id="c08c3bf663d6c761128d41298a81ff90e9861422" translate="yes" xml:space="preserve">
          <source>Establishes a weak pointer to &lt;code&gt;k&lt;/code&gt;, with value &lt;code&gt;v&lt;/code&gt; and a finalizer.</source>
          <target state="translated">값 &lt;code&gt;v&lt;/code&gt; 와 종료 자를 사용하여 &lt;code&gt;k&lt;/code&gt; 에 대한 약한 포인터를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fa73f5f806aef3a9c2cf308941c972c61aa06d4a" translate="yes" xml:space="preserve">
          <source>Eta-expand let-bindings to increase their arity.</source>
          <target state="translated">Eta-expand let-bindings는 그들의 신성을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="aef703e135cd421c9e00e6cdf19278c5fa4e1103" translate="yes" xml:space="preserve">
          <source>Eta-reduce lambda expressions, if doing so gets rid of a whole group of lambdas.</source>
          <target state="translated">람다 식을 제거하면 전체 람다 그룹이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b56f4d5159f46e4ce448beb87a82c5d223b09604" translate="yes" xml:space="preserve">
          <source>EvalExpr</source>
          <target state="translated">EvalExpr</target>
        </trans-unit>
        <trans-unit id="4a4a4d67eeae56d8c536fd8dc5f9bf2bf8707629" translate="yes" xml:space="preserve">
          <source>EvalOpts</source>
          <target state="translated">EvalOpts</target>
        </trans-unit>
        <trans-unit id="aaff208217b0da64aa7669ad3b2a794af7339538" translate="yes" xml:space="preserve">
          <source>EvalResult</source>
          <target state="translated">EvalResult</target>
        </trans-unit>
        <trans-unit id="e9db83c0176792c5159a1db6fb3a831430700a62" translate="yes" xml:space="preserve">
          <source>EvalStatus</source>
          <target state="translated">EvalStatus</target>
        </trans-unit>
        <trans-unit id="32e8dcb877d33a8b6be87a78578cbe26fb0b02d7" translate="yes" xml:space="preserve">
          <source>EvalStatus_</source>
          <target state="translated">EvalStatus_</target>
        </trans-unit>
        <trans-unit id="793b83cfd66d3728db79e4e49e17fad265bc1cbd" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;expr&lt;/code&gt;; see &lt;a href=&quot;using#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 평가 ; 자세한 내용은 &lt;a href=&quot;using#eval-mode&quot;&gt;식 평가 모드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a00547e6b2983863aa614cbec89441585f4c7061" translate="yes" xml:space="preserve">
          <source>Evaluate a TH computation.</source>
          <target state="translated">TH 계산을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="f1ef9c08f16f14c3a70e32394decb704d73e3860" translate="yes" xml:space="preserve">
          <source>Evaluate a computation with the given initial state and environment, returning the final state and output, discarding the final value.</source>
          <target state="translated">주어진 초기 상태 및 환경으로 계산을 평가하고 최종 상태를 반환하고 최종 값을 버립니다.</target>
        </trans-unit>
        <trans-unit id="5ce33b7119a1fcbbe3bea4a7d4ded00281d81b80" translate="yes" xml:space="preserve">
          <source>Evaluate a computation with the given initial state and environment, returning the final value and output, discarding the final state.</source>
          <target state="translated">주어진 초기 상태와 환경으로 계산을 평가하여 최종 값과 출력을 반환하고 최종 상태를 버립니다.</target>
        </trans-unit>
        <trans-unit id="5120b791c97275bfdab439ed5f408a9c14ba728c" translate="yes" xml:space="preserve">
          <source>Evaluate a state computation with the given initial state and return the final state, discarding the final value.</source>
          <target state="translated">주어진 초기 상태로 상태 계산을 평가하고 최종 값을 버리고 최종 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b97d0220a8ca2af7c82b7da3b6ba16d8000505a2" translate="yes" xml:space="preserve">
          <source>Evaluate a state computation with the given initial state and return the final value, discarding the final state.</source>
          <target state="translated">주어진 초기 상태로 상태 계산을 평가하고 최종 상태를 버리고 최종 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a930ebfd5fb1cacbafa73ebf67b0180221424b7" translate="yes" xml:space="preserve">
          <source>Evaluate a statement</source>
          <target state="translated">성명서 평가</target>
        </trans-unit>
        <trans-unit id="10b1615bc5fe3be87badd7f322df122d7263f0e6" translate="yes" xml:space="preserve">
          <source>Evaluate an accumulation computation with the given initial output history and return the final value, discarding the final output.</source>
          <target state="translated">주어진 초기 출력 이력으로 누적 계산을 평가하고 최종 출력을 버리고 최종 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcea707fea238821ed4197374c1152c03b1b0ac8" translate="yes" xml:space="preserve">
          <source>Evaluate each action in the sequence from left to right, and collect the results.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순서대로 각 조치를 평가하고 결과를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="683c5e18f9f4969c8903352565b7c40f13f7a1a2" translate="yes" xml:space="preserve">
          <source>Evaluate each action in the structure from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 조치를 왼쪽에서 오른쪽으로 평가하고 결과를 수집하십시오. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b79f750a8d1b02ad391c2774298dc7a6fd704a1" translate="yes" xml:space="preserve">
          <source>Evaluate each action in the structure from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 조치를 왼쪽에서 오른쪽으로 평가하고 결과를 무시하십시오. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b431a52bddcb68d44c1dd429faeea8f23fdc88b5" translate="yes" xml:space="preserve">
          <source>Evaluate each action in the structure from left to right, and ignore the results. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 조치를 왼쪽에서 오른쪽으로 평가하고 결과를 무시하십시오. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d397057e5945dba899dd4e1514d774561fd9fc37" translate="yes" xml:space="preserve">
          <source>Evaluate each monadic action in the structure from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조에서 각 모나 딕 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 수집합니다. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc11e71e709359c3c1e669f66d6d423d48161940" translate="yes" xml:space="preserve">
          <source>Evaluate each monadic action in the structure from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 모나 딕 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 무시하십시오. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6063e6194a70062b52c361c98f4c7128f36a77fd" translate="yes" xml:space="preserve">
          <source>Evaluate something of type &lt;code&gt;IO ()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IO ()&lt;/code&gt; 유형의 무언가를 평가하십시오 ()</target>
        </trans-unit>
        <trans-unit id="e2a3bf0d57f8c64c06fdec8818cb5c85283c2792" translate="yes" xml:space="preserve">
          <source>Evaluate something of type &lt;code&gt;IO String&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IO String&lt;/code&gt; 유형을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="6eecdb8df1d52cba306e7b9906768bc34faacbd7" translate="yes" xml:space="preserve">
          <source>Evaluate something of type &lt;code&gt;String -&amp;gt; IO String&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String -&amp;gt; IO String&lt;/code&gt; 유형의 무언가를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="e494ca5e6198cd08e7b47b6be6bc4945a4d44bdb" translate="yes" xml:space="preserve">
          <source>Evaluate something. This is used to support :force in GHCi.</source>
          <target state="translated">무언가를 평가하십시오. GHCi에서 : force를 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2cf419db4400f92d4c16bda25b7b49de7c246f" translate="yes" xml:space="preserve">
          <source>Evaluate the argument to weak head normal form.</source>
          <target state="translated">약한 머리 정상 형태에 대한 주장을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="6060f4f46d5f080bbe6d3a4e15ea7e03aae4d623" translate="yes" xml:space="preserve">
          <source>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt;.</source>
          <target state="translated">주어진 표현식 (또는 표현식이 제공되지 않은 경우 마지막 중단 점에서)을 평가하고 나중에 &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; 를&lt;/a&gt; 사용하여 나중에 검사하기위한 평가 단계를 기록 합니다. &lt;a href=&quot;#tracing&quot;&gt;추적 및 히스토리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bc4cf67d5d67cdacfaa5ff060fb29cd523c09db" translate="yes" xml:space="preserve">
          <source>Evaluates the relevant functions at each element in the structure, running the action, and builds a new structure with the same shape, using the results produced from sequencing the actions.</source>
          <target state="translated">구조의 각 요소에서 관련 기능을 평가하고 조치를 실행하고 조치 순서에서 생성 된 결과를 사용하여 동일한 모양의 새 구조를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="5600c714a91cbc3264f491ad475c86811b22d09a" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;f&lt;/code&gt; directly shows a call stack with a single entry, while evaluating &lt;code&gt;g&lt;/code&gt;, which also requests its call-site, shows two entries, one for each computation &amp;ldquo;annotated&amp;rdquo; with &lt;code&gt;HasCallStack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 를 평가 하면 단일 항목이있는 호출 스택이 직접 표시되고, 호출 사이트도 요청하는 &lt;code&gt;g&lt;/code&gt; 가 평가 되면 &lt;code&gt;HasCallStack&lt;/code&gt; 을 사용 하여 &quot;주석이 지정된 &quot;계산마다 하나씩 두 개의 항목이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="6de480eeff47d7212d5e046acac48253bd022e55" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th prefix takes \( O(\log(\min(i, n-i))) \), but evaluating every prefix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">\ (i \) 번째 접두사를 평가하려면 \ (O (\ log (\ min (i, ni))) \)가 필요하지만 시퀀스의 모든 접두사를 평가하려면 공유로 인해 \ (O (n) \)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6396b8883a4c5c234f705d6f1fbf827f38a7835a" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th suffix takes \( O(\log(\min(i, n-i))) \), but evaluating every suffix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">\ (i \) 번째 접미사를 평가하려면 \ (O (\ log (\ min (i, ni))) \)가 필요하지만 순서대로 모든 접미사를 평가하려면 공유로 인해 \ (O (n) \)가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ea09e351bce3db4c6389ffff16dcaf057265f37f" translate="yes" xml:space="preserve">
          <source>Evaluation has started on a spark.</source>
          <target state="translated">Evaluation has started on a spark.</target>
        </trans-unit>
        <trans-unit id="bcce67319f3801a5d8320bd2ddeb26734158769d" translate="yes" xml:space="preserve">
          <source>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</source>
          <target state="translated">데이터 패밀리가 최상위 선언으로 정의 되더라도 다른 패밀리 인스턴스에 대해 서로 다른 계산을 수행하는 함수는 여전히 클래스 유형의 메소드로 정의해야합니다. 특히 다음은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="712f436fb09e995690fe8d40968566162f8678b8" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;a&lt;/code&gt; is ill-typed, it is not used in the end, so if all that we&amp;rsquo;re interested in is &lt;code&gt;main&lt;/code&gt; it can be useful to be able to ignore the problems in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 형식이 잘못 되었지만 결국에는 사용되지 않으므로 관심있는 모든 것이 &lt;code&gt;main&lt;/code&gt; 경우의 문제를 무시할 수있는 &lt;code&gt;a&lt;/code&gt; 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c423833e7459f388f7a025deca957c83022894ae" translate="yes" xml:space="preserve">
          <source>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import &lt;code&gt;S(x)&lt;/code&gt; but not &lt;code&gt;T(x)&lt;/code&gt;, and then use &lt;code&gt;x&lt;/code&gt; unambiguously.</source>
          <target state="translated">필드 레이블이 해당 정의 모듈에 복제되어 있어도 다른 곳에서 선택기를 사용할 수 있습니다. 예를 들어, 다른 모듈은 &lt;code&gt;S(x)&lt;/code&gt; 가져올 수 있지만 &lt;code&gt;T(x)&lt;/code&gt; 는 가져올 수 없으며 &lt;code&gt;x&lt;/code&gt; 를 명확하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="852a6172c09d70538bebcbe548e6b3e70b6d5e28" translate="yes" xml:space="preserve">
          <source>Even though most of these examples are using the list monad, monad comprehensions work for any monad. The &lt;code&gt;base&lt;/code&gt; package offers all necessary instances for lists, which make &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; backward compatible to built-in, transform and parallel list comprehensions.</source>
          <target state="translated">이 예제들 대부분이리스트 모나드를 사용하고 있지만 모나드 이해는 모나드에 적용됩니다. &lt;code&gt;base&lt;/code&gt; 패키지 제공 할 목록에 대한 모든 필요한 경우, &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; 가&lt;/a&gt; 내장-에 이전 버전과 호환이, 변환 및 병렬 지능형리스트.</target>
        </trans-unit>
        <trans-unit id="1e2fd9aaf66af88d1fa27ea41b45f571960a585c" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5f2b0889226d76221df5eba41dfdfd027c049a" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">시프트 양이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 표시 되더라도 음수 시프트 양에 대해서는 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a98b3fabc4357473affe9eff5dad04c75f7f6eb" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">이 비록 거기에 &lt;code&gt;x&lt;/code&gt; 는 '범위에이야, 분명하다 &lt;code&gt;x&lt;/code&gt; 의 정의에서 패턴 &lt;code&gt;ok1&lt;/code&gt; 은 오직 필드 의미 할 수있다 &lt;code&gt;x&lt;/code&gt; 타입에서 &lt;code&gt;S&lt;/code&gt; 를 . 함수 &lt;code&gt;ok2&lt;/code&gt; 와 유사합니다 . 그러나의 레코드 업데이트에서 &lt;code&gt;bad1&lt;/code&gt; 와의 레코드 선택 &lt;code&gt;bad2&lt;/code&gt; 가하고자하는 두 가지 유형 중 어느 명확하지 않다.</target>
        </trans-unit>
        <trans-unit id="4622930c8ec60ffdcb4687bdfc5e61a4075cdba8" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">Even though there are two &lt;code&gt;x&lt;/code&gt; &amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt; . Similarly for the function &lt;code&gt;ok2&lt;/code&gt; . However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</target>
        </trans-unit>
        <trans-unit id="2711d7494e1ded0fd3622ca6129c265f52351d7e" translate="yes" xml:space="preserve">
          <source>Even when set to &lt;code&gt;ignore&lt;/code&gt;, a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt;&lt;code&gt;:script&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Even when set to &lt;code&gt;ignore&lt;/code&gt; , a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt; &lt;code&gt;:script&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="73d7a0d774535278c1215097572fe0930f17dd2b" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그를 사용하더라도 생성자 &lt;code&gt;T&lt;/code&gt; 의 필드는 압축 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="0c619c8d6ba2035f81d9f010c08ec0b1177929e5" translate="yes" xml:space="preserve">
          <source>Event logging</source>
          <target state="translated">이벤트 로깅</target>
        </trans-unit>
        <trans-unit id="913641e09266e8cb48d5e95316fd86cbe16755ba" translate="yes" xml:space="preserve">
          <source>EventManager</source>
          <target state="translated">EventManager</target>
        </trans-unit>
        <trans-unit id="ff23fd7f42569a5bfa090dd486d103be85fd0164" translate="yes" xml:space="preserve">
          <source>Eventlog tracing</source>
          <target state="translated">이벤트 로그 추적</target>
        </trans-unit>
        <trans-unit id="c19ae7eba2908ba6569d481309090a0fda383fe3" translate="yes" xml:space="preserve">
          <source>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</source>
          <target state="translated">Eventlog 추적은 성능 프로파일 링 시스템입니다. 이 함수는 이벤트 로그에 추가 이벤트를 생성합니다. 이벤트 로그 프로파일 링 도구와 함께이 기능을 사용하여 실행을 모니터링하고 성능 문제를 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9202d6978f7b6c56daee6dab6c663c232e9764fd" translate="yes" xml:space="preserve">
          <source>Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</source>
          <target state="translated">Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</target>
        </trans-unit>
        <trans-unit id="82d16de768c1684f419fe23bd359b377e6758d1e" translate="yes" xml:space="preserve">
          <source>Every complete Haskell program must define &lt;code&gt;main&lt;/code&gt; in module &lt;code&gt;Main&lt;/code&gt; in package &lt;code&gt;main&lt;/code&gt;. Omitting the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag compiles code for package &lt;code&gt;main&lt;/code&gt;. Failure to do so leads to a somewhat obscure link-time error of the form:</source>
          <target state="translated">모든 완전한 하스켈 프로그램을 정의해야합니다 &lt;code&gt;main&lt;/code&gt; 모듈의 &lt;code&gt;Main&lt;/code&gt; 패키지에 &lt;code&gt;main&lt;/code&gt; . &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt; 플래그를 생략하면 &lt;code&gt;main&lt;/code&gt; 패키지에 대한 코드가 컴파일됩니다 . 그렇지 않으면 다음과 같은 형식의 링크 타임 오류가 다소 모호해집니다.</target>
        </trans-unit>
        <trans-unit id="d0912fd6d2a0271d302c52a4acaff179b0c6995b" translate="yes" xml:space="preserve">
          <source>Every cycle in the module import graph must be broken by a &lt;code&gt;hs-boot&lt;/code&gt; file. Suppose that modules &lt;code&gt;A.hs&lt;/code&gt; and &lt;code&gt;B.hs&lt;/code&gt; are Haskell source files, thus:</source>
          <target state="translated">모듈 가져 오기 그래프의 모든주기는 &lt;code&gt;hs-boot&lt;/code&gt; 파일에 의해 중단되어야 합니다. 모듈 &lt;code&gt;A.hs&lt;/code&gt; 및 &lt;code&gt;B.hs&lt;/code&gt; 가 Haskell 소스 파일 이라고 가정하면 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="33d86826edcd97dcbde5f7c16a0f10d7e8256a5b" translate="yes" xml:space="preserve">
          <source>Every language extension can also be turned into a command-line flag by prefixing it with &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo;; for example &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt;. (Similarly, all &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo; flags can be written as &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas.)</source>
          <target state="translated">모든 언어 확장은 접두사&amp;ldquo; &lt;code&gt;-X&lt;/code&gt; &amp;rdquo; 를 사용하여 명령 줄 플래그로 전환 할 수도 있습니다 . 예를 들어 &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt; 입니다. 유사하게 모든 &quot; &lt;code&gt;-X&lt;/code&gt; &quot;플래그를 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89191834b0668388b7f06081ebe85c6fc7aa3ea9" translate="yes" xml:space="preserve">
          <source>Every language option can switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">모든 언어 옵션은 명령 줄 플래그 &quot; &lt;code&gt;-X...&lt;/code&gt; &quot;(예 : &lt;code&gt;-XTemplateHaskell&lt;/code&gt; )로 설정하고 플래그 &quot; &lt;code&gt;-XNo...&lt;/code&gt; &quot;로 해제 할 수 있습니다. (예 : &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c21e6f680a01c2f8b28c8d60711b7527a58afada" translate="yes" xml:space="preserve">
          <source>Every module has a &lt;em&gt;module name&lt;/em&gt; defined in its source code (&lt;code&gt;module A.B.C where ...&lt;/code&gt;).</source>
          <target state="translated">모든 모듈에는 소스 코드에 정의 된 &lt;em&gt;모듈 이름이&lt;/em&gt; 있습니다 ( &lt;code&gt;module A.B.C where ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b9fd929db55af9188984a5b1f15ada92d9684dba" translate="yes" xml:space="preserve">
          <source>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</source>
          <target state="translated">모든 새로운 바인딩은 현재 모듈 컨텍스트의 범위에있는 엔티티를 포함하여 동일한 이름의 기존 바인딩을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="f7098378d870c69a4432ef9315748f42a7c6f2be" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="87fea7be991371f64729bc8780fc11210c633480" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="abfc0f0b13db0da312949b88776c9010f5397cef" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="2cdcb7a5f8b0e5da9d82d98917b19bde316858e5" translate="yes" xml:space="preserve">
          <source>Exactly the same reasoning applies to &lt;code&gt;ExNumPat&lt;/code&gt;: matching against &lt;code&gt;ExNumPat&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, and &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt;.</source>
          <target state="translated">똑같은 논리가 적용 &lt;code&gt;ExNumPat&lt;/code&gt; 대해 일치 : &lt;code&gt;ExNumPat&lt;/code&gt; 가&lt;em&gt;필요&lt;/em&gt; 제약을 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 및 &lt;em&gt;제공하는&lt;/em&gt; 구속 &lt;code&gt;(Show b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b96d27d4acb5d7b08b44caf941f831bab1b616f" translate="yes" xml:space="preserve">
          <source>Exactly the same situation can arise in instance declarations themselves. Suppose we have</source>
          <target state="translated">인스턴스 선언 자체에서 정확히 동일한 상황이 발생할 수 있습니다. 우리가 가지고 있다고 가정</target>
        </trans-unit>
        <trans-unit id="fe669a2e98268a4e3f1914eea2b10b28c27678b1" translate="yes" xml:space="preserve">
          <source>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</source>
          <target state="translated">생성 된 프로파일 링 정보를 검사하고 해당 정보를 사용하여 프로그램을 최적화 한 후 필요에 따라 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="5ab5c95eb13c56a3fee4135ddda2d5191c14c8f0" translate="yes" xml:space="preserve">
          <source>Example 1: Custom Error Data Type</source>
          <target state="translated">예 1 : 사용자 정의 오류 데이터 유형</target>
        </trans-unit>
        <trans-unit id="9341e16e31da6f2a70822dbce4c15a6563123345" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Continuation Usage</source>
          <target state="translated">예 1 : 간단한 연속 사용법</target>
        </trans-unit>
        <trans-unit id="65d8343070f8245126756e9e6474efdb37e4866c" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Reader Usage</source>
          <target state="translated">예 1 : 간단한 리더 사용법</target>
        </trans-unit>
        <trans-unit id="e7b57a0dcf99e0a81e45002d7fa9585327408c44" translate="yes" xml:space="preserve">
          <source>Example 2: Modifying Reader Content With &lt;code&gt;local&lt;/code&gt;</source>
          <target state="translated">예 2 : &lt;code&gt;local&lt;/code&gt; 사용하여 판독기 내용 수정</target>
        </trans-unit>
        <trans-unit id="b7af5856636b2b3dd64495544e0d58ec7921152b" translate="yes" xml:space="preserve">
          <source>Example 2: Using &lt;code&gt;callCC&lt;/code&gt;</source>
          <target state="translated">예 2 : &lt;code&gt;callCC&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3f1f4d7e09a4ce050bc861cd17fcfb325ccd1802" translate="yes" xml:space="preserve">
          <source>Example 2: Using ErrorT Monad Transformer</source>
          <target state="translated">예 2 : ErrorT Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="49670fce677705355449a0491c747c92f53b6377" translate="yes" xml:space="preserve">
          <source>Example 2: Using ExceptT Monad Transformer</source>
          <target state="translated">예 2 : ExceptT Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="3b38bf4f99b69316fc2cabc16fe8efbc23e17cdb" translate="yes" xml:space="preserve">
          <source>Example 3: &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">예 3 : &lt;code&gt;ReaderT&lt;/code&gt; Monad 변압기</target>
        </trans-unit>
        <trans-unit id="2f4dd83523e08d239122d5d7b82fdc40b87078e4" translate="yes" xml:space="preserve">
          <source>Example 3: Using &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">예 3 : &lt;code&gt;ContT&lt;/code&gt; Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="589c32b6f4517cdf800a8b3876ce51a0178b7a54" translate="yes" xml:space="preserve">
          <source>Example type:</source>
          <target state="translated">예시 유형 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fa37f54302b03973bfbf2aa3fb535779d3383bb4" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">예제 (동작은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="790f2b42181ca616b7c127aef6e902fd9e8081ef" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ef181bf5a5a0563ded8a2fc63cfcae3d45812a" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와의 차이점의 예 :</target>
        </trans-unit>
        <trans-unit id="80e96827fe2478980a86e49ef7458c4629812185" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="498245f3f1e8f9b6f80d7ed20c13e42f043f24d9" translate="yes" xml:space="preserve">
          <source>Except</source>
          <target state="translated">Except</target>
        </trans-unit>
        <trans-unit id="150f49a28cd9890f5d74255011dd9ae13178dd32" translate="yes" xml:space="preserve">
          <source>ExceptT</source>
          <target state="translated">ExceptT</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="53a706616e11935ca633fadc1928372183e733d2" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b1c0dab2d59aa101f6c17d2f3c37c8dbb32aef4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ca0b055b03c1b83f5d783045937b6b971fc2c7" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b8e6291d3f08aeaec124c66c6cff001d6c6ea4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0356c4346732233d71d4ad17145a3a7d64d539e" translate="yes" xml:space="preserve">
          <source>Exception handling in the I/O monad</source>
          <target state="translated">I / O 모나드에서의 예외 처리</target>
        </trans-unit>
        <trans-unit id="4aba3643c6de6f96be69c3234f88f2d7abee91b2" translate="yes" xml:space="preserve">
          <source>Exception handling within STM actions.</source>
          <target state="translated">STM 조치 내에서 예외 처리</target>
        </trans-unit>
        <trans-unit id="eda52cb4b163a3d91ebc6efd255a35eb5c788dd0" translate="yes" xml:space="preserve">
          <source>Exception operations</source>
          <target state="translated">예외 연산</target>
        </trans-unit>
        <trans-unit id="1e0456156d2599fba71e66665c8effe9eb0cdf9b" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; 을 지원하지 않는 Windows 이외의 플랫폼에서 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 에 의해 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="ab0e1caad4d21b7759b69123f35074bf121ac468" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;hLock&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcbec4a21f1200ac1b10210e0b80c9fa92ae9e7" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. pattern matching failure and &lt;code&gt;error&lt;/code&gt;) can be treated as breakpoints, to help locate the source of an exception in the program.</source>
          <target state="translated">예외 (예 : 패턴 일치 실패 및 &lt;code&gt;error&lt;/code&gt; )는 프로그램에서 예외의 소스를 찾는 데 도움이되는 중단 점으로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19252ae3666000a0b6f93913a391be3ee8a0b825" translate="yes" xml:space="preserve">
          <source>Exceptions and exception-handling functions.</source>
          <target state="translated">예외 및 예외 처리 기능.</target>
        </trans-unit>
        <trans-unit id="581d67742f82ff9913666449de206cda75556316" translate="yes" xml:space="preserve">
          <source>Exceptions generated by array operations</source>
          <target state="translated">배열 연산에 의해 생성 된 예외</target>
        </trans-unit>
        <trans-unit id="934839970d31235dc74d44785440bb7587cc9762" translate="yes" xml:space="preserve">
          <source>Exceptions that occur in the &lt;code&gt;IO&lt;/code&gt; monad. An &lt;code&gt;IOException&lt;/code&gt; records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 모나드 에서 발생하는 예외 . &lt;code&gt;IOException&lt;/code&gt; 이는 어쩌면 더 구체적인 오류 유형, 설명 문자열 및 오류가 플래그 때 사용 된 핸들을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="08dd9b4521175f2b7645b6d05dd66e3f5d1e5a7a" translate="yes" xml:space="preserve">
          <source>ExclusiveLock</source>
          <target state="translated">ExclusiveLock</target>
        </trans-unit>
        <trans-unit id="a9e5edeee4b6bddbc59b5bc41ce4029d4ec4727e" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 가능한 인수 또는 쉘 명령 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 인 경우 현재 작업 디렉토리와 관련하여 상대 경로가 분석됩니다. &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 제공되는 경우 상대 경로가 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 또는 현재 작업 디렉토리 와 관련하여 해결되는지 여부에 따라 구현에 따라 달라 지므로 이식성을 보장하기 위해 절대 경로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="42e1121c05300716bc1e0f10a008032170bf3cee" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da49c4c138af06cdc6e4ed0555a2d722ce3bbf8b" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 가능한 인수 또는 쉘 명령 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 인 경우 현재 작업 디렉토리와 관련하여 상대 경로가 분석됩니다. &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 제공되는 경우 상대 경로가 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 또는 현재 작업 디렉토리 와 관련하여 해결되는지 여부에 따라 구현에 따라 달라 지므로 이식성을 보장하기 위해 절대 경로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbbcf8ab79fd69b3cdf42660517413d00119f401" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e45ade933abb2dbef129bbe667e5f06567379e" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 하고 생성 된 청크를 지연 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 . 작업은 게으른, 즉 게으른 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 청크 가 강제 될 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="44cef8606c2d8d69b084ef725295c455661c70d1" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 하고 생성 된 청크를 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 . 작업은 게으른, 즉 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 청크 가 강제 될 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d4c37228081ad690471866bfb49855698ac1573" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and return the computed result and the bytes written during the computation as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 을 실행 하고 계산 결과 및 계산 중에 쓴 바이트를 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a91780a4fbc0b4b5a96ff84d0f2ad27c4390b00" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; with a buffer-allocation strategy and a continuation. For example, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; is implemented as follows.</source>
          <target state="translated">버퍼 할당 전략과 연속으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 을 실행하십시오 . 예를 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; 은 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="34b863a511860977e79077de7a231a7aecf1ada7" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment</source>
          <target state="translated">수정 된 환경에서 계산 실행</target>
        </trans-unit>
        <trans-unit id="9074ee855e6397968c72ac1444df19911eaa577a" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 (더 일반적인 버전의 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ) 에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9bad7ac26cf07893f9cefd43f5bb9c7a61a20d5d" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 (더 일반적인 버전의 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ) 에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="1c369096a8c214ef9f4515d93a67dbb9c70e723b" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 ( &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 전문화)에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="e148fe739f9c54b1accabc69b62a9d19fee91018" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 전문화)에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="53f59c8f15736e3200571bde489e9c2748a0204d" translate="yes" xml:space="preserve">
          <source>Execute an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action, throwing a &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; if the predicate yields &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to the result returned by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. If no exception is raised, return the result of the computation.</source>
          <target state="translated">실행 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 던지는 행동을 &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; 을 술어가 산출하는 경우 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 결과에 적용 할 때 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 작업입니다. 예외가 발생하지 않으면 계산 결과를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="42c77fe8561e333489414079969807a39fd1e151" translate="yes" xml:space="preserve">
          <source>Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished.</source>
          <target state="translated">새 메모리 풀을 사용하여 작업을 실행합니다.이 작업은 작업이 완료된 후 내용을 포함하여 자동으로 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1262c3e03a483c6a9341f4b12dfc5bd8ac87a7c4" translate="yes" xml:space="preserve">
          <source>Executes a computation in a modified environment.</source>
          <target state="translated">수정 된 환경에서 계산을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8210b4609b3b832c81bcd8b6f74a6b3190413ae8" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">비동기 예외가 &lt;em&gt;마스크 된 상태&lt;/em&gt; 에서 IO 계산을 실행합니다 . 즉, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 스레드에서 예외를 발생시키려는 스레드는 비동기 예외가 다시 마스크 해제 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="46ec0e1cddb9075cc884b834b53f50ddc817ddcc" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</target>
        </trans-unit>
        <trans-unit id="778dbd9e9bf309d9af09860bc9150a182f094e04" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">비동기 예외가 &lt;em&gt;마스크 된 상태&lt;/em&gt; 에서 IO 계산을 실행합니다 . 즉, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 스레드에서 예외를 발생시키려는 스레드는 비동기 예외가 다시 마스크 해제 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt; ). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">파일의 행을 일련의 GHCi 명령으로 실행합니다. 이 명령은 &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt; 으로 설정 한 여러 줄 문장과 호환됩니다</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">쉘 명령 ⟨command⟩를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;IO String&lt;/code&gt; 유형의 계산으로 ⟨expr⟩ 을 실행 한 다음 결과 문자열을 GHCi 명령 목록으로 실행합니다. 여러 명령은 개행으로 구분됩니다. &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; 를&lt;/a&gt; 명령에 유용 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">빌더 실행</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">외부 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">실행은 한 단계 씩 진행될 수 있습니다. 평가자는 거의 모든 축소 후에 실행을 일시 중단하여 로컬 변수를 검사 할 수 있습니다. 이는 프로그램의 모든 지점에서 중단 점을 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">실행은 평가 모드에서 발생하는 각 평가 단계를 기억하지만 실제 중단 점에 도달 할 때까지 실행을 중단하지 않는 추적 모드에서 실행될 수 있습니다. 이 경우 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">중단 점에서 실행이 중지되었습니다. 프롬프트가 현재 중단 점에서 중지되었음을 표시하고 위치는 &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; 입니다. 위치를 더 명확히하기 위해 &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">실행 단계 마커</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">실행 전략</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">존재 테스트</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">iserv 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="cb193431524e4fae58710e9d90f4bc84b69056c1" translate="yes" xml:space="preserve">
          <source>ExitCaseAbort</source>
          <target state="translated">ExitCaseAbort</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">절대 파일 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">명시 &lt;code&gt;forall&lt;/code&gt; 항상 필요하지 않습니다 - 참조 &lt;a href=&quot;#pattern-equiv-form&quot;&gt;패턴 서명 해당하는&lt;/a&gt; 이 섹션의 예를 들면, 또는 &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">레이아웃 대신 명시 적 괄호와 세미콜론을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">명시 적 목록 (예 : &lt;code&gt;[True, False]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">명시 적으로 양방향</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">명시 적으로 양방향 패턴 동의어는 허용되는 구문 측면에서 암시 적으로 양방향 것보다 더 큰 유연성을 제공합니다. 예를 들어 다음은 법적으로 암시 적으로 양방향 패턴 동의어가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">명시 적으로과 관련된 finaliser 실행 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . 종료 후이 값을 참조하면 유효하지 않은 메모리 참조가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">유형 수준의 자연의 지수.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">클래스 이름 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">클래스, 관련 유형 &lt;code&gt;GMap&lt;/code&gt; 및 멤버 함수를 &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;lookup&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 내보내기합니다 . 의 데이터 생성자 &lt;code&gt;GMap&lt;/code&gt; (이 경우 &lt;code&gt;GMapEither&lt;/code&gt; 는 ) 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">매우 크거나 재귀적인 기능에 대해서도 모든 전개를 공개하십시오.</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">id byunit-id⟩로 패키지 노출</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">패키지 노출 ⟨pkgpose</target>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">패키지 ⟨pkg⟩를 노출하고 불신으로 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">⟨pkg⟩ 패키지를 공개하고 신뢰할 수 있도록 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">플러그인을위한 ⟨pkg-id⟩ 노출</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">플러그인에 ⟨pkg⟩ 노출</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 플러그인 네임 스페이스에 패키지를 노출 하지만 패키지는 이름이 아닌 설치된 패키지 ID로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 플래그를 GHC에 전달합니다. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning 및 &lt;/a&gt;Renaming 모듈에 설명 된 Thinning 및 Renaming을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 패키지를 공개 하지만 패키지 이름은 이름이 아닌 단위 ID (즉 , 설치된 패키지 데이터베이스에있는 항목 의 &lt;code&gt;id&lt;/code&gt; 값 , 이전에 설치된 패키지 ID라고도 함)로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;code&gt;-package-id&lt;/code&gt; 플래그를 GHC에 전달합니다. &lt;code&gt;-package-id&lt;/code&gt; 는 &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning 및 Renaming 모듈에&lt;/a&gt; 설명 된 Thinning 및 Renaming을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟨pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수있는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟩pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수없는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">표현식 인용은 대부분의 Haskell 언어 구문을 허용합니다. 그러나 표현식 인용이 현재 지원하지 않는 일부 GHC 특정 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">표현식 스플 라이스 : 익명 및 명명 된 와일드 카드를 표현식 서명에 사용할 수 있습니다. 정규식 서명과 마찬가지로 추가 제약 조건 와일드 카드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">식 평가 모드. 이것은 명령 행에 주어진 단일 표현식 (evaluateexpr⟩)이 있다는 점을 제외하고는 대화식 모드와 매우 유사합니다. 자세한 내용은 &lt;a href=&quot;#eval-mode&quot;&gt;식 평가 모드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">정교하게 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">확장 된 유클리드 알고리즘.</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 의 확장 버전</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">새로운 유형으로 확장</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">원 자성을 여러 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 로 확장하는 것은 문제가 있으므로 더 복잡한 작업을 수행해야하는 경우 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">확장 가능한 예외</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">GHC의 Handle 구현을위한 외부 API</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 속성</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 속성</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 요소</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 요소</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 생성 및 실행을위한 추가 기능 . 그것들은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 성능을 응용 프로그램별로 미세 조정하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">추가 인스턴스</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">명령 행에서 normal &lt;code&gt;-llib&lt;/code&gt; 옵션을 사용하여 추가 라이브러리를 지정할 수 있습니다 . 여기에서 라이브러리 라는 용어 는 외부 객체 코드의 &lt;em&gt;라이브러리&lt;/em&gt; 를 의미합니다. Haskell 소스 코드의 라이브러리를 사용하려면 &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;모듈과 파일 이름을&lt;/a&gt; 참조하십시오 . 예를 들어 &quot;m&quot;라이브러리를로드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">추가 제약 조건 와일드 카드는 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추출 &lt;em&gt;N&lt;/em&gt; 번째의 (0- 기반) 사지 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; . &lt;em&gt;n&lt;/em&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; 의해보고 된대로 size보다 작아야합니다 .</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 을 추출하고 이에 대한 조치를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</target>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">두 가지 유형의 평등의 증거를 추출</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치의 단어에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 16 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 32 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 8 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">적용된 유형의 동등성에서 인수의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">적용된 형식의 동등성에서 형식 생성자의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 제외한 모든 것을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">비율의 분모를 축소 된 형태로 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">쌍의 첫 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">스트림의 첫 번째 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">오류 메시지에서 메시지 문자열 추출</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">축소 된 형태로 비율의 분자를 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">라이터 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">누적 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">스트림의 비어있는 꼬리를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">쌍의 두 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">분수 성분 추출</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">서브리스트 추출</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">누적 오류가있는 계산을위한 추출기.</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모두 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 를 추출합니다 . 이 함수는 필요한 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫고 쓰기 버퍼를 비우는 부작용이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</target>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">불변 배열의 경계를 추출합니다</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">소스 위치에서 열 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">복소수의 허수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">소스 위치에서 라인 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">구문 분석 오류에서 오류 메시지 목록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">소스 위치에서 소스 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">복소수의 실수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">구문 분석 오류에서 소스 위치를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">F. Lundh : 빠른 검색 알고리즘. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">동시성을 사용하거나 필요로하는 FFI 데이터 유형 및 작업 (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">FFI 지원은 기본적으로 활성화되어 있지만 &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 명시 적으로 활성화하거나 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">SimpleMAPI와 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">Win32 보안과 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">위에서 설명한 문제에 직면하여 일부 Haskell 프로그래머는 다음 버전의 클래스 선언과 같은 것을 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">실패는 실패의 원인 / 위치에 대한 정보를 기록합니다. 실패 값은 바운드 함수를 우회하고 다른 값은 바운드 함수의 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">패밀리 인스턴스는 클래스 인스턴스와 마찬가지로 암시 적으로 내보내집니다. 그러나 이것은 인스턴스의 헤드에만 적용되며 인스턴스가 정의한 데이터 생성자에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">팬인 : 두 개의 인수 화살표 사이에서 입력을 나누고 출력을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">팬 아웃 (Fanout) : 입력을 양쪽 화살표로 보내고 출력을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">기본 2에 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 빠른 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 로그 : integerLog2 # 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; 는 일반적으로 유용하며 나머지는 &lt;code&gt;fromRational&lt;/code&gt; 의 빠른 구현에만 필요합니다 . 그것들은 &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt; 에 필요 하므로이 모듈을 공개해야하지만 문서에는 표시되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">시스템 시계에 빠르게 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">빠른 문자 조작 기능.</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 대한 빠른 하위 문자열 검색 .</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 한 게으른 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대한 빠른 하위 문자열 검색 . 엄격한 구현에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">빠르고 확인되지 않은 비트 시프 팅 기능.</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">인수 화살표를 통해 표시된 입력을 공급하고 나머지는 변경되지 않은 채로 출력에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">모나드 내 상태의 현재 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">환경의 가치를 이끌어냅니다.</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">가장 접근하기 어려운 절</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">가장 적은 중복 조항</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">가장 적발 된 조항</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="translated">Field CapNo</target>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="translated">Field CapSetId</target>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="translated">Field String</target>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="translated">Field TaskId</target>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="translated">Field ThreadId</target>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="translated">Field Word16</target>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="translated">Field Word32</target>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="translated">Field Word32[]</target>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="translated">Field Word64</target>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="translated">Field Word8</target>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="translated">Field [String]</target>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">필드 명확성 제거는 punning과 결합 될 수 있습니다 (Puns &lt;a href=&quot;#record-puns&quot;&gt;기록&lt;/a&gt; 참조 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">선택기 기능 또는 레코드 업데이트에 사용되는 필드 이름은 범위에 해당 필드가 하나뿐이거나 다음 섹션에 설명 된대로 유형 서명이 제공되므로 모호하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">필드는 모호하지 않은 경우에만 선택기 함수로 사용될 수 있으므로 &lt;code&gt;S(x)&lt;/code&gt; 및 &lt;code&gt;T(x)&lt;/code&gt; 가 모두 범위에있는 경우 여전히 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 환경 변수의 경우 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; 이&lt;/a&gt; ⟨name⟩로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 이 옵션을 통과하면 &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">파일 &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; 은 현재 디렉토리 또는 상위 디렉토리 (그러나 사용자의 홈 디렉토리)에있는 경우.</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">파일 할당</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</target>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">닫을 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">파일 확장자 문자</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">파일 잠금</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">파일 모드 (예 : 권한).</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">파일 이름 조작</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">파일 이름 템플릿. 템플리트가 &quot;foo.ext&quot;인 경우 작성된 ​​파일은 &quot;fooXXX.ext&quot;이며 여기서 XXX는 임의의 숫자입니다. 여기에는 경로 구분 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">&quot;의미있는&quot;접미사 (예 : &lt;code&gt;.lhs&lt;/code&gt; 또는 &lt;code&gt;.o&lt;/code&gt; )가 있는 파일 이름은 해당 파일에 &quot;올바른 일&quot;이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">파일 옵션</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">파일 상태</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">파일 동기화</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">환경 변수 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt; 가 ⟨file⟩ 으로 설정된 경우 ⟨file⟩ 파일 .</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt; 옵션을 전달하면 ⟨file⟩ 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">파일 헤더 프라그 마는 파일을 사전 처리하기 전에 한 번만 읽습니다 (예 : cpp).</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">파일 이름 완성</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">(일반적으로 도트 (있는 경우 포함) 실행 파일의 파일 이름 확장자 &lt;code&gt;&quot;&quot;&lt;/code&gt; POSIX 시스템 및 &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; Windows 또는 OS / 2).</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">실행 파일 이름 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">파일 이름 / 디렉토리 기능</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">파일과 핸들</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">다른 접미사가있는 (또는 접미사가없는) 파일은 링커로 바로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 사용하여 BufferRange 를 채우 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">메모리 영역의 지정된 바이트 수를 바이트 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">필요한 값으로 메모리 영역 채우기</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 조치를 사용하여 다른 맵에서 키가 누락 된 항목을 필터링하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">최종 데이터 포인터</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">마무리 수단 (A)에 대한 후속 호출 준비 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ; (b) 종료자를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">약한 포인터를 완성하십시오. 반환 값은 새로운 세계 상태와 &quot;unboxed Maybe&quot;를 포함하는 Unboxed 튜플이며 &lt;code&gt;Int#&lt;/code&gt; 및 (아마도 잘못된) 마무리 작업으로 표시됩니다. &lt;code&gt;Int#&lt;/code&gt; 의 &lt;code&gt;1&lt;/code&gt; 이 종료 자이 유효 함을 나타냅니다. 종료 기의 반환 값 &lt;code&gt;b&lt;/code&gt; 는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">Finalizer &lt;em&gt;는&lt;/em&gt; 명시 적으로 만들어지고 &lt;code&gt;IORef&lt;/code&gt; 및 &lt;code&gt;MVar&lt;/code&gt; 와 같은 ID를 가진 유형에 안정적으로 사용될 &lt;em&gt;수&lt;/em&gt; 있습니다 . 그러나 이러한 유형 중 하나에 종료자를 배치하려면 해당 유형에 제공된 특정 조작 (예 : &lt;code&gt;mkWeakIORef&lt;/code&gt; 및 &lt;code&gt;addMVarFinalizer&lt;/code&gt; )을 사용해야 합니다 (비 균일 성은 우연이 아닙니다). 이러한 작업 은 외부 상자가 컴파일러에 의해 최적화 될 때 종료자를 상자 자체에 연결하지 못하기 때문에 상자 내부의 기본 객체 (예 : &lt;code&gt;MutVar#&lt;/code&gt; 의 경우 MutVar # ) 에 &lt;code&gt;IORef&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">마지막으로, GHC는 제약 조건 해결이 완료된 후 &lt;code&gt;tcPluginStop&lt;/code&gt; 을 호출 하여 플러그인이 할당 한 모든 자원을 처리 할 수 ​​있도록합니다 (예 : SMT 솔버 프로세스 종료).</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">마지막으로, &lt;code&gt;readFile'&lt;/code&gt; 예제 의 예외 안전 변형이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">마지막으로 &lt;code&gt;-main-is&lt;/code&gt; 플래그 또는 &lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 다른 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="translated">Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; . In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">마지막으로 &lt;code&gt;Just&lt;/code&gt; 결과가 맵으로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="3ed43b18c0eb498b61dd7767854552765f4cd553" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; returns the pairs &lt;code&gt;(b, s)&lt;/code&gt; and &lt;code&gt;(c, s)&lt;/code&gt;. For monad transformers other than &lt;code&gt;StateT&lt;/code&gt;, this will be some other type representing the effects and values performed and returned by the &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; actions. The effect part of the &lt;code&gt;use&lt;/code&gt; result, in this case &lt;code&gt;_s2&lt;/code&gt;, usually needs to be discarded, since those effects have already been incorporated in the &lt;code&gt;release&lt;/code&gt; action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">마지막으로 &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ 옵션 은 컴파일러 생성 중간 C 파일 의 &lt;code&gt;.hc&lt;/code&gt; 파일 접미사를 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">마지막으로 현재 실행을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">마지막으로 단일 문자와 일치하는 기본 파서가 필요합니다.이 파서에서 임의로 복잡한 파서를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">마지막으로 디코더를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">대상 제약 조건 &lt;em&gt;과 일치&lt;/em&gt; 하는 모든 인스턴스 \ (I \)를 찾습니다 . 즉, 대상 제약 조건은 \ (I \)의 대체 인스턴스입니다. 이러한 인스턴스 선언이 &lt;em&gt;후보&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">해결되지 않은 모든 구속 조건을 찾으십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">나무의 깊이를 찾으십시오. 즉, 나무의 뿌리에서 가장 먼 잎까지의 가지 수 :</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">파일에 대한 시스템 별 제한 찾기</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">문자열에서 하위 문자열의 모든 (중복 될 수있는) 어커런스의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">트리에서 최대 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">형식은 그 사람 찾기 &lt;code&gt;(C a)&lt;/code&gt; 여기서 &lt;code&gt;a&lt;/code&gt; 형태 변수이며, 일반적인 유형의 변수 공유 그룹으로 그 제약을 분할 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">길이 찾기</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">회선 지향 사용자 상호 작용 세션을 완료하고 정리하십시오. &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 에 대한 기존 호출을 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">유한 그래프</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">유한 Int지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">유한 Int지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">유한 Int 세트</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">유한지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">유한지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">유한 세트</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">유한 시퀀스</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">첫 번째 인수는 후행 0을 잘라낼 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">결과의 첫 번째 성분은 &lt;code&gt;log2 n&lt;/code&gt; 이고 두 번째는 &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; 은 2의 거듭 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">첫 번째 목적지의 오프셋 (offset) &lt;em&gt;되지&lt;/em&gt; 사본 (즉, &lt;em&gt;하지&lt;/em&gt; 길이)</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">주어진 정량화되지 않은 제약 조건 &lt;code&gt;C t&lt;/code&gt; 가 있는지 확인하십시오 . 그렇다면 제약 조건을 해결하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">먼저 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 를 가져옵니다 . 이것은 안전하지 않은 모듈이지만 &lt;code&gt;M&lt;/code&gt; 은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 로 컴파일 되었으므로 &lt;code&gt;P&lt;/code&gt; 의 작성자는 해당 가져 오기를 담당합니다. &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 저자를 신뢰하므로이 수입은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="translated">First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt; . This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author, so this import is fine.</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">먼저, 모듈을 GHCi에로드하십시오 :</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">먼저 정의 된 매크로에서 이름과 정확히 일치하는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">첫째, 이전에는 불가능했던 해상도를 종료 할 수 있습니다. 예를 들어 일반 장미 데이터 유형에 대한 다음 인스턴스 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">고정 크기 빌더 기본 요소</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">고정 크기 프리미티브</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">고정 너비 16 진수</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">데이터 생성자와 마찬가지로 형식 생성자 또는 클래스에 대한 고정도를 선언 할 수 있습니다. 그러나 고 정성 선언에서 둘을 구별 할 수는 없습니다. 고 정성 선언은 데이터 생성자와 해당 유형 생성자의 고 정성을 설정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">고정 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">정착 성 조회</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">생성자의 고정</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">고정, 유형 동의어, 개방형 / 데이터 패밀리 선언은 일반적인 Haskell에서와 같이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">&quot;중지 후&quot;라고 말하는 깃발</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; 의 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">다양한 서브 시스템에서 디버깅 출력 및 추가 검사를 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">엄격한 생성자 필드 병합</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포인터 크기의 표현으로 엄격한 생성자 필드를 병합합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="e4ccb090ca696917e5de23363132c4238087f15c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12167983d0afff206c046e1d6d922143291d5f3e" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd78f746eff5d069a4c69da8e38598e4dcbf4a4c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a015af1d71e496c444ce3c462d153241cce86f16" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dafc2e8e7144d1472eedd451318a1d1537aeb13" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전 .</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">플로팅 렛 바인딩은 바인딩 사이트에 가깝습니다. 참조 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;하자 - 부동 : 바인딩을 이동하는 빠른 프로그램 (ICFP'96)을 얻었다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="translated">Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">플로트 방법</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">float / Int 변환, 랩핑 된 primops</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">플로팅 타입</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">제공된 쓰기 버퍼의 모든 데이터를 장치로 플러시합니다. 리턴 된 버퍼는 비어 있어야하며 쓰기 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; 의 버퍼를 비 웁니다 (있는 경우) . &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">제공된 쓰기 버퍼의 데이터를 차단하지 않고 장치로 플러시합니다. 쓴 바이트 수와 나머지 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">현재 버퍼를 비 웁니다. 이것은 청크 경계를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">버퍼 상태 플러시</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">암시 적 구문 분석 상태 플러시</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">monoid를 사용하여 목록을 접으십시오.</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">트리를 깊이 우선 순서대로 &quot;요약&quot;값으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">접어 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 대소 현명한 단지처럼 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">접는 동작</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">접기 및 순회</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">키 증가 순서로 접습니다.</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">마크 존스 (Mark Jones)의 제안에 따라, 그의 논문은 &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Haskell에있는 Haskell 타이핑에서&lt;/a&gt; 보다 일반적인 체계를 구현합니다. GHC &lt;em&gt;에서 종속성 분석은 명시 적 유형 서명이있는 변수에 대한 참조를 무시합니다.&lt;/em&gt; . 이 세분화 된 종속성 분석의 결과로 종속성 그룹이 더 작아지고 더 많은 바인딩이 유형 검사됩니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">ISO-10646 표준에 따라 &lt;code&gt;maxBound :: Char&lt;/code&gt; GHC의 Char 는 &lt;code&gt;0x10FFFF&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt; 의 권장 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">들면 및 &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; , 그들의 최대 공약수를 계산 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; 및 계수 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 만족 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; + &lt;em&gt;B &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g을&lt;/em&gt; . &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffDays&lt;/code&gt; (및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">들어 &lt;code&gt;Day&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">를 들면 &lt;code&gt;DayOfWeek&lt;/code&gt; (및 &lt;code&gt;Day&lt;/code&gt; 와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;LocalTime&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;NominalDiffTime&lt;/code&gt; 및 &lt;code&gt;DiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeOfDay&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeZone&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;ZonedTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용 &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; 및 &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 는 동의어이다 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">양방향 패턴 동의어의 경우, 패턴 동의어를 표현식으로 사용하는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">클래스의 경우 모든 유형 변수는 종류로 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">복소수를 들어 &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; 의 크기를 갖는 수이고 &lt;code&gt;z&lt;/code&gt; 반면, 그러나 실제 양 방향으로 배향 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 의 위상 갖는다 &lt;code&gt;z&lt;/code&gt; 하지만 단위 크기를.</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; : 최상위 레벨이있는 ​​데이터 유형의 경우 &lt;code&gt;::&lt;/code&gt; : 명시 적으로 정량화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">데이터 유형의 경우 모든 유형 변수는 종류로 주석을 달아야합니다. GADT 스타일 선언에는 종류 서명 ( 헤더에 최상위 수준 &lt;code&gt;::&lt;/code&gt; 이 있음)이있을 수도 있지만이 주석의 존재 여부는 선언에 완전한 서명이 있는지 여부에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">자세한 설명은 Levent Erkok의 논문, Monadic &lt;em&gt;Computations의 가치 재귀를&lt;/em&gt; 참조하십시오.&lt;em&gt;&lt;/em&gt; , Oregon Graduate Institute, 2002를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 에서 사용되는 알고리즘의 전체 사양 은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;이 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">완전한 작동 예제 는 GHC 소스 트리에서 &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">주어진 힙 크기 ( &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 옵션 사용)의 경우 압축은 실제로 더 적은 GC를 수행함으로써 GC 비용을 줄일 수 있습니다. 이는 라이브 데이터 대 힙 크기의 비율이 높을 때 (예 : 30 % 이상) 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">람다 바운드 또는 케이스 바운드 변수 x의 경우, 프로그래머는 x에 대해 명시적인 다형성 유형을 제공하거나 GHC의 유형 유추는 x의 유형에 그에 대한 전제가 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt; , all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">일반 &lt;code&gt;foreign export&lt;/code&gt; 의 경우 &lt;code&gt;M_stub.h&lt;/code&gt; 파일 에는 외국 수출 기능에 대한 C 프로토 타입이 포함됩니다. 예를 들어 다음 모듈을 컴파일하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">다품종 유형 군의 경우 유형과 유형이 다른지 확인합니다. 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">읽기 전용 상태는 &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">인터페이스가 동일한 엄격한 버전은 &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">형식 동의어의 경우 모든 형식 변수와 결과 형식에 모두 종류가 주석으로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">단방향 레코드 패턴 동의어의 경우 레코드 선택기를 정의하지만 레코드 업데이트 또는 구성은 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">예외 값 범위를 허용하는 변형에 대해서는 &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;지도 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 해당 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">모든 유형에 대해 (이 세 가지는 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 가 아니라 formatTime 에 의해 &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">거의 모든 현명한 프로그램의 경우 버그를 나타내며 다음과 같이 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">&quot;포장 할 수없는&quot; &lt;code&gt;U(...)&lt;/code&gt; 인수의 경우 내부 정보는 해당 구성 요소의 엄격 성을 알려줍니다. 따라서 인수가 쌍이고 &lt;code&gt;U(AU(LSS))&lt;/code&gt; 라고 표시되면 라고 표시되면&amp;ldquo;쌍의 첫 번째 구성 요소가 사용되지 않습니다. 두 번째 구성 요소는 세 개의 구성 요소 (첫 번째는 게으르고 두 번째 \ &amp;amp; 세 번째는 엄격함)로 포장 할 수 없습니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">들어 &lt;em&gt;인코딩의 효율적인 구현&lt;/em&gt; , (a) 약간의 시간이 결과 바이트 시퀀스 하스켈 값 변환에 소요되는 것이 중요 &lt;em&gt;하고&lt;/em&gt; 생성 된 시퀀스의 표현이 효율적으로 소비 될 수있는 것을 (b). &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 (a) O (1) 연결 연산과 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 기타 표준 Haskell 값에 대한 기본 인코딩의 효율적인 구현을 제공하여 지원 합니다. 그들은 (b) 결과를 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 제공함으로써 내부적 으로 연속 된 원시 메모리 &lt;em&gt;청크&lt;/em&gt; 에 대한 포인터의 링크 된 목록입니다 . 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 파일에 쓰거나 네트워크 소켓을 통해 전송하는 기능에 의해 효율적으로 사용될 수 있습니다. 각 청크 경계는 청크 본문을 소비하는 데 소비 된 작업에 대해 상환되어야하는 값 비싼 추가 작업 (예 : 시스템 호출)을 발생시킵니다. 그러므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 평균 청크 크기가 충분히 커지도록 특별한주의를 기울입니다. 충분히 큰 의미는 응용 프로그램에 따라 다릅니다. 현재 구현은 4kb에서 32kb 사이의 평균 청크 크기로 조정되며 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">열거의 경우, 0부터 n-1까지의 인덱스를 사용하여 nullary 생성자가 왼쪽에서 오른쪽으로 번호가 매겨지는 것으로 가정합니다. 이것은 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 정의한 것과 동일한 번호 입니다. 예를 들어 데이터 유형이 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">이것이 안전하지 않은 이유를 보여주는 예는 &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">예를 들어 &lt;code&gt;Recip.hs&lt;/code&gt; 라는 프로그램이 있습니다.이 프로그램 은 반복되는 부분을 괄호로 표시하여 역수의 정확한 십진수 표현을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">대화식 응용 프로그램의 경우 유휴 GC를 사용하는 것이 좋습니다. 이는 Haskell 계산이 수행되지 않을 때 유휴 시간에 종료자가 실행되고 교착 상태 스레드가 감지 될 수 있기 때문입니다. 또한 응용 프로그램이 사용 중일 때 GC가 발생할 가능성이 적으므로 응답 성이 향상 될 수 있습니다. 그러나 힙의 라이브 데이터 양이 특히 많으면 유휴 GC가 상당한 지연을 유발할 수 있으며 간격이 너무 작 으면 대화 형 응답성에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">가져온 모든 모듈의 경우 GHC에서는 가져 오기 명령문의 모듈 이름 &lt;a href=&quot;#search-path&quot;&gt;이 검색 경로에&lt;/a&gt; 지정된 전략을 사용하여 찾은 인터페이스 파일 (또는 소스 파일)의 모듈 이름과 정확히 일치해야 합니다 . 이는 대부분의 모듈에서 소스 파일 이름이 모듈 이름과 일치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">문자열 리터럴 많은 수의 애플리케이션의 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 병목이 될 수 있습니다. 이러한 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC 만 해당) 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">문자열 리터럴 수가 많은 응용 프로그램의 경우 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">기존 make 스크립트와의 호환성을 위해 &lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 연결 단계가 생략됩니다 ( &lt;code&gt;--make -no-link&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 유형이 &lt;code&gt;forall&lt;/code&gt; 로 시작하더라도 종류 변수를 명시 적으로 바인딩 할 필요 &lt;em&gt;는 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">이진 생성자</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 모두 에 대해 단계 번호에 인라인이 허용되는 시점이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">패턴 및 표현식 와일드 카드의 경우 &quot; &lt;code&gt;..&lt;/code&gt; &quot; &lt;em&gt;는 범위 내&lt;/em&gt; 누락 &lt;em&gt;된&lt;/em&gt; 레코드 필드로 확장 됩니다. 특히 &quot; &lt;code&gt;C {..}&lt;/code&gt; &quot; 의 확장 에는 다음 과 같은 경우에만 &lt;code&gt;f&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">상자 값 (포인터로 표시되는 값)의 경우 리프팅 된 유형 (&amp;perp;을 포함)과 리프팅되지 않은 유형 (하지 않은) 사이에 추가 구분이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">가변 길이 패딩을 포함 할 수있는 기능의 경우 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">For catching exceptions in pure (non- &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수 유형과의 단어 유형 ( &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 참조 )을 강제 변환 하면 부호가 아닌 표현이 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수형으로 또는 정수형으로 단어를 강제 변환하면 부호가 아닌 표현이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/etc/xdg&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.config&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/etc&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/usr/local/share/&lt;/code&gt; 및 &lt;code&gt;/usr/share/&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.local/share&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/usr/share&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">간단한 외부 이진 형식 (예 : C 구조)을 디코딩하고 생성하기 위해 이진이 사용될 수 있지만 일반적으로 복잡한 프로토콜에는 적합하지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 프리미티브를 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">Remote GHCi에 대한 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [Remote GHCi]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">합계 유형의 각 대안에 대해 이러한 필드로 구성된 레이아웃이 생성됩니다. 예를 들어 대안에 &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 필드가있는 경우 레이아웃에는 32 비트 워드, 32 비트 부동 소수점 및 포인터 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">각 가비지 콜렉션에 대해 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">트리의 각 노드에 대해 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;rootLabel&lt;/code&gt; 에 적용하고 &lt;code&gt;f&lt;/code&gt; 를 각 &lt;code&gt;subForest&lt;/code&gt; 에 적용한 결과를 적용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">빈 데이터 유형의 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 이 표현으로 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">이 주제에 대한 자세한 내용은 &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;SIGINT / SIGQUIT의 올바른 처리&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">이런 방식으로 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; &lt;code&gt;A.hs&lt;/code&gt; 모든 모듈 A.hs 에 대해 소스 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 있어야합니다 . 이 파일에는 약어 버전의 &lt;code&gt;A.hs&lt;/code&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">예를 들어, &lt;code&gt;-l-ag&lt;/code&gt; 는 GC 이벤트 ( &lt;code&gt;g&lt;/code&gt; )를 제외한 모든 이벤트 클래스 ( &lt;code&gt;-a&lt;/code&gt; )를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="a52ed97184e92138a6e73030c8150e134f0bb680" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;Fixed 1000&lt;/code&gt; will give you a &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; with a resolution of 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adc62b058c0496c81ae2687046d64f2c845f5f6" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; would be invalid base monads, but &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt; would be acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">예를 들어, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; 는 크기가 1kb 이하인 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 복사하고 그렇지 않으면 직접 삽입합니다. 이는 직접 삽입 된 1025 바이트, 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사이에 항상 단일 바이트가있을 수 있기 때문에 생성 된 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 평균 청크 크기는 513 바이트만큼 낮을 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; 는 &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; 아니라 f (\ a-&amp;gt; ab) 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="025997d25e9ad541ddb4bccc051a89bbfefa2c23" translate="yes" xml:space="preserve">
          <source>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">예를 들어, 처음 20 개의 정수와 2의 거듭 제곱을 인쇄하는 프로그램은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">예를 들어 트리의 사용자 정의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">예를 들어, GHC로 다음 모듈을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;foo&lt;/code&gt; 프로그램을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">예를 들어, 함수와 함께 사용하도록 의도되지 않은 유형 클래스를 고려해 보았지만 사용자는 실수로 함수 유형에서 함수를 사용했습니다. 그런 다음 누락 된 인스턴스에 대한 표준 GHC 메시지를받는 대신 EDSL에 고유 한보다 친숙한 메시지를 생성하는 것이 좋습니다. 마찬가지로, 유형 레벨 함수의 감소는 오류로 인해 중단 될 수 있습니다.이 시점에서 모호한 유형에 대한 일반적인 오류보다는 EDSL 특정 오류를보고하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">예를 들어, &lt;code&gt;:time&lt;/code&gt; 이라는 이름의 매크로 가 있고 쉘에 &lt;code&gt;:t 3&lt;/code&gt; 을 입력 한 경우 어떻게됩니까? 명령을 완료하는 데 사용하는 현재 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음과 같은 병렬 버전 인 이전 버전 인 &lt;code&gt;nfib&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">예를 들어 다음 정의를 고려하십시오 ( &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">예를 들어 데이터 유형이 주어지면</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 &lt;code&gt;hist&lt;/code&gt; 는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 hist는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">예를 들어, 선언이 주어지면</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">예를 들어 다음은 GHC의 &lt;code&gt;nofib&lt;/code&gt; 벤치 마크 제품군 에서 &lt;code&gt;sphere&lt;/code&gt; 프로그램을 위해 생성 된 힙 프로파일입니다 .</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">예를 들어, 다음은 네트워크 소켓에서 클라이언트 연결을 수신하고 클라이언트 연결 핸들에서 클라이언트 입력을 에코하는 데 &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;에코 서버를&lt;/a&gt; 구현하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">예를 들어, GHC 가 &lt;code&gt;-odir&lt;/code&gt; 또는 &lt;code&gt;-hidir&lt;/code&gt; 플래그 없이 &lt;code&gt;src/A/B/C.hs&lt;/code&gt; 파일에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈을 컴파일하는 경우 인터페이스 파일은 &lt;code&gt;src/A/B/C.hi&lt;/code&gt; 및 오브젝트에 배치됩니다. 에서 파일 &lt;code&gt;src/A/B/C.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">예를 들어, 인터페이스가 가져온 값의 유형에 놓여 있다면 GHC는 가져 오기 모듈에 대한 더프 코드를 생성 할 수 있습니다. &lt;em&gt;이것은 인터페이스 내부의 pragma에도 적용됩니다! &lt;/em&gt;pragma가 거짓말을하는 경우 (예 : 값의 &quot;arity&quot;에 대해) 더프 코드가 발생할 수 있습니다. 또한 유형이 다르더라도 자질이 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">예를 들어 다음 데이터 유형이 범위 내에있는 경우</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">예를 들어, 패키지 스펙에서 Haskell 라이브러리를 &lt;code&gt;HSfoo&lt;/code&gt; 로 지정하면 GHC가 실제로 사용하는 다양한 라이브러리가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">예를 들어, 프로그램의 핵심을 검사하고 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 것을 관찰하는 경우 . &lt;code&gt;-dinline-check foo&lt;/code&gt; 를 전달 하면 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 이유에 대한 보고서가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">예를 들어,이 동작이있는 80 열 터미널에서는 다음이 이중 간격 대신 단일 간격으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">예를 들어 다음 프로그램에서 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;f'&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">예를 들어, 항목은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">예를 들어, 동일한 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 을 여러 번 호출 하면 동일한 입력 히스토리가 공유됩니다. 반대로 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; 에 대한 여러 번의 호출 은 동일한 히스토리 파일을 공유하지 않는 한 고유 한 히스토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">예를 들어, 가능한 응용 프로그램 중 하나는 사전을 구체화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 기억이 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">예를 들어, 때때로 다음을 사용하여 &quot;클래스 동의어&quot;의 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">예를 들어, 검색 경로가 디렉토리가 있다고 가정 해 &lt;code&gt;d1&lt;/code&gt; , &lt;code&gt;d2&lt;/code&gt; 와 &lt;code&gt;d3&lt;/code&gt; , 우리는에 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모듈의 소스 파일을 찾고 모드 &lt;code&gt;A.B.C&lt;/code&gt; . GHC는 &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; , &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; , &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; 등을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; 와 같이 &quot; &lt;code&gt;&quot;::&quot;&lt;/code&gt; 하위 문자열에서 분할하려는 문자열이 있다고 가정하십시오 . &lt;code&gt;&quot;::&quot;&lt;/code&gt; 의 색인을 검색하고 해당 색인 전후에 하위 문자열을 사용하는 대신 &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">예를 들어, 파일을 읽으려고하는데 파일이 없으면 &quot;&quot;가 포함 된 것처럼 계속 진행하십시오. 모든 예외를 포착하고 핸들러에서 &quot;&quot;를 반환하려는 유혹을받을 수 있습니다. 그러나 이것은 모든 종류의 바람직하지 않은 결과를 초래합니다. 예를 들어, 사용자가 적절한 순간에 control-C를 누르면 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 예외가 발생하고 파일에 &quot;&quot;가 포함되어 있다는 확신하에 프로그램이 계속 실행됩니다. 마찬가지로, 다른 스레드가 파일을 읽는 스레드를 종료하려고하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 예외가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">예를 들어 다음 데이터 형식의 생성자 필드</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">예를 들어, 데이터 유형 &lt;code&gt;2 * A&lt;/code&gt; 및 &lt;code&gt;A + A&lt;/code&gt; 는 동형이지만 일부 계산은보다 자연스럽게 표현됩니다. 두 세계를 최대한 활용하기 위해 하나를 구현으로 선택한 다음 사용자가 원하는 경우 다른 표현을 사용할 수 있도록 패턴 동의어 세트를 제공 할 수 있습니다. 그런 다음 패턴 일치 검사기에 &lt;code&gt;LeftChoice&lt;/code&gt; 와 &lt;code&gt;RightChoice&lt;/code&gt; 모두에서 일치하는 함수 가 총계 임을 알리기 위해 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">예를 들어, 다음 코드는 GHC에서 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">예를 들어, 다음 옵션은 &lt;code&gt;Branch&lt;/code&gt; 및 &lt;code&gt;Leaf&lt;/code&gt; 생성자로 제한된 리테이너 프로파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">예를 들어, 이것들은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">예를 &lt;code&gt;Monad&lt;/code&gt; 코드에는 Monad 제약 조건 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">예 를 &lt;code&gt;#fullname&lt;/code&gt; 인스턴스는 #fullname 을 사용하여 &lt;code&gt;Person&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 필드에 액세스 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">예를 들어 &lt;code&gt;f x&lt;/code&gt; 의 값을 반환 하지만 먼저 메시지를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">예를 들어, CFI를 사용하여 FFI 및 전처리를 활성화하려면 :</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">예를 들어 간단한 &lt;code&gt;ls&lt;/code&gt; 명령 을 실행하려면</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">예를 들어, &lt;code&gt;network&lt;/code&gt; 패키지를 사용하는 &lt;code&gt;Foo.o&lt;/code&gt; 및 &lt;code&gt;Main.o&lt;/code&gt; 객체로 구성된 프로그램을 연결 하려면 GHC에 &lt;code&gt;-package&lt;/code&gt; 플래그를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">예를 들어 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 Haskell 프로그램을로드하고 실행하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">예를 들어, YYYY-MM-DD 형식으로 날짜를 구문 분석하고 월과 날짜에 선택적 선행 0을 갖도록 허용하려면 ( &lt;code&gt;%m&lt;/code&gt; 및 &lt;code&gt;%d&lt;/code&gt; 사용 된 &lt;code&gt;-&lt;/code&gt; 수정 자에 유의 ) :</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">예를 들어, 프로세스를 시작하고 문자열을 stdin에 공급하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">예를 들어 문자열을 토큰 화하려면 구분 기호를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">예를 들어 직접 재귀를 사용하여 계승 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">예를 들어, 모듈 A를 컴파일 할 때 B가 A를 직접 또는 간접적으로 가져 오지 않으면 B에서 가져온 템플릿 Haskell 함수 만 실행할 수 있습니다. 그 이유는 분명해야합니다. B를 실행하려면 A를 컴파일하고 실행해야하지만 현재 A를 타입 검사하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 보기 흉하지만 문제가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">네 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z.z'&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 이고 __GLASGOW_HASKELL_PATCHLEVEL2__ 값은 정수 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">단사 형 가족에 대한 자세한 내용은 하스켈 심포지엄 2015 종이를 참조 &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;하스켈에 대한 단사 유형의 가족&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">그러나 숨겨진 패키지의 경우 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 플래그를 사용하여 패키지를로드하도록 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역사적 이유로 보존 된 값은 / 강제 / 강제 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그들을 강제로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 하려면 preserveMissing '을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">예를 들어 간단한 프로필은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">예를 들어 다음과 같은 유형의 제품군이있는 경우</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; 로 프로그램을 실행하면 &lt;code&gt;hello-world.hp&lt;/code&gt; 라는 힙 프로파일 과 hello-world.prof 라는 비용 중심 프로파일이 &lt;code&gt;hello-world.prof&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">예를 들어, &lt;code&gt;-fno-specialise -O1&lt;/code&gt; 의 예를 들어보십시오 . 에도 불구하고 &lt;code&gt;-fno-specialise&lt;/code&gt; 명령 줄에 나타나는 전문화는 여전히 활성화됩니다. &lt;code&gt;-O1&lt;/code&gt; 이 &lt;code&gt;-fspecialise&lt;/code&gt; 를 암시 하고 이전 플래그를 대체 하는 경우 입니다. 반대로 &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; 는 예상대로 전문화없이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">예를 들어, 형식 서명의 첫 번째 와일드 카드 는 다음과 같은 오류 메시지를 생성 &lt;code&gt;not'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">예를 들어, 우리의 응용 프로그램에 더 유용한 오류 메시지를 제공하기 위해이 인터페이스를 사용할 수있는 &lt;code&gt;show&lt;/code&gt; 같은 불포화 기능에,</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; 클래스 에 속하는 모나드의 경우 GHC는 재귀 바인딩을 허용하는 확장 된 do-notation 버전을 제공합니다. &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; (언어 프라 그마 : &lt;code&gt;RecursiveDo&lt;/code&gt; 는 ) 키워드를 도입, 필요한 구문 지원을 제공 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 각각 표기의 높고 낮은 수준. &lt;code&gt;do&lt;/code&gt; 표현식의 바인딩과 달리 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 에 의해 도입 된 바인딩 은 일반적인 let-expression과 매우 유사하게 재귀 적으로 정의됩니다. 새로운 키워드 &lt;code&gt;mdo&lt;/code&gt; 로 인해이 표기법을 &lt;em&gt;mdo-notation이라고도&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">이 기능에 대한 자세한 내용은 Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones 및 Stephanie Weirich의 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki 페이지&lt;/a&gt; 또는 원본 &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">자세한 내용은 Conor McBride 및 Ross Paterson의 &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">GHC에 의해 생성 된 디버그 정보에 대한 자세한 내용은 Peter Wortmann의 박사 논문, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;* 최적화 된 Haskell 프로파일 링 : 인과 분석 및 구현 *을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da91b931841e7893478b07acb85bd4ccd0928c7e" translate="yes" xml:space="preserve">
          <source>For more information about this type's representation, see the comments in its implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">틱 틱틱 프로파일 링에 대한 자세한 내용은 &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;&quot;틱 키틱&quot;프로파일 링 사용 (구현 자용)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">API 사용과 샘플 및 참조에 대한 자세한 내용은 &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">자세한 내용 은이 라이브러리 디자인의 기초 가되는 &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 . 1995 년 고급 기능 프로그래밍에서 John Hughes의 / The Pretty-printing Library의 디자인 /.</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 새로운 SYB 위키 ( &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB)&lt;/a&gt; 를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 . @since 4.9.0.0</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">더 많은 동기 부여와 세부 사항은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; 페이지 또는 &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">대부분의 응용 프로그램에서는 다음 &lt;code&gt;Settings&lt;/code&gt; 플래그 를 대신 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">대부분의 응용 프로그램 (예 : REPL)의 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 가 올바른 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">대부분의 배열 유형의 경우이 작업은 O ( &lt;em&gt;n&lt;/em&gt; )이며 여기서 &lt;em&gt;n&lt;/em&gt; 은 배열의 크기입니다. 그러나 diffarray 패키지는이 작업이 업데이트 수에있어 복잡성을 갖는 배열 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">중첩 된 &lt;code&gt;foralls&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">newtypes를 들어, &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 와 &lt;code&gt;Bounded&lt;/code&gt; 항상 사용 파생 &lt;code&gt;newtype&lt;/code&gt; 이란 도없이, 전략을 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 이 가능. (주식 전략을 사용하여 파생 된 인스턴스와 눈에 띄는 차이가 없어야합니다.)</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">필수가 아닌 파일 (예 : 캐시) &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.cache&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ). 사용자 별 &lt;code&gt;/var/cache&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Haskell finalizer를 이식 할 수없는 지원에 대해서는 &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3383003efe56493c3ba8ee51d572a1bd3e32533a" translate="yes" xml:space="preserve">
          <source>For now, this module is the API for working with type-level literals. However, please note that it is a work in progress and is subject to change. Once the design of the &lt;code&gt;DataKinds&lt;/code&gt; feature is more stable, this will be considered only an internal GHC module, and the programmer interface for working with type-level data will be defined in a separate library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">개방형 및 폐쇄 형 패밀리의 경우 결과의 이름을 지정하지만 주입 주석을 건너 뛰어도됩니다. 주입 형 주석이없는 명명 된 결과가 연관된 유형 동의어 기본값으로 해석되는 연관된 유형 동의어의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">다른 모든 유형 클래스의 경우 :</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">다른 문서는 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">1 부에서는 &lt;code&gt;Encode'&lt;/code&gt; 클래스를 정의합니다 . 놀랍게도이 클래스는 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 종류 의 유형 생성자 &lt;code&gt;f&lt;/code&gt; 에 대해 매개 변수화 됩니다. 이것은 기술입니다. 모든 표현 유형 생성자는 종류 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 를 기본 종류로 사용합니다. 그러나 type 인수는 사용되지 않습니다. 이것은 나중에 언젠가 변경 될 수 있습니다. 클래스는 하나의 방법이 있고, 우리는 우리가 우리의 최종적인 기능을 갖고 싶어 유형을 사용하지만, 우리는 제네릭 형식 인수의 발생 대체 와 &lt;code&gt;f p&lt;/code&gt; 합니다 ( &lt;code&gt;p&lt;/code&gt; 는 , 그것은 사용되지 않습니다 어떤 인수입니다). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">필드가 많은 레코드의 경우와 같이 각 필드를 개별적으로 레코드 패턴으로 기록하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">단일 생성자 데이터 유형의 경우 파생 인스턴스 선언은 Haskell 2010 보고서의 19 장, 섹션 2 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html)&lt;/a&gt; 에서 튜플에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">어떤 이유로 Mingw는 &lt;code&gt;readline&lt;/code&gt; 라이브러리 와 함께 제공 되지만 &lt;code&gt;readline&lt;/code&gt; 헤더 와 함께 제공되지 않습니다 . 결과적으로 GHC (Hugs와 같은)는 Windows에서 대화식 입력에 &lt;code&gt;readline&lt;/code&gt; 을 사용하지 않습니다 . emacs 쉘 ​​버퍼를 사용하여 정밀한 시뮬레이션을 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">일부 특수 사용 사례의 경우 어떤 이벤트가 포함되는지 더 세밀하게 제어 할 수 있습니다. ⟨플래그⟩는 기록 할 이벤트 클래스를 나타내는 0 개 이상의 문자 시퀀스입니다. 현재 활성화 / 비활성화 할 수있는 이벤트 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">일부 값의 경우 순서가 아닌 목록 내용에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">스파크 이벤트의 경우 샘플링 및 완전 정확도의 두 가지 모드가 있습니다. 각 스파크의 수명주기에는 다양한 이벤트가 있으며 일반적으로 생성 및 실행이지만 더 뛰어난 가능성이 있습니다. 샘플링 된 모드에서 각 종류의 스파크 이벤트 발생 횟수는 빈번한 간격으로 샘플링됩니다. 완전 정확한 모드에서는 모든 스파크 이벤트가 개별적으로 기록됩니다. 후자는 런타임 오버 헤드가 높으며 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">기술적 인 이유로 GHCi 는 해석되는 모듈에 대해서만 &lt;code&gt;*&lt;/code&gt; 양식을 지원할 수 있습니다 . 컴파일 된 모듈 및 패키지 모듈은 현재 범위에 대한 내보내기에만 기여할 수 있습니다. GHCi가 해석 된 버전의 모듈을 로드하도록하려면 모듈을로드 할 때 &lt;code&gt;*&lt;/code&gt; 를 추가하십시오 ( 예 &lt;code&gt;:load *M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">기술적 인 이유로 바이트 코드 컴파일러는 최적화 패스 중 하나와 잘 상호 작용하지 않으므로 인터프리터를 사용할 때 최적화를 비활성화했습니다. 이는 큰 손실이 아닙니다. 최적화가 설정된 상태에서 해석하는 대신 빠르게 진행해야하는 코드 비트를 컴파일하면 훨씬 더 큰 승리를 거둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Bad Int&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같이 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Ex&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같은 것을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">첫 번째 트러스트 정의의 경우, GHC는 안전한 언어에 의해 부과 된 제한을 통해 트러스트 보증을 제공합니다. 신뢰의 두 번째 정의의 경우 보증은 처음에 모듈 작성자가 제공합니다. 그런 다음 클라이언트 C는 모듈이 상주하는 패키지를 신뢰 함을 표시하여 모듈 작성자를 신뢰하도록 설정합니다.이 신뢰 체인은 GHC가 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 컴파일 된 모듈을 보증하지 않으므로 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">문자열 데이터 자체의 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;ByteString&lt;/code&gt; 은 요소 당 하나의 바이트를 사용하며 가장 가까운 단어로 반올림됩니다. 예를 들어 오버 헤드를 포함하여 길이 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 은 32 비트 플랫폼에서 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 바이트를, 64 비트 플랫폼에서 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">이 모나드 변압기의 경우 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 자연스럽게 변환됩니다. 즉 모나드 변환 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a ,</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">이러한 이유로 GHC는 &lt;code&gt;tryPutMVar&lt;/code&gt; 에 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 대한 외부 API를 제공하며 C / C ++에서 Haskell 스레드를 저렴하고 비동기 적으로 깨울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt; ) when assigning costs.</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">이러한 이유로 GDB가 제공하는 소스 위치를 해석 할 때는주의해야합니다. 이러한 위치는 일반적으로 &quot;정확한&quot;의미이지만 항상 유용한 것은 아닙니다. 이러한 이유로 Haskell을 대상으로하는 프로파일 링 도구는 비용을 할당 할 때 표준 소스 위치 정보를 GHC 특정 주석 ( &lt;code&gt;-g2&lt;/code&gt; 로 방출)으로 보완해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">세 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 입니다.</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">위 의 &lt;code&gt;foo2&lt;/code&gt; 의 서명과 같이 &lt;em&gt;둘 이상의 요소&lt;/em&gt; 의 유형 레벨 목록의 경우 , 그 의미가 모호하지 않기 때문에 인용 부호는 생략 될 수 있습니다. 그러나 &lt;code&gt;foo0&lt;/code&gt; 및 &lt;code&gt;foo1&lt;/code&gt; 에서 와 같이 하나 또는 제로 요소 목록의 경우 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;[Int]&lt;/code&gt; 유형 이 Haskell에서 기존 의미를 갖기 때문에 따옴표가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">유형과 클래스의 경우 GHCi는이를 언급하는 인스턴스도 요약합니다. 관련이없는 정보를 표시하지 않으려면 (a) 헤드가 ⟨name⟩을 언급하고 (b) 인스턴스에 언급 된 다른 모든 항목이 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 의 결과로 범위가 한정된 경우에만 표시됩니다 . 또는 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">단항 생성자</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 같은 제한되지 않은 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">GHCi와 함께 사용하려면 각 라이브러리에 객체 파일도 있어야합니다. 오브젝트 파일 이름 에는 &lt;code&gt;lib&lt;/code&gt; 접 두부 가 &lt;em&gt;없으며&lt;/em&gt; 플랫폼의 일반 오브젝트 접미 부가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">의 값 &lt;code&gt;n&lt;/code&gt; 1보다 큰 우리가 사용 &lt;code&gt;par&lt;/code&gt; 평가할 스레드를 촉발 &lt;code&gt;nfib (n-1)&lt;/code&gt; 다음과 같이 사용할 &lt;code&gt;pseq&lt;/code&gt; 을 평가하기 위해 부모 스레드를 강제로 &lt;code&gt;nfib (n-2)&lt;/code&gt; 이 두 함께 추가 가기 전에 하위 식. 이 분할 및 정복 방식에서는 계산의 한 분기에 대해서만 새 스레드를 생성합니다 (부모가 다른 분기를 평가하도록 두는 것). 또한 부모는 표현식 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 에서 &lt;code&gt;n1&lt;/code&gt; &lt;em&gt;보다 먼저 &lt;/em&gt; &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 평가 하도록 &lt;code&gt;pseq&lt;/code&gt; 를 사용해야합니다 . 식을 &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; 로 재정렬하는 것만으로는 충분하지 않습니다.&lt;em&gt;&lt;/em&gt;컴파일러는 추가 항목을 왼쪽에서 오른쪽으로 평가하는 코드를 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">버전 들어 &lt;code&gt;x.y.z&lt;/code&gt; GHC의 값 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 은 (⟨y⟩ 너무 GHC 버전 6.2 예를 들어, 선두 제로 첨가 한 자릿수이면, 정수 ⟨xyy⟩이다 &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ). &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC 버전 번호 지정 정책에&lt;/a&gt; 대한 추가 정보 .</target>
        </trans-unit>
        <trans-unit id="930d459a31fb0c473c8d3d450ef14232e956aa5e" translate="yes" xml:space="preserve">
          <source>ForallInvis</source>
          <target state="translated">ForallInvis</target>
        </trans-unit>
        <trans-unit id="fc5f64a4d6f12d0fb09adaae4cd55424315fc13f" translate="yes" xml:space="preserve">
          <source>ForallVis</source>
          <target state="translated">ForallVis</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">GHC가 값을 인라인하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">힘 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 일반적인 형태입니다.</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 강제 실행하고 변경되지 않은 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">TH를 통해 GHC가 지원하는 외국 형식</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">내부적으로 UTF-16을 사용하는 외부 함수 는 문자 대신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 단위로 인덱스를 반환 할 수 있습니다 . 이러한 함수는 유니 코드 문자열의 유효성을 유지하기 위해 필요한 경우 오프셋을 조정하므로 이러한 인덱스와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f235bf33c8f99af06dcf27d617dccc24437bf4f1" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">구성 가능한 인코딩으로 CString에 대한 외부 마샬링 지원</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">스레드를 포크하고 스레드가 종료 되려고 할 때 예외 또는 리턴 값으로 제공된 함수를 호출하십시오. 이 함수는 비동기 예외를 마스킹하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">포크와 실행</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">스레드를 포크하고 죽입니다.</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">포크와 같은</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">크기와 위상의 극 성분에서 복소수를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">공식적으로 말하면, Haskell 98에서 프로그램의 엔티티 (함수, 유형 또는 클래스)는 프로그램이 정의 된 모듈 이름 쌍과 이름으로 고유하게 식별됩니다. GHC에서 엔티티는 패키지, 모듈 및 이름의 트리플로 고유하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">공식적으로, 클래스 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 는 에서 bifunctor 나타냅니다 &lt;code&gt;Hask&lt;/code&gt; &amp;gt; - &lt;code&gt;Hask&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">C 스타일의 형식화 문자열을 사용하여 가변 개수의 인수를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt; 에 따라 문자열을 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">형식 문자열.</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값의 포맷터입니다 .</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">서식 덤프</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">숫자를 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">숫자를 ASCII 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">두 정수의 비율을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">다행히 GHC는 두 가지 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">다행히도 디버거에는 일반 인쇄 명령 인 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 가 포함되어 변수의 실제 런타임 값을 검사하고 해당 유형을 재구성 할 수 있습니다. 우리가 &lt;code&gt;left&lt;/code&gt; 시도하면 :</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">분수 나누기.</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">분수 리터럴은 translation이 &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; 인 것을 제외하고는 동일한 방식으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">실수를 지원하는 분수.</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; 또는 &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt; 의 &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt; 함수 로 할당 된 메모리 블록을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 무료 데이터</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">캐시 된 디버그 데이터를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">콜 스택을 고정하여 추가 콜 사이트가 추가되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">가변 배열을 고정시킵니다. 나중에 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 를 변경하지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">지정된 &lt;code&gt;CallStack&lt;/code&gt; 에서 스택을 고정하여 더 이상의 콜 사이트가 밀리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">신선한 이름</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">오름차순 목록에서</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">내림차순 목록에서</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">정렬되지 않은 목록에서</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; 와 다른 모듈에서</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">의미 적 관점에서 :</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">구문 관점에서 :</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">여기에서 정수 유형의 모든 인수에 f를 적용하고 결과를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">문자열에서 생성자로 또는 그 반대로 : 모든 데이터 유형</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">로부터 &lt;code&gt;x1==x2&lt;/code&gt; 우리 필요 &lt;code&gt;Eq a&lt;/code&gt; 미세하다. &lt;code&gt;c1==c2&lt;/code&gt; 부터 우리 는 오늘날 Haskell에서 &lt;em&gt;좋지 않은 &lt;/em&gt; &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; 가 &lt;em&gt;필요&lt;/em&gt; 합니다. 우리는 그러한 제약을 해결할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">부터 &lt;code&gt;x==x&lt;/code&gt; 우리가 필요로 &lt;code&gt;Eq (m Int)&lt;/code&gt; 제약 조건을하지만, 상황은 우리가 알아낼 수있는 방법 제공 &lt;code&gt;Ord (m a)&lt;/code&gt; 제약. 그러나 주어진 제약 조건에서 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; 우리는 모든 a에 대한 두 번째 주어진 제약을 도출 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; 이고, 그로부터 &lt;code&gt;Eq (m Int)&lt;/code&gt; 를 쉽게 풀 수 있습니다 . 이 프로세스는 슈퍼 클래스가 이미 작동하는 방식과 매우 유사합니다. &lt;code&gt;Ord a&lt;/code&gt; 제약이 주어지면 두 번째로 &lt;code&gt;Eq a&lt;/code&gt; 제약이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">초록에서 :</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;ByteString&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;ByteString&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">컴파일러 플러그인과 같은 프론트 엔드 플러그인은 등록 된 플러그인으로 내보내집니다. 그러나 컴파일러 모듈과 달리 프론트 엔드 플러그인은 &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; 유형의 최소한 하나의 식별자 &lt;code&gt;frontendPlugin&lt;/code&gt; 을 내보내는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="translated">Full list of currently supported flags:</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">기능 구성.</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">함수 포인터</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능. 첫 번째 인수는 단어 왼쪽의 줄 내용을 반대로 한 것입니다. 두 번째 주장은 완성 될 단어입니다.</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">코딩 오류 처리를위한 함수 유형 두 가지 입력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">기능 유형. 마지막 유형 매개 변수는 &lt;em&gt;공변량&lt;/em&gt; 위치 에서 발생하는 한 함수 유형의 어느 곳에 나 나타날 수 있습니다 . 이것이 의미하는 바를 설명하기 위해 다음 세 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">기능 종속성은 Mark Jones가 &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt; 에 설명 된대로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">기능적 의존성은 클래스 선언 구문에서 세로 막대로 소개됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">기능적 의존성은 문제를 복잡하게합니다. 우리가 가지고 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">튜플 데이터 형식과 관련된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">파일 시스템 조작 및 조회를 위해 POSIX 표준에 의해 정의 된 기능. 기본 POSIX 기능의 이름은 가능할 때마다 표시됩니다. 다양한 오류 조건에 대한 자세한 설명과 함께 POSIX 기능에 대한보다 완전한 문서는 일반적으로 시스템 매뉴얼 페이지 또는 &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (무료 등록 필요)에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">여러 표준 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">몇 가지 표준 인코딩을 사용하여 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 지연 &lt;code&gt;ByteString&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
