<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fea1585aed3010cb59ede80216e1092bd438ce4" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</source>
          <target state="translated">인용 된 ⟨string⟩은 두 문자 시퀀스 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 의 첫 번째 발생에서 끝납니다 . 이스케이프는 절대로 수행되지 않습니다. 문자열에 해당 문자 시퀀스를 포함하려면 고유 한 이스케이프 규칙 (예 : 대신 문자열 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 사용)을 만들고 따옴표 함수가 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; &quot; 로 해석하도록해야합니다. ] &quot; . 이를 구현하는 한 가지 방법은 이스케이프 변환을 수행하기 위해 전처리 패스로 견적서를 작성하는 것입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;# 5348&lt;/a&gt; 의 토론을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">인용 된 ⟨string⟩은 두 문자 시퀀스 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 가 처음 나타날 때 끝납니다 . 절대로 이스케이프가 수행되지 않습니다. 문자열에 해당 문자 시퀀스를 포함하려면 고유 한 이스케이프 규칙 (예 : 대신 문자열 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 사용)을 발명하고 인용 기 함수가 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . 이를 구현하는 한 가지 방법은 따옴표를 사전 처리 패스로 작성하여 이스케이프 변환을 수행하는 것입니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;문제 # 5348&lt;/a&gt; 의 토론을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">이 보수적 인 전략에 대한 이론적 근거가 주어진다 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;논문&lt;/a&gt; &quot;하자가 일반화되어서는 안된다&quot;와 &quot;지역 가정 모듈 형 타입 추론&quot;및 관련 &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;블로그 게시물&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46c2ed2757c23fae8b2fbe6c5c9ab4a0e016d4ba" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">이 보수적 인 전략에 대한 이론적 근거가 주어진다 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;논문&lt;/a&gt; &quot;하자가 일반화되어서는 안된다&quot;와 &quot;지역 가정 모듈 형 타입 추론&quot;및 관련 &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;블로그 게시물&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">이 비용 중심에 기인 한 원시 시간 &quot;틱&quot; 이것으로부터, 위에서 언급 한 &lt;code&gt;%time&lt;/code&gt; 그림을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">지정된 모나드에 읽기 전용 환경을 추가하는 리더 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 가 역 추적 출력에이 기호 이름을 표시하지 않는 이유 는 디버그 정보 해석에 부정확성이 있기 때문에 C에서는 변하지 않고 Haskell 프로그램은 보존하지 않는다고 가정합니다. 불행히도이 동작이 업스트림에 고정 될 때까지이 문제를 수동으로 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">후자의 제한 이유는 인스턴스 일치를 확인할 수있는 방법이 없기 때문입니다. 치다</target>
        </trans-unit>
        <trans-unit id="76babb94bd7796eeda34a4c806d3669a17f9540b" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">이 예외의 이유는 &lt;code&gt;k&lt;/code&gt; 를 바인딩하는 다른 방법이 없을 수 있기 때문 입니다. 예를 들어, &lt;code&gt;S&lt;/code&gt; 가 &lt;em&gt;보이지 않는&lt;/em&gt; 매개 변수 &lt;code&gt;k&lt;/code&gt; 를 사용하여 다음과 같은 종류를 갖기를 원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">&lt;code&gt;mergeQs&lt;/code&gt; 에 대한 호출 이 게으른 이유는 큐의 마지막 요소에 대해 맨 아래가되어 완전히 정렬 된 시퀀스를 평가할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">트러스트를 검사하는 두 가지 모드가있는 이유는 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; 에&lt;/a&gt; 의해 활성화 된 추가 요구 사항으로 인해 Safe Haskell의 설계가 침투하기 때문입니다. 플래그가 활성화 될 때 Safe Haskell을 사용하는 패키지는 사용자 컴퓨터의 신뢰할 수있는 패키지 상태에 따라 컴파일되거나 컴파일되지 않을 수 있습니다. Safe Haskell이 제공 한 보증을 사용하지 않더라도 모두 깨지기 쉬우 며 모든 사람이 컴파일 오류를 일으 킵니다. 기본적으로 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 를 비활성화 하고 플래그로 설정하면 Safe Haskell이 항상 켜져있는 기능이 아닌 옵트 인 확장이됩니다.</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">리 바인드 가능한 연산자는 위 표에 제공된 &quot;예상 유형&quot;을 가져야합니다. 이러한 유형은 놀라 울 정도로 일반적입니다. 예를 들어, 다음 유형의 바인드 연산자를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">더 작은 부품에서 ByteString을 조립하는 권장 방법은 Data.ByteString.Builder의 빌더 모노 &lt;a href=&quot;data-bytestring-builder&quot;&gt;아이드&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">작은 부품에서 게으른 ByteString을 조립하는 권장 방법은 &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 의 빌더 모노 아이드 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">권장 청크 크기입니다. 현재 4k로 설정, 메모리 관리 오버 헤드 감소</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">레코드 필드 &lt;code&gt;f&lt;/code&gt; 의 범위는 어떻게 든 (적격 또는 비 적격)입니다.</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 를 재귀 적으로 사용 하면 두 번째 인수가 &lt;code&gt;Type&lt;/code&gt; 을 갖습니다 . 그러나 형식 유추와 마찬가지로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;사용자 제공 종류 서명&lt;/em&gt; (또는 CUSK)을 제공하여 다형성 재귀를 얻을 수 있습니다 . CUSK는 추론 할 필요없이 모든 인수 종류와 결과 종류를 알면 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dedba55228cde4bbd5f3a4194d8b8dabbf8ef98a" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 를 재귀 적으로 사용 하면 두 번째 인수가 &lt;code&gt;Type&lt;/code&gt; 종류를 갖게 됩니다. 그러나 유형 추론과 마찬가지로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;독립형 종류 서명&lt;/em&gt; 을 제공하여 다형성 재귀를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">호출자 프로세스에서 참조를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">관련된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;찾기 우선 설정 조작&lt;/a&gt; 은 다음과 같이 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">렌더링 모드.</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 표현 은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 와 약간 다릅니다 . 우리가 살펴 보자 &lt;code&gt;Tree&lt;/code&gt; 다시 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typ의 표현은 추상화되어 구현에서 멋진 표현 (예 : 공유 관리를위한 해시-콘솔)을 사용할 수 있습니다. 뷰 패턴이 없으면이 서명을 사용하는 것이 약간 불편합니다.</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">외부 파일 또는 스트림에서 줄 바꿈 표현.</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 의 종류를 요술하기 위해서 GHC에 의해 생성 된 표현 입니다.</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">이 표현은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 을 재사용합니다 . (이 재사용 가능성은 우리가 kind- &lt;code&gt;*&lt;/code&gt; -types에 대한 더미 유형 인수를 수행하는 이유 이지만, 이들 각각을 복제하지 않고 이미 다른 이름이 충분합니다.)</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">이 모듈에서 사용되는 표현은 고성능 사용 및 대량의 데이터 스트리밍에 적합합니다. 전체 내용이 메모리에 상주하지 않아도 큰 본문을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 유형의 표현과 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 을 구성하기 위해 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 의 파생 인스턴스에서 사용되는 함수 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">일정 변경 타이머는 기본적으로 20ms 단위로 실행되지만 &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS 옵션을 사용하여 변경할 수 있습니다 . &quot;예약&quot;일정을 변경 한 후에는 실행중인 스레드가 최대한 빨리 선점됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;getCurrentTime&lt;/code&gt; , &lt;code&gt;getPOSIXTime&lt;/code&gt; 의 해상도</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 GADT 스타일 데이터 형식 선언에 대한 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 GADT를 지원하는 GHC의 확장 기능에 대해 간략하게 설명합니다. 확장 프로그램은 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 로 활성화됩니다 . &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; 의&lt;/a&gt; 확장도 설정 &lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">기능적 종속성 ( &lt;a href=&quot;#functional-dependencies&quot;&gt;기능적 종속성&lt;/a&gt; ) 에 대한 제한 은 특히 ​​문제가됩니다. 머리에 나타나지 않는 컨텍스트에 유형 변수를 도입하려는 유혹이 있습니다. 이는 일반적인 규칙에서 제외 된 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이해의 결과 표현은 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; 의 &lt;em&gt;마지막&lt;/em&gt; 이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이해의 결과 표현은 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; 의 &lt;em&gt;마지막&lt;/em&gt; 이며 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f01982d31d372848e4d6802c210759a3354a8278" translate="yes" xml:space="preserve">
          <source>The result is always &lt;code&gt;&amp;gt;= 1&lt;/code&gt; since even zero is encoded with 1 limb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">결과적으로 구멍이나 변수는 &lt;code&gt;undefined&lt;/code&gt; 처럼 동작 하지만 컴파일 타임에 경고를 표시하고 런타임에 평가되면 동일한 메시지를 표시한다는 추가 이점이 있습니다. 이 동작은 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 옵션 의 동작을 따르며 , 이는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; 를 의미&lt;/a&gt; 합니다. &lt;a href=&quot;#defer-type-errors&quot;&gt;런타임에 유형 오류 연기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">결과 종류 주석은 선택 사항이며 생략하면 기본값 은 인수 종류와 같은 &lt;code&gt;Type&lt;/code&gt; 입니다. 다품종 유형 군은 종류 주석의 매개 변수를 사용하여 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 의 결과 는 형식이 선언 된 시점에 유효한 고 정성 선언이 주어지면 상수 만 포함하는 구문 상 올바른 Haskell 식입니다. 데이터 유형, 괄호 및 공백에 정의 된 생성자 이름 만 포함합니다. 레이블이 지정된 생성자 필드를 사용하면 중괄호, 쉼표, 필드 이름 및 등호도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">최종 연속으로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 사용하여 CPS 계산을 실행 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="6cddc91b7454e61583af3768c2c69961c994bfc1" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">최종 연속으로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 사용하여 CPS 계산을 실행 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">주어진 최종 연속으로 CPS 계산을 실행 한 결과. ( &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">주어진 최종 연속으로 CPS 계산을 실행 한 결과. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">ID를 최종 연속으로 사용하여 CPS 계산을 실행 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 아르메니아의 작은 합자 &quot;ﬓ&quot;(지금은 U + FB13)은 &quot;մ&quot;(남자, U + 0574) 순서로 접 히고 그 뒤에 &quot;ն&quot;(현재, U + 0576)로 접습니다. &quot;&amp;micro;&quot;(마이크로 부호, U + 00B5)는 케이스 대신 &quot;&amp;mu;&quot;(작은 글자 mu, U + 03BC)로 접힌 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 현재 아르메니아의 소형 합자 남성 (U + FB13)은 현재 빅램 (U + 0574 U + 0576)으로 접 히고 마이크로 부호 (U + 00B5)는 그리스어 소문자 mu로 접혔습니다. 자체 대신 (U + 03BC).</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">결과 문자열은 입력 문자열보다 길 수 있으며 입력 문자열에 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 를 적용하는 것과 다를 수 있습니다 . 예를 들어, 현재 아르메니아의 소형 합자 남성 (U + FB13)은 현재 빅램 (U + 0574 U + 0576)으로 접 히고 마이크로 부호 (U + 00B5)는 그리스어 소문자 mu로 접혔습니다. 자체 대신 (U + 03BC).</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, 라틴어 작은 합자 fl (U + FB02)은 라틴어 대문자 F (U + 0046)와 라틴어 소문자 l (U + 006C)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, &quot;İ&quot;(위의 점이있는 라틴 대문자 I, U + 0130)는 &quot;i&quot;(라틴의 소문자 i, U + 0069)와 &quot;̇&quot;(위의 점, U + 0307 결합) 순서로 매핑됩니다. .</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어 독일어 &quot;&amp;szlig;&quot;(eszett, U + 00DF)는 2 문자 시퀀스 &quot;SS&quot;에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어 독일어 eszett (U + 00DF)는 2 문자 시퀀스 SS에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">결과 문자열이 입력 문자열보다 길 수 있습니다. 예를 들어, 위의 점이있는 라틴 대문자 I (U + 0130)는 라틴어 문자 i 시퀀스 (U + 0069)에 매핑 된 다음 위의 점 (U + 0307)을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">결과 유형은 &lt;code&gt;Show&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">결과 유형이 &lt;code&gt;()&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">결과 유형도 분명해야합니다. 일반적으로 이것은 유추 될 수 있지만 그룹의 모든 패턴 동의어가 생성자에서 다형성 인 경우 사용자는 유형 서명을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">각 데이터 생성자의 결과 유형은 정의 된 유형 생성자로 시작해야합니다. 모든 생성자의 결과 유형이 &lt;code&gt;T a1 ... an&lt;/code&gt; 형식 인 경우 &lt;code&gt;a1 ... an&lt;/code&gt; 고유 유형 변수 인 경우 데이터 유형은 &lt;em&gt;일반입니다&lt;/em&gt; . 그렇지 않으면 &lt;em&gt;일반화 된&lt;/em&gt; 데이터 &lt;a href=&quot;#gadt&quot;&gt;유형 (GADT&lt;/a&gt; ( Generalized Algebraic Data Types) )입니다.</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">결과는 (아마도) 재귀 적 바인딩 세트가되어 왼쪽의 간단한 변수 만 바인딩합니다. (Haskell Report에서와 같이 한 단계 더 나아갈 수 있고 &lt;code&gt;fix&lt;/code&gt; 를 사용하여 재귀 바인딩을 비 재귀로 만들 수 있지만 Core에서는 그렇게하지 않으며 문제를 난독 화하기 때문에 여기서는 그렇게하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">&lt;code&gt;compactFixupPointers#&lt;/code&gt; 가 호출 될 때까지 결과 블록은 GC에 알려지지 않으며 주소가 이탈되지 않거나 메모리가 누출되지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 코드 및 가능한 실패는 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 경우와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">리턴 코드 및 가능한 실패는 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 경우와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">반환 값은 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; ( &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; 이어야 하지만 Haskell의 타입 시스템은 이것을 어렵게합니다).</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 리턴 값은 가비지 콜렉터 실행시기에 따라 달라 지므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 리턴 값은 가비지 콜렉터 실행시기에 따라 달라 지므로 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">그 반대의 경우도 반드시 그런 것은 아닙니다. 두 개의 안정된 이름이 같지 않으면 이름이 지정된 개체가 여전히 동일 할 수 있습니다. 특히 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 은 객체가 평가 된 후 다른 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">그 반대의 경우도 반드시 그런 것은 아닙니다. 두 개의 안정된 이름이 같지 않으면 이름이 지정된 개체가 여전히 동일 할 수 있습니다. 특히 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 은 객체가 평가 된 후 다른 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">다시 쓰기는 &lt;code&gt;Control.Exception.assert&lt;/code&gt; 의 응용 프로그램을 발견 할 때만 컴파일러에 의해 수행 되므로 원하는 경우 자신의 고유 버전의 &lt;code&gt;assert&lt;/code&gt; 를 정의하고 사용할 수 있습니다 . 그렇지 않은 경우 &lt;code&gt;Control.Exception&lt;/code&gt; 을 가져와 코드에서 &lt;code&gt;assert&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">레코드 업데이트 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">경험의 규칙은 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 사용 하여 게으른 값에서 예외를 강제로 처리하거나 처리하는 것입니다. 반면에 효율성상의 이유로 만 게으른 값을 강요하고 예외에 신경 쓰지 않으면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">경험의 규칙은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 를 사용 하여 게으른 값에서 예외를 강제로 처리하거나 처리하는 것입니다. 반면에 효율성상의 이유로 만 게으른 값을 강요하고 예외에 신경 쓰지 않으면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">내보내기 목록 규칙 (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;섹션 5.2&lt;/a&gt; )은 유형 패밀리에 대한 조정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">어휘 범위 유형 변수에 대한 규칙 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 범위 유형 변수&lt;/a&gt; 참조 )은 패턴 동의어 서명에 적용됩니다. 이러한 규칙에서 명시한 바와 같이 , 패턴 동의어의 정의에 대해 명시적이고 구문 적으로 볼 수있는 외부 &lt;code&gt;forall&lt;/code&gt; (범용) 범위 의 유형 변수 만 ; 내면에 묶여있는 실재는 그렇지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b99c4ffb314648f355d9f28d0c2cc30bab28737d" translate="yes" xml:space="preserve">
          <source>The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; 제약 조건 을 해결하기위한 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">'Typeable'제약 조건을 해결하기위한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ( 예 : 산술 시퀀스를 다루는 Haskell 보고서 섹션 참조) 와 같은 경계 유형을 통해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스 를 유지하는 규칙은 여기에 정의 된 다양한 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형을 통해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 와 같은 경계 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스 를 유지하는 규칙 (산술 시퀀스를 처리하는 Haskell 보고서 섹션 참조)도 여기에 정의 된 다양한 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 유형 에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 인스턴스를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">런타임은 &lt;em&gt;기능&lt;/em&gt; 이라고하는 가상 프로세서 세트를 관리하며 , 그 수는 &lt;code&gt;-N&lt;/code&gt; 옵션에 의해 결정됩니다 . 각 기능은 한 번에 하나의 Haskell 스레드를 실행할 수 있으므로 기능의 수는 물리적으로 병렬로 실행할 수있는 Haskell 스레드의 수와 같습니다. 기능은 하나 이상의 OS 스레드에 의해 애니메이션됩니다. 런타임은 각 기능에 대한 OS 스레드 풀을 관리하므로 Haskell 스레드가 외부 호출을 수행하는 경우 ( &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;멀티 스레딩 및 FFI 참조&lt;/a&gt; ) 다른 OS 스레드가 해당 기능을 대신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">런타임은 사용 가능한 작업자 OS 스레드를 사용하여 Haskell 스레드를 실행합니다. 특정 Haskell 스레드를 실행하는 데 사용되는 특정 OS 스레드를 제어해야하는 경우 OS 스레드 로컬 상태를 사용하는 외부 라이브러리를 호출해야하므로 바운드 스레드가 필요합니다 ( &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">동일한 &lt;code&gt;-v2&lt;/code&gt; 또한 각 컴파일 단계의 전체 명령 줄 (적절한 경우)은 또한 인쇄 된 것을 제외.</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">동일한 &lt;code&gt;-v3&lt;/code&gt; 각 컴파일 단계 후 중간 프로그램 표현은 또한 인쇄 된 것을 제외하고는 (전처리 및 C / 어셈블리 파일 제외).</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 와 동일 하지만 비 IO 계산 용입니다. 비 IO 유형의 Haskell 함수를 내보내는 데 사용되는 경우에는 &lt;code&gt;foreign export&lt;/code&gt; 및 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 를 포장 하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 과 동일 하지만 개행 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">같은 &lt;code&gt;register&lt;/code&gt; , 같은 이름의 패키지가 이미 설치되어있는 경우,이 새로운 하나에 의해 대체되는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">일반 Haskell 쌍과 동일하지만</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;Variable out of scope&lt;/code&gt; &quot;오류 와 동일한 동작 이 기본적으로 컴파일을 종료합니다. &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 이러한 오류를 지연시킬 수 있습니다 . 이 플래그는 런타임까지 범위를 벗어난 변수에 의해 생성 된 오류를 지연시키고 컴파일 타임 경고로 변환합니다. 이러한 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 의해 완전히 억제 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">GHC가 여전히 배치 모드에 있기 때문에 소스에서 모듈을 컴파일하더라도 동일한 플래그가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">동일한 functor이지만 요소를 역순으로 처리하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da41682db6dc3bc462b3f80ca76ddaa5753e53c9" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 요소를 역순으로 처리하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">동일한 functor이지만 반대 순서로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aaeaba67e253d52c7d36c2433b481fa76e2e2f2" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">동일한 펑터이지만 역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">동일한 정보가 여기에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9836bb2774b4fe28e93611c450bce02c5621a1e" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; 에&lt;/a&gt; 대해 동일한 단계 번호 지정 제어를 사용할 수 있습니다 ( &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 에 대해 동일한 위상 번호 매기기 제어를 사용할 수 있습니다 ( &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">동일한 정제 된 의존성 분석을 통해 상호 재귀 함수의 타입 시그니처는 서로 다른 컨텍스트를 가질 수 있으며, 이는 Haskell 98 (4.5.2 절 마지막 문장)에서 불법입니다. GHC는 &lt;em&gt;정제 된&lt;/em&gt; 그룹의 유형 서명이 동일한 유형 서명을 가지고 있다고 주장한다 . 실제로 이것은 동일한 패턴 바인딩으로 바인딩 된 변수 만 동일한 컨텍스트를 가져야한다는 것을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">&lt;code&gt;deriving&lt;/code&gt; 절에 의해 생성 된 인스턴스에도 동일한 제한이 적용됩니다 . 따라서 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">이 시나리오 는 완전한 &lt;a href=&quot;#using-own-main&quot;&gt;main&lt;/a&gt; 프로그램을 연결하는 것이 아니라 C 라이브러리를 배포하는 것과 같은 방식으로 배포 할 수있는 Haskell 코드에서 라이브러리를 만드는 것을 제외하고는 자신의 main () 사용 과 매우 유사 합니다. 암호.</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">검색 경로에는 기본적으로 단일 디렉토리가 포함됩니다.&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;(즉, 현재 디렉토리). 검색 경로의 내용을 추가하거나 변경하는 데 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">소스 파일을 찾기위한 검색 경로는 다음과 같이 GHCi 명령 행 에서 &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">두 번째 인수는 일반적으로 응용 프로그램의 이름입니다. 경로에 통합되므로 유효한 경로 문자로 구성되어야합니다. 참고 : 두 번째 인수가 절대 경로 인 경우 두 번째 인수 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">두 번째 조항은 조금 더 흥미 롭습니다. 오른쪽이 겹치는 영역에서 일치하면 두 개의 겹치는 유형 패밀리 인스턴스가 허용됩니다. 몇 가지 예가 여기에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 번째 생성자는 두 개의 필드로 구성됩니다. 각각은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; (Tree a) 로 표시되는 &lt;code&gt;Tree a&lt;/code&gt; 유형의 재귀 필드입니다 . 개별 필드의 표현은 이진 형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 를 사용하여 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 수행하는 두 번째로 가장 일반적인 단계 는 경계 프리미티브를 사용하여 버퍼를 채우는 것입니다. 이는 다음과 같이 작동합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 체크 경계 원시적을 실행하기 위해 왼쪽에 충분한 공간이 있는지. 있는 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 바운딩 된 기본 요소를 실행 하고 업데이트 된 버퍼로 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 호출합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 드라이버에 새 버퍼가 필요하다는 신호를 보냅니다. 이 버퍼는 최소한 프리미티브의 경계보다 커야합니다. 우리는 연속의 버퍼없는 검사 융합 버퍼가없는 검사의 수를 줄이기 위해 제한된 프리미티브를 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에스. 또한 우리는 먼저 충분한 공간이 남아 있는지 확인한 다음 주어진 값을 인코딩하는 방법을 결정함으로써 버퍼가 가득 찼음을 알리는 제어 흐름을 단순화하기 위해 경계 프리미티브를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">유형이 유형 매개 변수와 다르지만 유형 매개 변수를 포함하는 두 번째 경우는 놀랍도록 까다로울 수 있습니다. 예를 들어 다음 예제는 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">두 번째 옵션은 &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 플래그 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 )를 추가하는 것으로, 별도의 프로세스 에서 인터프리터를 실행하여 프로파일 된 코드를 직접로드하고 실행할 수 있습니다. 코드를 두 번 컴파일 할 필요가 없으며 &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 를&lt;/a&gt; 추가 하면 작동합니다. (이 옵션은 GHC 8.0.x에서 실험 중이지만 이후 릴리스에서는 기본값이 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">파일의 두 번째 부분은 프로그램에서 가장 많은 비용이 드는 기능을 코스트 센터별로 분류 한 것입니다. 이 경우, 프로그램에는 하나의 중요한 기능, 즉 &lt;code&gt;fib&lt;/code&gt; 만 있었고 프로그램 의 시간 및 할당 비용의 100 %를 담당했습니다.</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">이 매뉴얼의 종류 다형성에 대한 섹션에서는 유형 및 클래스 선언 &lt;a href=&quot;#inferring-variable-order&quot;&gt;의 변수&lt;/a&gt; 가 정렬되는 방식에 대해 설명합니다 ( 유형 / 클래스 선언에서 변수의 순서 유추 ).</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">환경에 적용 할 선택기 기능.</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">선택기의 엄격 주석 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">선택기의 압축 해제 주석 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">이 경우 시맨틱은 필수 엔티티 세트가 익스포트에 의해 독점적으로 정의된다는 것입니다. 내보내기 목록에 엔티티가 언급되지 않은 경우 필요하지 않습니다. 이 기능의 동기는 라이브러리 작성자가 누군가가 사용하고자하는 모든 기능의 유형을 포함하는 옴니버스 서명을 제공 할 수 있도록하는 것이며, 클라이언트는 실제로 필요한 기능으로 내보내기를 줄입니다. 예를 들어, 문자열에 대한 서명을 상속했다고 가정하면이 양식의 로컬 서명을 작성하여 필요한 엔티티 만 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; 의 의미 는 매우 간단합니다. GHC가 &lt;code&gt;rec&lt;/code&gt; 그룹을 찾을 때마다 바운드 변수 세트를 계산하고 &lt;code&gt;MonadFix&lt;/code&gt; 클래스에 속하는 기본 monadic value-recursion 연산자 &lt;code&gt;mfix&lt;/code&gt; 에 대한 적절한 호출을 도입합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell 패턴 일치의 의미 는 Haskell 보고서의 &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2 절에&lt;/a&gt; 설명되어 있습니다. 이 설명에 다음과 같이 추가 항목 10을 하나 더 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">패턴의 의미 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">서버 측 템플릿 Haskell 상태입니다. 이것은 StartTH 메시지에 의해 생성됩니다. GHC 타입 점검 모듈마다 새로운 것이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">정적 포인터 테이블에서 정적 포인터를 찾는 데 사용되는 키 세트는 다른 프로그램 바이너리에 대해 안정적으로 유지되는 것은 아닙니다. 즉, 동일한 프로그램 바이너리에서 시작된 프로세스 만 동일한 키 세트를 사용하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">알려진 인코딩 세트는 시스템에 따라 다르지만 최소한 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프롬프트에서 현재 &lt;em&gt;범위&lt;/em&gt; 에있는 모듈 세트 . 이 세트는 &lt;code&gt;import&lt;/code&gt; 및 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 로 수정되며 위에서 설명한대로 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 후에 자동으로 수정됩니다 . 범위 내의 모듈 세트는 &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; 로 표시&lt;/a&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;em&gt;로드 된&lt;/em&gt; 모듈 세트 . 이 세트는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 에&lt;/a&gt; 의해 수정되며 &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt; 과 함께 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 높이는 1이고 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 은 높이가 없기 때문에 마지막 법칙의 측면 조건이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 왼쪽 ID 이므로 마지막 법률의 부수 조건이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">서명은 패턴 바인딩이 아닌 함수 바인딩 또는 베어 변수 바인딩의 유형을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 디코더 를 실행하는 가장 간단한 인터페이스 입니다. 디코더가 오류가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 하거나 호출이 실패 하거나 입력이 부족하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="0e8c225c01f9faa3800585856cd9e7639c83f852" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15de436f5ad58966f3fd02d798c87b26a0a4d2de" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 시퀀스의 동작이 정의되지 않습니다. 대부분의 응용 프로그램에서는 이러한 상황이 발생하지는 않지만 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용할 때 특히 반복적으로, 특히 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 과 함께 사용하면 약간의주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9c06af16b62ace31432f475d864e0e1ea766afc" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건의 위반은 감지되지 않으며 크기 제한을 초과하면 시퀀스 동작이 정의되지 않습니다. 이는 대부분의 응용 프로그램에서 발생하지 않을 수 있지만 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , 특히 반복적으로 특히 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 과 함께 사용하는 경우에는주의가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과의 크기가 더 작아 질 수 있습니다 . 이 경우 관련 값은 &lt;code&gt;c&lt;/code&gt; 를 사용하여 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과의 크기가 더 작아 질 수 있습니다 . 이 경우 관련 값은 &lt;code&gt;c&lt;/code&gt; 를 사용하여 결합됩니다 . 두 개의 원래 키보다 큰 값이 &lt;code&gt;c&lt;/code&gt; 의 첫 번째 인수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 둘 이상의 고유 키를 동일한 새 키에 매핑 하면 결과 크기가 더 작아 질 수 있습니다 . 이 경우 원래 키 중 가장 큰 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 바이트 순서의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">세트의 크기는 &lt;code&gt;maxBound::Int&lt;/code&gt; 초과하지 않아야합니다 . 이 조건을 위반하면 감지되지 않으며 크기 제한을 초과하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">경계 쌍으로 정의 된 하위 범위의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정립 중요한 데이터 유형, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">당신이 가지고 갈 수있는 망치는 &lt;code&gt;INLINE&lt;/code&gt; 프라 그마입니다.</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">해결책은 인스턴스 별 함수를 직접 정의하여 pragma를 사용하여 너무 빨리 인라인되는 것을 방지하고 규칙을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">프로그램의 소스 파일이 모두 같은 디렉토리에있을 필요는 없습니다. &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt; 옵션은 검색 경로 (참조에 디렉토리를 추가하는 데 사용할 수있는 &lt;a href=&quot;separate_compilation#search-path&quot;&gt;검색 경로를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">소스 위치</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">특수 &lt;code&gt;family&lt;/code&gt; 은 표준 데이터 선언과 제품군을 구분합니다. 결과 종류 주석은 선택 사항이며 일반적으로 생략하면 기본값은 &lt;code&gt;Type&lt;/code&gt; 입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">특수 &lt;code&gt;family&lt;/code&gt; 는 패밀리를 표준 유형 선언과 구별합니다. 결과 종류 주석은 선택 사항이며 일반적으로 생략하면 기본값은 &lt;code&gt;Type&lt;/code&gt; 입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">특별 패키지 이름 &lt;code&gt;this&lt;/code&gt; 현재 패키지를 참조하는 데 사용할 수있는 내장된다.</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">사양은 형식 문자로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">지정된 파일은 C 프로그램, 컴파일 된 Haskell 파일 및 C 헤더에 포함됩니다. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; 가 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">대한 지정자 &lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; 및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 는 다른 유형의 의미 별개입니다. 음의 시간 차이에 대한 지정자는 일반적으로 음수입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 보다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 을 생각하십시오 ).</target>
        </trans-unit>
        <trans-unit id="509d7b73e79bd7157914844fa1c9246fd5e8d212" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; 및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 의 지정 자는 다른 유형과 의미 상 구분됩니다. 음의 시간차에 대한 지정자는 일반적으로 음수입니다 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 보다는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 을 생각하십시오 ).</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(blah1)&lt;/code&gt; 함수를 참조 할 수 &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; 나중에 선언 그룹의 일부, 따라서 보이지 마찬가지로 인 &lt;code&gt;$(blah1)&lt;/code&gt; 의 정의를 참조 할 수없는 &lt;code&gt;h&lt;/code&gt; 그와 같은 선언 그룹의 일부이기 때문에 ( &lt;code&gt;$(blah1)&lt;/code&gt; . 그러나, 스플 라이스 &lt;code&gt;$(blah1)&lt;/code&gt; 정의 볼 수 &lt;code&gt;f&lt;/code&gt; (그 직전의 선언 기이기 때문에).</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(blah2)&lt;/code&gt; 는 스플 라이스 &lt;code&gt;$(th2 ...)&lt;/code&gt; 와 동일한 정의를 볼 수 있습니다 (그러나 바인딩은 생성 &lt;em&gt;하지 않습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">splice &lt;code&gt;$(th1 ...)&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 정의를 볼 수 있습니다. splice는 최상위 수준이므로 이전 선언 그룹의 모든 정의가 표시됩니다 (즉, 모듈의 모든 정의는 포함하지만 다음을 포함하지는 않음). 스플 라이스 자체).</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">스플 라이스 &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;D&lt;/code&gt; 를 참조 &lt;em&gt;할 수 없습니다&lt;/em&gt; -동일한 선언 그룹에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">splice &lt;code&gt;$(th2 ...)&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 정의 , &lt;code&gt;$(th1 ...)&lt;/code&gt; 에 의해 생성 된 모든 바인딩 , &lt;code&gt;h&lt;/code&gt; 의 정의 및 &lt;code&gt;[qq|blah|]&lt;/code&gt; 의해 생성 된 모든 바인딩 ( 이것은 모두 이전에 있습니다) 선언 그룹).</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">실행할 스플 라이스</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">스택은 기본적으로 힙 프로필에서 계산되지 않습니다. RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">스택 추적은 종종 &lt;code&gt;GHC.List.CAF&lt;/code&gt; 와 같은 정보가없는 것으로 시작될 수 있습니다 . 이것은 GHC 옵티마이 저의 인공물로, 프로파일 링 시스템이 비용 센터 &quot;CAF&quot;에 할당하는 최상위 수준으로 예외를 발생시킵니다. 그러나 &lt;code&gt;+RTS -xc&lt;/code&gt; 는 현재 스택 만 인쇄하는 것이 아니라 CAF가 평가 될 때 스택을 더 깊게보고보고하며 CAF가 아닌 스택이 발견 될 때까지 추가 스택을보고 할 수 있습니다. 위의 예에서 다음 스택 ( &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 후 )에는 프로그램이 &lt;code&gt;head []&lt;/code&gt; 를 평가할 때 수행 한 작업에 대한 많은 정보가 들어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">스택 오버플로 메시지</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">독립형 구문은 일반 &lt;code&gt;deriving&lt;/code&gt; 절이 일반화 되는 것과 정확히 동일한 방식으로 새 유형에 대해 일반화됩니다 (newtypes에 대한 &lt;a href=&quot;#newtype-deriving&quot;&gt;일반화 된 파생 인스턴스&lt;/a&gt; ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">독립형 파생 선언은 데이터 유형 선언과 동일한 모듈에있을 필요는 없습니다. (그러나 고아 인스턴스 ( &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan 모듈 및 인스턴스 선언&lt;/a&gt; ) 의 위험에주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="704c3d94002789a8f5e8c50c778edbf18c8986c7" translate="yes" xml:space="preserve">
          <source>The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">독립형 종류 서명은 &lt;code&gt;T&lt;/code&gt; 에 대한 다형성 종류를 지정하며이 서명은 재귀 적 종류를 포함하여 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 호출에 사용 됩니다. 특히,의 재귀 사용 &lt;code&gt;T&lt;/code&gt; 는 종류에있다 &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">표준 C99 &lt;code&gt;fenv.h&lt;/code&gt; 헤더는 부동 소수점 장치의 상태를 검사하고 수정하는 작업을 제공합니다. 특히 부동 소수점 연산에 사용되는 반올림 모드를 변경하고 예외 플래그를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">표준 CPUTime 라이브러리.</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">표준 IO 라이브러리</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS X에 대한 표준 가정은 동적 라이브러리가 빌드시 라이브러리 파일의 전체 설치 경로 인&amp;ldquo;설치 이름&amp;rdquo;으로 스탬핑된다는 것입니다. 이후에 링크 된 라이브러리 또는 실행 파일 (아직 설치되지 않은 경우에도)은 해당 경로를 런타임 검색 위치로 선택합니다. ghc로 직접 컴파일 할 때 설치 이름은 기본적으로 빌드 위치로 설정됩니다. &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; 옵션 ( &lt;code&gt;-install_name&lt;/code&gt; 을 Apple 링커로 전달)으로이를 대체 할 수 있습니다 . Cabal이 당신을 위해 이것을합니다. 동적 라이브러리의 설치 이름을 최종 설치 위치의 절대 경로로 자동 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">표준 기본 규칙은 다음과 같이 확장됩니다. 해결되지 않은 모든 제약 조건에 표준 클래스 &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 이 포함 된 경우 기본값이 적용됩니다 . 적어도 하나는 숫자 클래스 &lt;em&gt;또는 &lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">표준 함수 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; 은 안정 포인터 테이블을 잠그고 주어진 안정 포인터를 해제 한 다음 안정 포인터 테이블을 다시 잠금 해제합니다. 많은 안정적인 포인터를 한 번에 해제 할 때 일반적으로 테이블을 한 번만 잠 그거나 잠금 해제하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">텍스트 인코딩 및 디코딩을위한 표준 기능은 엄격합니다. 즉, 유효하지 않은 입력에서 예외를 발생시킵니다. 이것은 실제 입력에서 도움이되지 않기 때문에 유효하지 않은 입력을 처리하기 위해 사용자 정의 핸들러를 허용하는 대체 함수가 존재합니다. 이 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; 핸들러는 일반적인 Haskell 함수입니다. 이 모듈에서 사전 제공 함수 중 하나를 사용하거나 사용자 정의 핸들러를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; 와 함께 사용되는 표준 관용구 는 연속을 명명하는 람다 표현을 제공하는 것입니다. 그런 다음 중첩 된 계산 내에 많은 계층이 있어도 해당 범위 내에서 명명 된 연속을 호출하면 계산에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">표준 라이브러리는이 장치 유형을 직접 지원하지 않지만 사용자 구현 에서는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 를 제외하고 &lt;code&gt;'\0'&lt;/code&gt; 문자로 구분 된 순서로 디렉토리에 파일 이름 목록을 제공해야합니다 . 및 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 이름. &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 . 검색 작업은 디렉토리에서 지원되지 않습니다 (0 위치 이외).</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수를 설정하여 일부 시스템에서 재정의 할 수있는 시스템 로더의 표준 라이브러리 검색 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">실행 스택의 상태</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">명령문 &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; 는 &quot; &lt;code&gt;IO&lt;/code&gt; 모나드 에서 실행 &lt;code&gt;return 42&lt;/code&gt; 를 실행 하고 결과를 &lt;code&gt;x&lt;/code&gt; 에 바인딩합니다 &quot;를 의미합니다. 그런 다음 &lt;code&gt;x&lt;/code&gt; 를 사용 하여 예를 들어 위에서와 같이 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">명령문이 바인딩이 아니거나 정확히 하나의 변수를 바인딩 하는 모나드 바인딩 ( &lt;code&gt;p &amp;lt;- e&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">저장된 값은 느리게 계산 될 큰 가상 데이터 구조를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">예외가 발생한 지점에서 처리 된 지점으로 바인딩 된 함수를 무시하여 예외를 throw 할 수있는 계산을 결합하는 전략입니다.</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 모나드 변환기는 주어진 모나드에 출력 (카운트 또는 문자열 출력과 같은) 컬렉션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 모나드 변환기는 주어진 모나드에 출력 (카운트 또는 문자열 출력과 같은) 컬렉션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형을 사용하려면 전체 문자열이 한 번에 메모리에 맞아야합니다. 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 작은 메모리 공간을 사용하여 메모리보다 큰 문자열을 스트리밍 할 수 있습니다. 대부분의 경우 청크 스트리밍의 오버 헤드로 인해 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형이 엄격한 대응 유형보다 느리지 만 항상 그런 것은 아닙니다. 때로는 하나의 모듈에서 함수의 시간 복잡도는 내부 구조가 다르기 때문에 다른 모듈과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">엄격한 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 모나드. &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 의 모나드는 파괴적인 업데이트가 가능하지만 (IO는 달리) 이스케이프 가능한 것입니다. 유형의 계산 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 복귀 형 값 , 및 &quot;스레드&quot;로 실행 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;s&lt;/code&gt; 매개 변수 중 하나입니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">엄격 성 분석기는 함수의 인수와 변수를 '엄격하게'처리 할 수있는 시점을 파악합니다 (즉, 함수에서 항상 특정 시점에서 평가됨). 이를 통해 GHC는 지연 인수에 적용될 때 프로그램의 의미를 변경함에 따라 적용되지 않는 언 박싱과 같은 특정 최적화를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">사용자가 필드를 소스 코드로 작성했을 때의 엄격함. 예를 들어 다음 데이터 형식에서</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">GHC가 컴파일하는 동안 필드를 유추하는 엄격 성. &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 의 9 가지 조합이 있지만 GHC가 결정하는 엄격 성은 궁극적으로 게 으르거나 엄격하거나 압축되지 않은 것 중 하나입니다. GHC가 결정하는 것은 사용자가 소스 코드에 작성하는 내용과 GHC 플래그의 영향을받습니다. 예를 들어,이 데이터 유형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">컴파일러가 선택기에 대해 유추 한 엄격 성</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">이 모듈의 문자열 기능은 화살표 키 및 기능 키와 같은 사용자 입력에 해당하는 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">패키지 이름 뒤의 괄호 안에있는 문자열은 설치된 패키지 ID입니다. 일반적으로 패키지 이름과 버전으로 시작하고 컴파일 된 패키지에서 파생 된 해시 문자열로 끝납니다. 패키지 간의 종속성은 패키지 및 버전이 아니라 설치된 패키지 ID로 표시됩니다. 예를 들어, &lt;code&gt;haskell98&lt;/code&gt; 패키지 의 종속성을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">유 방향 그래프의 강하게 연결된 구성 요소는 위상 적으로 역순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">유 방향 그래프의 강하게 연결된 구성 요소는 위상 적으로 역순으로 정렬됩니다. 이 함수는 각 노드에 대한 모든 정보가 유지된다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; 와 동일합니다. 이 인터페이스는 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 결과에 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 를 적용 할 때 사용 되므로 종속성 정보를 잃고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">역 토폴로지 순서로 그래프의 강력하게 연결된 구성 요소.</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">&lt;code&gt;n+k&lt;/code&gt; 패턴 에서 빼기 연산과 같거나 큰 검정 은 범위에있는 &lt;code&gt;(-)&lt;/code&gt; 및 &lt;code&gt;(&amp;gt;=)&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">입력이 충분하지 않아서 디코딩 할 수없는 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 접미 부입니다 .</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 액션 모음의 합계 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; 을.</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일련의 액션 모음의 합계 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을.</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을 일반화하는 조치 콜렉션의 합계입니다 . 기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 을 일반화하는 조치 콜렉션의 합계입니다 . 기본 4.8.0.0로, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 은 그냥 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 에 전문 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">수퍼 클래스 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">GHC에서 정의한 기호는 다음과 같습니다. 로컬 GHC 설치에 의해 정의 된 기호를 확인하려면 다음 트릭이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 허용되는 구문은 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 대한 구문과 동일합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 허용되는 구문은 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 대한 구문과 동일합니다 합니다.</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">패턴 동의어의 구문과 의미는 다음 하위 섹션에서 자세히 설명합니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;논문에&lt;/a&gt; 더 많은 세부 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">최소한의 완전한 정의를위한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">prompt &lt;code&gt;*module&lt;/code&gt; 의 구문은 프롬프트 에서 입력 한 표현식의 범위에 기여하는 ⟨module⟩의 전체 최상위 범위임을 나타냅니다. &lt;code&gt;*&lt;/code&gt; 없이 모듈 내보내기 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">문법은</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">구문은 (a) 키워드 &lt;code&gt;deriving&lt;/code&gt; 및 (b) 위치가 없다는 점을 제외하고 일반적인 인스턴스 선언과 동일 합니다 &lt;code&gt;where&lt;/code&gt; 부분 .</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">대안의 본문이 표현식이 아닌 명령이라는 점을 제외하면 구문은 &lt;code&gt;case&lt;/code&gt; 표현식과 동일합니다. 번역은 &lt;code&gt;if&lt;/code&gt; 의 번역과 유사 합니다 명령 합니다.</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">표현식에 대한 코스트 센터 주석의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCi 프롬프트에서 승인 된 명령문의 구문은 Haskell &lt;code&gt;do&lt;/code&gt; 표현식 의 명령문 구문과 정확히 동일 합니다. 그러나 여기에 모나드 과부하가 없습니다. 프롬프트에서 입력 한 명령문은 &lt;code&gt;IO&lt;/code&gt; 에 있어야합니다. 모나드 .</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">값의 구문은 필드에 따라 다릅니다. 다양한 필드 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">아래 표는 각 유형의 패턴 동의어를 사용할 수있는 위치를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해 설명 된 전술합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 작업에 대해서도 설명 합니다. 또한 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">템플릿 파일 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">하위 계산이 종료되면 (보통 또는 예외를 통해) 임시 저장소가 해제되므로이 함수가 반환 된 후에 임시 저장소에 대한 포인터를 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">&amp;ldquo;미등록&amp;rdquo;이라는 용어는 실제로&amp;ldquo;바닐라 C를 통한 컴파일&amp;rdquo;을 의미하며, GHC가 일반적으로 프로그램 속도를 높이기 위해 사용하는 플랫폼 별 트릭을 비활성화합니다. 등록되지 않은 컴파일시 GHC는 gcc를 통해 컴파일 된 C 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">용어 레벨 구문은 비슷합니다. 선행 및 선행 막대 ( &lt;code&gt;|&lt;/code&gt; )는 대체 방법을 나타냅니다. 위에 표시된 유형의 두 가지 용어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">파일의 세 번째이자 마지막 섹션은 비용 중심 스택별로 프로파일 분류를 제공합니다. 이것은 대략 프로그램의 콜 트리 프로파일입니다. 위의 예에서 비용이 많이 드는 &lt;code&gt;fib&lt;/code&gt; 호출 은 &lt;code&gt;main&lt;/code&gt; 에서 온 것이 분명합니다. .</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">세 번째 사례 선언은 적용 조건을 준수하지 않습니다. 실제로 (정말 이상한) 정의 :</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">세 번째 종류의 인스턴스는 모든 &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; 마다 존재 하며 두 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">와일드 카드의 세 번째 종류는 &lt;em&gt;추가 제약 와일드 카드입니다.&lt;/em&gt; 입니다. 추가 제약 조건 와일드 카드가 있으면 형식 검사 중에 임의의 수의 추가 제약 조건이 유추 될 수 있으며 형식 서명에 추가됩니다. 아래 예에서 추가 제약 조건 와일드 카드는 세 가지 추가 제약 조건을 유추하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">스레드가 차단되어 &lt;code&gt;MVar&lt;/code&gt; 만에 다른 참조가없는 &lt;code&gt;MVar&lt;/code&gt; 그 어느 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">스레드가 STM 트랜잭션 재 시도를 기다리고 있지만 관련된 &lt;code&gt;TVar&lt;/code&gt; 에 대한 다른 참조가 없으므로 계속 진행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">외래 호출을하는 스레드는 &lt;code&gt;pthread_kill()&lt;/code&gt; 사용하여 &lt;code&gt;SIGPIPE&lt;/code&gt; 신호를 보냅니다 . 이는 일반적으로 블로킹 시스템 호출이 &lt;code&gt;EINTR&lt;/code&gt; 과 함께 리턴되도록하기에 충분합니다 (기본적으로 GHC는 &lt;code&gt;SIGPIPE&lt;/code&gt; 에 대해 빈 신호 핸들러를 설치 하여 프로세스를 즉시 종료하는 기본 동작을 대체합니다).</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">스레드 런타임 시스템은 다음과 같은 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">프로그램의 특정 부분에 의해 발생 된 시간과 할당은 두 가지 방식으로 표시됩니다 :&amp;ldquo;이 개별&amp;rdquo;,이 코스트 센터 스택만으로 커버되는 코드에 의해 발생 된 비용,&amp;ldquo;상속 된&amp;rdquo;, 모두에 의해 발생 된 비용 포함 이 노드의 아이</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">GC 자체에서 경과 된 시간</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">GC 이전의 동기화 중 경과 된 시간</target>
        </trans-unit>
        <trans-unit id="4b330c6f47b52569d23f62fae825fc0e09a81ec0" translate="yes" xml:space="preserve">
          <source>The time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">시간 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="1637c3729549ceeb82c37601b6dec6b827e71006" translate="yes" xml:space="preserve">
          <source>The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</source>
          <target state="translated">&lt;a href=&quot;profiling#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 로 활성화 된 시간 프로파일 링 모드 도 이벤트 로그에 샘플 이벤트를 내 보냅니다. 프로파일 링이 시작될 때 틱 간격이 이벤트 로그로 내 보내진 다음 각 틱에서 현재 비용 센터 스택이 내보내집니다. 이를 통해 사용자는 프로그램 실행에 대한 대략적인 추적을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">주어진 값을 사용하여 입력을 구문 분석 할 수없는 경우 시간 값 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="806aa42ce85483bc45bf5f50020217f50c8cf737" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">시간 값 또는 주어진 형식을 사용하여 입력을 구문 분석 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">시간 값.</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">전체 실행에서 프로그램이 할당 한 총 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">수행 된 총 가비지 수집 수입니다.</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">프로그램 실행의 총 벽 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO가 실행될 때 트랜잭션에 일관성없는 메모리보기가있을 수 있습니다. 트랜잭션이 구현되는 방식으로 인해 프로그램 전체에서 사실로 예상되는 변형은 트랜잭션 내에서 사실이 아닐 수 있습니다. 일반적으로 이것은 프로그래머에게는 보이지 않지만 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 를 사용 하면 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO가 실행될 때 트랜잭션에 일관성없는 메모리보기가있을 수 있습니다. 트랜잭션이 구현되는 방식으로 인해 프로그램 전체에서 사실로 예상되는 변형은 트랜잭션 내에서 사실이 아닐 수 있습니다. 일반적으로 이것은 프로그래머에게는 보이지 않지만 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 를 사용 하면 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">번역은 간단한 비 재귀 바인딩뿐만 아니라 재귀 및 다형성 바인딩에 의미있는 뱅 패턴을 만들기 위해 신중하게 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">이러한 형식의 변환에는 &lt;code&gt;loop&lt;/code&gt; &lt;code&gt;ArrowLoop&lt;/code&gt; 사용 되므로 관련 화살표는 ArrowLoop 클래스에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">모나드를 동등한 모나드에 매핑하는 사소한 모나드 변환기.</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">고아의 문제점은 모듈의 인터페이스가 다른 용도로 사용되는지 여부에 관계없이 GHC가 인스턴스 또는 규칙이 역할을 수행하는 경우를 대비하여 모든 고아 모듈의 인터페이스 파일을 사전에 읽어야한다는 것입니다. 자세한 내용은 &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;고아 모듈 및 인스턴스 선언&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">후자는 유형 변수를 범위로 가져올 수 있다는 점을 제외하고는 두 가지를 동일하게 취급합니다 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;어휘 범위 변수 유형&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">두 생성자에는 다음과 같은 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">두 함수 &lt;code&gt;comp1&lt;/code&gt; 및 &lt;code&gt;comp2&lt;/code&gt; 동일한 의미를 가지고 있지만, &lt;code&gt;comp1&lt;/code&gt; 적용될 때 인라인한다 &lt;em&gt;두&lt;/em&gt; 인수하면서 &lt;code&gt;comp2&lt;/code&gt; 필요 &lt;em&gt;세&lt;/em&gt; . 당신이 말하면 이것은 큰 차이를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">두 옵션 세트는 다음과 같이 초기화됩니다. 먼저 &lt;a href=&quot;#ghci-dot-files&quot;&gt;.ghci 및 .haskeline 파일에&lt;/a&gt; 설명 된대로 두 옵션 세트가 모두 초기화됩니다 . 그런 다음 대화식 옵션이 다음과 같이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">인수없이 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 두 옵션 세트를 검사 할 수 있습니다 . 예를 들어, 깨끗한 GHCi 세션에서 다음과 같은 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가 될 수있는 값의 종류이다 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수있는 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 의, 그리고 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 유형 은 외국어로 유지되는 오브젝트에 대한 참조를 나타냅니다. 즉, 일반적으로 Haskell 스토리지 관리자가 관리하는 데이터 구조의 일부가 아닙니다. &lt;code&gt;Ptr a&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 과 vanilla 메모리 참조 사이의 본질적인 차이점 은 전자가 &lt;em&gt;finalizer&lt;/em&gt; 와 연관 될 수 있다는 것 입니다. 종료자는 Haskell 스토리지 관리자가 Haskell 힙 및 스택 내에 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 가리키는 참조가 더 이상 없음을 감지 할 때 호출되는 루틴입니다 . 일반적으로 종료자는 외부 오브젝트에 의해 바인드 된 자원을 해제하는 외국어로 루틴을 호출합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 중 어느 하나가 될 수있는 값의 종류이다 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수있는 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 의, 그리고 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 유형 에는 역할 표현에 매개 변수가 있으며 일반적으로 가장 일반적입니다. &lt;code&gt;Simple Age&lt;/code&gt; 는 &lt;code&gt;Simple Int&lt;/code&gt; 와 동일한 표현을 갖습니다 . 반면 &lt;code&gt;Complex&lt;/code&gt; 유형 은 &lt;code&gt;Complex Age&lt;/code&gt; 및 &lt;code&gt;Complex Int&lt;/code&gt; 가 동일 &lt;em&gt;하지&lt;/em&gt; 있습니다. 마지막으로, &lt;code&gt;Age&lt;/code&gt; 와 &lt;code&gt;Bool&lt;/code&gt; 은 관련이 없지만 &lt;code&gt;Phant Age&lt;/code&gt; 와 &lt;code&gt;Phant Bool&lt;/code&gt; 은 동일한 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">유형 &lt;code&gt;StreamPermParser s st a&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 함수에 의해 변환 될 때 &lt;code&gt;s&lt;/code&gt; 스트림을 사용자 상태 &lt;code&gt;st&lt;/code&gt; 로 구문 분석 하고 성공시 유형 &lt;code&gt;a&lt;/code&gt; 의 값을 리턴하는 순열 구문 분석기를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 종종 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . 그러나 이것이 필수적인 것은 아니며 포인터에 액세스하기위한 고유 한 작업을 제공 할 수 있습니다. 예를 들어 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정하기 위해 작은 외부 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6120b118bdba0e4c010f34fbf9eb9b4980f33ce0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스 인 경우가 많습니다 . 그러나 이것은 필수적인 것은 아니며 포인터에 액세스하기위한 자체 작업을 제공 할 수 있습니다. 예를 들어 작은 외부 함수를 작성하여 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;a&lt;/code&gt; 는 종종 마샬링 작업을 제공하는 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . 그러나 이것이 필수적인 것은 아니며 포인터에 액세스하기위한 고유 한 작업을 제공 할 수 있습니다. 예를 들어 C &lt;code&gt;struct&lt;/code&gt; 의 필드를 가져 오거나 설정하기 위해 작은 외부 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">타입 &lt;code&gt;t&lt;/code&gt; 는 임의 타입이다.</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">유형 체커는 때때로 오류 메시지에 유형 환경의 단편을 표시하지만이 플래그에 의해 설정된 최대 수까지만 표시됩니다. &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 로 끄면 무제한으로 사용할 수 있습니다. 구문 적으로 최상위 레벨 바인딩도 일반적으로 제외되지만 (여러 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 수 있으므로) -fno-max-relevant-bindings도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b4f3436c445b81b9b8c7c9be8963efa0b16fdd8a" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</source>
          <target state="translated">유형 검사기는 때때로 오류 메시지에 유형 환경의 일부를 표시하지만이 플래그로 설정된 최대 수까지만 표시합니다. &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 로 끄면 무제한이 제공됩니다. 구문 적으로 최상위 바인딩도 일반적으로 제외되지만 (수많은 수 있기 때문에) &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; 는 해제 된 형식을 안전하지 않게 강제 변환 할 수있는 형식입니다. 보다 구체적으로, 리프트 타입 &lt;code&gt;t&lt;/code&gt; 및 값 &lt;code&gt;x :: t&lt;/code&gt; 경우 &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">형식 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">타입 생성자 &lt;code&gt;Proxy#&lt;/code&gt; 는 어떤 타입 변수를 감시하는데 사용됩니다. 모델링 유형 응용 프로그램과 같은 작업을 수행하기 위해 프록시 값을 전달하려고 할 때 사용됩니다. &lt;code&gt;Proxy#&lt;/code&gt; 그것은 또한 다형성 종류를 가지고뿐만 아니라 언 박싱, 전부 무료되고, 더 런타임 표현이 없습니다.</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">타입 생성자 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 은 모두 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">타입 기능 &lt;code&gt;Item&lt;/code&gt; 은 구조체 &lt;code&gt;l&lt;/code&gt; 의 항목 유형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">의 유형 &lt;code&gt;SPECIALIZE&lt;/code&gt; 프라그 원본 함수의 형태 이하 다형성 임의의 타입 일 수있다. 구체적으로, 원래 함수가 &lt;code&gt;f&lt;/code&gt; 이면 pragma</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">유형에는 물론 클래스 컨텍스트가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 의 유형 골치 거리이지만 운영상리스트 폴드의 간단한 일반화입니다.</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">클래스 유형 변수 (이 경우 &lt;code&gt;a&lt;/code&gt; ) 만 제한하는 제약 조건 &lt;code&gt;Eq a&lt;/code&gt; 가 포함되어 있기 때문에 Haskell 98에서는 &lt;code&gt;elem&lt;/code&gt; 유형이 유효하지 않습니다. 이 경우 &lt;code&gt;a&lt;/code&gt; ). 보다 정확하게는 클래스 메소드 시그니처의 제한 조건이 거부되면</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">에 언급 된 자유 변수의 유형 &lt;code&gt;case&lt;/code&gt; 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에 인덱스가 있고 &lt;code&gt;e&lt;/code&gt; 에 요소가있는 불변의 비 엄격 (박스형) 배열 유형 .</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">비어 있지 않은 스트림의 유형</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 메소드 의 유형 은 &lt;code&gt;[a]&lt;/code&gt; 이며 이는 기본 메소드의 유형이기도합니다. &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 확장을 사용하여이 제한을 해제하고 다른 유형을 기본 메소드에 제공 할 수 있습니다 . 당신이 클래스에 열거의 일반적인 구현을 작성한 경우 예를 들어, &lt;code&gt;GEnum&lt;/code&gt; 방법으로 &lt;code&gt;genum&lt;/code&gt; 의 측면에서 &lt;code&gt;GHC.Generics&lt;/code&gt; , 당신은 기본 방법을 지정할 수 있습니다 일반적인 구현하는 용도 :</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">일반적으로 인수 유형은 &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; 에 표시된 것처럼 필요한 유형보다 일반적 일 수 있습니다 . ( &lt;code&gt;reverse&lt;/code&gt; 필요하지 않습니다 &lt;code&gt;Ord&lt;/code&gt; 제약 조건을.)</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">전체 &lt;code&gt;case&lt;/code&gt; 표현식 의 유형은 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">업데이트되는 식의 유형은 유추되지 않으며 제약 조건 해결이 수행되지 않으므로 다음은 모호한 것으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">객체의 유형은 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 의 인스턴스 여야하며 , 이는 단일 유형의 객체 만 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 으로 변환 될 수 있습니다 . 다형성 객체를 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 으로 변환하려면 단형 유형 서명을 지정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">모나드 &lt;code&gt;m&lt;/code&gt; 에 대해 상태 &lt;code&gt;u&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 스트림에서 작동하는 어휘 파서를 보유하는 레코드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">scrutinee의 유형은 엄격해야합니다.</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">유형 매개 변수 &lt;code&gt;c_m&lt;/code&gt; 은 &lt;code&gt;T1&lt;/code&gt; ~ &lt;code&gt;Tk&lt;/code&gt; 의 각 유형 변수에서 한 번 발생합니다 . 이 조건이 충족되지 않은 수업을 상상해보십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">type 매개 변수는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 의 인스턴스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">유형 매개 변수는 모두 유형 변수 여야하며 그 중 일부 (모두는 아님)가 클래스 매개 변수 일 수 있습니다. 각 클래스 매개 변수는 연관된 유형 당 최대 한 번만 사용할 수 있지만 일부 클래스는 생략 될 수 있으며 클래스 헤드 이외의 순서 일 수 있습니다. 따라서 다음과 같이 고안된 예가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">이 쌍의 유형 패턴은 &lt;code&gt;x&lt;/code&gt; 가 목록의 무한 중첩으로 대체되는 경우와 같습니다 . 이러한 유형의 사운드에는 이러한 인스턴스를 거부해야합니다.</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 의 유형 서명 은 명시 적 &lt;code&gt;forall&lt;/code&gt; ( &lt;a href=&quot;#decl-type-sigs&quot;&gt;선언 유형 서명&lt;/a&gt; ) 때문에 유형 변수 &lt;code&gt;a&lt;/code&gt; 를 범위로 가져옵니다 . a로 결합 된 형태 변수 &lt;code&gt;forall&lt;/code&gt; 첨부 선언 값의 전체 범위에 걸쳐 정의. 이 예에서, 유형 변수 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;ys&lt;/code&gt; 에 대한 유형 서명을 포함하여 &lt;code&gt;f&lt;/code&gt; 의 전체 정의에 걸쳐 있습니다. Haskell 98에서는 &lt;code&gt;ys&lt;/code&gt; 에 대한 유형을 선언 할 수 없습니다 . 범위가 지정된 유형 변수의 주요 이점은 그렇게 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">형식 클래스의 기본 메서드에 대한 형식 서명은 해당 기본 메서드의 형식 서명과 동일한 형식을 가져야합니다. 그렇지 않으면 타입 체커는 해당 클래스의 정의를 거부합니다. &quot;같은 양식을 취한다&quot;는 것은 기본 유형 서명이 문맥상에서 만 기본 유형 서명과 달라야 함을 의미합니다. 따라서 메소드 &lt;code&gt;bar&lt;/code&gt; 이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">인스턴스 선언의 타입 시그니처는 클래스 선언의 인스턴스 시그니처보다 인스턴스 이름보다 다형성이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">형식 서명에 결과 형식에 표시되지 않는 수량화 된 형식 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; 의 형식 서명은 정확성이 입증되지 않은 추측에 달려 있음을 사용자에게 알려줍니다. 이 기능을 사용하는 경우 사용자는 다음과 같은 의존성을 인정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">각 생성자의 형식 서명은 독립적이며 평상시처럼 암시 적으로 보편적으로 정량화됩니다. 특히, &quot; &lt;code&gt;data T a where&lt;/code&gt; &quot;헤더 의 타입 변수 는 범위가 없으며, 다른 생성자들은 보편적으로 정량화 된 타입 변수가 다를 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">크기와 크기에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">유형 변수 &lt;code&gt;a&lt;/code&gt; 는 다른 제약 조건에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">여기에 사용 된 유형 변수 &lt;code&gt;e&lt;/code&gt; 는 요소 유형을 나타내고 &lt;code&gt;ce&lt;/code&gt; 는 컨테이너 자체의 유형입니다. 이 프레임 워크 내에서,리스트 또는 특성 함수 (둘 다 동등 유형의 콜렉션을 나타내는 데 사용될 수 있음), 비트 세트 (문자 콜렉션을 나타내는 데 사용할 수있는) 또는 해시에 대해이 클래스의 인스턴스를 정의 할 수 있습니다. 테이블 (해시 함수가있는 요소의 컬렉션을 나타내는 데 사용할 수 있음) 표준 구현 세부 사항을 생략하면 다음과 같은 선언으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">Type 변수는 단일 구문 보이는 최 의해 정량화 &lt;code&gt;forall&lt;/code&gt; 타입의 서명. 예를 들어 GHC는 다음 예를 모두 거부합니다.</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">유형 변수 (제공된 경우)는 명시 적으로 분류 될 수 있으므로 다음 과 같이 &lt;code&gt;Foo&lt;/code&gt; 의 헤더를 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">타입 변수 &lt;code&gt;vk+1...vn&lt;/code&gt; 은 타입 &lt;code&gt;t&lt;/code&gt; , &lt;code&gt;s1..sk&lt;/code&gt; 또는 &lt;code&gt;t1..tj&lt;/code&gt; 에서 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;instance&lt;/code&gt; 선언 의 헤드에있는 유형 변수 는 &lt;code&gt;where&lt;/code&gt; 부분에 정의 된 메소드에 대한 범위 입니다. &lt;code&gt;instance&lt;/code&gt; 선언 에서 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 허용되지만 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 필요하지는 않습니다 . &lt;a href=&quot;#explicit-foralls&quot;&gt;명시 적 범용 정량화 (forall)를&lt;/a&gt; 참조하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f03bbab3fd03c0f04b9e0c0fedb642fb00b2844" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">외부 선언 형식의 형식 변수 는 다음 예제와 같이 &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 명시 적 &lt;code&gt;forall&lt;/code&gt; 로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">유형 패밀리 방정식의 오른쪽에있는 유형 변수는 평소와 같이 왼쪽에 명시 적으로 바인딩되어야합니다. 그러나 오른쪽에는 암시 적으로 바인딩 된 종류 변수를 언급 할 수 있으므로 &lt;em&gt;종류&lt;/em&gt; 변수에는 이 제한이 완화됩니다 . 예를 들어 다음은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">유형 변수 : &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 의 유형 수준에 해당 합니다 .</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">안전한 유형의 캐스트 작업</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 유형 , &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 클래스 및 Word32 및 Float와 Word64 및 Double 사이의 캐스트.</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; 는 다시 한 번 입력 레벨된다 프록시를, 단지의 여러 변종 만드는 데 사용 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">유형의 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 및 클래스 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">유형만으로는 이러한 법률이 적용되지 않으므로 직접 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">구체화 구멍 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; 의 추가 구멍 유형은 출력에 표시됩니다. 예를 들어 foldl1 (_ :: a-&amp;gt; a-&amp;gt; a) 는 구멍 &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; 대한 구체화입니다 . 이 플래그가 꺼져 있으면 출력에 &lt;code&gt;foldl1 _&lt;/code&gt; 만 표시되며 -XScopedTypeVariables 가 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; 구멍을 직접 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">박스형 튜플의 일반적인 사용은 단순히 여러 값을 반환하여 여러 결과를 &lt;code&gt;case&lt;/code&gt; 표현식 과 바인딩하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">결합 조작을 사용하여 맵 목록을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산을 사용하여 맵 목록의 결합 (( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="d32217b38bffdaa9ca587e9d6a40f750e6e5bfb9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산이있는 맵 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산을 사용하여 맵 목록의 결합 (( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="b99c2dfae5341557cba637c4f3ef989142689dd9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">결합 연산이있는 맵 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">지도 목록의 합집합</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="06da55697aaeea01f68121fc5dda49aec58e2fa9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5359b26f8252c95c2fa3287a62d5ed9a07ab46e7" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">지도 목록의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">세트리스트의 결합.</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Foldable 구조에서 집합의 합집합 : ( &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">이 그룹의 고유 한 숫자 ID (gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">단위 유형 &lt;code&gt;()&lt;/code&gt; 및 목록 유형 &lt;code&gt;[]&lt;/code&gt; 은 유형 기본값을 지정할 때 시도되는 표준 유형 목록의 시작 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">사용자가 소스 코드에서 필드를 작성했을 때의 압축 풀기 예를 들어 다음 데이터 형식에서</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">이것의 결과는 외래 호출에서 차단 된 Haskell 스레드가있는 경우 호출이 리턴 될 때까지 &lt;code&gt;hs_exit()&lt;/code&gt; 가 정지 (또는 통화 중 대기) 될 수 있다는 것입니다. 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; 호출 할 때 시스템에 그러한 스레드가 없는지 확인하는 것이 좋습니다 . 여기에는 I / O를 수행하는 스레드가 포함됩니다. I / O는 I / O 및 플랫폼 유형에 따라 외부 호출 차단을 사용하여 구현 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">의 사용 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 컴파일 할 &lt;code&gt;Danger&lt;/code&gt; A를 사용할 수 있습니다 하스켈의 기능을 제한하는 &lt;a href=&quot;#safe-language&quot;&gt;안전 부분 집합을&lt;/a&gt; . 여기에는 &lt;code&gt;unsafePerformIO&lt;/code&gt; , Template Haskell, 순수 FFI 기능, 규칙 및 겹치는 인스턴스의 작동 제한 이 포함되지 않습니다 . &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그는 또한 모듈에서 가져올 수 제한 &lt;code&gt;Danger&lt;/code&gt; 신뢰할 수있는 것으로 간주되는 만에. 신뢰할 수있는 모듈은 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈입니다 . 여기서 GHC는 코드가 안전하다는 기계적 보증을 제공합니다. 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 가 모듈이 안전하다고 주장하는 Trustworthy로 컴파일 된 모듈.</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">의 사용 &lt;code&gt;*&lt;/code&gt; 거주 유형의 종류를 나타 내기 위해이에 의존 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 의&lt;/a&gt; 미래의 릴리스에서 기본적으로 해제 한 후 가능성이 제거됩니다 확장. 이에 대한 이유와 지원 중단 일정은 &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC 제안서 # 30에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">사용 &lt;code&gt;?x&lt;/code&gt; 바인딩에서 &lt;code&gt;?y&lt;/code&gt; 바인딩 &quot;참조&quot;않는 &lt;code&gt;?x&lt;/code&gt; 의 종류 있도록 &lt;code&gt;f&lt;/code&gt; 이고</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 사용은 매우 양식화되어 있습니다. 적절한 언어 정의를 가져오고 결과 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 에서 필요한 어휘 파서를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 사용은 매우 양식화되어 있습니다. 적절한 언어 정의를 가져오고 결과 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 에서 필요한 어휘 파서를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">비용 중심 스택의 유용성은 예제를 약간 수정하여 더 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">컴파일러 &lt;a href=&quot;#default-deriving-strategy&quot;&gt;는 기본적으로&lt;/a&gt; 컴파일러가 잘못된 &lt;a href=&quot;#deriving-stragies&quot;&gt;전략을&lt;/a&gt; 선택하는 경우 원하는 파생 전략을 선택적으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">사용자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">일반적인 출력 스트림은 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 입니다. stderr이없는 Windows GUI 응용 프로그램의 경우 출력은 Windows 디버그 콘솔로 보내집니다. 이러한 함수의 일부 구현은 출력중인 문자열을 장식하여 추적 중임을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">배열에서 지정된 인덱스의 값입니다.</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">주 릴리스 &lt;code&gt;x.y.z&lt;/code&gt; 대한 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값 ( &lt;a href=&quot;phases#c-pre-processor&quot;&gt;C 전처리 &lt;/a&gt;기에 영향을주는 옵션 참조 ) 은 정수 ⟨xyy⟩ (⟨y⟩가 한 자리 인 경우 선행 0이 추가되므로 버전 6.8.2)입니다. GHC의 경우 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">스냅 샷 릴리스 의 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값은 정수 ⟨xyy⟩입니다. 그러나이 값을 테스트하는 조건부 코드를 작성해서는 안됩니다. 인터페이스가 매일 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 값이 세분화되지 않기 때문에 테스트하는 조건 자를 사용하여 조건부로 컴파일해야합니다. &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 이 지정된 주요 릴리스와 같거나 늦 거나 같은지 여부</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">값 &lt;code&gt;seq a b&lt;/code&gt; 경우 하단 인 &lt;code&gt;a&lt;/code&gt; 아래쪽으로하고, 그렇지 않으면 동일한 &lt;code&gt;b&lt;/code&gt; . 다시 말해, 첫 번째 인수 &lt;code&gt;a&lt;/code&gt; 를 약한 머리 정규형 (WHNF)으로 평가합니다. &lt;code&gt;seq&lt;/code&gt; 는 일반적으로 불필요한 게으름을 피함으로써 성능을 향상시키기 위해 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">컴파일 / 링크시 GHC 플래그 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">변수의 유형은 다형성이 아니며 &lt;code&gt;()&lt;/code&gt; 이 아니며 &lt;code&gt;Show&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">정의의 왼쪽에있는 변수는 오른쪽의 패턴에 의해 구속됩니다. 양방향 패턴 동의어의 경우 오른쪽의 모든 변수도 왼쪽에서 발생해야합니다. 또한 와일드 카드 패턴 및보기 패턴은 허용되지 않습니다. 단방향 및 명시 적 양방향 패턴 동의어의 경우 오른쪽 패턴에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">런타임의 변형 (&amp;ldquo;way&amp;rdquo;). 가장 일반적인 값은 &lt;code&gt;rts_v&lt;/code&gt; (바닐라), &lt;code&gt;rts_thr&lt;/code&gt; (스레드 실행, 즉이 사용하여 링크 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 옵션을) 및 &lt;code&gt;rts_p&lt;/code&gt; (프로파일 런타임, 즉이 사용하여 링크 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션). 다른 변형에는 &lt;code&gt;debug&lt;/code&gt; ( &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; 를&lt;/a&gt; 사용하여 연결됨 ) 및 &lt;code&gt;dyn&lt;/code&gt; 이 포함됩니다 (RTS는 동적으로 연결됩니다 (예 : 실행 파일 자체에 정적으로 연결되는 것이 아니라 공유 라이브러리)). 예를 들어 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">다양한 통신 프로세스는 정적 포인터 테이블의 값을 참조하는 데 사용 된 키를 동의해야합니다. 그렇지 않으면 조회가 실패합니다. 동일한 프로그램 바이너리에서 시작된 프로세스 만 동일한 키 세트를 사용하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">GHC 사본의 버전 번호 는 &lt;code&gt;--version&lt;/code&gt; 플래그 와 함께 &lt;code&gt;ghc&lt;/code&gt; 를 호출하여 찾을 수 있습니다 ( &lt;a href=&quot;using#options-help&quot;&gt;자세한 옵션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">프로그램이 컴파일되었거나 해석중인 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">이 프로그램을 컴파일하는 데 사용 된 GHC 버전.</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">강력하게 연결된 구성 요소 목록의 정점</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">강력하게 연결된 구성 요소의 꼭짓점</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">연관된 패밀리 인스턴스의 오른쪽에있는 클래스 매개 변수의 가시성은 패밀리 의 매개 변수 &lt;em&gt;에만&lt;/em&gt; 의존 합니다. 예를 들어 간단한 클래스 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt; 경고 는 기본적으로 꺼져 있지만 &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 포함되어 있으며 가져온 모듈이 내 보내지 않은 것을 숨기면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5369ef220638dc82aaace3093ac85be8f6ea055a" translate="yes" xml:space="preserve">
          <source>The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</source>
          <target state="translated">경고 &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (기본적으로 해제 됨)는 전제 구문을 사용하여 &lt;code&gt;qualified&lt;/code&gt; 어노테이션이있는 가져 오기 발생에 대해보고 합니다.</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">밑줄로 시작하는 이름에는 경고가 표시되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">필드 이름이 밑줄로 시작하면 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">경고는 복제 된 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">경고는 중복 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건 을 표시합니다 . : &lt;code&gt;f&lt;/code&gt; 의 정의에 의해 사용되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">경고는 중복 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건 을 표시합니다 . &lt;code&gt;Ord a&lt;/code&gt; 제약 조건 이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b81d66b467d23d7422d611d2f4898b0e6c539b7" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">예측 가능한 행동을 얻을 수있는 방법은 사용하는 것입니다 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; 의&lt;/a&gt; 프라그 또는 &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; 에 프라그를 &lt;code&gt;f&lt;/code&gt; 그 때까지 인라인되지 않도록, &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 불 수있는 기회가 있었다. 경고 플래그 &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;경고 및 온 전성 검사 참조&lt;/a&gt; )은이 상황에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">예측 가능한 동작을 얻는 방법은 &lt;code&gt;f&lt;/code&gt; 에서 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; pragma 또는 INLINE [⟨phase⟩] pragma 를 사용하여 규칙이 발사 될 때까지 인라인되지 않도록하는 것입니다. 경고 플래그 &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;경고 및 위생 검사 참조&lt;/a&gt; )은이 상황에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">이러한 상황을 식별하는 방법 은 데이터 유형, 클래스 및 유형 동의어의 유형 변수에 &lt;em&gt;역할을&lt;/em&gt; 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">이 라이브러리의 약한 포인터는 &lt;em&gt;finalization&lt;/em&gt; 이라는 다른 접근 방식을 지원 &lt;em&gt;합니다&lt;/em&gt; . 약한 포인터가 참조하는 키가 죽으면 스토리지 관리자는 프로그래머가 지정한 종료자를 실행합니다. 예를 들어 메모 테이블의 경우 종료자는 메모 테이블에서 키 / 값 쌍을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">해결 방법은 패키지를 구성하는 .o 파일을 &lt;code&gt;base&lt;/code&gt; 패키지가 수행 하는 방식에 따라 둘 이상의 .o로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">일하는 법</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">랩퍼 및 일반 기본값</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">지퍼 : &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">인용 부호는 템플릿 Haskell 인용 부호와 겹치므로 &quot; &lt;code&gt;e&lt;/code&gt; &quot;, &quot; &lt;code&gt;t&lt;/code&gt; &quot;, &quot; &lt;code&gt;d&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;p&lt;/code&gt; &quot;는 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">따옴표는 수입 된 견적 자의 이름이어야합니다. 임의의 표현이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">그러면 &lt;code&gt;Foo_stub.h&lt;/code&gt; 는 다음과 같은 내용 을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">그런 다음 &lt;code&gt;Parser&lt;/code&gt; 는 &lt;code&gt;MonadPlus&lt;/code&gt; 의 인스턴스입니다 . 모나 딕 시퀀싱은 파서의 연결을 구현하고 &lt;code&gt;mplus&lt;/code&gt; 는 선택을 제공합니다. 구문 분석기를 사용하려면 입력 문자열에서 구성된 구문 분석기를 실행하기위한 기본 요소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">그런 다음 &lt;code&gt;bar&lt;/code&gt; 의 기본 메소드는 다음 양식을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;stdout2&lt;/code&gt; 를 사용 하여 표준 출력에 쓸 수 있지만 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; 는 그렇지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">그런 다음 적용 가능한 설탕 제거로</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">그런 다음 사용자가 작성한 변수를 내재적으로 유형 변수의 종류로 범위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 다시 컴파일 하고 추가로 &lt;code&gt;-osuf p_o&lt;/code&gt; 를 사용 하여 오브젝트 파일 이름을 다르게 지정하십시오 (여기서 일반 오브젝트 접미 부가 아닌 접미 부를 선택할 수 있습니다). GHC는 스플 라이스 표현식을 실행할 때 첫 번째 단계에서 빌드 된 객체 파일을 자동으로로드합니다. &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 빌드 하고 템플리트 Haskell을 사용할 때 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 플래그 를 생략하면 GHC에서 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">그리고 일부 수입 모듈에 &lt;code&gt;M&lt;/code&gt; , 제약 &lt;code&gt;(E a Int)&lt;/code&gt; 로 설정하여 &quot;개선&quot;해야한다 &lt;code&gt;a = T&lt;/code&gt; , &lt;em&gt;명시 적 언급이 없어도&lt;/em&gt; 의 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;M&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">그러면 &lt;code&gt;HigherEq Option&lt;/code&gt; 인스턴스 를 파생시킬 수 있습니다 . 유일한 차이점은 이제 &lt;code&gt;(==#)&lt;/code&gt; 에 대한 기본이 아닌 유형 서명 이 &lt;code&gt;Eq a&lt;/code&gt; 제약 조건을 가져온다는 것 입니다. 기본이 아닌 유형 시그니처의 제약 조건은 파생 인스턴스 컨텍스트 자체에는 나타나지 않지만 기본 유형 시그니처에서 요구하는 의무를 이행하는 데 사용될 수 있습니다. 위의 예에서 기본 유형 서명은 &lt;code&gt;Eq a&lt;/code&gt; 인스턴스를 요구했으며 기본 이 아닌 서명은 해당 요청을 충족 할 수 있었으므로 파생 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">그러면 다음과 같은 결과로 오류가 발생하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">그러면 파생 &lt;code&gt;Foo&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">그런 다음 파생 인스턴스 선언은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">그러면 파서는 얼마나 많은 &lt;code&gt;tick&lt;/code&gt; 이 실행 되는지 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">그런 다음 나머지 프로그램은 구성된 플래그 목록을 사용하여 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">그런 다음 &lt;code&gt;args.txt&lt;/code&gt; 로 &lt;code&gt;foo&lt;/code&gt; 를 호출 한 결과는 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">그런 다음 다음과 같이 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 프리미티브 위에 고유 버전의 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">있습니다 &lt;em&gt;많은&lt;/em&gt; GHC에 의해 생성 된 코드의 품질에 영향을주는 옵션. 대부분의 사람들은&amp;ldquo;빠르게 컴파일&amp;rdquo;또는&amp;ldquo;프로그램을 기름칠 번개처럼 실행하게&amp;rdquo;과 같은 일반적인 목표 만 가지고 있습니다. 다음과 같은 최적화 (또는 부족) 패키지로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 현재 Windows에서는 구현되어 있지 않으며 외부 인터프리터는 GHCi 디버거를 지원하지 않으므로 중단 점 및 단일 스테핑이 필요하지 않습니다. &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt; 와 함께 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">유형이 지정된 구멍에 대해 표시되는 컨텍스트 정보의 양을 제어하기위한 몇 가지 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">다른 프로파일 링 관련 컴파일 옵션이 있습니다. &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 와 함께&lt;/em&gt; 사용하십시오 . 프로그램의 모든 모듈에 대해 일관되게 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">여기에 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">다음 과 같은 &lt;code&gt;case&lt;/code&gt; 명령 도 있습니다</target>
        </trans-unit>
        <trans-unit id="1279203c2e0d157a8d9dad524a1fc81607cfc8e4" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt;&lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">현재 유효한 구멍 맞춤을 정렬하는 방법에는 두 가지가 있습니다. &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt; &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 로&lt;/a&gt; 정렬을 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">유효한 구멍 맞춤을 정렬하는 방법에는 현재 두 가지가 있습니다. 정렬은 &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 로 전환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">객체 코드로 컴파일하는 데는 단점이 있습니다. 예를 들어 객체 코드 모듈에서 중단 점을 설정할 수 없습니다. 해석 된 모듈에서와 같이 모든 최상위 레벨 바인딩이 아니라 오브젝트 코드 모듈의 내보내기 만 GHCi에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">제 (기존의) 키워드로 도입 이해 규정의 다섯 개 가지 새로운 형태의 모든 있습니다 &lt;code&gt;then&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">RTS 옵션을 설정하는 네 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">매개 변수 인 위치 나 재귀 호출 인 위치를 구별하지 않는 많은 데이터 유형 일반 함수가 있습니다. 데이터 유형과 생성자의 이름을 전혀 신경 쓰지 않는 많은 데이터 유형 일반 함수도 있습니다. 이러한 상황에서 일반 함수에서 고려해야 할 사례 수를 최소로 유지하기 위해 위에서 소개 한 많은 유형 생성자가 실제로는 동의어이며 더 작은 생성자 집합의 변형으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">다른 RTS 옵션으로 선택하여 생성 할 수있는 다양한 종류의 프로파일이 있습니다. 이 장의 나머지 부분에서 다양한 종류의 프로필을 설명 할 것입니다. 일부 프로파일은 프로그램을 실행 한 후 추가 도구를 사용하여 추가 처리를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 사전 정의 된 인스턴스가 없습니다. 기본적으로 범위가 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;아니지만 GHC.OverloadedLabels&lt;/a&gt; 를 가져와 범위로 가져올 수 있습니다 . &lt;code&gt;IsString&lt;/code&gt; 과 달리 &lt;code&gt;IsLabel&lt;/code&gt; 에는 특별한 기본 규칙이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="70d1d2c96409db371b4aa9bd1644711aa1fc1d7d" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 사전 정의 된 인스턴스가 없습니다. 기본적으로 범위 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;내에 있지는 않지만 GHC.OverloadedLabels&lt;/a&gt; 를 가져와 범위로 가져올 수 있습니다 . &lt;code&gt;IsString&lt;/code&gt; 과 달리 &lt;code&gt;IsLabel&lt;/code&gt; 에 대한 특별한 기본값 규칙은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">실행 가능한 스레드가 없으므로 프로그램이 교착 상태입니다. &lt;code&gt;Deadlock&lt;/code&gt; 예외은 주 스레드에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; 와의 구문 변경은 없습니다 . 소스 레벨에서 나타나는 유일한 방법 은 &lt;code&gt;Monad&lt;/code&gt; 제약 조건이 필요없는 &lt;code&gt;do&lt;/code&gt; 표현식을 가질 수 있다는 것 입니다. 예를 들어 GHCi에서 :</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">전달할 &lt;code&gt;V1 p&lt;/code&gt; 유형의 값이 없으므로 (정의되지 않음 제외) 실제로는 불가능합니다. 이 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 에 대한 인스턴스를 정의하는 것이 왜 유용한 지 묻습니다 . 빈 유형을 비어 있지 않은 유형의 인수로 사용할 수 있으며 결과 유형을 계속 인코딩 할 수 있습니다. 다소 고안된 예로, 빈 유형은 아니지만 빈 목록 만 포함하는 &lt;code&gt;[Empty]&lt;/code&gt; 를 고려 하십시오. &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 보장하지만 우리는 같은 유형의 일반 함수를 호출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">실제로 모든 종류의 예외를 잡아야하는 경우가 있습니다. 그러나 대부분의 경우 이는 일부만 정리하면됩니다. 실제로 예외 자체에는 관심이 없습니다. 예를 들어, 파일을 열면 파일 처리가 정상적으로 실행되는지 아니면 예외가 발생하는지에 관계없이 파일을 다시 닫으려고합니다. 그러나 이러한 경우에는 실제로 예외를 전달하지는 않지만 적절한 시점에서 정리 함수를 호출하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 과 같은 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68320e8b907613c7782553698755865907bc858f" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags.</source>
          <target state="translated">표현에 액세스하는 플러그인을 정의하는 데 사용할 수있는 여러 가지 액세스 포인트가 있습니다. 이러한 모든 필드 는 &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 컴파일러에 전달 된 &lt;code&gt;CommandLineOption&lt;/code&gt; 문자열 목록을받습니다 .</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">표현에 액세스하는 플러그인을 정의하는 데 사용할 수있는 여러 가지 액세스 포인트가 있습니다. 이러한 모든 필드 는 &lt;code&gt;-fplugin-opt&lt;/code&gt; 플래그를 사용하여 컴파일러에 전달되는 &lt;code&gt;CommandLineOption&lt;/code&gt; 문자열 목록을받습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">생성 될 수있는 여러 가지 종류의 힙 프로파일이 있습니다. 모든 다른 프로파일 유형은 시간에 대한 라이브 힙 그래프를 생성하지만 라이브 힙이 밴드로 분류되는 방식이 다릅니다. 다음 RTS 옵션은 사용할 분류를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">예외를 포착하고 검사하기위한 몇 가지 기능이 있습니다. 모두 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">가비지 수집을 정확하게 제어 할 수있는 몇 가지 옵션이 있습니다. 다행히 정상적인 작동에서는 이러한 기능이 필요하지 않지만 최대 성능을 위해 조정할 수있는 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 에서 제공하는 다른 Haskell 및 GHC 관련 메일 링리스트가 몇 가지 있습니다 . 전체 목록을 보려면 &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; 로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">여기에주의해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">기존에 수량화 된 생성자를 사용할 수있는 방법에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f0614d42022b318b6c7e89cd2bff7336dde820" translate="yes" xml:space="preserve">
          <source>There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt;, &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</source>
          <target state="translated">이것을 사용할 때 몇 가지 제한이 있습니다. 파일 및 프로세스 IO가 대상에서 실행됩니다. &lt;code&gt;git-embed&lt;/code&gt; 와 같은 패키지 , &lt;code&gt;file-embed&lt;/code&gt; 및 기타 패키지 는 대상과 호스트가 동일한 파일 시스템을 공유하지 않으면 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">&lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 파생시킬 수있는 데이터 유형과 관련하여 몇 가지 다른 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 컴파일되지 않는 다른 시나리오가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">기본 유형의 사용에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">박스형 튜플 사용에는 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">힙 프로파일 링과 관련된 세 가지 옵션이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">세 개의 새로운 키워드가 있습니다 : &lt;code&gt;group&lt;/code&gt; , &lt;code&gt;by&lt;/code&gt; 및 &lt;code&gt;using&lt;/code&gt; . &lt;code&gt;sortWith&lt;/code&gt; 및 &lt;code&gt;groupWith&lt;/code&gt; 함수 는 키워드가 아니며 &lt;code&gt;GHC.Exts&lt;/code&gt; 에서 내 보낸 일반 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">현재 통화 스택에 액세스하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18668df28a2960d99f735bbd24797ff6843bd893" translate="yes" xml:space="preserve">
          <source>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</source>
          <target state="translated">구멍 맞춤 플러그인을 정의하기 위해 두 개의 액세스 포인트가 함께 번들로 제공됩니다. 즉, 후보 플러그인과 맞춤 플러그인이 각각 확인되고 적합 할 후보를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0e7482a52c288e2a6aa7c273bf0bcf1dbfeabe7e" translate="yes" xml:space="preserve">
          <source>There are two classes of event types:</source>
          <target state="translated">이벤트 유형에는 두 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">특수 구문에는 두 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLL을 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 에는 두 가지 중요한 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">이 디코더를 실행하는 방법에는 지연 입력 방법과 증분 입력 방법의 두 가지 방법이 있습니다. 여기에서는 게으른 입력 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">시퀀스와 목록 사이에는 두 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">이 카운터로 수행 할 수있는 두 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">browse 명령에는 두 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">이 pragma를 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">여러 프로세서에서 프로그램을 실행하는 방법은 두 가지가 있습니다. 프로그램에서 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; 를 호출 하거나 RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="54084616a21d75658db0216e6ad990b71f0f3457" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">여러 프로세서에서 프로그램을 실행하는 방법에는 두 가지가 있습니다. 프로그램에서 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; 를 호출 하거나 RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">원하는만큼 파일 헤더 프라그 마가있을 수 있으며 앞에 주석이 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">연관된 유형 동의어에 대해 최대 하나의 기본 선언이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 여러 호출이있을 수 있지만 각각은 &lt;code&gt;hs_exit()&lt;/code&gt; 한 번의 호출과 일치해야합니다 . 가장 바깥 쪽 &lt;code&gt;hs_exit()&lt;/code&gt; 는 실제로 시스템을 초기화 해제합니다. 현재 GHC의 런타임은이 문제가 발생한 후 안정적으로 다시 초기화 할 수 없습니다. &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;외부 기능 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">&quot; &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; &quot;옵션은 하나만있을 수 있지만 (예 : 위의 예에서 -hr ) 적용 할 수있는 추가 제한 수에는 제한이 없습니다. 모든 옵션은 한 가지 예외가 결합 될 수있다 : GHC는 현재 혼합 지원하지 않습니다 &lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt; 옵션을.</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">&lt;code&gt;RtsConfig&lt;/code&gt; 유형의 변수를 초기화하는 데 사용해야 하는 기본값 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 가 있습니다 . 앞으로 더 많은 필드가 &lt;code&gt;RtsConfig&lt;/code&gt; 에 추가 될 것이므로 앞으로 코드를 호환 가능하게하려면 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 로 초기화 한 다음 위의 코드 샘플에서와 같이 필수 필드를 수정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">컴파일 안전성 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt; 의 몇 가지 잠재적 인 솔루션과 관련된 문제에 대한 자세한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ef9b54093e73b5247e6192453bb1d4451bfc02a" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt; 에는 컴파일 안전과 관련된 몇 가지 잠재적 솔루션에 대한 자세한 논의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 사이에는 미묘한 차이가 있습니다 ! x 는 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이와 유사합니다 . 게으른 값 &lt;code&gt;x&lt;/code&gt; 에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;반환하십시오 &lt;/a&gt; . x 는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-exception#v:evaluate&quot;&gt;평가&lt;/a&gt; 하면 항상 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 생성됩니다 . 조치는시 예외가 발생합니다 것을 &lt;em&gt;실행&lt;/em&gt; IFF에 &lt;code&gt;x&lt;/code&gt; 는 시 예외가 발생 &lt;em&gt;평가&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="566104a98981fe95741524bb050f2354c55f9f53" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 사이에는 미묘한 차이가 있습니다 ! x 는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 의 차이와 유사합니다 . 게으른 값 &lt;code&gt;x&lt;/code&gt; 에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;반환하십시오 &lt;/a&gt; . x 는 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업 을 반환하지 못하고 대신 예외를 throw합니다. 반면에 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;평가&lt;/a&gt; 하면 항상 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 생성됩니다 . 조치는시 예외가 발생합니다 것을 &lt;em&gt;실행&lt;/em&gt; IFF에 &lt;code&gt;x&lt;/code&gt; 는 시 예외가 발생 &lt;em&gt;평가&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">교착 상태 감지와 종료 자 ( &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; 의 함수에 의해 생성됨) 간에 미묘한 상호 작용이 있습니다 . 스레드가 종료자가 실행되기를 기다리는 동안 차단되면 스레드가 교착 상태로 간주되어 예외가 전송됩니다. 따라서이 작업을 수행하지 않는 것이 좋지만 대안이없는 경우 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 이이를 가리 키도록 하여 스레드가 교착 상태로 간주되는 것을 방지 할 수 있습니다. 나중에 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 을 해제하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">불법 문자 처리 방법을 지정하는 추가 표기법 (GNU iconv에서 차용)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;스마트 생성자에&lt;/a&gt; 대한 광범위한 Haskell 민속 예술이 있습니다 . 본질적으로 생성자를 둘러싼 유효성 검사를 감싸고 해당 표현을 노출시키지 않는 함수입니다. 단점은 기본 생성자를 매 처로 사용할 수 없다는 것입니다. 패턴 동의어는 유효성 검사 및 일치를 위해 진정한 스마트 생성자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">프로파일 링에 의해 거주자 수치에서 차감되는 프로파일 링 자체의 오버 헤드가 있습니다. 물론 프로파일 링 지원없이 컴파일 할 때이 오버 헤드가 사라집니다. 공간 오버 헤드는 현재 힙 개체 당 2 개의 추가 단어이므로 약 30 %의 오버 헤드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">현재 &quot;스택 추적&quot;을 얻을 수있는 지원은 없지만 추적 및 기록 기능은 유용한 두 번째 최고를 제공하며, 이는 종종 오류 컨텍스트를 설정하기에 충분합니다. 예를 들어, 컴파일 된 코드에서 예외가 발생하더라도 예외가 발생하면 자동으로 중단 될 수 있습니다 ( &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;예외 디버깅&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; 유형에는 정확히 하나의 값이 있으므로 인코딩 할 때 지식이 필요 없으며 0 비트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 가 없습니다 . 현지 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 절대 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="19ed2f198aae585d94d8de2a49be348554775e93" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 인스턴스 는 없습니다 . 현지 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 절대 시간을 비교하려면 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">&lt;code&gt;deRefStableName&lt;/code&gt; 작업 이 없습니다 . 안정된 이름에서 원래 Haskell 객체로 돌아올 수 없습니다. 그 이유는 객체의 안정적인 이름이 있다고해서 객체 자체의 존재를 보장하지 않기 때문입니다. 여전히 가비지 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">&lt;code&gt;freeStableName&lt;/code&gt; 과 달리 &lt;a href=&quot;foreign-stableptr&quot;&gt;freeStableName&lt;/a&gt; 작업 이 없습니다 . 더 이상 필요하지 않은 경우 런타임 시스템이 안정적인 이름을 회수합니다.</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">더 없다 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; 또는 &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 가 태그되도록 소스의 주석, &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 읽기 전에 항상 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; 를 호출하기 때문에 읽기 버퍼에 해당하는 조작이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">기존 유형의 이름 만 바꾸는 newtypes에는 영향을 미치지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">평가 순서는 보장되지 않습니다. 구현은 구조물의 구성 요소를 임의의 순서로 또는 병렬로 평가할 수있다. 평가시 실제 주문을 하려면 &lt;code&gt;parallel&lt;/code&gt; 패키지의 &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; 에서 &lt;code&gt;pseq&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">런타임이 임의의 지연이 발생하지 않도록 노력하지만 예외가 즉시 전달된다는 보장은 없습니다. GHC에서, 스레드가 &lt;em&gt;안전 지점에&lt;/em&gt; 도달 할 때만 예외가 발생할 수 있으며 , 안전 지점은 메모리 할당이 발생하는 곳입니다. 일부 루프는 루프 내에서 메모리 할당을 수행하지 않으므로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 에 의해 중단 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">지연 시간이 만료되면 스레드가 즉시 다시 예약 될 것이라는 보장은 없지만 스레드가 지정된 것보다 &lt;em&gt;빨리&lt;/em&gt; 실행되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">모든 소스 파일을 &lt;code&gt;ghc -M&lt;/code&gt; 명령 에 대한 인수로 나열 할 필요는 없습니다 . &lt;code&gt;ghc&lt;/code&gt; 는 &lt;code&gt;ghc --make&lt;/code&gt; (GHC 6.4의 새로운 기능) 와 같이 종속성을 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">소스 에는 엄격함 ( &lt;code&gt;!&lt;/code&gt; ) 또는 게으름 ( &lt;code&gt;~&lt;/code&gt; ) 주석이 없으므로 &lt;code&gt;'NoSourceStrictness&lt;/code&gt; 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">&lt;code&gt;Danger&lt;/code&gt; 가 가져올 수 있는 모듈에 제한을 두는 방법은 없습니다 . 이를 통해 &lt;code&gt;Danger&lt;/code&gt; 의 작성자 는 시스템에 현재 설치된 모든 패키지에 대해 매우 큰 공격 영역을 제공합니다. 이러한 패키지 중 하나에 취약점이 있으면 &lt;code&gt;Danger&lt;/code&gt; 모듈이이를 악용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">초기 데이터 이외의 다른 입력을 제공 할 방법이 없습니다. 점진적으로 더 많은 데이터를 제공하려면 증분 입력 인터페이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">이제 가져 오기 및 내보내기 목록에 약간의 모호성이 있습니다. 예를 들어 &lt;code&gt;import M( (+) )&lt;/code&gt; 을 작성 하면 &lt;em&gt;함수 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 또는 &lt;em&gt;형식 생성자 &lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 를 의미 합니까? 기본값은 전자이지만 &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; 에&lt;/a&gt; 의해 암시 됨 )를 사용하면 GHC를 사용하여 후자를 키워드 &lt;code&gt;type&lt;/code&gt; 으로 시작 하여 후자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">하나의 가장자리 경우가 있습니다 : &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 현재 항상 빈리스트 (상관없이 생산 &lt;code&gt;tys&lt;/code&gt; 제공됩니다).</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">이 일반적인 규칙에는 한 가지 예외가 있습니다. : load로 프로그램을 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 하거나 &lt;code&gt;ghci&lt;/code&gt; 를 호출 할 때 프로그램을 지정 하면 모듈 이름 대신 파일 이름을 지정할 수 있습니다. 이 파일 이름은 존재하는 경우로드되며 원하는 모듈을 포함 할 수 있습니다. 동일한 디렉토리에 여러 개의 &lt;code&gt;Main&lt;/code&gt; 모듈이 있고 &lt;code&gt;Main.hs&lt;/code&gt; 를 모두 호출 할 수없는 경우에 특히 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">설명해야 할 까다로운 사례가 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">구문상의 모호성에는 한 가지 문제가 있습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">실제로 I / O 작업을 &quot;수행&quot;하는 한 가지 방법이 있습니다 : 프로그램의 &lt;code&gt;Main.main&lt;/code&gt; 에 바인딩하십시오 . 프로그램이 실행되면 I / O가 수행됩니다. 해당 함수 자체가 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 있고 &lt;code&gt;Main.main&lt;/code&gt; 에서 직접 또는 간접적으로 호출 되지 않는 한 임의의 함수에서 I / O를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25f515351416a88c7165a7d23467301f2a1ae98e" translate="yes" xml:space="preserve">
          <source>There is room for extra information in the event type specification, which can be ignored by older tools.</source>
          <target state="translated">이전 도구에서는 무시할 수있는 이벤트 유형 사양에 추가 정보를위한 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCi가 prelude 및 표준 라이브러리를로드하는 동안 잠시 일시 중지 될 수 있으며 그 후에 프롬프트가 표시됩니다. 배너에서 알 수 있듯이 &lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;사용 가능한 명령 목록과 각 명령에 대한 반줄 설명을 봅니다. 우리는이 명령들 대부분을 설명 할 &lt;a href=&quot;#ghci-commands&quot;&gt;것이며 GHCi 명령의&lt;/a&gt; 모든 명령들에 대한 완전한 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">같은 키를 가진 약한 포인터가 여러 개있을 수 있습니다. 이 경우 이러한 약한 포인터 각각에 대한 종료자는 모두 임의의 순서로 또는 키가 죽을 때 동시에 실행됩니다. 프로그래머가 오브젝트에 대한 유일한 참조 (예 : 닫고 싶은 파일)를 가지고 있다고 가정하는 종료자를 지정하면, 프로그래머는 그러한 종료자가 하나만 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma에는 세미콜론으로 구분 된 규칙이 0 개 이상있을 수 있습니다 (레이아웃 규칙에 의해 생성 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">토큰에 공백이 없어야합니다. &lt;code&gt;[quoter|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">값 선언은 없어야하지만 값에 대한 형식 서명이있을 수 있습니다. 예를 들어 서명을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">값 선언은 없어야하지만 값에 대한 형식 서명이있을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">모호한 다시 쓰기 시스템을 정의하지 않도록 유형 패밀리의 방정식에 약간의 제한이 있어야합니다. 따라서 개방형 패밀리의 방정식은 호환 가능하도록 제한됩니다. 두 가지 유형의 패턴이 호환되는 경우</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 의 또 다른 변형 (즉 &lt;code&gt;Par0&lt;/code&gt; )이 있었지만 이후에는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;동시성&lt;/em&gt; 과 &lt;em&gt;병렬&lt;/em&gt; 처리는 잘 구분되어 있습니다 . 병렬 처리는 여러 프로세서를 동시에 사용 하여 프로그램을 &lt;em&gt;더 빠르게&lt;/em&gt; 실행하는 &lt;em&gt;것&lt;/em&gt; 입니다. 반면에 동시성은 추상화의 수단입니다. 여러 비동기 이벤트에 응답해야하는 프로그램을 구성하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">거기 만들 수있는 특수 기능의 &lt;code&gt;StablePtr&lt;/code&gt; : &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; 는 RTS가 필요하기 때문에, &lt;code&gt;StablePtr&lt;/code&gt; 을 원시에 &lt;code&gt;MVar#&lt;/code&gt; 객체, 우리는 바로 그것을 만들 수 없습니다. 마십시오 &lt;em&gt;하지&lt;/em&gt; 만 사용 &lt;code&gt;newStablePtr&lt;/code&gt; 온 &lt;code&gt;MVar&lt;/code&gt; : 프로그램이 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">&lt;code&gt;CYGWIN&lt;/code&gt; 환경 변수에 &lt;code&gt;tty&lt;/code&gt; 가 포함되어 있지 &lt;em&gt;않으면&lt;/em&gt; Cygwin 쉘을 사용할 수 있습니다 . 이 모드에서 Cygwin 쉘은 Windows 콘솔 쉘처럼 작동하며 콘솔 이벤트는 하위 프로세스로 전파됩니다. 있습니다 &lt;code&gt;CYGWIN&lt;/code&gt; 환경 변수를 설정해야합니다 &lt;em&gt;전에&lt;/em&gt; Cygwin에서 쉘을 시작; 나중에 변경해도 쉘에는 영향을 미치지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">외부 라이브러리를 사용하는 경우 다른 한 잡았다 염두에 곰에있다 : 라이브러리가 포함되어있는 경우 &lt;code&gt;main()&lt;/code&gt; 함수를 다음이 GHC 자신과 링크 충돌이 될 것입니다 &lt;code&gt;main()&lt;/code&gt; (기능 예. &lt;code&gt;libf2c&lt;/code&gt; 및 &lt;code&gt;libl&lt;/code&gt; 자신이 &lt;code&gt;main()&lt;/code&gt; 들 ).</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 함수 패밀리 중 하나를 호출 할 때 모든 예외 핸들러 주위에 묵시적인 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 가 있습니다. 이는 대부분의 시간이 필요하기 때문입니다. 예외 처리기가 시작될 때 스택에 다른 예외를 처리 할 예외 처리기가 없을 수 있기 때문에 예외 처리기를 시작할 때 일반적인 경쟁 조건이 제거됩니다. 그러나 핸들러를 입력 할 때 비동기 예외가 마스킹되면 중단되기 전에 새 예외 핸들러를 설치할 시간이 있습니다. 이것이 기본값이 아닌 경우 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b1f8f78c4b21b4ebde0207b0aeba4e07d56d547" translate="yes" xml:space="preserve">
          <source>Therefore, if we run GHC against the following code using the plugin from above:</source>
          <target state="translated">따라서 위의 플러그인을 사용하여 다음 코드에 대해 GHC를 실행하면 :</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">이러한 &lt;code&gt;Names&lt;/code&gt; 은 템플릿 하스켈 표현식, 패턴, 선언 등을 구성하는 데 사용될 수 있습니다. 또한 &lt;code&gt;reify&lt;/code&gt; 함수에 대한 인수로 제공 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">이러한 RTS 옵션은 (a) GHC 버그를 피하기 위해, (b)&amp;ldquo;실제로 발생하는 상황&amp;rdquo;을 확인하기 위해 또는 (c) 기분이 좋아서 사용할 수 있습니다. 매일 사용하지 않는 것이 좋습니다!</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">Hongwei Xi와 Tim Sheard의 논문에 이러한 사례와 기타 여러 사례가 나와 있습니다. &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;위키에&lt;/a&gt; 대한 더 긴 소개 가 &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;있으며 팬텀 유형&lt;/a&gt; 의 Ralf Hinze의 Fun 에는 많은 예제가 있습니다. 논문은 GHC에서 구현 된 것과 다른 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">이들은 각각 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; 로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">이것들은 &lt;em&gt;신뢰할 수있는&lt;/em&gt; 모듈 데이터에서 &lt;a href=&quot;data-coerce&quot;&gt;얻을&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">다음은 데이터 생성자가 다형성 인수 유형을 갖는 &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;newtype&lt;/code&gt; 선언의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">이들은 프로그램이 실행되도록 컴파일 된 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">이들은 GHC 자체가 컴파일 된 플랫폼입니다. 다시 말하지만, 이는 일반적으로 빌드 및 대상 플랫폼과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">이들은 프로그램이 구축 된 플랫폼입니다. (즉, GHC 자체의 대상 플랫폼입니다.) 일반적으로 이것은 대상 플랫폼과 동일합니다. 크로스 컴파일하면 잠재적으로 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">이러한 속성은 모든 속성이 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">버그 나 성능 문제를 조사하는 데 유용 할 수 있습니다. 프로덕션 코드에서는 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">이러한 기능은 직접 대응 &lt;code&gt;cub&lt;/code&gt; , &lt;code&gt;cud&lt;/code&gt; , &lt;code&gt;cub1&lt;/code&gt; , &lt;code&gt;cud1&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">이러한 문자는 공백, 작은 따옴표, 큰 따옴표 및 백 슬래시 문자입니다. 백 슬래시 문자는 항상 뒤에 오는 문자를 이스케이프합니다 (즉, 추가 고려없이 통과 함). 따옴표를 사용하여 블록에서 문자를 이스케이프 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;편지&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;마크&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;숫자&quot;가 아닌 것이 무엇인지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서에서 &quot;문장&quot;이 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;분리기&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">이러한 클래스는 유니 코드 표준의 일부인 &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;유니 코드 문자 데이터베이스에&lt;/a&gt; 정의되어 있습니다. 동일한 문서는 &quot;기호&quot;가 무엇인지 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">이 클래스는 휴대용 Haskell에서 변압기 인수에 대한 제약 조건을 표현하는 데 필요합니다. 따라서 새로운 변환기 &lt;code&gt;T&lt;/code&gt; 의 경우 다음과 같은 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">이러한 고려 사항은 다음과 같은 고아 모듈 정의로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">이들은 파라 메트릭으로 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">이러한 이벤트는 &lt;em&gt;항상&lt;/em&gt; GHC 시스템의 버그이므로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="588a8548c6363993d22d2b7e86c47e328069a514" translate="yes" xml:space="preserve">
          <source>These events are typically produced during program startup and describe the environment which the program is being run in.</source>
          <target state="translated">이러한 이벤트는 일반적으로 프로그램 시작 중에 생성되며 프로그램이 실행되는 환경을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7e9e62a89c4ce54bd1d84649823a3e3080b1425a" translate="yes" xml:space="preserve">
          <source>These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;non-moving collection&lt;/code&gt;&lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</source>
          <target state="translated">이러한 이벤트는 &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;non-moving collection&lt;/code&gt; &lt;/a&gt; 수명주기 의 다양한 단계를 표시 합니다. &lt;code&gt;+RTS -lg&lt;/code&gt; 이벤트 세트 로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">이 플래그는 모듈에 &quot;고아&quot;인스턴스 선언 또는 다시 쓰기 규칙이 포함될 때마다 경고가 발생합니다. 인스턴스 선언은 클래스와 인스턴스 유형이 같은 모듈에서 선언되지 않은 모듈에 나타나는 경우 고아입니다. 규칙이 다른 모듈에서 선언 된 함수에 대한 규칙 인 경우 고아입니다. 고아를 포함하는 모듈을 고아 모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">이 플래그는 다른 백엔드에서 다양한 정보 비트를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">이 플래그는 GHC의 프론트 엔드에서 다양한 정보를 덤프합니다. 여기에는 파서 및 인터페이스 파일 판독기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">이 플래그는 GHC의 타입 체커 및 리 네이터로부터 다양한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="2dc9a8e0f094a600546405a33b0a5ef835899c04" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</source>
          <target state="translated">이 플래그는 GHC의 C-- 파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">이 플래그는 GHC C-\-파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">이 플래그는 GHC의 코어-코어 파이프 라인의 다양한 단계를 덤프합니다. 이것은 디 슈거 러로 시작되며 단순화 기, 작업자 래퍼 변환, 규칙 엔진, 전문가, 엄격 성 / 발생 성 분석기 및 공통 하위 식 제거 패스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">이 플래그는 GHC STG 파이프 라인의 다양한 단계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="50fcdcd1fe44bc0c3ab929a2c58bbb80cb13f620" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</source>
          <target state="translated">이러한 플래그 는 C로 시작 하는 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기&lt;/a&gt; 파이프 라인 의 다양한 단계를 덤프 하고 네이티브 어셈블러를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">이 플래그 는 C-\-로 시작하고 기본 어셈블러를 생성 하는 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;기본 코드 생성기&lt;/a&gt; 파이프 라인 의 다양한 단계를 덤프 합니다.</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 개별 최적화를 켜고 끕니다. 기본적으로 on으로 표시된 플래그는 &lt;code&gt;-O&lt;/code&gt; 에 의해 활성화 되므로 명시 적으로 설정할 필요가 없습니다. &lt;code&gt;-fwombat&lt;/code&gt; 플래그 는 다음과 같이 말함으로써 무효화 될 수 있습니다. &lt;code&gt;-fno-wombat&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">표준 유형에 대한 이러한 포맷터는 새로운 유형별 포맷터를 작성하는 데 편의를 위해 제공됩니다. 일반적인 패턴은 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; 로 던지는 것입니다 새 유형에 대한 대부분의 포맷 처리를 수행 로 입니다.</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">이 네 가지 속성은 안전한 언어로 형식을 신뢰할 수 있고 모듈 내보내기 목록이 존중된다는 것을 신뢰할 수 있으며 성공적으로 컴파일 된 코드는 평상시와 동일한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 &lt;a href=&quot;prelude&quot;&gt;Prelude에서&lt;/a&gt; 내보내기도합니다. .</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">이러한 함수는 항상 ASCII를 가정하지 않고 현재 로케일에 의해 결정된 인코딩을 사용한다는 점에서 &lt;code&gt;CAString&lt;/code&gt; 대응 기능과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">이러한 함수는 인스턴스화되는 유형에 따라 다른 결과를 반환해야하기 때문에 오버로드됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">이 함수는 시프트되는 양이 기계 Int #의 비트 크기보다 클 때 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">이러한 함수는 내부적으로 다양한 오류를 발생시키기 위해 사용되며 새로운 유형별 포맷터에서 사용하기 위해 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">이 함수를 사용하여 새로운 대수 유형에 대한 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 인스턴스 를 어셈블 할 수 있습니다 . 예를 들어, 정의가 주어지면</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">이 함수는 levity-polymorphic 변수를 바인딩하지 않으므로 허용됩니다. 이들의 다형성을 통해 사용자는 박스를 사용하지 않는 유형을 반환하는 함수를 편리하게 스텁 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044a64ee1e082d15f5fc359f3ff870486d8b309f" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">이 함수는 임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작을 종료 자로 허용 하여 이식 가능한 &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; 모듈 에서 이름을 일반화합니다 . 이러한 종료자는 반드시 별도의 스레드에서 실행됩니다 (cf. 2003 년 &lt;em&gt;POPS&lt;/em&gt; Hans Boehm의 &lt;em&gt;소멸자, 종료 자 및 동기화&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">이 함수는 시퀀스의 왼쪽 또는 오른쪽 끝에서 순차적으로 검색하여 일치하는 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">이러한 함수 는 훨씬 유연한 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 보다 이전 버전 입니다.</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">이 함수는리스트 &lt;code&gt;xs&lt;/code&gt; 를 인덱스 콜렉션으로 취급하며 인덱스 범위는 0에서 &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">이 함수는리스트 &lt;code&gt;xs&lt;/code&gt; 를 인덱스 콜렉션으로 취급하며 인덱스 범위는 0- &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">이러한 인스턴스는 암시 적 종류 매개 변수가 다르기 때문에 호환됩니다. 첫 번째는 &lt;code&gt;Type&lt;/code&gt; 을 사용 하고 두 번째는 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">이 매크로는 GHC 7.10.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">이 매크로는 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 이 제공하는 것보다 세밀한 정보를 제공하기 위해 제공됩니다 . 일반적으로 패치 수준 릴리스간에 대부분의 API가 안정적으로 유지 될 것으로 예상되기 때문에 필요하지 않지만 때때로 버그를 수정하기 위해 내부 API 변경이 필요합니다. 패치 레벨에서 조건부 컴파일은 이전 릴리스의 버그를 해결하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">이러한 매크로는 Haskell 모듈에서 생성 된 C 소스 (예 : &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; 및 &lt;code&gt;.hc&lt;/code&gt; )를 포함하여 Haskell 소스 및 C 소스를 사전 처리 할 때 설정됩니다. 파일)를 .</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">이 모듈은 Prelude 기능과의 이름 충돌을 피하기 위해 수입 규정을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">이러한 연산은 각각 &lt;code&gt;False&lt;/code&gt; 와 &lt;code&gt;True&lt;/code&gt; 대신 &lt;code&gt;0#&lt;/code&gt; 과 &lt;code&gt;1#&lt;/code&gt; 반환 합니다. 자세한 내용은 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool 위키 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7ccd9c5b4911eda91ad51529b53aa771bb31514" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : platform-dependent flags에&lt;/a&gt; 자세히 설명되어 있습니다 . 플래그가 &lt;code&gt;-O&lt;/code&gt; 에 의해 내포되면 플래그 설명에 명시 적으로 다르게 명시되지 않는 한 &lt;code&gt;-O2&lt;/code&gt; 에도 내포됩니다 . 플래그에 &lt;code&gt;-O0&lt;/code&gt; 만 내포 된 경우 플래그는 &lt;code&gt;-O&lt;/code&gt; 및 &lt;code&gt;-O2&lt;/code&gt; 로 내포되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;최적화 (코드 개선)에&lt;/a&gt; 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">이 옵션은 치명적인 것으로 간주되는 경고를 제어하고 컴파일을 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">이 옵션은 프로그램 실행 및 가비지 수집기의 시간, 할당 된 메모리의 양, 힙의 최대 크기 등과 같은 런타임 시스템 통계를 생성합니다. 세 가지 변형은 서로 다른 세부 수준을 제공합니다. &lt;code&gt;-T&lt;/code&gt; 는 데이터를 수집하지만 출력을 생성하지 않습니다. &lt;code&gt;-t&lt;/code&gt; GHC의 &lt;code&gt;-Rghc-timing&lt;/code&gt; 옵션 과 동일한 형식으로 단일 출력 라인을 생성합니다. &lt;code&gt;-s&lt;/code&gt; 는 프로그램과 &lt;code&gt;-S&lt;/code&gt; 는 추가로 각각의 모든 가비지 콜렉션에 대한 정보를 생성합니다. &lt;code&gt;--internal-counters&lt;/code&gt; 전달스레드 된 런타임에 대한 자세한 요약은 실행 중에 누적 된 다양한 내부 수를 포함합니다. 이들은 지정되지 않았으며 릴리스간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;ByteString&lt;/code&gt; 을 다른 생성자로 압축 해제하면 이러한 오버 헤드를 모두 1 워드 (4 또는 8 바이트) 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">이 문서와 화살표에 대한 자세한 내용은 &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 패턴은 GHC 버전 8.0 이상에서만 사용 가능하며 버전 8.2는 더 잘 작동합니다. 이러한 최신 버전의 GHC를 작성할 때 &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 있는 대신 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; 패턴을 사용할 수 있습니다 . &amp;lt;| , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">이들은 잠재적으로 중복되지만 GHC는 플래그 설정에 관계없이 인스턴스 선언 자체에 대해 불평하지 않습니다. 나중에 제약 조건 &lt;code&gt;(C Int Char)&lt;/code&gt; 을 해결하려고 하면 첫 번째 인스턴스 만 일치하고 모두 잘됩니다. &lt;code&gt;(C Bool Bool)&lt;/code&gt; 과 유사합니다 . 그러나 &lt;code&gt;(C Int Bool)&lt;/code&gt; 을 해결하려고하면 두 인스턴스가 모두 일치하고 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">이 pragma는 함수 정의의 인라인을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">이러한 제한 사항은 쉽게 확인되고 형식 유추가 종료되도록합니다. 그러나 유형 변수의 재귀 발생이 패밀리 응용 프로그램 아래에있는 &lt;code&gt;a ~ [F a]&lt;/code&gt; 와 같은 소위 &quot;루피 평등&quot;이있는 경우 유형 유추의 완전성을 보장하기에 충분하지 않습니다 . 데이터 생성자 응용 프로그램-자세한 내용은 위에서 언급 한 논문을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f701b27c6f77c55b38a0a5e6d91357571f66567" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">이러한 제한은 쉽게 확인되며 유형 추론의 종료를 보장합니다. 그러나,이 같은 정도로 '깨어나 등식'호출의 존재에 입력 추론 보증 완전성에 충분하지 &lt;code&gt;a ~ [F a]&lt;/code&gt; , 여기서, 타입 변수 재귀 발생 가족 애플리케이션 아래이고 데이터 생성자 응용 프로그램-자세한 내용은 위에서 언급 한 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항으로 인해 인스턴스 확인이 종료됩니다. 각 축소 단계는 하나 이상의 생성자에 의해 문제가 더 작아집니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;제약 조건 처리 규칙을 통한 기능적 종속성 이해&lt;/a&gt; 문서에서 이러한 제한 이유에 대한 많은 배경 자료를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">이 규칙은 레코드 와일드 카드를 사용자가 확장 버전을 작성할 수있는 상황으로 제한합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">이러한 유형은 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 에 가변 개수의 인수 처리를 구현하는 데 필요합니다 . 그들의 구현은 의도적으로이 모듈에서 보이지 않습니다. 적절한 클래스의 인스턴스가 아닌 유형의 인수를 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 에 전달하려고 시도 하면 컴파일러는이를 누락 된 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 인스턴스로보고합니다 . (모두 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">이러한 유형은 Haskell의 C 라이브러리 인터페이스에 액세스하기 위해 C 함수 프로토 타입을 정확하게 나타 내기 위해 필요합니다. Haskell 시스템은 C와 같은 유형을 정확하게 표현할 필요는 없지만 Haskell 유형과 관련하여 다음과 같은 보증이 제공됩니다. &lt;code&gt;CT&lt;/code&gt; C 유형 &lt;code&gt;t&lt;/code&gt; 를 나타내는 CT .</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 은 S의 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 의 인스턴스 및있는 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 을 . 이는 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; (각각 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; )의 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 인스턴스를 의미합니다 . &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; (각각 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ) 만큼 나쁘게 행동 합니다.</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 이란 기본 외국인 종류의, 그리고 인스턴스 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 유형으로 표시됩니다 &lt;code&gt;newtype&lt;/code&gt; 은 의에서 유형의 &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; 및 &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 의 인스턴스 및있는 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">위 함수의 이러한 변형은 유니 코드를 모르는 C 라이브러리와 함께 사용하기위한 것입니다. 정보 손실이 발생할 수 있으므로 이러한 기능은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">위 함수의 이러한 변형은 시스템에 따라 C &lt;code&gt;wchar_t&lt;/code&gt; 유형을 사용하여 유니 코드를 인코딩하는 C 라이브러리와 함께 사용됩니다 . 지원되는 유일한 인코딩은</target>
        </trans-unit>
        <trans-unit id="d4df89c18ae8de17d49ca0683c16ba6bdd50a129" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">그들은 말할 &lt;code&gt;make&lt;/code&gt; 의 경우 것으로 &lt;code&gt;Foo.o&lt;/code&gt; , &lt;code&gt;Foo.hc&lt;/code&gt; 또는 &lt;code&gt;Foo.s&lt;/code&gt; 이 보다 이전의 수정 날짜가 &lt;code&gt;Baz.hi&lt;/code&gt; 을 한 후 오래된 파일이 최신 상태로 만들어야합니다. 지금까지 그것을 가지고 &lt;code&gt;make&lt;/code&gt; 그렇게 할 규칙 보이는; 앞의 접미사 규칙 중 하나가 작업을 훌륭하게 수행합니다. 이러한 의존성은 &lt;code&gt;ghc&lt;/code&gt; 에 의해 자동으로 생성 될 수 있습니다 . &lt;a href=&quot;#makefile-dependencies&quot;&gt;의존성 생성&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">그것들은 Simon Peyton Jones, Andrew Gordon, Sigbjorn Finne 의 논문 &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; 에 소개 되었지만, 그 구현에 대한 세부 사항은 그 이후로 변경되었지만 (특히 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 이제 단순히 블록을 오류로 사용하지만. )</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">알아야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">이 &quot;기능&quot;은 &lt;code&gt;unsafePerformIO&lt;/code&gt; 와 피상적 인 유사성을 갖지만 실제로는 혼돈의 악의적 인 에이전트입니다. 현실의 이음새 (및 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드)를 선택 해제하여 일반 규칙이 더 이상 적용되지 않도록합니다. 그것은 합리적이라고 생각하도록 당신을 유혹하지만, 당신이 그것을 보지 않을 때는 뒤에서 찌르고 모든 변경 가능한 버퍼의 별칭을 지정합니다. 노련한 Haskell 프로그래머의 시체가 발에 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6dd831f46ec853aa8fce97c6a2a27a512463cc" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">이 &quot;기능&quot;은 &lt;code&gt;unsafePerformIO&lt;/code&gt; 와 피상적으로 유사 하지만 실제로는 혼돈의 악의적 인 에이전트입니다. 일반 규칙이 더 이상 적용되지 않도록 현실의 이음새 (및 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드)를 선택 해제합니다. 그것은 합리적이라고 생각하도록 당신을 달래 주지만, 당신이 보지 않을 때 그것은 당신을 뒤에서 찌르고 모든 가변 버퍼를 별칭으로 만듭니다. 노련한 하스켈 프로그래머의 시체가 발 밑에 흩어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">이&amp;ldquo;기능&amp;rdquo;은 반 직관적 일 수 있습니다 : &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; 는 중간 C 코드를 파일에 넣습니다. &lt;code&gt;foo.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 동등 술어는 문자열에 패턴 일치를 제거 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 Windows 이외의 플랫폼에서 명령 행 인수 및 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c332f21db0753a9ce2e0bf5358f7f0659bb25726" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 비 Windows 플랫폼에서 명령 줄 인수와 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 Windows 이외의 플랫폼에서 명령 행 인수 및 환경 변수를 디코딩하고 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 는 기본적으로 제공되는 형식 이외의 형식으로 확장 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 를 인스턴스화 하고 형식에 대한 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 를 제공 하면됩니다. &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 을 제공 할 수 있습니다유형별 수정자를 처리 있지만 일반적으로 기본 인스턴스가 최선의 선택입니다.</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">이 약어는 최상위 선언 슬라이스를 더 조용하고 덜 협박하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">이 추상 데이터 형식은 구문 분석 오류 메시지를 나타냅니다. 다음과 같은 네 가지 종류의 메시지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">이는 pragma 바로 다음의 모든 열 번호를 42에서 시작하도록 조정합니다.이 pragma의 존재는 진단 품질에만 영향을 미치며 코드 자체의 구문은 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">이를 통해 다른 유형의 동일한 런타임 표현을 지정하여 유형에 대한 클래스 인스턴스를 &lt;code&gt;deriving&lt;/code&gt; 시킬 수 있습니다 ( 둘 사이에 &lt;code&gt;Coercible&lt;/code&gt; 인스턴스 가 존재하도록 함 : &lt;a href=&quot;#coercible&quot;&gt;Coercible 제한 조건&lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">이를 통해 지정된 필드의 레코드 유형에 대해 다형성 인 정의를 사용할 수 있습니다. 예를 들어, 다음은 필드 &lt;code&gt;name :: String&lt;/code&gt; 가진 모든 레코드 유형에서 작동합니다. .</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">이를 통해 더 짧은 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a1d903f792395fe48e068f8423dc24b82157d5" translate="yes" xml:space="preserve">
          <source>This also applies to GADT-style data instances:</source>
          <target state="translated">이는 GADT 스타일 데이터 인스턴스에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;libfoo.so&lt;/code&gt; 라이브러리 가 현재 디렉토리에 있고 프로그램이 전개되면 실행 가능한 &lt;code&gt;main&lt;/code&gt; 과 동일한 디렉토리에 있다고 가정합니다 . 이와 유사하게 실행 파일과 관련된 하위 디렉토리 (예 : &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="61fe3a7a67ef0295ed3b813ce3259d063c2d2b72" translate="yes" xml:space="preserve">
          <source>This avoid generating Typeable-related bindings for modules and types. This is useful when debugging because it gives smaller modules and dumps, but the compiler will panic if you try to use Typeable instances of things that you built with this flag.</source>
          <target state="translated">이렇게하면 모듈 및 유형에 대한 유형 가능 관련 바인딩이 생성되지 않습니다. 이것은 더 작은 모듈과 덤프를 제공하기 때문에 디버깅 할 때 유용하지만이 플래그로 빌드 한 항목의 Typeable 인스턴스를 사용하려고하면 컴파일러가 패닉 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f906decfdad529805a16ffec27620b40f24764" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9638426e03b58cbb0b8529e91d4b2a020cb1636d" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">필요하지 않더라도 소수점이 항상 보장된다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; 로 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">이 동작은 GHC의 내장 Ctrl-C 처리와 다릅니다.이 처리는 사용자가 Ctrl-C를 두 번째로 누른 후 프로그램을 즉시 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">이 동작은 대부분의 응용 프로그램에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">이 동작은 키에 접근 할 수 있다는 의미에 따라 다릅니다. 비공식적으로 루트 세트의 일반 포인터를 따르면 약한 포인터를 따르지 않으면 도달 할 수있는 것이 있습니다. 도달 가능성을 다음과 같이 더 정확하게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6b2b05c125a4021b12f162035f98b456ef9c82e9" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt;&lt;code&gt;NondecreasingIndentation&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt; &lt;code&gt;NondecreasingIndentation&lt;/code&gt; &lt;/a&gt; 확장에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">이 동작은 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 확장에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">이 동작은 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; = True 옵션이 설정된 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 에 의해 구현됩니다 . 특히, &lt;code&gt;SIGINT&lt;/code&gt; 신호는 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 가 리턴 될 때까지 (또는 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 가 비-아무것도 아닌 결과를 리턴 할 때까지) 무시 되므로 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 특히 중요합니다. 작성된 모든 프로세스에 대해 .</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 동작은 때때로 평가 순서를 제어 할 때 유용합니다. 특히 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 의 라이브러리 정의에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">이것은 모두 작은 스크립트로 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점진적으로 빠릅니다.일부 monoid의 .</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">일부 monoid의 경우 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; 보다 점증 적으로 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">다음과 같이 컴파일하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e5132d5805fa0f4b66063054f14a1690215ca6" translate="yes" xml:space="preserve">
          <source>This can be exponential in the arity of the pattern and in the number of guards in some cases. The &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt;&lt;/a&gt; limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</source>
          <target state="translated">이는 패턴의 배열과 경우에 따라 가드 수에서 기하 급수적 일 수 있습니다. &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt; &lt;/a&gt; 제한이 있는지 우리가 부분적으로 성공한 경기에서 얻은 정제 된 정보를 잊고에 의해, 패턴의 수에 다항식으로 확장 할 수 있습니다. 위의 예에서 제한이 1이면 정제되지 않은 원래 모델로 다음 절을 계속 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c46a06f859ec4216c3665e278e7c6dd66a8347dc" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly quantifying over &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;k&lt;/code&gt; 를 명시 적으로 정량화하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">프로그램이 &lt;code&gt;head []&lt;/code&gt; 오류 에 대해 불평하고 어떤 코드가 문제의 원인 &lt;code&gt;-prof -fprof-auto&lt;/code&gt; ( &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 참조 )로 컴파일 하고 실행하는 경우 디버깅에 특히 유용 할 수 있습니다. 와 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; 당신에게 오류가 발생 된 지점에서 정확하게 호출 스택을 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">예를 들어, 표준 핸들의 대상을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">면밀히 살펴 보는 표현식에 하단이 아닌 값이 없음을 알고있을 때 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">이는 숫자 데이터 유형의 양수 및 음수 범위가 일치하지 않을 때 차이를 만들 수 있습니다. 예를 들어, 8 비트 산술에서 -128은 표현 가능하지만 +128은 표현할 수 없습니다. 따라서 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 은 예기치 않은 정수 리터럴 오버플로 메시지를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">이 기능은 주어진 텍스트를 출력하는 동안 터미널의 배경색을 일시적으로 설정 한 다음 터미널을 기본 전경 및 배경색으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">이 기능은 주어진 텍스트를 출력하는 동안 터미널의 전경색을 임시로 설정 한 다음 터미널을 기본 전경색과 배경색으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">GHC가 프로파일 링 된 객체 코드를로드하여 스플 라이스를 실행할 때 사용할 수 없기 때문에 Template Haskell 코드가 포함 된 다중 모듈 프로그램이 있고 프로파일 링을 위해 컴파일해야하는 경우 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">이 변경 사항은 메인 모듈에만 적용됩니다. 다른 모듈은 &lt;code&gt;-main-is&lt;/code&gt; 플래그에 관계없이 여전히 기본 내보내기 목록에서 &lt;code&gt;main&lt;/code&gt; 을 내 보냅니다 . 이 예제에서와 같이 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 다른 진입 점을 가리키는 경우에도 &lt;code&gt;-main-is&lt;/code&gt; 를 기본 내보내기 목록을 통해 &lt;code&gt;main&lt;/code&gt; 을 내보내는 기존 모듈 에서 &lt;code&gt;-main-is&lt;/code&gt; 를 사용할 수 있습니다 ( -main-is MainWrapper.program로 컴파일 됨 ).</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">이 클래스에는 &lt;em&gt;용어에&lt;/em&gt; 포함 된 정보에서 두 가지 유형의 동등성을 배울 수있는 유형이 포함되어 있습니다 . 일반적으로이 클래스에는 단일 유형 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">이 클래스는 형식 수준의 자연과 관련된 정수를 제공합니다. 모든 구체적인 리터럴에는 0, 1, 2 등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">이 클래스는 유형 수준 기호와 관련된 문자열을 제공합니다. 모든 구체적인 리터럴에는 &quot;hello&quot;등의 클래스 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">이 클래스는 FlexibleInstances가 없기 때문에 Haskell98 호환성 해결 방법으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">이 클래스는 재귀의 번역에 사용되는 &lt;code&gt;do&lt;/code&gt; GHC와 포옹 지원 표기.</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">하나의 인스턴스 만있는이 클래스 는 구체적 유형 인 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이 유형 클래스 인스턴스로 허용되지 않는다는 사실에 대한 임시 해결책으로 사용됩니다 . 역 호환성을 위해 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">이 코드 조각은 치명적인 오류를 유발해야하지만 다음과 같은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍 을 이루도록 보장합니다 . (이 코드를 직접 작성하는 것보다 사용하는 것이 좋습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 일반적인 패턴을 추상화하는 대괄호).</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">이 코드 는 중요한 부분에 대한 비동기 예외를 마스킹 하여 &lt;code&gt;acquire&lt;/code&gt; 이 &lt;code&gt;release&lt;/code&gt; 와 쌍을 이루도록합니다. (이 코드를 직접 작성하는 대신 일반 패턴을 추상화하는 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="3494ba5905a6ab7393145cd907a3ba47ca64dbf3" translate="yes" xml:space="preserve">
          <source>This code is in the style of both transformers and mtl, and is compatible with them, though doesn't mimic the module structure or offer the complete range of features in those packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합기는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 의 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 결합자는 선택을 구현합니다. 파서 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 먼저 &lt;code&gt;p&lt;/code&gt; 를 적용 합니다. 성공하면 &lt;code&gt;p&lt;/code&gt; 값 이 반환됩니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 실패 &lt;em&gt;모든 입력을 사용하지 않고&lt;/em&gt; , 파서 &lt;code&gt;q&lt;/code&gt; 는 시도됩니다. 이 연결자들은 동일한 정의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 용 의 부재 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 의 클래스 및 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 부재) &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">이 결합자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 으로 표현됩니다 . 사용자 정의 토큰 스트림을 승인하는 데 사용됩니다. 예를 들어, 소스 위치로 구성된 기본 토큰 스트림이 있다고 가정하십시오. 그런 다음 단일 토큰을 허용하는 파서를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">이 결합기는 임의의 미리보기가 필요할 때마다 사용됩니다. &lt;code&gt;p&lt;/code&gt; 가 실패 할 때 입력을 소비하지 않은 것처럼 가장하기 때문에 ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) 결합기는 입력을 소비하면서 첫 번째 파서가 실패한 경우에도 두 번째 대안을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">이 명령을 사용하면 적절한 터미널 대신 파이프를 통해 상호 작용할 때에도 GHCi에서 명령 완료를 요청할 수 있으며 GHCi의 완료를 텍스트 편집기 및 IDE와 통합하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">이 명령은 편집기 및 IDE에서 식별자의 모든 사용을 강조 표시하고 탐색하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 goto-definition 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">이 명령은 GHCi를 텍스트 편집기 및 IDE와 통합하여 show-type-under-point 기능을 제공 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">이 계산은 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 예외 중 하나와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a53acc002bbe269420ba165928d4d81ea8f10ab" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">이 계산은 다음과 같이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">이것은 외부 호출과 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 의 상호 작용과 관련이 있습니다. 일반적으로 &lt;code&gt;throwTo&lt;/code&gt; 의 대상이 외래 통화에 관련된 경우에는 통화가 돌아올 때까지 그리고 발신자가 차단 될 때까지 예외가 발생하지 않습니다. 이로 인해 응답하지 않을 수 있으며 이는 사용자 인터럽트 (예 : Control-C)의 경우 특히 바람직하지 않습니다. Control-C 신호가 수신 될 때 ( UNIX의 &lt;code&gt;SIGINT&lt;/code&gt; ) 기본 동작 은 기본 스레드에서 &lt;code&gt;UserInterrupt&lt;/code&gt; 예외를 발생시키는 것입니다. 그 때 메인 스레드가 외래 호출에서 차단되면 프로그램은 사용자 인터럽트에 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">이 조건은 유형별로 확인되지 않습니다. 제공된 값이 유효한 전체 주문인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">이렇게하면 문자열이 변환되지만 공백을 줄 바꿈 불가능으로 유지하고 입력 목록의 각 문자열 사이에 줄 바꿈을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">이것은 문자열을 변환하지만 공백을 줄 바꿈 불가능한 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">이받는 대응 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 연산에 의해 제공되는 &lt;code&gt;base&lt;/code&gt; 의 &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;수치의&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="b849491aac2caa06d22e6da0aa56daf804da18ae" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">이것은 현재</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">이 데이터 유형은 동등성 관계를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;a&lt;/code&gt; 유형 의 값에서 작동하는 연산자를 지정 합니다 . 연산자는 이진 접두사 또는 단항 접두사 또는 접미사입니다. 이항 연산자에는 관련 연관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">이 데이터 유형은 연산자의 연관성을 지정합니다 (왼쪽, 오른쪽 또는 없음).</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 로 점진적 으로 상승하는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">이 데이터 유형 &lt;code&gt;G&lt;/code&gt; 는 종류와 유형이 모두 GADT와 유사합니다. &lt;code&gt;g :: G a&lt;/code&gt; 있고 &lt;code&gt;a :: k&lt;/code&gt; 가 있다고 가정하십시오 . 그런 다음 &lt;code&gt;g&lt;/code&gt; 가 실제로 &lt;code&gt;GMaybe&lt;/code&gt; 임을 발견하기 위해 패턴 일치 는 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 과 &lt;code&gt;a ~ Maybe&lt;/code&gt; 를 알려줍니다 . &lt;code&gt;G&lt;/code&gt; 에 대한 정의 는 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 유효 해야 하지만 &lt;code&gt;G&lt;/code&gt; 에서의 패턴 일치는 &lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt; 넘어서는 확장이 필요하지 않습니다 . 이 작업은 실제로 일반 GADT의 간단한 확장이며 종류와 유형이 동일하다는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">이 데이터 유형은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 의해 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 의 버퍼 별 버퍼 실행을위한 공통 인터페이스 역할을합니다 . 이 인터페이스의 일반적인 사용자는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;enumerator&lt;/code&gt; 와 같은 iteratee 스타일 라이브러리 입니다.</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">이 디코더는 모든 입력을 읽어야 리턴 할 수 있다는 단점이 있습니다. 반면, 디코더 오류없이 디코딩 할 수 있다는 것을 알기 전까지는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 운영 체제를 기반으로 조건부 컴파일을 허용합니다. 여기서 ⟨os⟩는 현재 운영 체제의 이름입니다 (예 : &lt;code&gt;linux&lt;/code&gt; , Windows의 경우 &lt;code&gt;mingw32&lt;/code&gt; , &lt;code&gt;solaris&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">이 정의는 호스트 아키텍처를 기반으로 조건부 컴파일을 허용합니다. 여기서 &quot;arch⟨는 현재 아키텍처의 이름입니다 (예 : &lt;code&gt;i386&lt;/code&gt; , &lt;code&gt;x86_64&lt;/code&gt; , &lt;code&gt;powerpc&lt;/code&gt; , &lt;code&gt;sparc&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">이 정의는 &lt;code&gt;f1&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; 에서 엄격 하게 만드는 반면, 뱅이 없으면 게으를 것입니다. 강타 패턴은 물론 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">이는 일반적인 &lt;code&gt;deriving&lt;/code&gt; 조항 과 거의 동일한 방식으로 컨텍스트가 추론 되는 파생 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 인스턴스를 나타냅니다 . 독립형 &lt;code&gt;deriving&lt;/code&gt; 선언 에서 와일드 카드를 사용 하는 것은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 완전한 액세스를 제공합니다 . 따라서 지정된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 내용을 덮어 쓰지 않도록 각별히주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 액션을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때는 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다&lt;/em&gt; . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게하는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">이 디자인은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 구현에 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 전체 액세스 권한을 제공합니다 . 따라서 주어진 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 외부의 어떤 것도 덮어 쓰지 않도록 최대한주의해야합니다 . 또한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 적으로 투명 하도록 추가주의를 기울여야합니다 . 의 의견을 참조 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 자세한 내용은 기능을. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현할 때 &lt;em&gt;안전 벨트&lt;/em&gt; 가 &lt;em&gt;전혀 없습니다.&lt;/em&gt; 작업을 . Haskell 서버에서 다음 버퍼 오버플로 공격을 가능하게 할 수있는 코드를 작성하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">이 차이점은 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 의&lt;/a&gt; 작동 방식 때문에 중요 합니다. 파생 된 &lt;code&gt;Functor Right&lt;/code&gt; 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35e478384f40b7a1e661dbe9f918af72fd276223" translate="yes" xml:space="preserve">
          <source>This distinction is only meaningful for monads which have multiple exit points, such as &lt;code&gt;Except&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt;. For monads that only have a single exit point, there is no difference between &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; has a more constrained type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">런타임 경로는 포함되지 않습니다. 표준 위치 또는 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수가 제공하는 디렉토리에서 사용 가능한 공유 라이브러리에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">더 이상 작동하지 않습니다. 가정하자 모듈 &lt;code&gt;C&lt;/code&gt; 의 수입 모듈 &lt;code&gt;B&lt;/code&gt; 를 , 및 &lt;code&gt;B&lt;/code&gt; 의 수입 모듈 &lt;code&gt;A&lt;/code&gt; . 모듈의 변경 그래서 &lt;code&gt;A&lt;/code&gt; 는 모듈이 필요할 수 있습니다 &lt;code&gt;C&lt;/code&gt; 를 컴파일하고, 따라서하면된다 &lt;code&gt;A.hi&lt;/code&gt; 은 우리가 여부를 확인해야합니다 변경 &lt;code&gt;C&lt;/code&gt; 가 다시 컴파일해야합니다. 그러나 &lt;code&gt;C&lt;/code&gt; 의 종속성은 &lt;code&gt;B.hi&lt;/code&gt; 가 아닌 &lt;code&gt;A.hi&lt;/code&gt; 만 나열 하며 &lt;code&gt;A&lt;/code&gt; 에 대한 일부 변경 사항 ( &lt;code&gt;B&lt;/code&gt; 에서 내 보낸 함수의 인라인에 나타나는 함수의 정의 변경 )은 &lt;code&gt;B.hi&lt;/code&gt; 변경하지 않을 수 있습니다 . 안녕 하나 그래서 지금&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">변수 &lt;code&gt;x&lt;/code&gt; 가 표현-다형 적 유형을 가질 것이기 때문에 이것은 &lt;code&gt;bad&lt;/code&gt; 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">이것은 코드 생성기의 조립 단계에서 바로 가기를 가능하게합니다. 간단히 말하면 단축 명령은 명령 블록 A가 무조건 점프로만 구성된 경우 A의 후속 점프로 점프하여 A에 대한 모든 점프를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">이 인코딩은 어느 방향으로도 실패하지 않습니다. 그러나 인코딩하면 정보가 삭제되므로 인코딩 다음에 디코딩하는 것이 ID가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">이 인코딩은 바이트 시퀀스 &quot;xc0x80&quot;을 사용하여 NUL을 나타내며 문자열은 NUL로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이를 통해 Bifold의 각 단계가 적용되기 전에 약한 머리 정상적인 형태로 강요되어 다른 방식으로 발생하는 뭉크의 수집을 피할 수 있습니다. 이것은 종종 유한 구조를 단일 모 놀리 식 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ) 로 엄격하게 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것은 접힘의 각 단계가 적용되기 전에 약한 머리 정상 형태로 강요되도록 보장하고, 그렇지 않으면 발생하는 썽크의 수집을 피합니다. 이것은 종종 유한리스트를 하나의 단일 결과 (예 : &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ) 로 엄격히 줄이려는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">이 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">이를 통해 모듈을 신뢰할 수 있지만 모듈 작성자가 보증을 제공합니다. 그런 다음이 모듈의 클라이언트는 모듈을 포함하는 패키지를 신뢰하도록 지정하여 모듈 작성자를 신뢰하도록 지정합니다. &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 은 모듈을 안전한 언어로 제한하지 않습니다. 그러나 &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;안전한 중복 인스턴스&lt;/a&gt; 만 허용하도록 중복 인스턴스의 해상도를 제한합니다 . 또한 안전한 가져 오기 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">이 예제는 이스케이프 연속이 작동하는 방식을 보여주고 사용법에 대한 일반적인 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">이 예는 다음 중 하나의 컷 다운 버전입니다.</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">이 예제는 &lt;code&gt;Type&lt;/code&gt; 생성자를 직접 사용한 경우 훨씬 복잡한 구성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">이 예제는 &lt;code&gt;Functor&lt;/code&gt; 만 필요합니다. Functor 는 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 변환되기 때문입니다 . 더 복잡한 예제에는 &lt;code&gt;Applicative&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">이 예제는 생성자에 포함 된 값을 신경 쓰지 않을 때 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 를 사용하여 패턴 일치를 피하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">이 예는 사용 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 마이크로 소프트 워드의 기능을하지만, 제공 &lt;code&gt;HsStart&lt;/code&gt; 는 첫 번째 함수 전에 호출되며, &lt;code&gt;HsEnd&lt;/code&gt; 이 지난 후, 다음 그것을 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예는 원본 Concurrent Haskell 논문에서 수정되었습니다. 상위 레벨 동기화 프리미티브를 빌드하는 데 사용되는 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 의 더 많은 예는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">이 예제는 다음 예제에서 알 수 있듯이 명령문에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">이 예외는 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 를 호출하는 다른 스레드 또는 어떤 이유로 스레드를 종료해야하는 경우 시스템에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">이 예외는 사용자가 일반적인 메커니즘 (예 : 콘솔의 Control-C)을 통해 프로그램 종료를 요청하면 프로그램의 기본 스레드에서 기본적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">이 확장을 통해 프로그래머는 &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;IntMap&lt;/code&gt; , &lt;code&gt;Vector&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 및 &lt;code&gt;Array&lt;/code&gt; 와 같은 구조 구성에 목록 표기법을 사용할 수 있습니다 . 다음 코드 목록은 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">이 확장을 통해 모든 형식의 제약 조건을 작성할 수 있습니다 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 는 &lt;code&gt;(==)&lt;/code&gt; 방법 의 두 번째 사용법에서 발생하는 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 제약 조건 을 해결하는 데 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">이 확장을 사용하면 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#type-instance-declarations&quot;&gt;형식 인스턴스 선언&lt;/a&gt; , &lt;a href=&quot;#closed-type-families&quot;&gt;닫힌 형식 패밀리&lt;/a&gt; , &lt;a href=&quot;#assoc-inst&quot;&gt;연결된 인스턴스&lt;/a&gt; 및 &lt;a href=&quot;#rewrite-rules&quot;&gt;다시 쓰기 규칙&lt;/a&gt; 에서 형식 및 종류 변수를 명시 적으로 수량화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">이 확장은 또한 데이터 계열 인스턴스에 대한 일부 제한 사항을 완화합니다. 특히 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;newtype instance&lt;/code&gt; 에 &lt;code&gt;Type&lt;/code&gt; 뿐만 아니라 &lt;code&gt;TYPE r&lt;/code&gt; 의 반환 종류를 제공하도록 허용합니다 . 예를 들어, 다음 &lt;code&gt;newtype instance&lt;/code&gt; 선언이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">이 확장은 다음 위치에서 종류 서명을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">이 확장은 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을 일반화&lt;/a&gt; 합니다. GND 를 사용하여 &lt;code&gt;Num Unicode&lt;/code&gt; 를 파생 시키려면 ( &lt;code&gt;deriving newtype Num&lt;/code&gt; ) &lt;code&gt;Num Int&lt;/code&gt; 인스턴스를 재사용해야합니다 . 함께 &lt;code&gt;DerivingVia&lt;/code&gt; , 우리는 명시 적으로 표현 유형을 지정할 수 있습니다 &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">이 확장은 새 유형에 완전한 사용자 지정 종류 서명 (CUSK)이 있는지 여부를 결정하는 데 영향을줍니다. 정확한 영향은 &lt;a href=&quot;#complete-kind-signatures&quot;&gt;CUSK 섹션에 명시되어 있습니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">이 확장은 &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MHC (MonadFail Proposal)&lt;/a&gt; 아래 GHC 8.6.1부터 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">이 확장은 일시적이며 이후 릴리스에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">이 기능은 GHC 8.0.x에서 실험 중이지만 이후 릴리스에서 기본값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">이 기능은 더 이상 GHC에 없지만 다시 쓰기 규칙을 사용하면 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">이 기능은 GHC와 함께 제공되는 핵심 라이브러리 외부에서 사용하기위한 것이 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC 개발자 위키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee160906b857c67fe57bb11a964fcfc779b0e3a" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">이 기능은 GHC와 함께 제공되는 핵심 라이브러리 외부에서 사용하기위한 것이 아닙니다. 자세한 내용은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC 개발자 위키를&lt;/a&gt; 참조하세요. .</target>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">이 기능은 GHC 7.4.1에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 또한 중괄호 안에 &lt;em&gt;유추 된&lt;/em&gt; 유형 변수를 인쇄 할 수있게합니다 . &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;유추 된 변수와 지정된 형식 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">이 플래그는 콜론으로 구분 된 &lt;code&gt;dirs&lt;/code&gt; 목록을 검색 경로에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">이 플래그는 모듈의 선언 된 안전 속성 (Safe, Unsafe, Trustworthy)을 무시하도록 활성화 될 수 있으므로 이러한 플래그가 지정되지 않은 것처럼 컴파일이 진행됩니다. 이는 플러그인을 사용하여 컴파일 할 때 특히 유용하며, 일반적으로 컴파일 된 모듈이 안전하지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">이 플래그는 토글의 제안 또는 유형 적용을 표시하지 않음으로써 유효한 홀 맞춤 제안의 상세를 줄이기 위해 토글 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">이 플래그를 전환하여 유효한 구멍 맞춤 표시를 완전히 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 플래그를 의미하며, 이는 &lt;a href=&quot;#typed-holes&quot;&gt;형식화 된 구멍&lt;/a&gt; 및 변수에 대해이 동작을 가능하게 합니다. 원하는 경우 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 지정 하여 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; 를 활성화하지 않고 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 를 활성화 할 수 있습니다. -fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; 플래그 다음에 명령 행에서 -defer-out-of-scope-variables .</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">이 깃발은 해커 영토입니다. 이 플래그의 주요 목적은 새로운 코드 레이아웃 알고리즘을 쉽게 디버깅하고 조정할 수 있도록하는 것입니다. 더 나은 결과를 제공하는 값이 다음 릴리스에서 더 나 빠지지 않을 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">이 플래그는 정의가 인라인되지 않은 이유를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">이 플래그는 실행하려는 규칙이 실행되지 않는 이유를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="913346e87539751c35ed9c7fbbe9dacd336e394e" translate="yes" xml:space="preserve">
          <source>This flag offers a workaround, albeit a slightly convoluted one. To be able to load an object file outside of the low 2Gb, the object code needs to be compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt;. When the &lt;code&gt;+RTS -xp&lt;/code&gt; flag is passed, the linker will assume that all object files were compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and load them anywhere in the address space. It&amp;rsquo;s up to you to arrange that the object files you load (including all packages) were compiled in the right way. If this is not the case for an object, the linker will probably fail with an error message when the problem is detected.</source>
          <target state="translated">이 플래그는 약간 복잡하지만 해결 방법을 제공합니다. 낮은 2Gb 외부에서 객체 파일을로드하려면 객체 코드를 &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 로 컴파일해야합니다 . 때 &lt;code&gt;+RTS -xp&lt;/code&gt; 플래그가 전달되고, 링커는 모든 오브젝트 파일로 컴파일 된 것으로 가정합니다 &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 과 주소 공간에서 어디를로드합니다. 로드하는 개체 파일 (모든 패키지 포함)이 올바른 방식으로 컴파일되었는지는 사용자가 결정합니다. 개체에 해당하지 않는 경우 링커는 문제가 감지 될 때 오류 메시지와 함께 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-Wundef&lt;/code&gt; 를 C 전 처리기 (사용중인 경우)에 전달 하여 정의되지 않은 식별자 에서 &lt;code&gt;#if&lt;/code&gt; 지시문의 사용에 대해 전처리 기를 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">이 플래그는 런타임시 공유 라이브러리를 찾기위한 여러 모드 중 하나를 선택합니다. 각 모드에 대한 설명은 &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;런타임시 공유 라이브러리 찾기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="707ef7038c152a9d95c30f93e519ab392f0434e0" translate="yes" xml:space="preserve">
          <source>This flag sets the size (in bytes) threshold above which the second approach is used. You can disable the second approach entirely by setting the threshold to 0.</source>
          <target state="translated">이 플래그는 두 번째 방법이 사용되는 크기 (바이트) 임계 값을 설정합니다. 임계 값을 0으로 설정하여 두 번째 접근 방식을 완전히 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">이 플래그는 열 0의 백 스페이스가 커서를 이전 행의 마지막 열로 랩핑하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">이 플래그는 커서가 한 행의 마지막 열에서 다음 행의 첫 번째 열로 자동 랩핑되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">이 플래그 는 랩 어라운드를 야기하는 문자가 제어 문자 일 때 터미널이 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; 스타일 랩핑을 수행하지 않도록 지정합니다 . 이것을 &quot;뉴 라인 글리치&quot;또는 &quot;매직 랩&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">이 플래그는 GHC에게 공유 Haskell 라이브러리에 연결하도록 지시합니다. 이 플래그는 현재 대상의 형식이 아닌 종속 라이브러리의 선택에만 영향을줍니다 (-shared 참조). &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;공유 라이브러리&lt;/a&gt; 작성 방법에 대한 공유 라이브러리 사용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">이 플래그는 단순히 &lt;code&gt;-k&lt;/code&gt; 였지만 GHC 7.2.1에서는 &lt;code&gt;-ki&lt;/code&gt; 로 이름이 바뀌 었습니다 . 이전 이름은 이전 버전과의 호환성을 위해 여전히 허용되지만 이후 버전에서는 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">명시 적 내보내기 목록을 선언하지 않고 모듈을 선언하면이 플래그가 경고합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">이 플래그는 범위로 가져온 엔티티를 명시 적으로 나열하지 않는 규정되지 않은 &lt;code&gt;import&lt;/code&gt; 선언을 사용하는 경우 경고합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">이 플래그는 유형이 해제되지 않은 변수를 바인딩하는 패턴을 작성할 때마다 경고하지만 패턴은 뱅 패턴이나 베어 변수가 아닙니다. 언 리프트 &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;타입에&lt;/a&gt; 대한 정보는 언 박스 타입 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cae0b42613ae5635daabfb73c1fd1a6fde87c094" translate="yes" xml:space="preserve">
          <source>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</source>
          <target state="translated">이 플래그는 올바르게 구현되지 않았으며 이제 더 이상 사용되지 않습니다. 이후 버전의 GHC에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">이 양식은 &lt;code&gt;INLINABLE&lt;/code&gt; (아마도 전문화 가능) 로 표시된 가져온 함수를 특수화되지 않은 다른 함수를 호출하여 특수화 할 수없는 경우를 포착하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">이 형식은 이전 형식과 유사하지만 f의 첫 번째 인수로 전달되는 함수를 작성할 수 있습니다. 결과적으로 f는 모든 유형을 가져야합니다 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 입니다. 유형에서 볼 수 있듯이이 기능을 사용하면 변환중인 목록의 요소에서 일부 정보를 &quot;투영&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">이 함수는 선택적 선행 부호 문자와 하나 이상의 10 진수를 허용합니다. 후행 &lt;code&gt;'.'&lt;/code&gt; 을 제외 하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 함수에서 허용하는 구문과 유사한 구문 입니다. 또는 &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;하지&lt;/em&gt; 뒤에 숫자가 소모되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f4a157f15275b0104f4661492b13677fdbb6264" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 종료 자를 추가합니다 . 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 종료 자를 추가합니다 . 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">이 함수는 주어진 외부 객체에 종료자를 추가합니다. 종료 자는 이미 등록 된 동일한 객체에 대해 다른 모든 종료 자 &lt;em&gt;보다 먼저&lt;/em&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">이 함수 는 스레드 RTS를 사용할 때 항상 현재 스레드의 이벤트 관리자 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 반환 하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 반환 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">이 함수는 다음과 같이 정의 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">이 함수 는 입력 영역을 미리 채운다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; 과 정확히 동일한 방식으로 작동 합니다. 입력 영역에있는 텍스트는 두 개의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이 있는 2 개의 튜플로 제공됩니다 . 튜플의 왼쪽에있는 문자열 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; 를 호출하여 획득 )은 커서 왼쪽에 표시되고 오른쪽에있는 문자열 ( &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; 를 호출하여 획득 )은 커서 오른쪽에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7f64006d44420f7d5449007f9ad343dd8f086e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">이 기능은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다. EOF에 도달하면이 함수는 예외를 발생시키는 대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">이 함수는 특히 파일 이름 자체에 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 보다 예측 가능할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">이 함수는 특히 파일 이름 자체에 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 보다 예측 가능할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">이 함수는 명령 행 인수를 구문 분석하고 분할 된 인수를 목록의 요소로 리턴하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">이 함수 는 한 유형별로 매개 변수화 된 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 을 다른 유형으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 선행 부호 문자를 처리하지 않습니다. 부호있는 입력을 처리해야하는 경우 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 함수는 복사를 전혀 수행하지 않고 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 풀어 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 으로 표시합니다 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; 두 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">이 기능은 제로 복사를 수행하고, 단지 펼쳤다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; A와 나타나는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a47c3f2d7d39a2c3b063895b58a717924193e65c" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 함수는 제로 복사를 수행하고 단순히 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 래핑 해제 하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 으로 표시합니다 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; 두 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="c7536fe5974322621a8dd1f75ea634bfbda36cef" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">이 기능은 제로 복사를 수행하고, 단지 펼쳤다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; A와 나타나는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 . 그것은이다 &lt;em&gt;안전하지 않은&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">이 기능은 해당 이물질이 일련의 IO 동작에서 지정된 위치에 존재하도록합니다. 특히 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 은 사용자 조치를 실행 한 후 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="826e259566faf8425ada2d502fd2ea8be00aa816" translate="yes" xml:space="preserve">
          <source>This function exists because in order to thread their effects through the execution of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, monad transformers need values to be threaded from &lt;code&gt;use&lt;/code&gt; to &lt;code&gt;release&lt;/code&gt; and from &lt;code&gt;release&lt;/code&gt; to the output value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">이 함수는 외부 포인터의 포인터 구성 요소를 추출합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 에 대한 인수가 지정된 외부 포인터의 마지막 사용 발생 인 경우 종료자가 실행되어 방금 얻은 일반 포인터가 무효화되는 것처럼 잠재적으로 위험한 작업 입니다. 따라서 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 은 포인터의 위치가 보장되어야 할 때마다 사용해야합니다. 즉, 다른 사용법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">이 함수는 외부 포인터의 포인터 구성 요소를 추출합니다. &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 에 대한 인수가 지정된 외부 포인터의 마지막 사용 발생 인 경우 종료자가 실행되어 방금 얻은 일반 포인터가 무효화되는 것처럼 잠재적으로 위험한 작업 입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 은 포인터의 위치가 보장되어야 할 때마다 사용해야합니다. 즉, 다른 사용법이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많으면 더 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; 의 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많거나 스트림이 제공된 수만큼 길어서 더 효율적일 경우 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 결과와 비교할 때와 같은 대답을 제공 하지만 문자 수가 숫자보다 많으면 더 단락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">이 기능은 한동안 &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; 모듈 에서 사용 가능했으며 버전 1.2.1.0부터 &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; 모듈의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 정지 된 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 정지 된 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">이 기능은 두 가지 방식으로 &lt;em&gt;안전하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">동일한 기본 페이지를 참조하는 다른 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이있을 수 있으므로이 함수는 &lt;em&gt;안전하지 &lt;/em&gt;않습니다 . 이것을 사용 하면 기본 바이트 배열에서 생성 된 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 더 이상 유효 하지 않다는 증거가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;안전하지&lt;/em&gt; 않습니다. 첫 번째 인수가 가리키는 기본 버퍼를 수정하여 참조 투명성을 해제 할 수 있습니다. 원래 버퍼에 대한 변경 사항은 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을가 나중에 수정이 변경 사항이 결과에 반영됩니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 참조 투명성을 깨고.</target>
        </trans-unit>
        <trans-unit id="1834d9d84b56bb752c51f02a1d644b2b93d96323" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 경우 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을가 나중에 수정이 변경 사항이 결과에 반영됩니다 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 참조 투명성을 깨고.</target>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 나중에 수정하면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명성을 손상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 을 나중에 수정하면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명성을 손상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f349071f25d8991d866f99530006dd7090d11a0c" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 이 나중에 수정되면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영됩니다. 참조 투명도가 깨집니다.</target>
        </trans-unit>
        <trans-unit id="e7b49b304d9d1b37bde4bfa9bfeb7383e8f4a58d" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 이 나중에 수정되면이 변경 사항이 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 반영되어 참조 투명도가 깨집니다.</target>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 이 가리키는 버퍼를 수정하면 이 수정 내용이 결과 &lt;code&gt;ByteString&lt;/code&gt; 에 반영되어 참조 투명성이 손상 됩니다.</target>
        </trans-unit>
        <trans-unit id="ce62a4da0ca7ff6594e5735e96a49ced57bae709" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">이 기능은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . 원래 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 가리키는 버퍼를 수정하면 이 수정이 결과 &lt;code&gt;ByteString&lt;/code&gt; 에 반영되어 참조 투명성이 깨집니다.</target>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 와 거의 동일합니다 . 유일한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">finalizer를 두 번 호출하여 &lt;em&gt;double free&lt;/em&gt; 오류가 발생하거나 &lt;code&gt;malloc&lt;/code&gt; 으로 할당되지 않은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 에 전달하면 이 함수도 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="725d98580cd2d533b5eb08b0b83d5983bcb4d0b9" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">이 함수는 종료자를 두 번 호출하여 &lt;em&gt;이중 자유&lt;/em&gt; 오류가 발생하거나 &lt;code&gt;malloc&lt;/code&gt; 로 할당되지 않은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 을 전달하는 경우 에도 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 제거되어 더 이상 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 와 같습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 터미널에 연결되어 있고 에코가 활성화 된 경우 터미널 스타일 상호 작용을 사용합니다. 그렇지 않으면 (예 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 이 파이프 인 경우) 파일 스타일 상호 작용을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="925f47def99f594f17042330b2cb3a4074f9cfdc" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">이 함수는 일반적인 unsafeInterleaveST와 동일하지만 인라인되어 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">이 함수는 코드 크기가 크더라도 할당 전략과 융합 할 수 있도록 인라인되어 있습니다. 예를 들어, 기본 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 함수 &lt;code&gt;toLazyByteString&lt;/code&gt; 은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">이 함수는 코드 크기가 크더라도 할당 전략과 융합 할 수 있도록 인라인되어 있습니다. 예를 들어, 기본 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 함수 &lt;code&gt;toLazyByteString&lt;/code&gt; 은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">이 함수는 대소 문자를 구분하지 않고 대소 문자를 구분하지 않는 문자열 비교를 수행 할 때 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">이 함수는 주로 대소 문자를 구분하지 않거나 대소 문자를 구분하지 않는 문자열 비교를 수행하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">이 기능은 모든 응용 프로그램 수준 정리 처리기에서 호출하기위한 것입니다. 프로세스를 종료하고 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">이 기능은 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 보다 효율적 입니다. 많은 경우 버퍼 할당을 수행 할 필요가 없기 때문에 toLazyByteString . 또한 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 여러 실행 결과 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 버퍼에 연결 되므로 불필요한 버퍼 플러시를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af91de3226aaac03a1110fced423ab247dd1f835" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">이 함수는 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 보다 효율적 입니다. toLazyByteString 은 대부분의 경우 버퍼 할당을 수행 할 필요가 없기 때문입니다. 또한 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 여러 실행 결과가 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 버퍼에 연결되어 불필요한 버퍼 플러시를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 의 작업을 사용하여 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 가리키는 개체와 데이터를 마샬링하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스 의 작업을 사용하여 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 가리키는 개체와 데이터를 마샬링하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; 및 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 경우에만 정의됩니다 (참고 : 문서에서는 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; 만 지원 한다고 주장 하지만 실제 구현은 최대 256을 지원합니다).</target>
        </trans-unit>
        <trans-unit id="1f0db6399242ab25312fe9ac2fbde674ee7aa2e5" translate="yes" xml:space="preserve">
          <source>This function is runtime-representation polymorphic, but the &lt;code&gt;RuntimeRep&lt;/code&gt; type argument is marked as &lt;code&gt;Inferred&lt;/code&gt;, meaning that it is not available for visible type application. This means the typechecker will accept &lt;code&gt;coerce @Int @Age 42&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 메모리 영역을 해제하는 종료자가 연결된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 메모리 영역을 해제하는 종료자가 연결된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리 영역을 해제하는 종료 장치가 첨부 된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리 영역을 해제하는 종료 장치가 첨부 된 메모리 영역을 생성합니다. &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 , 메모리 블록이 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 에 의해 할당되었음을 보장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리 크기가 명시 적으로 여러 바이트로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; 이없는 내부적으로 최적화 된 ForeignPtr 표현이 사용된다는 점을 제외하고 mallocForeignPtrAlignedBytes 와 유사합니다 . 종료자를 추가하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 이없는 내부적으로 최적화 된 ForeignPtr 표현이 사용된다는 점을 제외하면 mallocForeignPtrBytes 와 유사합니다 . 종료자를 추가하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">이 함수는 필요한 메모리의 크기와 정렬이 명시 적으로 바이트 수로 제공된다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;needle&lt;/code&gt; 에서 엄격하고 &lt;code&gt;haystack&lt;/code&gt; 덩어리에서 게으르다 (가능한 한) .</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">이 함수는 첫 번째 인수에서 엄격하고 두 번째 인수에서 게으르다.</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">이 함수는 계산 결과가 엄격하고 바이트 쓰기가 게으 릅니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 순수 코드에서 사용하기에 적합합니다. IO 컨텍스트에서는 대신 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">반환 된 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 의 유형 이 예상 한 유형과 일치하지 않으면 프로그램 동작이 정의되지 않으므로이 함수는 안전 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 리터럴 을 구성하기 위해 GHC에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">이 함수는 GHC에서 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 리터럴 을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">이 기능은 예를 들어 자녀가 종료 될 때 부모에게 알리는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">이 기능은 멀티 스레드 프로그램에서 안전한 방식으로 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 를 사용하는 데 유용합니다 . 하나만있는 경우 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 사용하여 다음을 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 를 액세스하고 수정이 경쟁 조건을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 cTRL_C_EVENT 핸들러를 설정하려고 할 때 적합하지 않습니다. cTRL_C_EVENT 핸들러를 설정하려면 대신 &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">이 함수는 &quot;정확하지 않은 예외에 대한 의미론&quot;논문에서 제안한대로 하나의 예외를 다른 예외에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 가 정의 된 경우이 함수는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 로만 정의 된 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 인스턴스 와 함께 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; 를 사용하면 무한 재귀가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b30959a5096a71e3cec93cd57d2e51e397b263e" translate="yes" xml:space="preserve">
          <source>This function may be used to debug Haskeline's input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">이 기능은 참조 적으로 투명해야합니다. 즉, 동일한 크기의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 여러 번 호출 하면 동일한 바이트 시퀀스가 ​​작성되고 동일한 값이 계산되어야합니다. 변경 가능한 상태가 필요한 경우이 함수를 호출 할 때마다 새로 할당해야합니다. 무어 인 경우,이 함수는 연속이 완료되면 호출해야합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 의 모노 닉 시퀀싱이 작동하지 않습니다. 마지막으로,이 함수는 그것이 작성했다고 주장하는 모든 바이트에 써야합니다. 그렇지 않으면 결과 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 이 참조 투명성을 보장하지 않으며 민감한 데이터가 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">이 기능은 참조 적으로 투명해야합니다. 즉, 동일한 크기의 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 여러 번 호출 하면 동일한 바이트 시퀀스가 ​​작성되어야합니다. 변경 가능한 상태가 필요한 경우이 함수를 호출 할 때마다 새로 할당해야합니다. 무어 인 경우,이 함수는 연속이 완료되면 호출해야합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 연결이 작동하지 않습니다. 마지막으로,이 함수는 그것이 작성했다고 주장하는 모든 바이트에 써야합니다. 그렇지 않으면 결과로 생성 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 참조 투명성을 보장하지 않으며 민감한 데이터가 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">이 함수는 한 번에 청크를 읽고 각 판독에서 청크 크기를 증가시킵니다. 그런 다음 최종 문자열은 적절한 크기로 재 할당됩니다. 사용 가능한 메모리의 절반보다 큰 파일의 경우 메모리가 소진 될 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">이 함수는 한 번에 청크를 읽고 각 판독에서 청크 크기를 증가시킵니다. 그런 다음 최종 문자열은 적절한 크기로 재 할당됩니다. 사용 가능한 메모리의 절반보다 큰 파일의 경우 메모리가 소진 될 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">이 함수는 인수에 다음 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 중 하나가 있으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">이 함수는 인수에 다음 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 중 하나가 있으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 닫히거나 취소 된 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 에서 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">이 함수는 &lt;code&gt;node&lt;/code&gt; 유형의 값으로 레이블이 지정된 &lt;code&gt;key&lt;/code&gt; 유형의 정점이있는 그래프를 나타내는 인접 목록을 가져 와서 해당 목록 의 &lt;code&gt;Graph&lt;/code&gt; 기반 표현을 생성 합니다. &lt;code&gt;Graph&lt;/code&gt; 결과가 나타내는 &lt;em&gt;형상&lt;/em&gt; 주어진 정점의 라벨 인접한 정점을 검색하고, b) 방법 키 주어진 정점을 가져 오지 방법)의 그래프를, 상기 기능들은 설명합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">이 함수는 오류 메시지를 작성하는 데 사용할 추가 &lt;code&gt;String&lt;/code&gt; 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">프로세스 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 이외의 다른 경우이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 . 대신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 를 얻으려면 &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1318cc2b39b86c3da816e772a9967719bb468613" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">이 함수는 제한 조건 해결 프로세스에서 두 가지 지점에서 호출됩니다. 주어진 제한 조건을 단순화 한 후 및 원하는 제한 조건을 전개하지 않은 후. 두 단계는 도출 될 수 있고 원치 않는 것이 첫 번째 경우에 비어 있기 때문에 구별 될 수 있습니다. 각각의 경우 플러그인은</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">이 함수는 &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; 를 래핑 하는데, 여기에는 몇 가지 구현 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 과 같은이 함수 는 고정 된 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 목록 기반 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 기능을 일반화합니다 .</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">이는 Haskell 모듈 당 하나의 파일과 &lt;code&gt;hpc_index.html&lt;/code&gt; , &lt;code&gt;hpc_index_alt.html&lt;/code&gt; , &lt;code&gt;hpc_index_exp.html&lt;/code&gt; , &lt;code&gt;hpc_index_fun.html&lt;/code&gt; 색인 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c5344bdf0cc9457503d3d92a9eb3e0f2cb07653d" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;unpinned&lt;/a&gt;&lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">이는 &lt;code&gt;safe&lt;/code&gt; 외부 함수 호출에 힙 개체 참조를 전달하는 것이 안전하지 않다는 것을 의미하므로 라이브러리 작성자를 크게 제한합니다 . 예를 들어, &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;고정되지 않은 &lt;/a&gt; &lt;code&gt;ByteArray#&lt;/code&gt; 를 네이티브 코드에 직접 전달하여 불필요한 복사본을 만드는 것을 방지하는 것이 바람직합니다 . 그러나 이것은 호출 중에 가비지 수집기에 의해 배열이 이동되지 않도록 보장되는 경우에만 안전하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">이는 힙 객체 참조를 &lt;code&gt;safe&lt;/code&gt; 외부 함수 호출 에 전달하는 것이 안전하지 않기 때문에 라이브러리 작성자를 크게 제한합니다 . 예를 들어, 불필요한 복사를 피하기 위해 고정되지 않은 &lt;code&gt;ByteArray#&lt;/code&gt; 를 원시 코드로 직접 전달하는 것이 바람직합니다 . 그러나 이것은 호출 도중에 가비지 콜렉터가 배열을 이동시키지 않는 경우에만 안전하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 호출과 같은 효과를 갖는다 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 가진 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 함께, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 호출과 같은 효과를 갖는다 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 을 가진 &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 함께, &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">이것은 두 가지 효과가 있습니다. 첫 번째는 공유 라이브러리 버전의 Haskell 패키지 (예 : base)와 링크 될 수있는 방식으로 코드를 컴파일하는 것입니다. 두 번째는 링크 할 때 정적 버전이 아닌 패키지 라이브러리의 공유 버전에 대한 링크입니다. 분명히 패키지를 공유 라이브러리로 빌드해야합니다. 지원되는 플랫폼에서 GHC는 모든 핵심 패키지에 대한 공유 라이브러리와 함께 제공되지만 추가 패키지 (예 : Cabal)를 설치하는 경우 공유 라이브러리 ( Cabal의 경우 &lt;code&gt;--enable-shared&lt;/code&gt; ) 로 빌드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">이 아이디어는 매우 오래되었습니다. 파생 가능 &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;클래스&lt;/a&gt; 의 Seciton 7을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">이 구현은 &lt;code&gt;memset(3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">이 구현은 의도적으로 순진합니다. 인스턴스는 규모에 맞게 최적화 된 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">이는 단일 바이트 만 포함하더라도 출력 버퍼를 비우는 것을 의미합니다. 그러므로 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 만 대형 (위해 &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 들. 그렇지 않으면 생성 된 청크가 너무 조각화되어 나중에 효율적으로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">이는 단일 바이트 만 포함하더라도 출력 버퍼를 비우는 것을 의미합니다. 그러므로 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 만 대형 (위해 &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 들. 그렇지 않으면 생성 된 청크가 너무 조각화되어 나중에 효율적으로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 대부분의 프로그램에서 효율성이 약간 향상되지만 크게 향상되지는 않습니다. 이 가짜 &quot;최적화&quot;를 억제하려면 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">여기에는 주 스레드가 포함되므로 &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; 를&lt;/a&gt; 사용 하면 프로그램에서 사용중인 스택 공간을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">이것은 더 많은 데이터를 쓸 수 있음을 나타냅니다. 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 작업을 제공합니다 . 적절한 버퍼로 해당 조치를 호출해야합니다. int는 다음 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 작업에 필요한 &lt;em&gt;최소&lt;/em&gt; 버퍼 크기를 나타냅니다 . 즉, 다음 조치를 호출하면 최소한이 크기의 버퍼 길이를 제공 &lt;em&gt;해야합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">이 인라이닝은 호출에 대한 인수 나 &lt;code&gt;f&lt;/code&gt; 정의 크기에 관계없이 발생합니다 . 무조건적입니다. 주된주의 사항은 &lt;code&gt;f&lt;/code&gt; 의 정의가 컴파일러에 표시되어야한다는 것입니다. 따라서 GHC가 크기에 관계없이 전개를 기록 할 수 있도록 정의에 &lt;code&gt;INLINABLE&lt;/code&gt; pragma를 사용하여 기능을 표시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">플러그인을 코어-투-코어 패스로 삽입합니다. &lt;code&gt;-fplugin=(module)&lt;/code&gt; 과 달리 플러그인 모듈은 &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin을&lt;/a&gt; 호출하는 모듈과 동일한 패키지에 상주 할 수 없습니다 . 이런 식으로, 구현은 플러그인이 필요할 때까지 빌드 될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff50fa3f4d1717b720187c6141e26cd711cc26f" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">이렇게하면 플러그인이 코어 대 코어 패스로 삽입됩니다. &lt;code&gt;-fplugin=(module)&lt;/code&gt; 과 달리 플러그인 모듈은 &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin을&lt;/a&gt; 호출하는 모듈과 동일한 패키지에있을 수 없습니다 . 이러한 방식으로 구현시 필요한 시간에 플러그인이 빌드 될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">이 인스턴스는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 인스턴스 와 비슷한 고려 사항이 있습니다. 비효율적 인 비용으로 추상화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">이 인스턴스는 편의성과 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 일관성을위한 것 입니다. 이것은 WHNF가 함수의 NF와 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0eaa2be703bfed5db1962bf2e87d773ccbf9e44d" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">이 인스턴스는 편리하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 와의 일관성을위한 것 입니다. 이것은 WHNF가 함수의 NF와 동일하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">이 인스턴스는 생성자 &lt;code&gt;MkNT&lt;/code&gt; 가 범위 내에 있는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">이 인스턴스는 비효율적 인 비용으로 데이터 추상화를 유지합니다. 데이터 추상화를 위해 리플렉션 서비스를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">이 인스턴스는 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 동작을 복사하여 생성되었습니다 . &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; . 실수가 있다고 생각되면 언제든지 개선 사항을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 인스턴스는 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 동작을 복사하여 작성되었습니다 . &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 파생 된 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 파생 된 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; 필드가 제거 된 경우이 인스턴스는 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype 의 파생 인스턴스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7a50a4b488dfd0ceef47a8a415f99ee744d5ed8" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-ord#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe29b722781fc1de8c3cf834abcc1f449fc0a931" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">이렇게하면 사용 된 심볼뿐만 아니라 모든 심볼을 동적 심볼 테이블에 추가하도록 링커에 지시합니다. 현재 Linux 및 Windows / MinGW32 만 해당됩니다. 이는 Linux에서 &lt;code&gt;-optl -rdynamic&lt;/code&gt; 을 사용 하고 Windows에서 &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 링커가 위치 독립적 실행 파일을 생성하도록 지시합니다. 이 플래그는 실행 파일을 생성하는 동안에 만 유효하며 링크되는 모든 오브젝트 코드는 &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; &lt;/a&gt; 로 생성되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">이 인터페이스는 Niklas R&amp;ouml;jemo에서 파서 (parser)를 위해 도입되었습니다. 이는 수도원 인터페이스보다 더 많은 공유를 허용하기 때문입니다. 여기서 이름은 대부분 Doaitse Swierstra의 구문 분석 작업을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">이다 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; 의 인수가 튀 겼다.</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">이것의 &quot;안전한&quot;변종 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 은 USING &lt;code&gt;mpz_powm_sec()&lt;/code&gt; 부 채널 공격에 반발하도록 설계되고 따라서 암호화 애플리케이션을 위해 의도되는 기능.</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">이것은 6.2 및 이전 버전에 비해 동작이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 의 조합입니다 . 즉. &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에서 값을 가져 와서 다시 넣고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d6388ad09499896ee48a8e46a65f919073bd630f" translate="yes" xml:space="preserve">
          <source>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</source>
          <target state="translated">이는 유형 패밀리의 모든 응용 프로그램이 그 배열과 관련하여 완전히 포화되어야한다는 요구 사항의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">이것은 객체 파일에서 직접 링크를 시도 할 때 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; 의 좋은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">이것은 전 세계적으로 노출 된 패키지의 차이점으로부터 프로그램을 격리하는 좋은 방법이며 패키지 종속성에 대해 명시 적으로 설명하는 것이 좋습니다. Cabal은 항상 이런 이유로 &lt;code&gt;-hide-all-packages&lt;/code&gt; 플래그를 GHC에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">이 안내서는 &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; 언어를 위한 대화식 및 일괄 컴파일 시스템 인 Glasgow Haskell Compiler (GHC) 사용에 대한 안내서 입니다.</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">UTC로 측정 한 시간입니다. 정밀도는 10 ^ -12 초입니다.</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">이것은 시계로 측정 한 시간 길이입니다. 변환 함수는이를 초로 취급합니다. 정밀도는 10 ^ -12 초입니다.</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">Koen Claessen이 처음 작성한 파서 결합기 라이브러리입니다. 모든 대안을 병렬로 구문 분석하므로 다른 파서와의 일반적인 공간 누출 소스 인 입력 문자열의 시작 부분을 유지하지 않습니다. &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 선택 콤비는 진정으로 교환 법칙이 성립이다; 어느 분기가 &quot;더 짧아&quot;차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">이것은 많은 정보입니다! 그러나 대부분은 실제로 메타 정보에 불과하므로 데이터 유형 및 생성자의 이름을 만들고 유형 수준에서 더 많은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">하스켈 스타일 언어에 대한 최소 토큰 정의입니다. 주석 스타일, 유효한 식별자 및 대소 문자 구분을 정의합니다. 예약어나 연산자를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">이것은 Java 스타일 언어에 대한 최소 토큰 정의입니다. 주석 스타일, 유효한 식별자 및 대소 문자 구분을 정의합니다. 예약어나 연산자를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">효율적인 스택 추적을위한 모듈입니다. 이 스택 추적 구현은 낮은 오버 헤드로 간주됩니다. 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 의 비 차단 버전입니다 . 프로세스가 여전히 실행 중이면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 이 반환됩니다. 프로세스가 종료 된 경우, &lt;code&gt;e&lt;/code&gt; 는 프로세스의 종료 코드 인 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="1f500d4f7fd67c8ad0b3e4a53af642dd0d2ae2b1" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">일반적으로 프로그래머는 &lt;code&gt;(*) a b&lt;/code&gt; 가 &lt;code&gt;a * b&lt;/code&gt; 와 같을 것으로 예상하기 때문에 다소 약한 배열 입니다. &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; 를&lt;/a&gt; 사용하면 &lt;code&gt;(*)&lt;/code&gt; 의이 특별한 처리가 발생할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">이것은 약간 포함 된 휴리스틱이지만 기존 코드의 동작을 변경 하는 가져온 모듈 &lt;code&gt;N&lt;/code&gt; 의 상황을 캡처합니다 . 예를 들어, 두 번째 조건을 위반하지 않으면 모듈 작성자 &lt;code&gt;M&lt;/code&gt; 은 형식 클래스 또는 &lt;code&gt;N&lt;/code&gt; 에 정의 된 형식에 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 정의에 적합한 것이다 &lt;code&gt;mtimes&lt;/code&gt; 의 멤버 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bec2a1e9f6c0528918f3d75270102aae0235701e" translate="yes" xml:space="preserve">
          <source>This is a tad complicated for our &lt;code&gt;ApplicativeDo&lt;/code&gt; extension which will give it a &lt;code&gt;Monad&lt;/code&gt; constraint. For an &lt;code&gt;Applicative&lt;/code&gt; constraint we write it of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 멱등을위한 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 유효한 정의입니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 멱등에 대한 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 의 변형으로 , finalizer는 임의의 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작입니다. 호출되면 종료자는 새 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">이것은 &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; 의 변형으로 , finalizer는 임의의 &lt;code&gt;IO&lt;/code&gt; 동작입니다. 호출되면 종료자는 새 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">이것은 이물질 안에있는 포인터를 보는 방법입니다. 이 함수는 해당 포인터에 적용되는 함수를 사용합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 실행됩니다. 이물질은 내부에서 직접 사용되지 않더라도 적어도 전체 동작 중에 살아 있어야합니다. 조치에서 포인터를 리턴하고 조치가 완료된 후 사용하는 것은 안전하지 않습니다. 포인터의 모든 사용은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 브래킷 안에 있어야합니다 . 이 안전하지 않은 이유는 아래의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 과 동일 합니다. 컴파일러는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 개체가 아닌 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 개체의 사용 만 추적 할 수 있기 때문에 종료자가 예상보다 빨리 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">이것은 이물질 안에있는 포인터를 보는 방법입니다. 이 함수는 해당 포인터에 적용되는 함수를 사용합니다. 그런 다음 결과 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 동작이 실행됩니다. 이물질은 내부에서 직접 사용되지 않더라도 적어도 전체 동작 중에 살아 있어야합니다. 조치에서 포인터를 리턴하고 조치가 완료된 후 사용하는 것은 안전하지 않습니다. 포인터의 모든 사용은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 브래킷 안에 있어야합니다 . 이 안전하지 않은 이유는 아래의 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 과 동일 합니다. 컴파일러는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 개체가 아닌 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 개체의 사용 만 추적 할 수 있기 때문에 종료자가 예상보다 빨리 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">이것은 GHC 6.8.2의 최적화가 좋지 않은 경우의 해결 방법입니다. 일정한 너비의 이동을 감지하지 못하고 모든 이동에 테스트 및 분기를 추가합니다. 약 10 %의 성능 저하가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 와 거의 동일 하지만 옵션 인수, 비 옵션 목록, 인식 할 수없는 옵션 목록 및 오류 메시지 목록으로 구성된 4 배를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">이것은 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 와 거의 동일합니다 . 단, &lt;code&gt;ghc-pkg dump&lt;/code&gt; 는 결과를 구문 분석하는 도구에서 사용하기위한 것입니다. 예를 들어 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 는 오류가 발생하는 경우 ' 패턴과 일치하는 패키지를 찾지 못하면 &lt;code&gt;ghc-pkg dump&lt;/code&gt; 는 아무 것도 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">이것은 나무의 이화 현상으로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">병렬 가비지 콜렉션에 참여할 스레드 수이기도합니다. 기능 수는 물리적 프로세서 코어 수보다 크게 설정하지 않는 것이 좋습니다. 시스템의 다른 프로세스와의 충돌을 피하기 위해 하나 이상의 코어를 자유롭게 두는 것이 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">이것은 항상 필수 유형입니다. 너비와 부호는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; 컴파일러를 사용하여 실행 코드를 생성 하는 대체 백엔드입니다 . 일반적으로 네이티브 코드 생성기만큼 성능이 뛰어난 코드를 생성하지만 경우에 따라 훨씬 빠른 코드를 생성 할 수 있습니다. 이것은 벡터와 같은 패키지를 사용하는 숫자 배열 무거운 코드의 경우 특히 그렇습니다. 패널티는 컴파일 시간이 크게 늘어납니다. &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 LLVM 백엔드를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">이 기능은 실험적인 기능이므로 문제가 발생하거나 추가 튜닝을 통해 이점을 얻을 수 있는지 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 의 접두사 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">이것은 인수가 뒤집힌 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 의 접미사 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">때문이다 &lt;code&gt;qsort&lt;/code&gt; 가이 다형성 함수이며, GHCi 런타임에 타입 정보를 전달하지 않기 때문에,이 형태 변수를 포함하는 자유 변수의 런타임 형식을 확인할 수 없습니다. 따라서 프롬프트에서 &lt;code&gt;left&lt;/code&gt; 을 표시하도록 요청하면 GHCi는 사용할 &lt;code&gt;Show&lt;/code&gt; 인스턴스를 파악할 수 없으므로 위의 유형 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9020fa1ceb2a91d141dfe05d47580894b2e14468" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">&lt;code&gt;Natural&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 에서 사용하는 일반적인 유형 입니다. 이 형식은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 래핑하는 단일 생성자로 구성 되므로 압축을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">정확성을 유지하는 데 중요합니다. 다른 모듈에 정의 된 엔터티는 정확성 (기능 또는 성능)에 대해 게으름에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">현재 다음 조작으로 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">그러나 이것은 위험한 영토입니다. 예를 들어, 다음은 typechecker 루프를 만드는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">이것은 GHC의 버그로 인한 것입니다. 보고하십시오 ( &lt;a href=&quot;intro#bug-reporting&quot;&gt;GHC의 버그보고&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">이것은 &lt;code&gt;if p then y else x&lt;/code&gt; 와 같다; 즉, 인수가 재정렬 된 if-then-else 구문으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 본질적으로 항상 첫 번째 결과를 리턴하는 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 의 성능이 더 우수한 버전입니다 . 자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62b9a042aea0816af6e299c00f387f0402dcd3d1" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Eq&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">이것은 본질적으로 &lt;code&gt;data Foo a&lt;/code&gt; 대한 선언 후에 &lt;code&gt;deriving Eq&lt;/code&gt; 을 작성한 것과 동일 합니다 . 이 기능을 사용하려면 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">이것은 &lt;code&gt;data Foo a&lt;/code&gt; 대한 선언 후 &lt;code&gt;deriving Foo&lt;/code&gt; 를 파생시키는 것처럼 본질적으로 동일 합니다 . 이 기능을 사용하려면 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt; )를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">이는 평균적으로 성능을 향상시킬 것으로 예상되지만 실제 성능 차이는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">이것은 GHC 다시 쓰기 규칙을 작성하는 사람들에게만 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">실행 파일에 링크 된 다른 코드가 참조하지 않더라도 런타임에 이러한 Haskell 라이브러리에 정의 된 기호가 필요할 수있는 특수 응용 프로그램을위한 것입니다. 당신이 사용하는 경우 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; , 당신은 아마 또한 원하는 &lt;code&gt;-rdynamic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;insertLookup&lt;/code&gt; WithKey를 사용하여 &lt;code&gt;insertLookupWithKey&lt;/code&gt; 을 정의하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">오른쪽 에 &lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt; 를 사용 하면 표현이 잘되지 않기 때문에 불법 입니다. 그러나 명시적인 양방향 패턴 동의어를 사용하면 엄격한 패턴 동의어를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">이것은 내부적으로 0을 나타내는 기계 명령어로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">이것은 단지 편리한 기능이며 간단히 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">이것은 대부분 Cmm 패스 중에 수행됩니다. 그러나 이것은 코너 케이스를 놓칠 수 있습니다. 따라서 -O2에서 asm 단계에서 패스를 다시 실행하여이를 잡습니다.</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">이것은 일반적으로 가능한 모든 문자를 반환하는 것이 아니라 상위 수준의 구성으로 오류 메시지를 반환하려는 대체 대안의 끝에 사용됩니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 예제 의 &lt;code&gt;expr&lt;/code&gt; 구문 분석기 가 실패하면 오류 메시지는 '... : expecting expression'입니다. &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 결합자가 없으면 메시지는 '... : &quot;let&quot;또는 letter'를 기대하지만 덜 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">이것은 일반적으로 가능한 모든 문자를 반환하는 것이 아니라 상위 수준의 구성으로 오류 메시지를 반환하려는 대체 대안의 끝에 사용됩니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 예제 의 &lt;code&gt;expr&lt;/code&gt; 구문 분석기 가 실패하면 오류 메시지는 '... : expecting expression'입니다. &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 결합자가 없으면 메시지는 '... : &quot;let&quot;또는 letter'를 기대하지만 덜 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">출력이 길거나 ASCII가 아닌 문자가 포함 된 문자열을 포함하는 경우와 같이 특정 경우에는 이상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특수 문자에는 처리되지 않습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와 같은 특수 문자를 이해하므로 사용자 문자열에 대해 stringToHtml 또는 lineToHtml을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eee7f5de1930e679b3ff1bf2b45247aa3e4891d" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">특수 문자에 대해서는 처리되지 않습니다. 사용자 문자열에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와 같은 특수 문자를 이해하므로 stringToHtml 또는 lineToHtml을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">이것은 큰 함께 특히 유용하다 &lt;code&gt;-A&lt;/code&gt; 의 예를 들면, 값 &lt;code&gt;-A64m -n4m&lt;/code&gt; 큰 코어 카운트 (8 +)의 조합이 유용하다.</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">이것은 다음과 같이 GHC에 대한 &lt;code&gt;ViewPatterns&lt;/code&gt; 확장에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">이 클래스는 &lt;code&gt;IsString&lt;/code&gt; 클래스 ( &lt;a href=&quot;#overloaded-strings&quot;&gt;오버로드 된 문자열 리터럴&lt;/a&gt; 참조 )와 비슷하지만 레이블의 텍스트를 유형 수준 문자열로 사용할 수있게하는 추가 유형 매개 변수가 있습니다 ( &lt;a href=&quot;#type-level-literals&quot;&gt;유형 수준 리터럴&lt;/a&gt; 참조 ). 참고 것을 &lt;code&gt;fromLabel&lt;/code&gt; 는 추가했다 &lt;code&gt;Proxy# x&lt;/code&gt; GHC 8.0에서 인수를, 그러나 이것은 (참조 유형의 응용 프로그램으로 GHC 8.2에서 제거 &lt;a href=&quot;#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램을&lt;/a&gt; 대신 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">RHS의 유형에 대해 &quot;최상위 레벨&quot;이 없기 때문에 ( &lt;code&gt;PackMap&lt;/code&gt; 에 추가 매개 변수를 추가하는 것이 끔찍할 수 있기 때문에) 거부되므로 암시 적 수량 화가 발생하지 않으며 선언이 거부됩니다 ( &quot; &lt;code&gt;f&lt;/code&gt; 가 범위를 벗어남 &quot; &amp;rdquo;). 해결책 : 명시 적 &lt;code&gt;forall&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">이것은 하스켈 98 거부하지만, 존스의 방식 하에서 대한 정의 &lt;code&gt;g&lt;/code&gt; 은 따로 행 들면 제 타입 체크된다 &lt;code&gt;f&lt;/code&gt; 참조가 있기 때문에, &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;g&lt;/code&gt; 의 오른쪽은 종속성 분석에 의해 무시된다. 그런 다음 &lt;code&gt;g&lt;/code&gt; 의 유형이 일반화되어</target>
        </trans-unit>
        <trans-unit id="af9e5e6b5a1471403ba13a39e6cf598e61cc7f1f" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type is generalised, to get</source>
          <target state="translated">이것은 하스켈 98 거부하지만, 존스의 방식 하에서 대한 정의 &lt;code&gt;g&lt;/code&gt; 은 따로 행 들면 제 타입 체크된다 &lt;code&gt;f&lt;/code&gt; 참조가 있기 때문에, &lt;code&gt;f&lt;/code&gt; 의 &lt;code&gt;g&lt;/code&gt; 의 오른쪽은 종속성 분석에 의해 무시된다. 그런 다음 &lt;code&gt;g&lt;/code&gt; 유형이 일반화되어</target>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">컴파일러가 Template Haskell을 지원하면 &lt;code&gt;1&lt;/code&gt; 로 설정되고 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 으로 설정 됩니다. 후자는 부트 스트랩 중 또는 인터프리터를 사용할 수없는 아키텍처의 1 단계 컴파일러의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 법칙 이 일종의 연관성을 암시 하기 때문에 이것은 추상 형식에도 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 법칙 이 일종의 연관성을 암시 하기 때문에 이것은 추상 형식에도 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">단일체가 단일체 법칙을 만족한다고 가정하기 때문에 이것은 추상 유형에도 적합합니다. 또는 &lt;code&gt;foldr&lt;/code&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">투명하게 내보내는 데이터 유형에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 &quot;후문&quot; 이므로 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 수행 할 수 있습니다. 이를 안전하게하려면 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 부작용이없고 환경과 무관해야합니다.</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드에 대한 &quot;후문&quot; 이므로 언제든지 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산을 수행 할 수 있습니다. 이를 안전하게하려면 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산에 부작용이없고 환경과 무관해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">이것은 &lt;code&gt;LINE&lt;/code&gt; pragma와 유사하며 자동으로 생성 된 Haskell 코드에서 사용하기위한 것입니다. 원래 코드의 열 번호를 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">이것은 &lt;code&gt;getContents&lt;/code&gt; 의 정의 된 동작입니다 . stdin Handle을 반 닫힘으로 알려진 상태로 설정합니다. 여기서 추가 I / O 작업은 금지됩니다. I / O 상태는 계산간에 유지되므로 semi-closed 상태는 다음 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 명령 까지 지속 됩니다.</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">이것이 기본 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 전술입니다.</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">초기 로케일 인코딩입니다. &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; 에 의해 이후에 변경된 경우이 값은 해당 변경 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">이것은 펼치기 (일명 인라인)에 대한 마술 컷오프 수치입니다.이 크기 아래에서는 함수 정의가 콜 사이트에서 펼쳐지지만 더 크지 않습니다. 함수에 대해 계산되는 크기는 표현식의 실제 크기에서 표현식을 인라인 할 컨텍스트에 따라 적용되는 할인을 뺀 두 가지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">이것이 프로그램을 더 빠르게 만드는 가장 기본적인 방법입니다. 특히 &lt;code&gt;-O2&lt;/code&gt; 의 경우 컴파일 시간이 느려집니다 .</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">이것은 약한 포인터를 만들기위한 가장 일반적인 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">이것은 그룹화 유형 문 중 가장 일반적인 것입니다. 이 형식에서, f는 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 유형을 가져야 합니다. (a-&amp;gt; t)-&amp;gt; [a]-&amp;gt; [[a]] 입니다. 와 마찬가지로 &lt;code&gt;then f by e&lt;/code&gt; 상기의 경우, 첫 번째 인자는리스트의 각 요소가 변형되고 그것을 계산 예를 할 수있는 컴파일러에 의해 F에 공급되는 함수이다. 그러나 비 그룹화 사례와 달리 f는 추가로 목록을 여러 하위 목록으로 분할합니다. 즉,이 명령문 이후의 모든 지점에서 이해하기 전에 &lt;em&gt;목록&lt;/em&gt; 에서 발생하는 바인더는 단일 값이 아닌 가능한 값 &lt;em&gt;목록&lt;/em&gt; 을 나타냅니다. 이를 이해하기 위해 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">이것은 외부 프로세스를 생성하는 가장 일반적인 방법입니다. 프로세스는 쉘에 의해 실행되는 명령 행이거나 인수 목록이있는 원시 명령 일 수 있습니다. 새 프로세스의 stdin, stdout 및 stderr 스트림은 개별적으로 새 파이프, 기존 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에 연결되거나 부모에서 상속 될 수 있습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="11f3ed6859503f000bff2d612fad07f02ba594bf" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">이것이 가장 작은 토큰 정의입니다. 이 정의를 다른 정의의 기초로 사용하는 것이 좋습니다. &lt;code&gt;emptyDef&lt;/code&gt; 에는 예약 된 이름이나 연산자가 없으며 대소 문자를 구분하며 주석, 식별자 또는 연산자를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">이것은 토큰을 수락하는 가장 원시적 인 조합입니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; 파서는 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c028e89a3d3ce63ac917bdfc38f641c5b46ea80a" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt;&lt;code&gt;-fvia-C&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">이것은 GHC에서 가장 오래된 코드 생성기이며 일반적으로 GHC 7.0에서 더 이상 사용되지 않는 더 이상 포함되지 않습니다. &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt; &lt;code&gt;-fvia-C&lt;/code&gt; &lt;/a&gt; 플래그로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">이것은 GHC에서 가장 오래된 코드 생성기이며 일반적으로 GHC 7.0에서 더 이상 사용되지 않는 것은 아닙니다. &lt;code&gt;-fvia-C&lt;/code&gt; 플래그로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">이것은 예외 포착 기능 중 가장 간단한 것입니다. 단일 인수를 취하여 실행하며 예외가 발생하면 예외 값이 인수로 전달 된 &quot;handler&quot;가 실행됩니다. 그렇지 않으면 결과가 정상적으로 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">이것은 UTC의 가장 간단한 표현입니다. 요일 번호와 자정의 시간 오프셋으로 구성됩니다. 하루에 윤초가 추가 된 경우 86401 초가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">GHC가 소스 파일을 한 번에 하나씩 컴파일하거나 객체를 실행 파일에 연결할 수있는 일반적인 배치 컴파일러 모드입니다. &lt;a href=&quot;#options-order&quot;&gt;배치 컴파일러 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">이것은 인수를 통해 구체화 된 필드 포맷터의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">사용자가 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 를 호출하면 발생 합니다. 첫 번째 &lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 에 지정된 인수 이고 두 번째 &lt;code&gt;String&lt;/code&gt; 은 위치입니다.</target>
        </trans-unit>
        <trans-unit id="aebf3f40f6a1942ecdd588383580c2939b2e0f04" translate="yes" xml:space="preserve">
          <source>This is unsafe because GHC cannot check for you that the expression really does have the type you claim it has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">이는 AST 따옴표의 구멍 또는 확인되지 않은 식별자에 사용됩니다. 변수 이름이나 생성자 이름이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">내부 GHC 호출 규칙을 따르는 Cmm 코드로 작성된 함수를 가져 오는 데 사용됩니다. 인수 및 결과는 인수 유형이 될 수 있습니다 것을 제외하고, 언 박싱 유형해야합니다 &lt;code&gt;Any&lt;/code&gt; (의 방법으로 &lt;code&gt;unsafeCoerce#&lt;/code&gt; ) 및 결과 유형은 언 박싱 튜플 또는 유형으로 허용되는 &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">이것은 모나드 변환기에 의해 매개 변수화 된 기능에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">생성 된 파일이 &lt;code&gt;Unique&lt;/code&gt; 순서에 의존하는지 테스트하기 위해 &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb2802e19e3cc64605ff63d36592512d32cabe42" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;rsquo;s.</source>
          <target state="translated">생성 된 파일이 &lt;code&gt;Unique&lt;/code&gt; 순서에 따라 달라지는 지 테스트하기 위해 &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="223669d1cce36e8738573bac6e197f3c8162072c" translate="yes" xml:space="preserve">
          <source>This is very similar to &lt;code&gt;&lt;a href=&quot;../mtl-2.2.2/control-monad-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;MonadError&lt;/code&gt;, but based on features of &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;. In particular, it handles the complex case of asynchronous exceptions by including &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; in the typeclass. Note that the extensible exceptions feature relies on the RankNTypes language extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">RIO 모듈이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;로 컴파일되어 &lt;code&gt;Danger&lt;/code&gt; 모듈이 임포트 할 수있게 됩니다. &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 플래그는 같은 모듈에 어떤 제한을 두지 않는 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; (에 인스턴스를 중복 제한 할 것으로 예상 않는 &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;안전 중복되는 경우&lt;/a&gt; ). 대신 모듈 작성자는 코드가 안전하지 않은 기능을 내부적으로 사용할 수 있지만 안전한 방식으로 사용할 수있는 API 만 노출한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">이것은 널리 잘못된 기능으로 간주되며 언어에서 제거 될 예정입니다. GHC에서는 사용되지 않는 확장 &lt;code&gt;DatatypeContexts&lt;/code&gt; 에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">이것은 특별히 깨달 지 않습니다. 무슨 일하는 것입니다 &lt;code&gt;left&lt;/code&gt; 평가되지 않은 계산 (현탁액, 또는 썽크)에 결합되고, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 어떤 평가를 강요하지 않습니다. 아이디어는 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 를 사용하여 불행한 부작용없이 중단 점에서 값을 검사 할 수 있다는 것입니다. 평가를 강제로 수행하지 않아 프로그램이 평상시와 다른 응답을 줄 수 있으므로 예외가 발생하거나 무한 루프 또는 추가 중단 점이 발생하지 않습니다 ( &lt;a href=&quot;#nested-breakpoints&quot;&gt;중첩 된 중단 점&lt;/a&gt; 참조 ). . 썽크를 강제하는 대신 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; 는&lt;/a&gt; 각 썽크를 밑줄로 시작하는 새로운 변수 (이 경우 &lt;code&gt;_t1&lt;/code&gt; )에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">GHC는 패키지라고하는 사전 컴파일 된 라이브러리에서 모듈을 찾습니다. 자세한 내용은 패키지 ( &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; ) 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="e058359ab2e82e0cac7dd3d00a96ceff57c41dfb" translate="yes" xml:space="preserve">
          <source>This kind is similar to the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;, but with a key difference: the type variables quantified by the &lt;code&gt;forall&lt;/code&gt; are followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;), not a dot (&lt;code&gt;.&lt;/code&gt;). This is a visible, dependent quantifier. It is visible in that it the user must pass in a type for &lt;code&gt;k&lt;/code&gt; explicitly, and it is dependent in the sense that &lt;code&gt;k&lt;/code&gt; appears later in the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;. As a counterpart, the &lt;code&gt;k&lt;/code&gt; binder in &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; can be thought of as an &lt;em&gt;invisible&lt;/em&gt;, dependent quantifier.</source>
          <target state="translated">이러한 종류의 종류 비슷 &lt;code&gt;ProxyKInvis&lt;/code&gt; 하지만 중요한 차이가 다음에 의해 정량화 된 형태 변수 &lt;code&gt;forall&lt;/code&gt; 화살표 따른다 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )가 아니라 도트 ( &lt;code&gt;.&lt;/code&gt; ). 이것은 가시적이고 종속적 인 수량 자입니다. 사용자가 &lt;code&gt;k&lt;/code&gt; 에 대한 유형을 명시 적으로 전달해야한다는 점에서 볼 수 있으며 &lt;code&gt;k&lt;/code&gt; 가 나중에 &lt;code&gt;ProxyKVis&lt;/code&gt; 유형으로 표시 된다는 점 에서 종속적 입니다. 대응 물로서, &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 의 &lt;code&gt;k&lt;/code&gt; 바인더 . k-&amp;gt; 유형 은 &lt;em&gt;보이지 않는&lt;/em&gt; 종속 수량 자로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">친절한 추론의 부족은 단순히 GHC 내에서 공학적 문제이지만,이를 작동시키는 것은 추론 인프라를 실질적으로 변화시킬 것이며, 그 대가가 가치가 있는지는 확실하지 않습니다. 위의 인스턴스에서 &lt;code&gt;b&lt;/code&gt; 의 종류 를 제한 하려면 인스턴스 헤드에서 종류 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="35e744da89ea652776d7de1d49ded5a0e6370630" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">이러한 종류의 추론의 결여는 GHC 내의 엔지니어링 문제 일 뿐이지 만 작동하게하면 추론 인프라에 상당한 변화가 생기며 그만한 가치가있는 것은 분명하지 않습니다. 위의 인스턴스에서 &lt;code&gt;b&lt;/code&gt; 의 종류 를 제한 하려면 인스턴스 헤드에 종류 서명을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">이 레거시 모듈은 목록 전문화 된 &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 작업에 대한 액세스를 제공합니다 . 이 모듈은 향후 GHC 버전에서 다시 사라질 수 있으며 &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;FTP (Foldable / Traversable-in-Prelude Proposal)&lt;/a&gt; 구현으로 인해 일반화해야하는 목록 전문 작업 중 일부에 액세스 할 수있는 전환 도구로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 차이 목록을 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; A와 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 부동 소수점 값을 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 lexeme 구문 분석기는 유효한 식별자를 구문 분석합니다. 식별자 문자열을 반환합니다. 이 구문 분석기는 예약어 인 식별자에서 실패합니다. 유효한 식별자 (시작) 문자와 예약어는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;identifier&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 lexeme 구문 분석기는 유효한 식별자를 구문 분석합니다. 식별자 문자열을 반환합니다. 이 구문 분석기는 예약어 인 식별자에서 실패합니다. 유효한 식별자 (시작) 문자와 예약어는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;identifier&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 exeme 파서는 법정 연산자를 구문 분석합니다. 연산자의 이름을 반환합니다. 이 파서는 예약 된 연산자 인 연산자에서 실패합니다. 유효한 연산자 (시작) 문자와 예약 연산자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;operator&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 exeme 파서는 법정 연산자를 구문 분석합니다. 연산자의 이름을 반환합니다. 이 파서는 예약 된 연산자 인 연산자에서 실패합니다. 유효한 연산자 (시작) 문자와 예약 연산자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 로 전달 되는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;operator&lt;/code&gt; 사용하여 토큰 하나로 처리됩니다 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">이 lexeme 파서는 리터럴 문자열을 구문 분석합니다. 리터럴 문자열 값을 반환합니다. 이 파서는 이스케이프 시퀀스 및 간격을 올바르게 처리합니다. 리터럴 문자열은 Haskell 보고서에 정의 된 문법 규칙 (대부분의 프로그래밍 언어와 매우 일치)에 따라 구문 분석됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
