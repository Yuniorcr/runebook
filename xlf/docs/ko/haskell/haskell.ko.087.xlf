<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">유형 패밀리 선언에는 오른쪽이 없지만 GHC는 여전히 &lt;code&gt;F&lt;/code&gt; 에 대한 종류를 유추해야합니다 . 제약 조건이 없으므로, 모든 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; 유추 할 수 있습니다. k1-&amp;gt; k2 이지만 &lt;em&gt;너무&lt;/em&gt; 다형성으로 보입니다 . 따라서 GHC는 완전히 제한되지 않은 종류 변수를 &lt;code&gt;Type&lt;/code&gt; 으로 기본 설정 하고 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; 얻습니다 . 종류 시그니처를 사용하여 &lt;code&gt;F&lt;/code&gt; 를 종류가 다형성으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">클래스 패밀리 인스턴스 선언은 적절한 패밀리 선언이 범위 내에있을 때만 합법적입니다. 클래스 인스턴스가 클래스 선언을 표시해야하는 것처럼 말입니다. 또한 각 인스턴스 선언은 패밀리 선언에 의해 결정된 종류를 따라야하며 인스턴스 선언의 유형 매개 변수 수는 패밀리 선언의 유형 매개 변수 수와 일치해야합니다. 마지막으로, 유형 인스턴스의 오른쪽은 단일 유형이어야하며 (즉, 모든 유형을 포함하지 않을 수 있음) 모든 포화 바닐라 유형 동의어가 확장 된 후에는 패밀리 동의어를 제외하고 동의어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">유형 가족 결과</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">유형 군 결과 서명</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="translated">입력 된 스플 라이스에 구멍 입력 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;# 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;# 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">타이핑 된 스플 라이스의 타이핑 구멍 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;문제 # 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;문제 # 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 백업하는 데 사용할 수있는 장치의 유형입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; 참조 ). 표준 라이브러리 는 기본 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 인스턴스 가 FD 인 파일 디스크립터 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; 참조 )를 사용 하여 Posix 파일 조작을 통해 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 작성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">형식 문자열에서 수정 자 문자를 구문 분석 할 함수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">타입 표현</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">&lt;em&gt;원시&lt;/em&gt; 임의 정밀도 Naturals를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">GMP 사지를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">임의 정밀도의 음이 아닌 정수를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">유형 스플 라이스 : 유형 스플 라이스에서는 익명 와일드 카드 만 지원됩니다. 명명 된 및 추가 제약 조건 와일드 카드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">유형 동의어 패밀리가 인스턴스 헤드에 전혀 나타나지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr #의&lt;/a&gt; 유형 동의어</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">생성자를위한 메타 정보 인코딩을위한 타입 동의어</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">데이터 유형의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">레코드 선택기의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">재귀를 인코딩하기위한 형식 동의어 ( &lt;code&gt;Type&lt;/code&gt; 종류 )</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">타입 동의어</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">유형 동의어는 유형 수준의 매크로와 비슷하지만 Haskell 98은 개별 동의어 선언에 많은 규칙을 적용합니다. &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는 &lt;em&gt;유형 동의어를 확장 한 후에 만&lt;/em&gt; 유형에 대한 유효성 검사를 수행합니다 . 이는 GHC가 Haskell 98보다 유형 동의어에 대해 훨씬 더 자유로울 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">밑줄에 식별자를 접미사 (예 : &lt;code&gt;_a&lt;/code&gt; ) 로 지정하여 유형 와일드 카드의 이름을 지정할 수도 있습니다 . 이를 &lt;em&gt;와일드 카드&lt;/em&gt; 라고 합니다. 하나의 유형 서명 내에서 동일한 이름의 와일드 카드가 발생하면 모두 동일한 유형으로 통합됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">유형 확인 및 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">타입 클래스와 암시 적 매개 변수 제약</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">타입 레벨 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">유형 수준 &quot;not&quot;. &lt;code&gt;4.10.0.0&lt;/code&gt; 이후의 인젝 티브 타입 패밀리 .</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">타입 레벨 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">유형 레벨 &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt; . &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">타입 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">제안 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">표현 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 가능 값의 유형 클래스입니다 . &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 의 방법은 값 필드 포맷 디스크립터를 받아 하나 실패로 인해 잘못된 설명하거나 생성 &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 결과한다. 기본 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 은 수정자를 기대하지 않습니다. 일반적인 경우입니다. 최소 예 : &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">유형이 지정된 표현식 스플 라이스 : 유형이 지정되지 않은 표현식 스플 라이스와 동일한 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">유형이 지정된 표현식</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">유형이 지정된 구멍은 GHC의 기능으로 밑줄 (예 : &quot; &lt;code&gt;_&lt;/code&gt; &quot;, &quot; &lt;code&gt;_foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;_bar&lt;/code&gt; &quot;)로 작성된 특수 자리 표시자를 표현식으로 사용할 수 있습니다. 컴파일하는 동안 이러한 구멍은 구멍 위치에 어떤 유형이 예상되는지, 자유 유형 변수의 원점에 대한 정보 및 구멍을 채우는 데 도움이되는 로컬 바인딩 목록 및 유형에 맞는 범위의 바인딩을 설명하는 오류 메시지를 생성합니다. 실제 코드로 구멍을 채우는 데 도움이 될 수 있습니다. 타입 홀은 GHC에서 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTC 및 UT1의 유형 및 함수</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">유니 코드 텍스트의 인코딩 및 디코딩 오류를 처리하기위한 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">리모트 GHCi에서 리모트 오브젝트를 참조하기위한 유형. 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [외부 GHCi 포인터]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">텍스트 인코딩 / 디코딩 실패 방법을 지정하는 유형</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I / O 오류의 종류</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">유형과 클래스 제약 조건은 접두사로 쓸 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">일반적으로 GHCi는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후에로드 한 모듈 수만 표시합니다 . 이 플래그를 사용하면 GHC는로드 된 모듈의 이름도 나열합니다. 이것은 GHC 8.2.1 이전의 기본 동작이며 일부 툴링 사용자에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">일반적으로이 &lt;code&gt;GSerialize&lt;/code&gt; 클래스는 표현 유형에 대한 인스턴스 만 갖는 것이 적합하므로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 자체를 입력 하면 현재 정의 된 매크로가 나열됩니다. &lt;code&gt;:def!&lt;/code&gt; 가 아니면 기존 명령 이름을 재정의하려고하면 오류가 발생합니다 . form이 사용되며,이 경우 해당 이름의 이전 명령을 자동으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 를 입력 하면 현재 정의 된 매크로가 나열됩니다. 기존 명령 이름을 재정의하려고하면 &lt;code&gt;:def!&lt;/code&gt; 이 경우 해당 이름을 가진 이전 명령을 자동으로 덮어 씁니다. 그러나 내장 명령의 경우 명령 이름 앞에 이중 콜론 (예 : &lt;code&gt;::load&lt;/code&gt; )을 추가 하여 이전 명령을 계속 사용할 수 있습니다 . &lt;code&gt;:{&lt;/code&gt; , &lt;code&gt;:}&lt;/code&gt; 및 &lt;code&gt;:!&lt;/code&gt; 명령을 재정의 할 수 없습니다 . .</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">입력 : ⟨exp⟩ 유형이 ⟨T1⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩이고 ⟨pat⟩가 ⟨T2⟩와 일치하면 전체보기 패턴이 ⟨T1⟩과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">유닉스 스타일 포맷</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">유닉스 스타일 파싱</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE 환경 변수.</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTC는 시계로 측정 한 시간으로 &quot;도약 초&quot;라고하는 가끔씩 초를 추가하거나 제거하여 지구와 보조를 맞추도록 수정되었습니다. 이러한 수정 사항은 예측할 수 없으며 6 개월 전에 통지합니다. 이 수정 프로그램으로 컴파일 된 프로그램은 6 개월 후에 만료 될 수 있으므로 이러한 수정 사항에 대한 표는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16 (Windows 시스템에서 사용).</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-16 코덱</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 서로 게이트 코드 포인트는 유니 코드 스칼라 값 세트에 포함되지 않지만 불행히도 Haskell에 의해 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정됩니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, '')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32 (C 컴파일러는 &lt;code&gt;201605L&lt;/code&gt; 을 정의 함 ) 또는</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-32 코덱</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-8 코덱</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">단항 부정.</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">단항 부정. 음의 &lt;code&gt;Int#&lt;/code&gt; 범위는 양의 범위보다 하나 더 확장 되므로 가장 음수 인 &lt;code&gt;negateInt#&lt;/code&gt; 는 항등 연산입니다. 이런 식으로 &lt;code&gt;negateInt#&lt;/code&gt; 는 항상 자체 역수입니다.</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">식에 사용 된 언 바운드 데이터 생성자는 위와 동일하게 동작합니다. 그러나 &lt;em&gt;패턴에&lt;/em&gt; 사용 된 바인딩되지 않은 데이터 생성자 는 지연 될 수 없으며 대신 컴파일을 중단합니다. (구현 용어에서는 유형 검사기 대신 이름 바꾸기 프로그램에 의해보고됩니다.)</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">이름이 같은 언 바운드 식별자는 동일한 기능 내에서도 통합되지 않지만 개별적으로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">무제한 채널.</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">박스형 배열</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">박스형 불변 배열.</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">박스형 표현 유형</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">박스형 합계 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">박스형 합계 유형 생성자</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">Unboxed sum은 힙에 sum을 할당하고 포인터로 값을 나타내는 대신 unboxed tuple과 같이 구성 요소로 표시된다는 의미에서&amp;ldquo;unboxed&amp;rdquo;입니다. 이러한&amp;ldquo;구성 요소&amp;rdquo;는 합계 유형의 대안에 따라 다릅니다. 박스형 튜플과 같이 박스형 합계는 리프팅 된 구성 요소에 게으르다.</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">박스형 튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">박스형 튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">박스형 튜플은 여러 값을 반환해야하는 함수에 사용되지만 일반적으로 본격적인 튜플 사용과 관련된 힙 할당을 피합니다. 박스형 튜플이 반환되면 구성 요소는 레지스터 나 스택에 직접 저장됩니다. 박스형 튜플 자체에는 합성 표현이 없습니다. &lt;code&gt;primops.txt.pp&lt;/code&gt; 에 나열된 많은 기본 작업은 상자가 없는 튜플을 반환합니다. 특히, &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;ST&lt;/code&gt; 모나드는 작동 순서 동안 불필요한 할당을 피하기 위해 상자없는 튜플을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">Unboxed 튜플은 실제로 &lt;code&gt;GHC.Exts&lt;/code&gt; ; 그것들은 구문 확장 ( &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; )입니다. 박스형 튜플은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">박스형 튜플은 다중 대치 대안에 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">박스형 유형은 C에서 사용하는 &quot;원시 기계&quot;유형에 해당합니다. &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *) 등 이러한 유형 의 &lt;em&gt;기본 작업&lt;/em&gt; (PrimOps)은 다음과 같습니다. 기대할 수 있습니다. 예를 들어, &lt;code&gt;(+#)&lt;/code&gt; 은 &lt;code&gt;Int#&lt;/code&gt; s 에 추가 된 것으로서, 우리 모두가 알고 사랑하는 기계 추가 (일반적으로 하나의 명령)입니다.</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">확인되지 않은 액세스</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">확인되지 않은 부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">불변 배열의 확인되지 않은 읽기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">변경 가능한 배열의 확인되지 않은 쓰기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">제안의 유형이나 응용 프로그램을 표시하지 않음으로써 유효한 구멍 맞춤 목록을 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">C 전 처리기에서 기호 정의</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">일반적인 방법으로 매크로 &quot;기호&quot;를 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">사용자 정의 명령 ⟨name⟩을 정의 해제하십시오 ( 위의 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 이는 &lt;code&gt;Either * Char&lt;/code&gt; 와 같은 표현식이 &lt;code&gt;(*) Either Char&lt;/code&gt; 아닌 &lt;code&gt;Either (*) Char&lt;/code&gt; 로 구문 분석 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 같은 식 수단이 있다는 &lt;code&gt;Either * Char&lt;/code&gt; 로 파싱 &lt;code&gt;Either (*) Char&lt;/code&gt; 아닌 &lt;code&gt;(*) Either Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">GHC에서 다시 쓰기 규칙은 중단 (==)을 특수한 breakByte에 대한 호출로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">Mac OS X에서는 디버그 정보가 실행 파일과 떨어져 있습니다. 실행 파일을 컴파일 한 후 &lt;code&gt;dsymutil&lt;/code&gt; 유틸리티를 사용하여 디버깅 정보를 추출하여 디버그 아카이브에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">대부분의 상황에서 독립 실행 형 파생을 사용하여 생성자가 모두 범위에 속하지 않는 데이터 유형에 대한 인스턴스를 작성할 수는 없습니다. 파생 된 인스턴스가 배후에서 생성자를 사용하는 코드를 생성하기 때문에 추상화가 중단되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">ByteString 펼치기</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">생성자 응용 프로그램 펼치기</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">불행히도 DWARF는 GHC가 생성하는 코드를 완전히 설명하기에 충분하지 않습니다. 이것은 라인 정보의 경우에 가장 분명합니다. GHC는 다양한 가능한 소스 위치 중에서 일부를 선택해야합니다. 이는 기존 통계 프로파일 링 도구로 DWARF 정보의 유용성을 제한합니다. 프로파일 링을 위해서는 확장 된 디버깅 정보를 사용하는 것이 좋습니다. 아래의 &lt;em&gt;프로파일 링&lt;/em&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">불행히도. 아직 구현하지 않았습니다. GHCi에로드하기 전에 문제가있는 모듈을 직접 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">유니 코드 표준 범주 (UnicodeData 테이블의 열 2)는 유니 코드 표준 (특히 유니 코드 문자 데이터베이스)에 나열된 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">유니 코드 로마 숫자도 &quot;숫자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">유니 코드 대안</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">유니 코드 문자는 문자, 숫자, 표시, 문장 부호, 기호, 구분 기호 (공백 포함) 및 기타 (제어 문자 포함)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">유니 코드 인코딩 / 디코딩</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">유니 코드 일반 범주</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">단방향 동의어는 패턴 컨텍스트에서만 사용할 수 있으며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​출력 기록으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​상태로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">무인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">프로그램 텍스트에 지정된 순서대로 1부터 계산하여 데이터 유형 생성자를위한 고유 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">독특한 개체</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">단위 : 인수가없는 생성자에 사용</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">세계시</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">범용 결합 기능</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">유닉스 시스템</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">달리 문서화되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">달리 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 우측 함수 유형을 포함하는 데이터 타입에 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">달리 &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 암시하지 않습니다 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; . 이 결정의 근거는 용어 레벨 패턴 이름과 달리 유형 이름은 종종 문서화 목적으로 명시 적으로 선택되므로 유형 이름에 밑줄을 사용하면 문서를 읽기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">프로그램을 불완전하게 만들고 평가할 때 오류를 생성하는 &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; 과 달리 형식 서명에 구멍이있을 필요는 없습니다. 형식 검사기는 형식 서명이 있거나없는 바인딩을 형식 검사 할 수 있습니다 (대부분의 경우). 부분 타입 시그니처는 두 극단 사이의 간격을 메우고, 프로그래머는 어떤 유형의 부분에 주석을 달고 어떤 부분을 유형 검사기에 남겨 둘지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 와 달리이 옵션으로 인해 패키지 ⟨pkg be가 결과 실행 파일 또는 공유 객체에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 와 달리 요소를 강제하지 않고 검색하는 데 사용할 수 있습니다. 예를 들어, 시퀀스의 다섯 번째 요소 삽입 &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 키에서 &lt;code&gt;k&lt;/code&gt; , 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 타입 생성자에 매핑되지 않는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; . 다음과 같이 직접 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 절대 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 과 달리 재귀 함수 에는 &lt;code&gt;INLINABLE&lt;/code&gt; pragma 를 사용하는 것이 좋습니다 . &lt;code&gt;SPECIALISE&lt;/code&gt; 나중에 사용할 수 있도록하는 주된 이유</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">달리 C에서 &lt;code&gt;printf(3)&lt;/code&gt; 이 본의 서식 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 인수의 형태에 의해 구동된다; 형식은 유형에 따라 다릅니다. 로 포맷 종류 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;상자 밖으로&quot;는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 GHC는 데이터 유형의 형식을 제한하지 않습니다. 대신 GHC는 단순히 지정된 클래스에 적합한 상용구 코드를 생성하고 유형을 확인합니다. 유형 오류가 있으면 문제입니다. (GHC는 유형 오류가있는 경우 문제 코드를 표시합니다.)</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 인스턴스는 데이터 유형보다 더 구체적 일 수 있습니다 ( &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 완화 된 규칙을&lt;/a&gt; 사용한다고 가정) ). 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">Haskell-98 스타일 데이터 형식 선언과 달리 &quot; &lt;code&gt;data Set a where&lt;/code&gt; &quot;헤더 의 형식 변수 에는 범위가 없습니다. 실제로, 대신에 친절한 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">표현식 및 선언 유형 서명과 달리 패턴 유형 서명은 암시 적으로 일반화되지 않습니다. &lt;em&gt;패턴 바인딩&lt;/em&gt; 의 &lt;em&gt;패턴&lt;/em&gt; 은 이미 범위에있는 유형 변수 만 언급 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 과 달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 &lt;code&gt;encode'&lt;/code&gt; 가 아니라 &lt;code&gt;encode&lt;/code&gt; '를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; 형식의 일반 선언 스플 라이스와 달리 선언 준 따옴표는 선언 그룹을 중단시키지 않습니다. 자세한 정보는 &lt;a href=&quot;#th-syntax&quot;&gt;구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">일반적인 선언 스플 라이스와 달리 선언 준 따옴표는 분리되지 않습니다. 이 준표자는 나머지 선언 그룹이 처리되기 전에 확장되고 생성 된 선언은 주변 선언 그룹에 병합됩니다. 따라서, 볼 타입 환경 &lt;code&gt;reify&lt;/code&gt; 선언의 quasiquoter에서이 quasiquoter의 선언 그룹에서 아무것도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">서명 파일에 선언 된 엔터티 만 범위로 가져 오는 다른 선언과 달리 구현의 인스턴스는 서명 파일에서 선언되지 않은 경우에도 항상 범위로 가져옵니다. 이것은 모듈이 서명에 대해서는 타입 검사를 할 수 있지만 일치하는 구현에 대해서는 검사 할 수 없음을 의미합니다. 서명이있는 패키지 내에 고아 인스턴스를 정의하지 않으면 이와 같은 상황을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">다른 제거 기능과 달리이 기능은 읽기 전용으로 표시되거나 권한으로 인해 제거 할 수없는 파일을 삭제하려고 시도합니다. 결과적으로 제거가 완료되지 않으면 나머지 파일의 권한 또는 속성이 변경 될 수 있습니다. 디렉토리에 하드 링크가 있으면 모든 관련 하드 링크에 대한 권한이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">비슷한 이름의 다른 함수와 달리 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 는 Win32 API의 &lt;code&gt;SearchPath&lt;/code&gt; 를 사용하지 않습니다 . 따라서 Windows에서이 기능의 동작은 Windows 이외의 플랫폼에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">일반 모듈과 달리 서명의 정의 된 엔터티에는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일에 작성된 엔터티 뿐만 아니라 상속 된 서명의 엔터티 도 포함됩니다 ( &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그 에서 유추 ). 이러한 엔티티는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일을 유형 검사 할 때 범위 내에서 고려되지 않지만 서명을 가져 오는 모듈 또는 서명으로 가져올 수 있습니다. 이 규칙의 예외는 아래에 설명 된 내보내기 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 묶인 타입 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 방정식 의 오른쪽에 걸쳐 있습니다. (따라서 구별 유형 변수 사용할 필요가 없다; 사용 &lt;code&gt;a&lt;/code&gt; . 동등한 것)를</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 바인딩 된 유형 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 방정식 의 오른쪽 범위로 지정 됩니다. (따라서 고유 한 유형 변수를 사용할 필요가 없습니다. &lt;code&gt;a&lt;/code&gt; 를 사용 하는 것은 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">연관된 유형 패밀리 선언 자체와 달리 기본 인스턴스의 유형 변수는 상위 클래스의 유형 변수와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 의 기본 정의와 달리 0에 대해 정의되므로 가능하면 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전 예제와 달리 현재는 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용하여 모호성을 수동으로 해결할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="translated">일반 데이터 정의와 달리 데이터 계열의 결과 종류는 &lt;code&gt;Type&lt;/code&gt; 일 필요가 없습니다 . 또는 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">일반 데이터 정의와는 달리, 데이터 가족의 결과 종류 일 필요는 없습니다 &lt;code&gt;Type&lt;/code&gt; : 그것은 양자 택일 (와 종류의 변수가 될 수 있습니다 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ). 그러나 데이터 인스턴스의 종류는 &lt;code&gt;Type&lt;/code&gt; 으로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">:-) GHC에 제공하는 유용한 편집증 옵션은 &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lint 옵션입니다. 이로 인해 각 코어에서 코어로의 변환 패스 후 &quot;보풀이없는&quot;패스가 오류 (특히 유형 오류)를 확인합니다. 우리는 &lt;code&gt;-dcore-lint&lt;/code&gt; 실행 합니다. 컴파일 시간이 약 5 %입니다.</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">세마포어를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">벡터의 요소를 언 박스 튜플에 풉니 다. #</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">압축 풀기 생성자 필드는 컴파일러에 펼침을 표시하여 가능한 한 자주 복싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">Unpacking 생성자 필드는 Unfolding을 컴파일러에 노출하여 가능한 한 자주 리 박싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt; 1&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">활성 시간 초과를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">등록되지 않은 컴파일은 GHC를 새로운 머신으로 포팅 할 때 유용 할 수 있습니다. 이는 사전 설치 도구를 &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 로 줄이며 그 외에는 더 이상 등록되지 않은 컴파일을 얻기 위해 작성해야하는 플랫폼 별 코드의 양을 줄여 주기 때문입니다. 가는 것은 보통 아주 작습니다.</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">컴파일 타임에는 등록되지 않은 컴파일을 선택할 수 없습니다. 적절한 옵션 세트로 GHC를 빌드해야합니다. 자세한 내용은 GHC 빌딩 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자, 0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 반환 반환 범위 검사를 생략합니다. 이는 프로그래머가 범위를 다른 방식으로 검사하도록 보장해야 할 의무가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 반환하는 안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (아래 첨자) 연산자입니다. 이는 경계 검사를 생략합니다. 이는 프로그래머가 다른 방식으로 경계를 검사해야한다는 의무가 수반된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">안전하지 않은 API 만.</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">안전하지 않은 IO 작업</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 사이의 안전하지 않은 변환 . 이것은 no-op이며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성에 편의상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 간의 안전하지 않은 변환 . 이것은 작동하지 않으며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">안전하지 않은 변환 코드</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">소수 자릿수에 대한 안전하지 않은 변환.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">안전하지 않은 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">안전하지 않은 저수준 작업</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">안전하지 않은 작업</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 수준 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 단위 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">STM 모나드에서 IO를 안전하지 않게 수행합니다. 조심하십시오 : 이것은 매우 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">특정 옵션을 설정 해제합니다. 사용 가능한 옵션 목록은 &lt;a href=&quot;#ghci-set&quot;&gt;: set 및 : seti 명령&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">부호없는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">부호없는 정수 유형</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 소리</target>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">불안정한 스냅 샷 릴리스의 이름은 &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; 입니다. 여기서 &lt;code&gt;YYYYMMDD&lt;/code&gt; 는 스냅 샷이 작성된 소스의 날짜입니다. 예를 들어, &lt;code&gt;6.7.20040225&lt;/code&gt; 는 &lt;code&gt;6.8&lt;/code&gt; 분기를 만들기 전에 HEAD의 스냅 샷입니다 .</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWST 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">누적 계산을 (결과, 출력) 쌍으로 래핑 해제합니다. (의 역 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">누적 계산을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">일련의 쌍을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">문자가 지정된 소스 위치를 업데이트하십시오. 문자가 개행 ( ​​'\ n') 또는 캐리지 리턴 ( '\ r') 인 경우 행 번호는 1 씩 증가합니다. 문자가 탭 ( 't') 인 경우 열 번호는 가장 가까운 8 '까지 증가합니다 열, 즉 &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; . 다른 모든 경우에는 열이 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">지정된 시간 (마이크로 초) 내에 실행되도록 활성 시간 초과를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &quot;을 사용하여 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; 대해 미리 작성된 정확한 바이트 수를 계산하십시오 . 경우 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 가 작성되고보고 제로 반면, 기록 된 바이트 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 에 보고 한 바이트.</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt; 사용할 프로그램을 선택 하려면 -pgmF ⟨cmd⟩ 를 사용하십시오 . ⟨cmd⟩ 프리 프로세서는 명령 행에 최소한 세 개의 인수가 제공됩니다. 첫 번째 인수는 원본 소스 파일의 이름이고, 두 번째는 입력을 보유한 파일의 이름이며, 세 번째는 ⟨cmd⟩가 출력을 기록해야하는 파일의 이름</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 규칙이 해고되고 있는지 아주 자세하게 볼 수 있습니다. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt; 정의 된 규칙 확인 &lt;em&gt;이 모듈을&lt;/em&gt; . 여기에는 전문화 단계에서 생성 된 규칙이 포함되지만 다른 모듈에서 가져온 규칙은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실행중인 규칙을 확인하십시오. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용 하고 중단 가능한 작업을 피 하십시오 . 이를 위해서는 인터럽트가 가능한 작업을 알아야합니다. 주어진 라이브러리 함수에 대해 내부적으로 인터럽트 가능한 조작을 호출 할 수 있는지 여부를 알 수 없습니다. 대신 아래에 보장 할 수없는 보장 가능한 작업 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 범위 동안 호출 된 인터럽트 가능 조작 이 단시간 동안 만 차단 될 수 있다는 것을 보장 할 수 없으면 일반적으로 권장되지 않습니다 . 그렇지 않으면, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 는 프로그램을 교착 상태로 만들고 사용자 인터럽트에 응답하지 않는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">이 문제를 피 하려면 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 의 동작을 얻으려면 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; 을 사용 하여 &lt;a href=&quot;data-monoid&quot;&gt;Data&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 의 동작을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">실행 파일에 &lt;strong&gt;strip&lt;/strong&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">LLVM을 통해 컴파일하는 대신 GHC의 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;고유 코드 생성기를&lt;/a&gt; 사용하십시오 . &lt;code&gt;-fasm&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 된 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">STM을 사용하십시오. 트랜잭션은 항상 완전히 실행되거나 전혀 실행되지 않기 때문에 트랜잭션은 비동기 (및 실제로 동기) 예외가있는 상태에서 변하지 않는 상태를 유지하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 입력 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 증거 로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">더 큰 힙을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">가장 오래된 세대를 수집하려면 압축 알고리즘을 사용하십시오. 기본적으로 가장 오래된 세대는 복사 알고리즘을 사용하여 수집됩니다. 이 옵션을 사용하면 대신 해당 위치로 압축됩니다. 압축 알고리즘은 복사 알고리즘보다 속도가 느리지 만 메모리 사용량을 상당히 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">ApplicativeDo에 대해 느리지 만 더 나은 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">제목에 작은 상자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오. 항상 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">다음과 같이 레코드 표현식에 명시 적 유형 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">오류 메시지에 색상 사용</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">GHCi 명령 히스토리 파일 &lt;code&gt;.ghci-history&lt;/code&gt; 에 현재 디렉토리를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">사이의 값을 소수점 표기법을 사용하여 &lt;code&gt;0.1&lt;/code&gt; 및 &lt;code&gt;9,999,999&lt;/code&gt; 달리, 과학 표기법을.</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">주어진 파일에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">외국 수출 신고를 사용하여 외부에서 호출하려는 Haskell 함수를 수출하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">세대 Cgen⟩ 이상의 병렬 GC에서로드 밸런싱을 사용하십시오. ⟨gen⟩을 생략하면로드 밸런싱이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">더 많은 메모리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">이 유형의 사용은 권장하지 않습니다. 다음과 같은 내용을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">세대 ⟨gen⟩ 이상에서는 병렬 GC를 사용하십시오. ⟨gen⟩을 생략하면 병렬 GC가 완전히 꺼지고 순차적 GC로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">posix setgid를 사용하여 하위 프로세스의 그룹 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">posix setsid를 사용하여 새 세션에서 새 프로세스를 시작하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">posix setuid를 사용하여 하위 프로세스의 사용자 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">이전 매개 변수를 사용하십시오. 기본적으로 PostScript 그래프는 페이지를 채울 수 있도록 가로 및 세로로 자동 배율이 조정됩니다. 그러나 프리젠 테이션에 사용할 일련의 그래프를 준비 할 때 이전 그래프와 동일한 스케일, 음영 및 순서를 사용하여 새 그래프를 그리는 것이 종종 유용합니다. &lt;code&gt;-p&lt;/code&gt; 플래그의 이전 실행에 의해 결정된 파라미터를 사용하여 그려 그래프 발생 &lt;code&gt;hp2ps&lt;/code&gt; 에 &lt;code&gt;file&lt;/code&gt; . 이들은 &lt;code&gt;file@.aux&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">정적 하스켈 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">엄격 주석을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아닌 경우에도 가능하면 터미널 스타일의 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 블록 에서 반박 가능한 패턴을 제거 할 때 레거시 &lt;code&gt;Monad.fail&lt;/code&gt; 함수 대신 &lt;code&gt;MonadFail.fail&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="translated">C 코드 생성기를 사용하십시오. 등록되지 않은 GHC 빌드에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="translated">Haskell 2010 언어 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">OS 선호도 기능을 사용하여 OS 스레드를 CPU 코어에 고정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;-fno-cse&lt;/code&gt; 를 사용하면 모듈에서 공통 하위 표현식 제거가 수행되지 않도록 할 수 있습니다. 이는 별도의 두 가지 부작용을 결합 할 수 있습니다. 좋은 예는 여러 전역 변수를 사용하는 것입니다 ( 아래 예의 &lt;code&gt;test&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">실행 된 규칙을 보려면 디버그 플래그 &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용하십시오. 추가 정보가 필요한 경우 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 는 각 개별 규칙 발생을 보여주고 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 는 코드가 재 작성 전후에 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">디버깅 런타임 사용</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 코드 생성기의 레지스터 할당에 그래프 색상 지정 레지스터 할당자를 사용하십시오. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">기본 코드 생성기에서 반복 병합 그래프 색상 지정 레지스터 할당자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">입력 및 출력 모두에서 기본 개행 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">새로운 cfg 기반 블록 레이아웃 알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">⟨file⟩ 또는 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; 패키지 환경 을 사용하십시오 &lt;code&gt;-&lt;/code&gt; 패키지 환경을 읽지 않으면 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">개인용 이스케이프 메커니즘을 사용하여 잘못된 시퀀스를 라운드 트립 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">실행 가능 프로그램 에서 런타임 플래그 &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;-with-rtsopts&lt;/code&gt; 로 설정된 옵션을보십시오 .</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">지정된 패키지 환경을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">제공된 손잡이를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">스레드 런타임 사용</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">다음과 같이 레코드 업데이트에 푸시되는 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows CREATE_NEW_CONSOLE 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">프로세스를 작성할 때 Windows DETACHED_PROCESS 플래그를 사용하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">바운드 스레드 사용으로 인해 실제로 성능 손실이 관찰 된 드문 경우 &lt;em&gt;에만&lt;/em&gt; 이 기능을 사용하십시오 . 메인 스레드를 바인딩 할 필요가없고 동시성 (예 : 웹 서버) 을 &lt;em&gt;많이&lt;/em&gt; 사용 하는 프로그램 은 &lt;code&gt;main&lt;/code&gt; 액션을 &lt;code&gt;runInUnboundThread&lt;/code&gt; 로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">이 기능을 사용하면 JSON 또는 HTML과 같은 텍스트 기반 형식에 효율적인 인코더를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용 하여 작은 ( &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 작성 하거나 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 에서 생성 된 청크와 공유되지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">청크가 생성 된 직후 폐기되는 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 생성에이 전략을 사용하십시오 . 예를 들어 네트워크 소켓에 쓰기 위해 생성하는 경우를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">이 전략을 사용하면 청크가 하나의 가비지 콜렉션에서 살아남을 수있는 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 생성 할 수 있습니다. 이 전략은 너무 많은 메모리가 쏟아지지 않도록 절반 이하로 채워지는 버퍼를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">박스가없는 유형 (GHC 확장)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때는 유니 코드 구문을 사용하십시오. &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">표현식, 유형 및 종류를 인쇄 할 때 유니 코드 구문을 사용하십시오. &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">C 컴파일러로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">C 컴파일러로 cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-cpp&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">C 프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-cpp&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">DLL 생성기로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">LLcmd⟩를 LLVM 컴파일러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">LLVM 최적화 프로그램으로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">LLcmd⟩를 LLVM 최적화 프로그램으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">⟨cmd⟩를 어셈블러로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtool에 대한 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool의 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩를 외부 인터프리터 명령으로 사용합니다 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 기본값 : &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;ghc-iserv-prof&lt;/code&gt; , &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 이 활성화 된 경우 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;ghc-iserv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">interpretcmd⟩를 외부 인터프리터 명령으로 사용하십시오 ( &lt;a href=&quot;ghci#external-interpreter&quot;&gt;별도의 프로세스에서 인터프리터 실행&lt;/a&gt; 참조 ). 기본값 : &lt;code&gt;-prof&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;ghc-iserv-prof&lt;/code&gt; , &lt;code&gt;-dynamic&lt;/code&gt; 이 활성화 된 경우 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 또는 그렇지 않은 경우 &lt;code&gt;ghc-iserv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">외부 통역사 명령으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">⟨cmd⟩를 libtool 명령으로 사용하십시오 ( &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt; 만 사용 하는 경우).</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtool 명령으로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-staticlib&lt;/code&gt; 만 사용 하는 경우).</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">링커로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="translated">개체 파일 병합시 ⟨cmd⟩를 링커로 사용</target>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="translated">개체 파일을 병합 할 때 (예 : GHCi에로드하기 위해 결합 된 개체를 생성 할 때) ⟨cmd⟩를 링커로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">링커로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">리터럴 프리 프로세서로 precmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">⟨cmd⟩를 전처리기로 사용합니다 ( &lt;a href=&quot;#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="translated">⟨cmd⟩를 전처리기로 사용 ( &lt;a href=&quot;phases#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt; 만 사용)</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩ 사용 ( &lt;code&gt;-F&lt;/code&gt; 만 해당)</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">프리 프로세서로 ⟨cmd⟩를 사용하십시오 ( &lt;code&gt;-F&lt;/code&gt; 만 사용).</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">Windows에서 매니페스트를 포함시키기위한 프로그램으로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windows에서 매니페스트를 포함하는 데 사용할 프로그램으로 ⟨cmd⟩를 사용하십시오. 일반적으로 이것은 GHC 설치와 함께 제공되는 프로그램 &lt;code&gt;windres&lt;/code&gt; 입니다. &lt;a href=&quot;#options-linker&quot;&gt;연결에 영향을주는 옵션의 &lt;/a&gt; &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">스플리터로 ⟨cmd⟩ 사용</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">스플리터로 ⟨cmd⟩를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">filefile⟩을 makefile로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makefile&lt;/code&gt; 또는 &lt;code&gt;Makefile&lt;/code&gt; 대신 ⟨file⟩을 makefile로 사용하십시오 . ⟨file⟩이 존재하지 않는 경우, &lt;code&gt;mkdependHS&lt;/code&gt; 는 그것을 만듭니다. 우리는 종종 &lt;code&gt;-dep-makefile .depend&lt;/code&gt; 를 사용 하여 종속성을 &lt;code&gt;.depend&lt;/code&gt; 에 넣은 다음 &lt;code&gt;.depend&lt;/code&gt; 파일 을 &lt;code&gt;Makefile&lt;/code&gt; 에 &lt;code&gt;include&lt;/code&gt; 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">프로그램을 실행할 때 ⟨x⟩ 동시 스레드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">대화식 바인딩 세트에 대한 SPT 항목을 추가하기 위해 GHCi에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">'x 등에 사용되지만 프로그래머는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">컴파일러 생성 오류 메시지에 사용됩니다. 인코딩하면 문자열 정크 바이트가 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">매개 변수 발생을 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">오버로드 및 오버로드되지 않은 리터럴에 사용됩니다. 현재 오버로드되지 않은 리터럴을 표현할 수있는 좋은 방법이 없습니다. 그게 중요하지 않을까요?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; , &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 및 &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n,n'..m]&lt;/code&gt; 에서 &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; 에 사용되며 가능한 구현은 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; , &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; , &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 및 &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..]&lt;/code&gt; 을 &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">Haskell의 &lt;code&gt;[n..m]&lt;/code&gt; 을 &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; 변환하는 데 사용되며 가능한 구현은 &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">Fast String 조각을 나타내는 데 사용되지만 이제는 더 이상 사용되지 않으며 Str 생성자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; 의 &lt;code&gt;xxxBy&lt;/code&gt; 함수 계열 과 함께 사용하기에 유용한 결합기 ( 예 :</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">유용한 오류 처리 기능</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">NF = WHNF가 보유하는 유형에 대해 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 를 정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">가비지 수집이 필요한 장기 할당에 유용합니다. 그러나 메모리에 대한 포인터를 외부 데이터 구조로 저장하려는 경우 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 을 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">할당이 지정된 &lt;code&gt;IO&lt;/code&gt; 계산을 통해 범위를 지정하려는 경우 단기 할당에 유용합니다 . 이러한 종류의 할당은 일반적으로 FFI 기능과 데이터를 마샬링 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">에 유용한:</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">유용한 기능과 결합기.</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">유용한 기능.</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">유용한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">인스턴스 작성에 유용한 헬퍼</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">불변으로 인한 유용한 속성 :</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">사용자 환경</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">사용자 상호 작용 기능</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">사용자 이름</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">사용자 환경 설정</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">사용자 정의 연산자에는 새 &lt;code&gt;form&lt;/code&gt; 키워드 대신 바나나 괄호가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">사용자 정의 유형 오류</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 비교 ( &lt;code&gt;Ord&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">사용자 제공 평등 ( &lt;code&gt;Eq&lt;/code&gt; 컨텍스트 대체 )</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">사용자는 GHC가 지문을 계산하기 위해 내부적으로 사용하는 것과 동일한 기능을 사용할 수 있습니다. &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint의&lt;/a&gt; 모듈은 지문을 구성하기위한 유용한 기능을 제공합니다. 예를 들어, &lt;code&gt;fingerprintFingerprints&lt;/code&gt; 와 &lt;code&gt;fingerprintString&lt;/code&gt; 을 함께 사용 하면 플러그인에 인수를 순진하게 쉽게 지문으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;~/.haskeline&lt;/code&gt; 파일을 사용 하여 인터페이스를 사용자 정의 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">내장 제약 조건 해결 동작과 충돌하지 않는 경우 사용자는 자신의 &lt;code&gt;HasField&lt;/code&gt; 인스턴스를 정의 할 수 있습니다. 이를 통해 다른 유형의 데이터 유형에 대해 &quot;가상&quot;레코드 필드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">사용자는 다음 규칙을 준수 할 것으로 예상되는 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 의 사용자 지정 인스턴스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">이 기능의 사용자는 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; 그들이 다른 하스켈 스레드가 readProcess의 결과를 기다리는 동안 계속 실행하려면.</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">사용자는 &lt;code&gt;~&lt;/code&gt; 를 원할 가능성이 높지만 , GHC가 사전에 두 가지 관심 유형이 같은 종류라는 것을 알 수없는 경우 &lt;code&gt;~~&lt;/code&gt; 를 사용할 수 있습니다. 있다는 증거 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; GHC이 모두 알려 &lt;code&gt;k1&lt;/code&gt; 과 &lt;code&gt;k2&lt;/code&gt; 동일하고 있는지 및 &lt;code&gt;b&lt;/code&gt; 동일하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">구성 및 패턴 일치를 포함하여 생성자를 언급하기 때문에 항상 모호하지 않은 필드를 사용하면 중복 된 필드 이름을 자유롭게 사용할 수 있습니다. 예를 들어, &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 다음이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="translated">모든 세대에 대해 세대 별 복사 가비지 수집기를 사용합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">8 비트 문자 사용</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">프로그래머는 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#newtype-deriving&quot;&gt;newtypes의 일반화 된 파생 인스턴스)을&lt;/a&gt; 사용하여 기존 클래스 인스턴스를 가져 와서 새 유형의 해당 클래스 인스턴스로 &quot;리프팅&quot;할 수 있습니다. 그러나 이것이 항상 안전한 것은 아닙니다. 예를 들어 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC에 &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 에&lt;/a&gt; 의해 인쇄 될 때마다 닫힌 유형 패밀리 방정식 간의 비 호환성을 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 를&lt;/a&gt; 사용하면 GHC에게 인쇄시 동등 관계를 구별하도록 지시합니다. 예를 들어, &lt;code&gt;~&lt;/code&gt; 는 균질 해제 평등 (인수의 종류는 동일 함)이며 &lt;code&gt;~~&lt;/code&gt; 는 이종 해제 평등 (인수의 종류가 다를 수 있음)이며 &lt;code&gt;~#&lt;/code&gt; 는 이기종 해제 된 평등, GHC의 내부 평등 관계입니다. 솔버. 일반적으로 사용자는 여기서 미묘함에 대해 걱정할 필요가 없습니다. &lt;code&gt;~&lt;/code&gt; 아마 당신이 원하는 것입니다. &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 가&lt;/a&gt; 없으면 GHC는이 모든 것을 &lt;code&gt;~&lt;/code&gt; 로 인쇄합니다 . &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;평등 제약 조건을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt; 유형의 GHC 인쇄 강제 변환을합니다. 다른 종류의 유형 간 동등성을 증명하려고 할 때 GHC는 유형 수준의 강제를 사용합니다. 사용자는 내부 용이므로 이러한 정보를 거의 볼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; GHC는 명시 적으로 인쇄 할 수 &lt;code&gt;forall&lt;/code&gt; 유형의 상단 수준에서 정량화; 일반적으로 이것은 억제됩니다. 예를 들어 GHCi에서 :</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">사용 &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; GHC는 일반적으로 억제하는 유형의 종류 인수를 인쇄 할 수 있습니다. 종류 다형성을 사용할 때 중요 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 의 형식 서명 에있는 형식 변수가 형식 응용 프로그램에 사용 가능 하지 않다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 보이는 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; 을&lt;/a&gt; 사용하면 &lt;code&gt;myLength1&lt;/code&gt; 의 유형 서명 에있는 유형 변수가 유형 적용에 사용할 수 없다는 결론을 내릴 수 있습니다. 그러나 이것은 사실이 아닙니다! 가시적 인 유형 응용 프로그램 속성과 관련하여 가장 정확한 정보를 원하면 &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 를&lt;/a&gt; 사용 하는 것은 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 것이 좋습니다. 그렇지 않으면 추가 포장 및 포장 풀기가 최적화되지 않기 때문입니다. 사실, 가능성이 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 도 성능을 악화시킬 수 &lt;em&gt;와 &lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 를&lt;/a&gt; (그것이 당신에게 무슨 일이 생기면 알려 주시기), 그러나 이것은 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 은 하스켈 런타임 시스템의 스케줄링 행동에 전혀 차이가 없습니다. 당신이 사용해야하는 일반적인 오해입니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 을 외국 전화를 걸 때 모든 하스켈 스레드를 차단하지 않도록; 그렇지 않습니다. 모든 Haskell 스레드 (GHC 포함)를 차단하지 않고 외래 전화를 걸 려면 프로그램을 링크 할 때 &lt;code&gt;-threaded&lt;/code&gt; 옵션 만 사용 하고 외래 가져 오기가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 파괴됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수 있지만 typechecker는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않습니다. 즉, 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 사용 은 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 사용하면 STM이 제공하는 일부 보증이 무효화 됩니다. 썽크가 평가되는시기에 따라 다른 트랜잭션 내에서 트랜잭션을 실행할 수 있습니다. 중첩 된 트랜잭션이 시도되면 런타임에서 예외가 발생합니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 안전하게 사용할 수는 있지만 유형 검사기 는 중첩 트랜잭션을 시도 할 수있는 프로그램을 배제하지 않으므로 프로그래머가이를 방지하기 위해 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 내부에서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 위험하지만 다른 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 대한 자세한 내용은 unsafeIOToSTM 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">로 ByteStrings를 사용 &lt;code&gt;CString&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">ByteString을 CString으로 사용</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">CString에 함수와 함께 ByteStrings 사용</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; 옵션 없이 GHC를 사용하면 모든 외래 호출은 시스템의 다른 모든 Haskell 스레드를 차단하지만 I / O 작업은 그렇지 않습니다. 으로 &lt;code&gt;-threaded&lt;/code&gt; 옵션의 만 외국 통화 &lt;code&gt;unsafe&lt;/code&gt; 속성은 다른 모든 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">공유 객체 이름에 GHC의 버전 번호를 사용하면 다른 GHC 버전으로 컴파일 된 다른 라이브러리 버전을 표준 시스템 위치 (예 : * nix &lt;code&gt;/usr/lib&lt;/code&gt; 아래)에 설치할 수 있습니다 . GHC의 버전 번호를 얻으려면 &lt;code&gt;ghc --numeric-version&lt;/code&gt; 을 호출 하고 ⟨GHCVersion⟩ 대신 해당 출력을 사용하십시오. 공유 객체 링크를 위해 객체 파일을 준비하는 방법에 대한 &lt;a href=&quot;phases#options-codegen&quot;&gt;코드 생성&lt;/a&gt; 에 영향을주는 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 조합을 사용하면 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 일반 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는 수행 방법에 대한 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 조합을 사용하면 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; 프레임 워크를 사용하여 데이터 유형 제네릭 프로그래밍을 쉽게 수행 할 수 있습니다 . 이 섹션에서는이를 수행하는 방법에 대한 매우 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">로케일 종속 인코딩 사용</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">패키지를 사용하는 것이 더 간단 할 수는 없습니다 : &lt;code&gt;--make&lt;/code&gt; 또는 GHCi를 사용 하는 경우 설치된 패키지의 대부분은 추가 옵션없이 프로그램에서 자동으로 사용할 수 있습니다. 이 규칙의 예외는 아래의 &lt;a href=&quot;#using-packages&quot;&gt;패키지 사용&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">값을 0으로 설정하면 RTS 클럭이 완전히 비활성화되고 컨텍스트 스위치 타이머 및 힙 프로파일 링 타이머에 따라 타이머를 비활성화하는 효과가 있습니다. 상황 전환은 여전히 ​​발생하지만 결정 론적으로 정상보다 훨씬 빠른 속도로 진행됩니다. 인터벌 타이머를 비활성화하면 런타임시 비결 정성 소스가 제거되므로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="translated">구멍 맞춤 플러그인을 사용하면 유효한 구멍 맞춤 제안의 동작을 확장하여 GHC가 사용하는 유형이 지정된 구멍에 대한 동일한 정보를 사용하여 Hoogle 또는 기타 외부 도구를 사용하여 유효한 구멍 맞춤을 찾거나 합성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">레코드 선택기 사용</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 모듈을 병렬로 컴파일 할 수 있습니다. ⟨n⟩ 작업을 병렬로 컴파일하려면 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; 을 지정 하십시오 . ⟨n⟩을 생략하면 기본값은 프로세서 수입니다.</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">은 Using &lt;code&gt;+&lt;/code&gt; 용 의 형태 &lt;code&gt;module&lt;/code&gt; 명령은 현재 범위에 모듈을 추가하고 &lt;code&gt;-&lt;/code&gt; 이를 제거한다. &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 가 없으면 현재 범위는 지정된 모듈 세트로 대체됩니다. 이 양식을 사용하고 &lt;code&gt;Prelude&lt;/code&gt; 를 생략 하면 암시 적 &lt;code&gt;Prelude&lt;/code&gt; 가져 오기가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="translated">이것을 사용하면 프로그램이 약간 느려질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">일반적으로 GHC 블랙홀은 스레드를 전환 할 때만 썽크입니다. 이 플래그는 썽크가 입력 되 자마자 그렇게합니다. &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;공유 메모리 멀티 프로세서에서 Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">일반적으로 사용자의 실제 이름 (pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">일반적으로 파일 이름은 모듈 이름을 따서 지정해야하며 모듈 이름의 점은 디렉토리 구분 기호로 대체해야합니다. 예를 들어, Unix 시스템에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈 은 일부 기본 디렉토리와 관련 하여 파일 &lt;code&gt;A/B/C.hs&lt;/code&gt; 에 배치되어야합니다 . 다른 모듈 ( 예 : &lt;code&gt;Main&lt;/code&gt; ) 에서 모듈을 가져 오지 않으면 파일 이름을 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">Win32 API 호출을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">Windows C 문자열의 기본 마샬링을위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">문서를위한 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;foreign import safe&lt;/code&gt; FFI 호출에 유효한 인수 : &lt;code&gt;ByteArray#&lt;/code&gt; 및 &lt;code&gt;MutableByteArray#&lt;/code&gt; . 바이트 배열은 &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;고정&lt;/a&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="translated">&lt;code&gt;foreign import unsafe&lt;/code&gt; FFI 호출에 유효한 인수 : &lt;code&gt;Array#&lt;/code&gt; , &lt;code&gt;SmallArray#&lt;/code&gt; , &lt;code&gt;ArrayArray#&lt;/code&gt; , &lt;code&gt;ByteArray#&lt;/code&gt; 및 이러한 유형의 변경 가능한 대응 항목.</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">유효한 &lt;code&gt;fst _ _&lt;/code&gt; 구멍 인 &lt;code&gt;head _ _&lt;/code&gt; 또는 fst _ _ 와 같은 구멍 이 있지만 리파이닝 레벨이 &lt;code&gt;&amp;gt;= 2&lt;/code&gt; 인 경우 유효한 리파이닝 구멍 맞춤의 유효한 목록이 종종 커질 수 있습니다 .이 구멍 은 하나 이상의 구멍 때문에 관련이 없을 것입니다 이러한 구멍의 종류 나 종류가 제안 된 식별자에 의해 전혀 제약을받지 않는다는 점에서 여전히 완전히 개방되어있다. 기본적으로 이러한 구멍은보고되지 않습니다. 이 플래그를 켜면 해당 구멍이 유효한 다듬기 구멍 맞춤 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 유효성을 검사합니다 . 이 접근 방식은 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt; 사용의 장점을 보여 줍니다 . 우리는에 계속 전달 &lt;code&gt;validateName&lt;/code&gt; 및 인터럽트의 실행을 &lt;code&gt;Cont&lt;/code&gt; 발 블록 &lt;em&gt;내부&lt;/em&gt; 의 &lt;code&gt;validateName&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 를 채우는 동안 계산 된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 값 은 항상 네트워크 순서 (빅 엔디안) 형식으로 인코딩되며 인코딩 된 데이터는 컴퓨터 엔디안, 워드 크기 또는 컴파일러 버전간에 이식 가능해야합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 인코딩 된 데이터 는 모든 컴퓨터에서 쓰고 다른 컴퓨터에서 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TExp a&lt;/code&gt; 유형의 값은 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; 함수를 사용하여 &lt;code&gt;Exp&lt;/code&gt; 유형의 값으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">바닐라 유형 동의어 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">타입 어플리케이션에 사용할 수없는 변수가 우선입니다.</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort ( &lt;a href=&quot;#scopedsort&quot;&gt;지정된 변수의&lt;/a&gt; 정렬)에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">사용자가 명시 적으로 정렬하지 않은 변수는 ScopedSort (ScopedSort)에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; 하는 &quot;장벽 재정렬에&quot;속성 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">의 변형 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 의 스타일 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">허용되는 인스턴스의 다양성이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">OS 버전 확인</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">버전 정보</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">컴퓨터에 대한 버전 정보.</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에서 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 구성하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 크기의 moduli 용 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 버전</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">버전 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 는 에서 작동 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;nextPrimeInteger&lt;/code&gt; 작동하는 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 의 버전</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">버전 관리 체계는 다양하고 다양하므로이 라이브러리에서 제공하는 버전 표현은 거의 모든 기능이 합리적으로 제공 될 수없는 전체 일반 성과 너무 제한적인 특정 버전 관리 체계를 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">시퀀스의 왼쪽 끝을 봅니다.</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">시퀀스의 오른쪽 끝보기</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">패턴보기</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">언어 패턴 &lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; 에&lt;/a&gt; 의해 뷰 패턴이 활성화됩니다 . 보기 패턴에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">보기 패턴은 언어 확장 &lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; 에&lt;/a&gt; 의해 활성화됩니다 . 보기 패턴에 대한 자세한 정보와 예는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">뷰 패턴은 다른 패턴 안에 중첩 될 수있는 패턴 가드와 다소 비슷합니다. 그것들은 추상 타입의 값들에 대한 패턴 매칭의 편리한 방법입니다. 예를 들어, 프로그래밍 언어 구현에서 다음과 같이 언어 유형의 구문을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">뷰 패턴을 사용하면 패턴 내부에서 뷰 함수를 호출하고 결과와 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">거의 모든 종류의 데이터 생성자를 포함하여 거의 모든 데이터 생성자를 승격시킬 수 있습니다. 이 규칙에는 몇 가지 예외 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">무효 : 생성자가없는 데이터 유형에 사용</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경고 :이 기능은 맵을 손상시킬 수 있으며 결과는 입력의 내부 구조에 따라 달라질 수 있습니다. 사용자는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 를 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">경고 : 컴파일러가 기본 데이터 구조를 자유롭게 최적화하거나 복제 할 수 있기 때문에 기본이 아닌 기본 Haskell 유형에 대한 약한 포인터는 특히 취약합니다. 따라서 종료자를 일반 Haskell 유형에 배치하려고하면 종료 기가 예상보다 빨리 실행될 수 있습니다. 조기 종료가 쉬운 캐시 및 메모 테이블에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">장치를 사용할 수있게 될 때까지 기다리십시오</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">지정된 수량이 준비 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 을 기다 립니다 (일명 &lt;strong&gt;P&lt;/strong&gt; 작업).</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">신호를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">지정된 프로세스가 종료 될 때까지 대기하고 종료 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">최상위 인스턴스 선언을 사용하여 단순화 할 수있는 형식 서명의 클래스 제약 조건에 대해 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="translated">바인딩 된 변수가 사용되지 않는 경우 레코드 와일드 카드 일치에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="translated">와일드 카드가 패턴을 바인딩하지 않으면 레코드 와일드 카드 일치에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 예 : &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(*&amp;gt;)&lt;/code&gt; 이 거꾸로 정의 된 경우 경고합니다 ( 즉, &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; 가 거꾸로 정의 된 경우 경고합니다 (예 : &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 가 거꾸로 정의되어 있으면 경고합니다 (예 : &lt;code&gt;pure = return&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">패턴 바인딩이 고독한 와일드 카드 패턴이거나 뱅킹 패턴이 아닌 한 변수가 바인딩되지 않는 경우 경고합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">승격 된 데이터 생성자가 이름 앞에 틱없이 사용 된 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">규칙이 실행되기 전에 함수가 인라인 될 수 있으므로 재 작성 RULE이 실행되지 않을 수 있음을 경고합니다. &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;규칙이 INLINE / NOINLINE pragma와 상호 작용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Applicative&lt;/code&gt; 또는 &lt;code&gt;Monad&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규적인 &lt;code&gt;Monad&lt;/code&gt; 또는 &lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">비정규 &lt;code&gt;Semigroup&lt;/code&gt; 또는 &lt;code&gt;Monoid&lt;/code&gt; 인스턴스 선언이 감지되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없으면 패키지를로드하고 대상 패키지 설명의 추가 라이브러리 스탠자를 분석 할 때로드해야한다고 추론했습니다.</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="translated">GHCi가 공유 라이브러리를로드 할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">범위를 벗어난 지연된 변수가 발생하면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;MonadFail&lt;/code&gt; 인스턴스 가없는 do-block에 실패한 패턴이 사용될 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">정의가 향후 &lt;code&gt;Semigroup&lt;/code&gt; 타입을 표준 유형 클래스에 포함시키는 것과 충돌 할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">지원되지 않는 LLVM 버전으로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용할 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">경고 : 주어진 &lt;code&gt;Vertex&lt;/code&gt; 이없는 경우 &lt;code&gt;nodeFromVertex&lt;/code&gt; 함수는 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">경고 :이 기능에는 몇 가지 단점이 있습니다 (설명서 참조). 대신 Control.Concurrent.threadDelay를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">경고 :이 함수는 가장자리리스트의 꼭짓점이 주어진 &lt;code&gt;Bounds&lt;/code&gt; 내에 있지 않으면 런타임 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">경고 : 인터페이스가 불안정합니다.</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">경고 : 줄 바꾸기 및 탭 문자는 구분 기호로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 토론하십시오. 향후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">경고 : *이 모듈은 내부에 있습니다. 필요한 경우 관리자에게 문의하여 수행하려는 작업을 설명하고 공개 API에서 필요한 작업에 대해 토론하십시오. 향후 릴리스에서는 모듈이 전혀 노출되지 않을 수 있으므로이 작업을 수행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">(a) 정의 모듈 내에서의 사용, (b) 클래스 인스턴스에서 메소드 정의 및 (c) 내보내기 목록에서의 사용에 대해서는 경고 및 사용 중단이보고되지 않습니다. 후자는 한 모듈이 모여 여러 다른 모듈의 내보내기를 다시 내보내는 라이브러리 내에서 가짜 불만을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">경고는 오류가 아닌 경고로만 취급됩니다. 이것이 기본값이지만 &lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 플래그 를 무효화하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">경고는 오류가 아닌 경고로만 처리됩니다. 이것이 기본값이지만 &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 플래그 를 부정하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="translated">향후 GHC 릴리스에서 변경 될 수있는 핵심 라이브러리 모듈의 정식 가져 오기에 대해 경고합니다. 현재 다음 모듈에이 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">이 프로그램은 &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;등록되지 않은&amp;rdquo;&lt;/a&gt; GHC 버전으로 컴파일 되었습니까 ? (즉, 현재 지원되지 않는 플랫폼이기 때문에 플랫폼 별 최적화가 컴파일되지 않은 GHC 버전입니다.)이 값은 실험적으로 빌드 된 GHC를 사용하지 않는 한 일반적으로 아니오입니다.</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우리는 (1) 버퍼를 작성하는 것에 대한 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 구현하는 BuildStep 에 완전히 넘겨줌으로써 달성 합니다 . 이 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 은 버퍼의 시작과 끝을 알려줍니다 ( &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 나타냄 ). 그런 다음, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 는 이것의 큰 접두사로 쓸 수 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 이 원하시는 어떤 방법이다. 경우] &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 가 완료되면, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 은 전체, 또는 바이트의 긴 시퀀스는 다음 직접 삽입 할 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 를 사용하여 A 호출자이 신호 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">우리는 (2) 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 가 계속되는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 을 수행하는 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 으로 구현 되도록 요구함으로써이를 달성 함으로써 업데이트 된 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 로 호출 합니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 연결을 구현하려면 함수 호출에서 두 개의 포인터 만 전달하면됩니다 . 또한 많은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 완전히 인라인되어 있으므로 컴파일러는 함수 호출없이 그리고 권투없이 전혀 시퀀스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">병렬 프로그램을 프로파일 링 하는 데 &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; 를 사용하는 것이 좋습니다 . 병렬 실행을 시각화하기위한 GUI를 제공하며 GHC와 함께 제공되는 시간 및 공간 프로파일 링 기능을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 의 운영을 높이고 자 합니다. 동작을 위해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; , 우리는 알고 &lt;code&gt;throwE e&lt;/code&gt; 우리가 두 개의 모나드 변압기를 통해 올릴 수 있도록, 간단한 작업입니다 &lt;code&gt;InterpM&lt;/code&gt; 이와 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">우리는 실제로 더 구체적인 유형으로 &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; 를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">우리는 하나의 모듈에 국한되지 않습니다 : GHCi는의 혼합, 여러 개의 모듈에서 범위를 결합 할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 및 비 &lt;code&gt;*&lt;/code&gt; 의 형태. GHCi는 이러한 모든 모듈의 범위를 결합하여 프롬프트에서 적용되는 범위를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">이것을 절차 또는 화살표 추상화라고합니다. 람다 식과 마찬가지로 변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;proc&lt;/code&gt; -expression 내에 바인딩 된 새 변수 입니다. 화살표 입력을 나타냅니다. 위의 예에서 &lt;code&gt;-&amp;lt;&lt;/code&gt; 는 식별자가 아니라 화살표 유형의 표현식과 해당 화살표에 대한 입력으로 공급 될 표현식에서 명령을 빌드하는 데 사용되는 새로운 예약 기호입니다. (이상한 모양은 나중에 더 의미가있을 것입니다.) 화살표의 적용과 유사하게 읽을 수 있습니다. 위의 예는 Haskell 식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">Writer를 사용하여 프리미티브를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">비슷한 방식으로 생성자 클래스의 인스턴스를 파생시킬 수도 있습니다. 예를 들어, 상태 및 고장 모나드 변압기를 구현했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">또한 핸들 또는 파일과의 값을 직접 직렬화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">소스의 마크 업 버전을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">공백과 같은 문자를 포함하는 인수를 인용 할 수도 있고 Haskell 문자열처럼 취급하거나 Haskell 목록 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">위 의 &lt;code&gt;byteStringHex&lt;/code&gt; 예제 와 같이 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 16 진수로 인코딩하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">이제 예상대로 &lt;code&gt;x&lt;/code&gt; 의 유형 이 재구성 되었으며 &lt;code&gt;f&lt;/code&gt; 의 유형 도 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">우리는 &lt;em&gt;바이너리&lt;/em&gt; 형식으로 변환하고 있음을 분명히 알 수 있습니다 . 유니 코드 코드 포인트가 127보다 큰 '&amp;lambda;'및 '&amp;ouml;'문자는 해당 UTF-8 멀티 바이트 표현으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 를 여러 번 사용하여 여러 프리미티브를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 목록의 여러 값을 단일 값으로 결합 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 는 여러 가지 다른 작업에서 monoid 이므로 여기에서 유형을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">우리는 &lt;code&gt;D&lt;/code&gt; 를 컴파일 한 다음 다음과 같이 전체 프로그램을로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">파일에서 GHCi 입력을 읽는 명령을 정의 할 수 있습니다. 이는 GHCi 세션에 반복적으로로드 할 바인딩 세트를 작성하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 변환기 를 추가하여 계산하는 파서를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; 형식을 수정하여 접두사, 접두사 또는 레코드 패턴 동의어를 정의 할 수 있습니다 . 이에 대한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">정규 이해로 번역하여 병렬 목록 이해를 정의 할 수 있습니다. 기본 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">비결 정성을 제공 하는 &lt;code&gt;[]&lt;/code&gt; 모나드에 상태 ( 파싱 ​​될 남은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; )를 추가하여 이러한 파서 모나드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">다음 인스턴스를 사용하여이 유형의 값을 바이트 문자열로 인코딩 할 수 있습니다.이 인스턴스는 반복적으로 구조를 직렬화하여 처리합니다.</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">newtype이 마지막 클래스 매개 변수 인 경우 다중 매개 변수 클래스의 인스턴스를 파생시킬 수도 있습니다. 이 경우 클래스의 &quot;부분 응용 프로그램&quot;이 &lt;code&gt;deriving&lt;/code&gt; 조항에 나타납니다 . 예를 들어, 클래스가 주어지면</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">대신 새로운 유형의 &lt;code&gt;App&lt;/code&gt; ( &lt;code&gt;App f a&lt;/code&gt; 및 &lt;code&gt;f a&lt;/code&gt; 가 메모리에서 동일하게 표시됨)을 만들고 &lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt; 를 사용하여이 패턴의 사용을 명시 적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;MismatchedParentheses&lt;/code&gt; 예외를 &lt;code&gt;MismatchedParentheses&lt;/code&gt; , &lt;code&gt;SomeFrontendException&lt;/code&gt; 또는 &lt;code&gt;SomeCompilerException&lt;/code&gt; 으로 잡을 수 있지만 &lt;code&gt;IOException&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">이제 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">값과 응용 프로그램으로 구성된 간단한 표현식을 EvalStmt에 전달할 수 있습니다. 이를 통해 GHCi가 : set args 및 : set prog를 구현하는 데 사용하는 다른 함수에서 명령문을 랩핑 할 수 있습니다. 앞으로이 작은 언어를 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">클래스 선언에서 빈 멤버를 제거하여이 특정 문제를 회피 할 수 있습니다. 그러나 나머지 멤버 인 insert 및 member에는 모호한 유형이 없지만 사용하려고 할 때 여전히 문제가 발생합니다. 예를 들어 다음 두 가지 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">모나드 결합자를 사용하여 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 인스턴스 작성을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">다음과 같이 마지막 두 개로 작성된 명령에 필요한 추가 입력을 일반 표현식에 적용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">그런 다음 표현 및 패턴 컨텍스트에서 &lt;code&gt;HeadC&lt;/code&gt; 를 사용할 수 있습니다. 패턴 컨텍스트에서는 길이가 하나 이상인 목록의 헤드와 일치합니다. 표현식 컨텍스트에서 싱글 톤 목록을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">따라서 &lt;code&gt;P&lt;/code&gt; 유형 (생성자 &lt;code&gt;MkP&lt;/code&gt; 가 있음 )을 승격 된 데이터 생성자 &lt;code&gt;'P&lt;/code&gt; (종류 &lt;code&gt;Prom&lt;/code&gt; ) 와 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">우리는 유형 체킹 수 &lt;code&gt;A&lt;/code&gt; 이 서명에 대해, 또는 우리는 인스턴스화 할 수 &lt;code&gt;Str&lt;/code&gt; 다음과 같은 선언을 제공하는 모듈. 서명 인스턴스화 방법에 대한 자세한 내용은 Cabal의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">우리는 &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt; 의 인스턴스 이지만 &lt;code&gt;Monad&lt;/code&gt; 가 아닌 타입으로 do-notation을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">예를 들어 고정 값을 프리미티브 앞에 추가하거나 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">우리는 levity polymorphism을 사용하여 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 와 함께 좋은 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">다음 함수를 사용하여 조각을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">GHCi를 사용할 때 프로파일 러를 사용하여 스택 추적을 수집 할 수 있습니다 (GHCi의 &lt;a href=&quot;#ghci-stack-traces&quot;&gt;스택 추적&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 긴 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">이를 사용하여 목록의 가장 짧은 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">마법의 유선 유형이 유형 &lt;a href=&quot;ghc-base&quot;&gt;검사기&lt;/a&gt; 가 알아 낸 것과 혼동되기 때문에 이러한 기능을 사용할 수있는 모듈 (예 : GHC.Base ) 에서 이러한 기능을 정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">우리는 우리 자신의 연산자를 정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">우리는 들어 올릴 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 에 작업을 &lt;code&gt;InterpM&lt;/code&gt; 이 세 가지 사용하여 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 들,하지만 &lt;code&gt;InterpM&lt;/code&gt; 는 자동의 인스턴스 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 우리가 사용할 수 있도록, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 을 대신 :</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">우리는 &lt;code&gt;f0&lt;/code&gt; 에게 아무것도 해독하기에 충분한 입력을 줄 수 없었 으므로 빈 문자열을 반환했습니다. 두 번째 연속 &lt;code&gt;f1&lt;/code&gt; 에 입력의 마지막 바이트를 공급하면 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">우리는 시뮬레이션 할 수 &lt;code&gt;if&lt;/code&gt; 정의하여</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;g&lt;/code&gt; 를 적용 해 볼 수 있습니다. &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 유형의 인수 와 &lt;code&gt;x :: b&lt;/code&gt; 기대하기 때문에 작동하지 않습니다 . 더 나쁜 것은, &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 타입의 인수가 필요하기 때문에 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;a&lt;/code&gt; 타입 의 무언가로 바꿀 수 없다는 것입니다 ! 요컨대,이 작업을 수행하는 좋은 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">우리는 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 유형의 두 값을 생성합니다 . 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 생성자를 사용하고 다른 하나는 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 생성자를 사용합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 이있는 경우 ) 또는 &quot;times-two&quot;함수 ( &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 가있는 경우 )를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">다음 표에서 UTF-8 CSV 인코딩 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">컴파일 된 버전의 &lt;code&gt;C&lt;/code&gt; 를 얻지 못했습니다 ! 어떻게 된 거예요? 글쎄, GHCi에서 컴파일 된 모듈은 다른 컴파일 된 모듈에만 의존 할 수 있으며,이 경우 &lt;code&gt;C&lt;/code&gt; 는 객체 파일이없는 &lt;code&gt;D&lt;/code&gt; 에 의존 하므로 GHCi는 &lt;code&gt;C&lt;/code&gt; 의 객체 파일 도 거부했다 . 자, &lt;code&gt;D&lt;/code&gt; 도 컴파일하자 :</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">우리는 &lt;code&gt;C&lt;/code&gt; 의 컴파일 된 버전을 얻지 못했습니다 ! 어떻게 된 거예요? 글쎄요, GHCi에서 컴파일 된 모듈은 다른 컴파일 된 모듈에만 의존 할 수 있습니다.이 경우 &lt;code&gt;C&lt;/code&gt; 는 객체 파일이없는 &lt;code&gt;D&lt;/code&gt; 에 의존 하므로 GHCi는 &lt;code&gt;C&lt;/code&gt; 의 객체 파일 도 거부했습니다 . 좋습니다. &lt;code&gt;D&lt;/code&gt; 를 컴파일 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">우리는 세 종류의 와일드 카드를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 보편적으로 다형성이 아니기 때문에 &lt;code&gt;E3&lt;/code&gt; 의 주장을 접지 않습니다. 에서 &lt;code&gt;E3&lt;/code&gt; 은 그것의 최종 형태 파라미터와 동일하지 않도록, (암시 적) 실존 정량화 &lt;code&gt;E&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">비록 &lt;code&gt;(a ~ Int)&lt;/code&gt; 이지만 &lt;code&gt;Int&lt;/code&gt; 가 구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지 않기 때문에 &lt;code&gt;E1&lt;/code&gt; 또는 &lt;code&gt;E4&lt;/code&gt; 의 인수를 접지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">어려운 방법으로 패키지를 작성하지 않는 것이 좋습니다. 대신 가능 하면 &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; 인프라를 사용하십시오 . 패키지가 특히 복잡하거나 많은 구성이 필요한 경우 저수준 메커니즘으로 돌아 가야 할 수 있으므로 용감한 영혼을위한 몇 가지 힌트가 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">우리는 일상 업무에 &lt;code&gt;-O*&lt;/code&gt; 플래그를 사용하지 않습니다 . 우리는 &lt;code&gt;-O&lt;/code&gt; 를 사용 하여 적절한 속도를 얻습니다. 예를 들어, 무언가를 측정하고 싶을 때. 우리는 파산을 원할 때 &lt;code&gt;-O2&lt;/code&gt; 를 사용하는 경향이 있습니다 (그리고 우리는 많은 커피 휴식을 취합니다).</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 수준의 숫자로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수가 동일한 유형 레벨 기호로 인스턴스화되었다는 증거를 얻거나 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">우리는 &lt;code&gt;_t1&lt;/code&gt; 썽크 만 평가 하여 목록의 머리를 드러 냈으며 꼬리는 이제 &lt;code&gt;_t2&lt;/code&gt; 에 바인딩 된 또 다른 썽크 입니다. &lt;code&gt;seq&lt;/code&gt; 기능을 사용할 수 있도록, 여기에 사용하기 조금 불편 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; (! 독자들에게 숙제로 남긴다) 더 좋은 인터페이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">현재 기능 번호를 찾아 C로 전달합니다.이 값은 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 로 다시 전달 되며 RTS가 &lt;code&gt;tryPutMVar&lt;/code&gt; 를 수행하려고 시도 할 기능을 RTS가 알 수 있도록 도와줍니다 . 신경 쓰지 않으면 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 기능에 대해 &lt;code&gt;-1&lt;/code&gt; 을 전달 하면 임의의 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">우리는이 &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; , &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; , 그리고 &lt;code&gt;x :: b&lt;/code&gt; . 이것을 사용하여 어떻게 든 구멍에 밑줄로 표시하고 &lt;code&gt;Int&lt;/code&gt; 유형의 값을 채워야합니다 . 우리의 옵션은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">우리는 GHC를 분기시키고 문제를 해결하는 것이이 컴파일 된 것 이외의 다른 클래스의 프로그램을 발견 한 적이 없으며, 모든 컴파일에 추가적인 오버 헤드를 부과 할 것입니다. 따라서 버그는 수정되지 않은 상태로 유지됩니다. &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;GHC 인라이너의 비밀&lt;/a&gt; 에는 더 많은 배경이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">우리는 이러한 종류를 유추합니다 :</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">내부적으로 테이블 내부의 셀을 유형의 객체로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">&lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트 로 새 샘플의 시작을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; 모드는 내부 UTF-16 인코딩을 통해 바이트를 왕복하는 바이트를 만들기 때문에 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 시퀀스 를 &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 로 인코딩 할 때 문자를 감지하면 잘못된 문자를 표시해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">나중에이 기능의 구문과 의미를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEAD 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 안정적인 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드&lt;/a&gt; 할 수있게 만들 수 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git 리포지토리&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">현재 stable 브랜치의 스냅 샷 릴리스 &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;를 다운로드 할 수&lt;/a&gt; 있으며 최신 소스는 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git 저장소&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">우리는 지연 계산, 즉 썽크가 생성 될 때 현재 스택을 캡처하고 평가 될 때이 스택을 복원한다고 앞서 언급했습니다. 최상위 썽 크는 어떻습니까? 프로그램이 컴파일 될 때 &quot;생성&quot;되므로 어떤 스택을 제공해야합니까? 최상위 썽크의 기술적 이름은 CAF ( &quot;Constant Applicative Form&quot;)입니다. GHC는 모듈의 모든 CAF에 단일 비용 센터 &lt;code&gt;M.CAF&lt;/code&gt; 로 구성된 스택을 할당합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 모듈의 이름입니다. &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 각 CAF에 다른 스택을 제공 할 수도 있습니다 . 이것은 &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 로&lt;/a&gt; 컴파일 할 때 특히 유용합니다 (기본값은 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;이상) 함수 본문의 상수가 최상위 수준으로 올라가 CAF가되기 때문입니다. 이러한 CAF가 무엇에 해당하는지 확인 하려면 Core ( &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; )&lt;/a&gt; 를 참조해야 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">앞서 언급 한 바와 같이 게으른 계산, 즉 썽 크는 생성 될 때 현재 스택을 캡처하고 평가 될 때이 스택을 복원합니다. 최상위 썽 크는 어떻습니까? 그것들은 프로그램이 컴파일 될 때&amp;ldquo;만들어집니다&amp;rdquo;. 그래서 우리는 어떤 스택을 주어야합니까? 최상위 썽크의 기술적 이름은 CAF (&amp;ldquo;일정 적용 신청서&amp;rdquo;)입니다. GHC는 모듈의 모든 CAF에 단일 비용 센터 &lt;code&gt;M.CAF&lt;/code&gt; 로 구성된 스택을 할당합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 모듈의 이름입니다. &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 각 CAF에 다른 스택을 제공 할 수도 있습니다 . &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 로&lt;/a&gt; 컴파일 할 때 특히 유용합니다 ( &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 의&lt;/a&gt; 기본값과 같이).기능 체의 상수가 최상위 수준으로 상승하여 CAF가됨에 따라) 이러한 CAF가 무엇에 해당하는지 판별 하려면 코어 ( &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; )&lt;/a&gt; 를 참조해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알 수 있습니다 . 따라서 (B)는 부분 성이 없으며 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며, GHC는 실제로 함수가 절대 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">우리는 (B)를 훨씬 선호합니다. 왜? GHC는 &lt;code&gt;(True :~: False)&lt;/code&gt; 가 빈 유형 임을 알 수 있기 때문 입니다. 따라서 (B)는 편파성이 없으며 GHC는 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 수 있습니다. 반면에 (A)는 위험 해 보이며 GHC는 실제로 함수가 호출 될 수 없는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">일반적으로 새 샘플의 시작을 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 이벤트로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">이제 실제 &lt;code&gt;encode&lt;/code&gt; 함수에 대해 &lt;code&gt;Encode&lt;/code&gt; 클래스를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">이제 hpc의 주요 모드에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">우리는 원래 표현의 자유 변수가 아닌 범위 내의 모든 변수에 대한 바인딩을 제공했지만, 이것이 성능에 상당한 영향을 미치기 때문에 자유 변수에 대한 현재 제한 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 및 &lt;code&gt;argv&lt;/code&gt; 에 대한 참조를 &lt;code&gt;hs_init()&lt;/code&gt; 전달하여 RTS에 대한 인수를 분리 할 수 ​​있습니다 (예 : &lt;code&gt;+RTS...-RTS&lt;/code&gt; 사이의 인수 ).</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">파일을 찾을 수 없거나 읽기에 실패하면 종료합니다. (대구 또는 다른 고객을위한 편의 루틴)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt; 플래그 와 병렬로 실행되도록 코드를 컴파일하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">표준 Windows 콘솔에서 GHCi를 실행하는 것이 좋습니다 . GHC 설치 프로그램이 추가 한 시작 메뉴 항목에서 &lt;code&gt;GHCi&lt;/code&gt; 옵션을 선택 하거나 &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; 를 사용하여 Windows 콘솔을 가져 &lt;code&gt;ghci&lt;/code&gt; 를 호출 하십시오 . 당신의 &lt;code&gt;PATH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">분기를 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 목록으로 나타내 므로 버전 3.2.1은 [3,2,1]이됩니다. 사전 순서 (즉, &lt;code&gt;[Int]&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 기본 인스턴스 )는 분기의 자연스러운 순서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">서명이 기본 방법에만 적용됨을 알리기 위해 &lt;code&gt;default&lt;/code&gt; 키워드를 재사용합니다 . 의 인스턴스를 정의 할 때 &lt;code&gt;Enum&lt;/code&gt; 클래스가 원래 형 &lt;code&gt;[a]&lt;/code&gt; 의 &lt;code&gt;enum&lt;/code&gt; 여전히 적용된다. 그러나 빈 인스턴스를 제공 할 때 기본 구현 &lt;code&gt;(map to genum)&lt;/code&gt; 이 채워지고 유형 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 유형 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">바운드 검사가 융합되도록 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; 의 연속 사용을 다시 작성합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">GHC에 대한 다음 메일 링리스트를 운영합니다. 적절하다고 생각되면 가입하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;f&lt;/code&gt; 의 타입 변수 가 &lt;em&gt;지정&lt;/em&gt; 되고 &lt;code&gt;g&lt;/code&gt; 의 변수 는 &lt;em&gt;유추&lt;/em&gt; 된다고 말합니다 . 일반적인 규칙은 다음과 같습니다. 사용자가 소스 프로그램에서 유형 변수를 작성한 경우 &lt;em&gt;지정됩니다&lt;/em&gt; . 그렇지 않은 경우 &lt;em&gt;추론됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 중단 점을 설정 하고 호출합니다.</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">항목 개수도 공유 메모리에 저장되고 여러 코어에서 지속적으로 업데이트하기 때문에 여러 코어에서 프로파일 링 할 프로그램을 컴파일 할 때 &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">그런 다음 새로운 Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;Danger&lt;/code&gt; 플러그인 을 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">우리는 &lt;code&gt;class&lt;/code&gt; 를 확장해야 합니다 (경고 : 이것은 다소 혼란스럽지 않은 비 터미널 기호입니다), 즉 인스턴스 선언에 나타날 수있는 두 가지 추가 양식</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">기본 서명을 사용하여 GHC ( &lt;a href=&quot;#generic-programming&quot;&gt;일반 프로그래밍&lt;/a&gt; )의 일반 프로그래밍 을 단순화 합니다.</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">다음 표에서 인코딩 기능의 효율성을 벤치마킹 하기 위해 &lt;code&gt;criterion&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">연속 &lt;code&gt;f0&lt;/code&gt; 을 사용하여 두 번째 패킷을 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 줄여 읽기 를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">읽기를 단순화하기 위해 다음 가져 오기를 사용하고 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 를 축약 합니다.</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">차라리 버그와 같은 동작을보고하여 문제를 해결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC 특정 비트를 &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt; . 나머지 코드는 FFI 표준을 지원하는 Haskell 구현간에 이식 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">우리는 &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; ; 나머지 코드는 FFI 표준을 지원하는 Haskell 구현에서 이식 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">약한 포인터는 캐시 및 메모 테이블에 특히 유용합니다. 메모 테이블을 작성하려면 함수 인수 (키)에서 결과 (값)로 데이터 구조 맵핑을 빌드하십시오. 함수를 새 인수에 적용하면 먼저 키 / 값 쌍이 이미 메모 테이블에 있는지 확인하십시오. 요점은 메모 테이블 자체가 키와 값을 유지하지 않아야한다는 것입니다. 따라서 테이블에는 일반적인 포인터가 아닌 키에 대한 약한 포인터가 포함되어야합니다. 값에 대한 유일한 참조는 실제로 메모 테이블에서 올 수 있으므로 값에 대한 포인터는 약해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">약한 포인터.</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">ThreadId에 대한 약한 참조</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">GHC 사용자 안내서에 오신 것을 환영합니다</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="translated">재귀 함수와 상호 재귀 함수 그룹은 어떻습니까? 비용은 어디에 계산됩니까? 글쎄, GHC는 서로를 재귀 적으로 호출 한 함수 그룹에 대한 정보를 유지하지만이 정보는 기본 시간 및 할당 프로필에 표시되지 않고 대신 호출 그래프가 다음과 같이 트리로 평면화됩니다. 현재 스택의 다른 곳에서 발생하면 스택의 다른 항목을 푸시하지 않고 대신이 호출에 대한 비용이 호출자 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; 로 집계됩니다 .</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">재귀 함수와 상호 재귀 함수 그룹은 어떻습니까? 비용은 어디에서 발생합니까? GHC는 서로 호출하는 함수 그룹에 대한 정보를 재귀 적으로 유지하지만이 정보는 기본 시간 및 할당 프로파일에 표시되지 않고 대신 다음과 같이 콜 그래프가 트리로 표시됩니다. 현재 스택의 다른 곳에서 발생하면 스택의 다른 항목을 푸시하지 않고이 호출에 대한 비용이 호출자에게 집계됩니다 &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">원래 정의에서 발생한 모호성 문제는 어떻습니까? 빈 함수에는 여전히 &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; 유형이 있지만 더 이상 모호한 유형으로 간주 할 필요가 없습니다. 변수 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나지 않지만 &lt;code&gt;Collects&lt;/code&gt; 클래스에 대한 종속성 은 우리에게 알려줍니다 &lt;code&gt;=&amp;gt;&lt;/code&gt; 기호 의 오른쪽에 나타나는 &lt;code&gt;ce&lt;/code&gt; 에 의해 고유하게 결정됩니다 . 따라서 빈이 사용되는 컨텍스트는 여전히 &lt;code&gt;ce&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 모두에 대한 유형을 결정하기에 충분한 정보를 제공 할 수 있습니다.모호함이 없습니다. 보다 일반적으로, 오른쪽의 변수에 의해 (직접 또는 간접적으로) 고유하게 결정되지 않은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 왼쪽에 변수가 포함 된 경우에만 유형을 모호한 것으로 간주하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">무엇 실제로 일어나는 일은 GHCi는 표현을 typechecks 것을, 그리고 그것이이없는 경우 &lt;code&gt;IO&lt;/code&gt; 의 유형을 다음과 같이 다음 그것을 변환 : 표현의 &lt;code&gt;e&lt;/code&gt; 로 변신</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 타입의 값으로 무엇을 할 수 있습니까? 특히 &lt;code&gt;MkFoo&lt;/code&gt; 에서 패턴 일치를 하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">x에 대한 명시 적 유형을 &quot;제공&quot;한다는 것은 무엇을 의미합니까? 패턴 유형 서명 ( &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt; )을 사용하여 x에 대한 유형 서명을 직접 제공하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">안전하다는 것은 무엇을 의미합니까? &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 모듈을 가져와도 모듈 을 가져 오지 않고 잘 컴파일되는 코드의 의미를 변경해서는 안됩니다. &lt;em&gt;시맨틱 일관성&lt;/em&gt; 이라고 알려진 Safe Haskell 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">유형 생성자에 대해&amp;ldquo;완전한 사용자 제공 종류 서명&amp;rdquo;으로 간주되는 것은 무엇입니까? 다음과 같은 형태입니다.</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">&lt;em&gt;실존 적&lt;/em&gt; 정량화 와 어떤 관련이 있습니까? 간단히 &lt;code&gt;MkFoo&lt;/code&gt; 는 (거의) 동형 형태 를가 집니다</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">유형 생성자 (예 : &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; )를 포괄하는 일반 클래스를 정의하려면 어떻게해야 합니까?</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; 의 종류는 무엇입니까 ? &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 라고 말할 수 있습니다 . Type-&amp;gt; k-&amp;gt; Type 이지만 이것은 올바르지 않습니다. &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; 와 같은 잘못된 항목을 허용 하므로 &lt;code&gt;Int&lt;/code&gt; 가 &lt;code&gt;Bool&lt;/code&gt; 종류가 아니기 때문에 거부해야합니다 . 중요한 관찰은 두 번째 주장의 종류가 첫 번째 주장에 &lt;em&gt;달려&lt;/em&gt; 있다는 것입니다 . GHC는 &lt;code&gt;ProxyKVis&lt;/code&gt; 의 종류에 대해 제공하는 구문에서 이러한 종속성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">결과 유형 에서이 &quot; &lt;code&gt;a&lt;/code&gt; &quot; 는 무엇입니까 ? 분명히 우리는 이것을 의미하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">어떤 종류의 접속인가</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">주어진 유형 매개 변수의 역할은 무엇입니까? GHC는 역할 유추를 수행하여 모든 매개 변수에 대한 올바른 역할을 결정합니다. 몇 가지 기본 사실로 시작합니다. &lt;code&gt;(-&amp;gt;)&lt;/code&gt; 에는 두 가지 표현 매개 변수가 있습니다. &lt;code&gt;(~)&lt;/code&gt; 두 개의 공칭 매개 변수가 있습니다. 모든 유형 패밀리의 매개 변수는 공칭입니다. 모든 GADT와 유사한 매개 변수는 공칭입니다. 그런 다음 이러한 사실은 이러한 유형이 사용되는 모든 장소로 전파됩니다. 데이터 유형 및 동의어의 기본 역할은 팬텀입니다. 클래스의 기본 역할은 명목입니다. 따라서 데이터 유형 및 동의어의 경우 오른쪽에서 사용되지 않거나 팬텀 위치의 다른 유형에서만 사용되는 모든 매개 변수는 팬텀이됩니다. 매개 변수가 표현 위치에서 사용될 때마다 (즉, 해당 변수가 역할 표현 인 생성자에 대한 유형 인수로 사용됨) 우리는 그 역할을 팬텀에서 표현으로 올립니다. 마찬가지로 매개 변수가 공칭 위치에 사용되면 해당 역할이 공칭으로 업그레이드됩니다. 우리는 역할을 명목에서 팬텀 또는 표현으로, 또는 표현에서 팬텀으로 다운 그레이드하지 않습니다.이러한 방식으로 각 매개 변수에 대해 가장 일반적인 역할을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; 의 역할 은 무엇입니까 ? 처음에는 홍당무가 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 역할을 나타내는 것처럼 보일 것입니다. 둘 다 오른쪽에 사용되며 유형 패밀리에는 관여하지 않기 때문입니다. 그러나 다음 예제와 같이 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; 의 역할 은 무엇입니까 ? 처음에는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 둘 다 역할을 표현해야하는 것처럼 보일 것입니다. 둘 다 오른쪽에서 사용되고 둘 다 유형 패밀리에 포함되지 않기 때문입니다. 그러나 다음 예에서 볼 수 있듯이 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCi는 무엇을해야합니까? 엄밀히 말하면, 프로그램은 모호합니다. &lt;code&gt;show (reverse [])&lt;/code&gt; (여기서 GHCi가 계산하는 것)는 &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; 유형을 &lt;code&gt;a&lt;/code&gt; 표시 방법은 유형 a 에 따라 다릅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">단일 패턴 세트에 적용 되는 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 가있는 경우 어떻게 됩니까? 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">어떤 종류의 힙 프로필을 수집합니까?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskell 컴파일러가 올바르게 생성하는 것은 사용되는 백엔드 코드 생성기에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC 백엔드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">인스턴스를 파생시킬 때 사용자가 명시 적으로 요청하는 것.</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">이것이 우리가 할 수있는 것은 이기종 값을 조작하는 여러 함수와 함께 이기종 값을 패키징 한 다음 패키지 모음을 균일 한 방식으로 처리하는 것입니다. 이런 식으로 객체 지향 프로그래밍을 상당히 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">마지막에해야 할 일.</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 이 아닌 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">에서 키 수행 할 작업 &lt;code&gt;m2&lt;/code&gt; 하지만 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 의 키로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">비 옵션에 따른 옵션으로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">텍스트로해야 할 일.</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">우리가 보여준 것은 어떤 &lt;code&gt;make&lt;/code&gt; 와도 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">어떤 다른 것은 우리가 지금 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 매개 변수 (그리고로 사용되는 매개 변수를 참조 &lt;code&gt;a&lt;/code&gt; ), 이름 어디서나 명시 적으로 언급되지 않는다; 우리는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;Tree a&lt;/code&gt; 의 재귀 적 사용을 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">예외가 발생할 때 대상 스레드가 수행 한 작업은 손실되지 않습니다. 다른 스레드가 필요할 때까지 계산이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; 가 활성화 되면 anyclass 를 사용 &lt;code&gt;anyclass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 모호한 필드는 오히려 최상위 레벨에보다, 그 데이터 타입의 일환으로 내 보내야합니다. 예를 들어 다음은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">때 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 유형 및 종류의 변수가 explicily 같은 방식으로 관련 데이터 또는 형의 가족 인스턴스에 바인딩 할 수 있습니다 (같은 제한)와 같은 &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 또는 &lt;a href=&quot;#type-instance-declarations&quot;&gt;유형의 인스턴스 선언&lt;/a&gt; . 예를 들어, 위의 내용을 적용하면 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 이 활성화 되면 왼쪽에서 사용되는 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 좌측에서 사용 유형 또는 종류의 변수를 명시 적으로 결합 될 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가&lt;/a&gt; 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newtype&lt;/code&gt; 은을 .</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt; 활성화되어, GHC는 인쇄 &lt;code&gt;RuntimeRep&lt;/code&gt; 의 경솔-다형성 유형에 대한 유형의 변수를. 그렇지 않으면 GHC는이를 기본값으로 &lt;code&gt;LiftedRep&lt;/code&gt; 로 설정 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 을 사용 하면 명시 적 으로 수량화 된 유형 변수도 사용되지 않은 것으로 식별 될 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">때 &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt; 활성화되어, 추정 변수는 중괄호로 인쇄됩니다. 따라서 이전 예제 의 데이터 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형은 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; . GHCi 세션에서이 동작을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 정의 결합 기능을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 과도한 인라인을 방지하려면 일반적으로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 만 사용 하여 사용자 정의 결합 기능을 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 에 세 개의 인수가 제공 되면 호출 사이트에 인라인됩니다. 따라서 사용자 정의 결합 기능을 정의 할 때만 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 를 사용해야 합니다. 예를 들어, 당신은 정의 할 수 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 등을</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 가 활성화되어 사용 &lt;code&gt;anyclass&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 가 활성화되고 우리가 newtype이란에 대한 파생되는, 다음 사용 &lt;code&gt;newytype&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">경우 &lt;code&gt;mappend x x = x&lt;/code&gt; ,이 정의가 바람직되어야 오히려 O (로그 N)에 비해 O (1)에 작동하기 때문에</target>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; 는 O (1)에서 작동하기 때문에,이 정의가 아닌 O (로그 n)이보다 바람직 할 것이다.</target>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">GHC가 클래스의 인스턴스를 찾을 수 없으면 알고있는 인스턴스의 일부 목록이 표시됩니다. 이 플래그를 사용하면 알고있는 &lt;em&gt;모든&lt;/em&gt; 인스턴스를 인쇄 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">GHC 가 &lt;code&gt;foreign export&lt;/code&gt; 또는 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 를 사용 하는 모듈 (예 : &lt;code&gt;M.hs&lt;/code&gt; )을 컴파일 할 때 C 프로그램에서 사용할 &lt;code&gt;M_stub.h&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">등록되지 않은 모드에서 GHC를 빌드하면 LLVM 및 C 코드 생성기 만 사용할 수 있습니다. 네이티브 코드 생성기는 그렇지 않습니다. LLVM은 일반적으로 미등록 모드에서 C 백엔드에 비해 상당한 성능 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">GHC를 사용하여 C 파일을 컴파일하는 경우 GHC는 패키지 포함 경로를 추가하고 &lt;code&gt;ghcversion.h&lt;/code&gt; 를 직접 포함 합니다. 컴파일러는 패키지 데이터베이스 의 &lt;code&gt;rts&lt;/code&gt; 패키지에서 &lt;code&gt;ghcversion.h&lt;/code&gt; 파일 의 경로를 찾습니다 . 경우에 따라 컴파일러의 패키지 데이터베이스에 &lt;code&gt;rts&lt;/code&gt; 패키지가 포함되어 있지 않거나 포함 할 특정 &lt;code&gt;ghcversions.h&lt;/code&gt; 를 지정하려고합니다 . 이 옵션을 사용하여 포함 할 &lt;code&gt;ghcversions.h&lt;/code&gt; 파일 의 경로를 지정할 수 있습니다. 이것은 주로 GHC의 빌드 시스템에서 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">GHC는 제약 조건 &lt;code&gt;C Int Bool&lt;/code&gt; 을 해결 하려고 할 때 인스턴스 선언의 헤드를 인스턴스화하여 모든 인스턴스 선언을 제약 조건과 일치시킵니다. 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">GHCi가 중단 점에서 중지되고 프롬프트에 입력 된 표현식이 두 번째 중단 점을 트리거하면 새 중단 점이 &quot;현재&quot;가되고 이전 중단 점이 스택에 저장됩니다. 이러한 방식으로 임의의 수의 중단 점 컨텍스트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">GC가 시작되면 실행중인 모든 뮤 테이터 스레드가 중지되고 동기화되어야합니다. GC가 시작되고 모든 뮤 테이터 스레드가 중지되는 시점을 GC 동기화 단계라고합니다. 이 단계가 오래 걸리는 경우 (1ms보다 긴 것이 긴 것으로 간주 됨) 전체 처리량에 심각한 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">GHC 컴파일 프로그램을 &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS 옵션 과 함께 실행하면 &lt;code&gt;prog.prof&lt;/code&gt; 라는 파일이 생성됩니다 . 이 경우 파일에는 다음과 같은 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">Bare 유형 변수 &lt;code&gt;a&lt;/code&gt; 가 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 각각 &lt;code&gt;fmap&lt;/code&gt; 및 &lt;code&gt;traverse&lt;/code&gt; 정의에 대해 &lt;code&gt;f a&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">특정 행과 열에 중단 점이 설정되면 GHCi는 중단 점을 설정할 위치를 포함하는 가장 작은 하위 표현식을 선택합니다. 참고 : GHC는 TAB 문자의 너비가 1 인 것으로 간주합니다. 즉, 열이 아닌 문자를 계산합니다. 이것은 일부 편집자가하는 것과 일치하고 다른 편집자와는 일치하지 않습니다. 최선의 조언은 소스 코드에서 탭 문자를 모두 사용하지 않는 것입니다 ( &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">특정 행에 중단 점이 설정되면 GHCi는 해당 행에서 시작하고 끝나는 가장 왼쪽의 하위 표현식에 중단 점을 설정합니다. 동일한 열에서 두 개의 완전한 하위 표현식이 시작되면 가장 긴 하위 표현식이 선택됩니다. 줄에 완전한 하위 표현식이 없으면 줄에서 시작하는 가장 왼쪽에있는 표현식이 선택되고 해당 줄을 부분적으로 또는 완전히 덮는 가장 오른쪽에있는 표현식이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">데이터 형식의 경우 &lt;code&gt;T&lt;/code&gt; 는 모든 생성자, 즉 함께 가져 &lt;code&gt;T(..)&lt;/code&gt; 하지만, 추상적 즉 내 보낸 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 할 수있는 오류 코드 목록은 기본 기능에 대한 POSIX 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">기본 POSIX 함수를 호출하는 함수가 실패하면 errno 코드는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 로 변환됩니다 . 생성 될 수있는 errno 코드 목록은 기본 기능에 대한 POSIX 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">hs-boot 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 컴파일 될 때 범위 및 유형 오류가 있는지 확인합니다. 상위 모듈 &lt;code&gt;A.hs&lt;/code&gt; 가 컴파일 될 때 두 모듈 이 비교되고 두 모듈 이 일치하지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하여 조치를 생성하고 병합 된 맵에서 결과를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">두 맵에서 키가 발견되면 키와 값에 함수를 적용하고 결과 조치를 수행하며 병합 된 맵에서 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">현재 컴파일중인 패키지 (예 : &quot;홈&quot;패키지)에서 제공 한 모듈을 가져 오지만 명령 줄에 대상으로 명시 적으로 나열되지 않은 경우 Cabal이 GHC가 &lt;code&gt;exposed-modules&lt;/code&gt; 이나 &lt;code&gt;other-modules&lt;/code&gt; 모듈 에 나열되지 않은 모듈을 픽업하지 않도록하는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">이름이나 패키지가 범위 내에 없으면 대신 의미가있는 이름이나 패키지를 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">겹치는 인스턴스로 인해 특정 유형 클래스 메서드 호출이 안전하지 않은 것으로 간주되고 컴파일되는 모듈이 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 를 사용하면 컴파일이 실패합니다. 들면 &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; , 제한은 적용되지 않고, 안전한 사용을 추론 모듈, 이들은 안전하지 않은 추론한다.</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나 &lt;code&gt;main&lt;/code&gt; 함수는 인수를 직접 사용하지 않으므로 ghci에서 테스트하는 동안 단순히 &lt;code&gt;main&lt;/code&gt; 함수에 인수를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">프로그램이 컴파일되고 실행될 때 &lt;code&gt;getArgs&lt;/code&gt; 함수를 사용하여 명령 행 인수에 액세스 할 수 있습니다 . 그러나, 우리는 간단히에 인수를 전달할 수 없습니다 &lt;code&gt;main&lt;/code&gt; 우리가 ghci에서 테스트하는 동안 같은 기능 &lt;code&gt;main&lt;/code&gt; 기능은 직접하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">문자열이이 플래그에 전달되면 이름이 문자열과 접두사를 공유하는 모든 함수에 대한 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식에 생성자가없는 경우 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스는 &lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수의 (아래) 값을 강제로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;foldr&lt;/code&gt; 및 &lt;code&gt;foldMap&lt;/code&gt; 을 재귀 적으로 호출 합니다. 컨텍스트에 따라 &lt;code&gt;null&lt;/code&gt; 은 재귀 적으로 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;all null&lt;/code&gt; 을 호출 할 수 있습니다. . 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">구문 적으로 &lt;code&gt;a&lt;/code&gt; 와 같지만을 포함 &lt;code&gt;a&lt;/code&gt; 이 발견되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 는&lt;/a&gt; 재귀 적으로 &lt;code&gt;fmap&lt;/code&gt; 을 호출 합니다. 마찬가지로 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 재귀 적으로 &lt;code&gt;traverse&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">유형 레벨 명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하면 언급 된 각 유형 / 종류 변수도 범위 내에 있거나 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 특히 Haskell의 다른 장소와 달리 자유 변수는 암시 적으로 바인딩되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">값이 &lt;code&gt;do&lt;/code&gt; - notation으로 묶인 경우 &lt;code&gt;&amp;lt;-&lt;/code&gt; 의 왼쪽에있는 패턴 이 일치하지 않을 수 있습니다. 이 경우이 클래스는 복구 할 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">경고가 발생하면이를 제어하는 ​​특정 경고 플래그가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">와일드 카드가 단일 유형으로 인스턴스화되지 않으면 일반 유형으로 일반화됩니다. 예를 들어 새로운 유형 변수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명령문이 내 보내지 않은 엔티티를 숨길 때</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">연관된 데이터 또는 유형 동의어 패밀리 인스턴스가 유형 클래스 인스턴스 내에 선언되면 선택적으로 패밀리 키워드에서 &lt;code&gt;instance&lt;/code&gt; 키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">예외가 기본 프로그램 외부로 전파되면 Haskell 시스템은 연관된 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 값을 인쇄 하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">명시적인 &lt;code&gt;forall&lt;/code&gt; 이 있는 경우 아직 범위에 포함되지 않은 언급 된 &lt;em&gt;모든&lt;/em&gt; 유형 및 종류 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">명시 적 &lt;code&gt;forall&lt;/code&gt; 이 존재하는 경우, 아직 범위 내에 있지 않은 언급 된 모든 &lt;em&gt;유형&lt;/em&gt; 변수는 &lt;code&gt;forall&lt;/code&gt; 에 의해 바인딩되어야합니다 . 필요한 경우 종류 변수는 암시 적으로 바인딩됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 인스턴스가 정의 된 경우 유형 클래스에 의해 정의 된 비트 단위 연산은 C on &lt;code&gt;t&lt;/code&gt; 의 해당 비트 단위 연산과 동일한 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">인스턴스 때 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 정의되어 &lt;code&gt;CT&lt;/code&gt; 의 값 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 가 일치 &lt;code&gt;t_MIN&lt;/code&gt; 및 &lt;code&gt;t_MAX&lt;/code&gt; C.에서</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CT&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 의 인스턴스 가 정의 되면 유형 클래스에 의해 정의 된 술어는 &lt;code&gt;t&lt;/code&gt; 의 C에서 해당 술어와 동일한 관계를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">인스턴스 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 가 정의되어 &lt;code&gt;CT&lt;/code&gt; , Type 클래스에 의해 정의 된 산술 연산은상의 C에 대응하는 연산과 동일한 기능 (있는 경우)를 구현 &lt;code&gt;t&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">적용 가능한 경우 특정 병리학 적 경우에는 조금 더 나쁠 수 있지만이 기능 대신 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 거의 항상 좋습니다 . 예를 들어, 문자 목록을 마비 시키려면</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">소스 파일을 컴파일하라는 요청을 받으면 GHC는 일반적으로 객체 파일과 인터페이스 파일의 두 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">데이터베이스를 수정하라는 메시지가 표시되면 &lt;code&gt;ghc-pkg&lt;/code&gt; 는 기본적으로 전역 데이터베이스를 수정합니다. &lt;code&gt;--user&lt;/code&gt; 를 지정 하면 사용자 데이터베이스에서 작동하거나 &lt;code&gt;--package-db&lt;/code&gt; 를 사용하여 다른 데이터베이스에서 완전히 작동 할 수 있습니다. 이러한 옵션이 여러 개 제공되면 가장 오른쪽 옵션이 작동 할 데이터베이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">두 플래그가 제공되면 &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 대체 하고 &lt;code&gt;+&lt;/code&gt; 는 공백을 대체합니다. &lt;code&gt;*&lt;/code&gt; 변환 에서 음의 너비 지정자는 양수로 취급되지만 왼쪽 조정 플래그를 암시합니다.</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">바운드 유형 / 종류 변수가 필요한 경우 두 변수를 모두 포함해야하지만 패턴 변수가 필요하지 않은 경우 두 번째 변수를 비워 둘 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">패키지를 공유 라이브러리로 빌드 할 때 GHC를 사용하여 링크 단계를 수행 할 수 있습니다. 기본 링커에서 일부 세부 정보를 숨기고 GHC (DLL, ELF DSO 및 Mac OS dylib)에서 지원하는 모든 공유 객체 변형에 대한 공통 인터페이스를 제공합니다. 공유 객체는 다음 두 가지 이유로 특정 방식으로 이름을 지정해야합니다. 호출 규칙과 관련하여 (2) 정적 이름과 달라야합니다. 그렇지 않으면 &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그를 작동 시키는 데 필요한만큼 정확하게 링커를 제어 할 수 없습니다 ( &lt;a href=&quot;phases#options-linker&quot;&gt;연결에 영향을주는 옵션&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 외부 또는 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 내부에서 호출되면 이 함수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">호출시 &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; 가 인쇄 ⟨n⟩ &lt;sup&gt;번째&lt;/sup&gt; 행 ⟨m⟩ &lt;sup&gt;번째&lt;/sup&gt; ⟨type⟩ 붙이고 완료 도메인 부분 입력 ⟨string-literal⟩ 수료 후보. 현재 는 입력 프롬프트에서 GHCi가 대화식으로 제공 할 수있는 완료 종류를 나타내는 &lt;code&gt;repl&lt;/code&gt; 도메인 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 를 호출하면 두 개의 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 을 결합하는 함수 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 변환 할 때 &lt;code&gt;map toUpper&lt;/code&gt; 와 같은 결합 자를 사용하여 문자열의 각 문자를 개별적으로 변환 할 수 없습니다 . 일부 쓰기 시스템의 규칙에 따라 잘못된 결과가 발생하기 때문입니다. &lt;code&gt;toUpper&lt;/code&gt; 와 같은이 모듈의 전체 문자열 대 / 소문자 변환 함수 는 올바른 대 / 소문자 변환 규칙을 따릅니다. 결과적으로,이 기능들은 하나의 입력 문자를 두세 개의 출력 문자로 매핑 할 수 있습니다. 예를 들어, 각 기능의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">폐쇄 형 패밀리 방정식 쌍을 확인할 때 GHC는 RHS를 통합하려고했습니다. 그들이이 방정식 쌍을 통일하지 않으면 주입 주석을 위반하지 않습니다. RHS가 일부 치환 (통화 될 수 있음) 하에서 통일 될 수있는 경우, LHS가 동일한 치환 하에서 통일되거나 후자의 식의 LHS가 이전 식에 포함됩니다. 두 조건이 모두 충족되지 않으면 GHC는 유형 패밀리가 주입 적이 지 않다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 와 결합 하면 사용자는 쿼리에 와일드 카드를 삽입하고 인스턴스와의 ⟨type⟩ 일치를 위해 각 와일드 카드에 필요한 제약 조건을 학습 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; 로&lt;/a&gt; 템플릿 Haskell 코드 를 컴파일 할 때 인터프리터에서 프로파일 링 된 객체 코드를 실행할 수 있으므로 먼저 &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 없이 모듈을 컴파일 할 필요가 없습니다 ( &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;프로파일 링에 템플릿 Haskell 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 로 컴파일 할 때 ⟨n⟩ 모듈을 병렬로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">목록을 구성 할 때 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 은 (목록이의 결과 인 경우 &quot;성공&quot;모든 결과를 반환하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 이 더 적합 할 것이다) :</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">Haskell 패키지에 대한 공유 객체를 생성 할 때 GHC가이 패키지에 대해 링크 될 때 공유 객체를 인식 할 수 있도록 공유 객체의 이름을 올바르게 지정해야합니다. 공유 객체 이름 맹 글링을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">이것이 올바른 데이터 구조인지를 결정할 때 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">GHCi 매크로를 정의 할 때, 특히 탭 완성과 관련하여 이름이 내장 명령과 충돌 할 수있는 경우에주의해야 할 중요한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">Haskell에서 임베디드 도메인 특정 언어를 디자인 할 때 유형 수준에서 &lt;code&gt;error&lt;/code&gt; 와 같은 것이 유용 합니다. 이러한 방식으로, EDSL 설계자는 표준 GHC 유형 오류가 아니라 DSL에 특정한 유형 오류를 보여줄 수있다.</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">리스트로 표기하면 desugaring &lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt; GHC가 사용 &lt;code&gt;fromList&lt;/code&gt; 모듈로부터 (등) 방법 &lt;code&gt;GHC.Exts&lt;/code&gt; 를 . &lt;code&gt;GHC.Exts&lt;/code&gt; 를 가져올 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">그렇게 할 때, 선택적으로&amp;ldquo; &lt;code&gt;family&lt;/code&gt; &amp;rdquo;키워드를 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">사용 가능한 경우 GHC는 &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">활성화되면 GHC는 &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt; 확장 의 유니 코드 기호를 사용하여 유형 서명을 인쇄합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">활성화 된 경우 GHC는 유형 검사기에서 추가 정보를 경고로 인쇄합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">활성화되면 GHC는 형식 동의어 확장 형식을 형식 오류로 인쇄합니다. 예를 들어이 형식 동의어를 사용하면</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">활성화 된 경우, 신뢰할 수있는 모듈에 대한 추가 검사를 켜 &lt;code&gt;M&lt;/code&gt; 있는 패키지를 요구, &lt;code&gt;M&lt;/code&gt; 에 대한 고려에 상주 신뢰할 수있는 &lt;code&gt;M&lt;/code&gt; 이 신뢰할 고려되어야합니다.</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드를 생성 할 때 다른 모듈에서 가져온 엔티티가 동적으로 링크 될 수 있다고 가정하십시오. 이 플래그는 &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="translated">내장 명령에 우선 순위를 부여 할 때 &lt;code&gt;::type 3&lt;/code&gt; 과 같이 :: &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt; &lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">여러 소스의 패키지를 통합 할 때 여러 패키지가 동일한 이름의 모듈을 게시하는 상황이 발생할 수 있습니다. 이전에는 이러한 모듈을 구별 할 수있는 유일한 방법은 &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;패키지 인증 가져 오기&lt;/a&gt; 를 사용하는 것 입니다. 그러나 GHC 7.10부터 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 플래그 (및 해당 변형)가 확장되어 사용자가 모듈 가져 오기에 첨부 할 수있는 가져 오기 목록과 유사하게 패키지가 범위에 포함되는 모듈을 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부에서 호출 될 때이 함수를 사용하면 마스크 된 비동기 예외 (있는 경우)가 발생할 수 있습니다. 인터럽트 가능한 작업을 수행하는 것과 같지만 (#interruptible 참조) 실제 차단은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 호출되면 런타임은 비용 중심 프로파일을 기계가 읽을 수있는 JSON 형식으로 생성합니다. 이 형식의 최상위 개체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">&lt;code&gt;-g&lt;/code&gt; 플래그 와 함께 호출되면 GHC는 표준 &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; 디버깅 정보를 생성 합니다. 이 형식은 거의 모든 POSIX 호환 대상에서 사용되며 디버깅 및 성능 도구 (예 : &lt;code&gt;gdb&lt;/code&gt; , &lt;code&gt;lldb&lt;/code&gt; 및 &lt;code&gt;perf&lt;/code&gt; )에서 GHC 컴파일 프로그램의 구조를 이해하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">시작시 &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt; 플래그를 지정 하지 않으면 GHCi 는 다음 파일에서 명령을 읽고 순서대로 실행합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">GHC는 유형을 종류 검사 할 때 유형의 종류를 일반화하는 방법을 알아낼 때 해당 유형으로 작성된 내용 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">바이너리 실행 파일을 링크 할 때 &lt;code&gt;-l&lt;/code&gt; 앞에 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 플래그를 삽입합니다. 하스켈 라이브러리에 대한 플래그를, 그리고 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 이후</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">바이너리 실행 파일을 링크 할 때,이 삽입 플래그 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 어떤 전에 &lt;code&gt;-l&lt;/code&gt; 하스켈 라이브러리에 대한 플래그 및 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; OS X에 (이후, 플래그가 없습니다 &lt;code&gt;-Wl,-all_load&lt;/code&gt; 에는 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 와 동등한 항목이 없습니다 . 이 플래그는 또한 &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; 사용하지 않습니다. &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; ( OS X의 경우 -Wl, -dead_strip )를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">최종 프로그램을 링크 할 때 GHC를 사용하여 링크를 수행하는 것이 일반적으로 가장 쉬운 방법이지만 필수는 아닙니다. GHC를 사용하는 경우 플래그 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; 을&lt;/a&gt; 잊지 마십시오 . 그렇지 않으면 GHC가 &lt;code&gt;Main&lt;/code&gt; Haskell 모듈에 연결을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="translated">링크 할 때 링커는 참조되지 않은 모든 섹션을 자동으로 제거하여 더 작은 실행 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결시 링커는 참조되지 않은 모든 섹션을 자동으로 제거하여 더 작은 실행 파일을 생성 할 수 있습니다. 효과는 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 다소 더 효율적입니다. 생성 된 라이브러리 파일은 &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 보다 약 30 % 작습니다 .</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">부하 분산시 스레드를 동일한 노드의 다른 기능으로 마이그레이션하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 를 사용&lt;/a&gt; 하여 소스 모듈을로드 할 때 GHCi는 일반적으로 컴파일 된 해당 객체 파일을 찾고 가능한 경우 소스를 해석하기 위해 우선적으로 파일을 사용합니다. 예를 들어, 모듈 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 로 구성된 4 모듈 프로그램이 있다고 가정하십시오 . 모듈 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 모두 가져 &lt;code&gt;D&lt;/code&gt; 만하고 수입 모두 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;C&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">프로그램 실행을위한 프로파일을 볼 때 종종 실행에서 특정 지점이나 단계를 표시하고 프로파일에서 시각적으로 볼 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">일치하는 경우 GHC는 인스턴스 선언의 컨텍스트를 고려하지 않습니다 ( &lt;code&gt;context1&lt;/code&gt; 등)를 .</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">클래스 선언을 병합 할 때 수퍼 클래스와 메소드가 정확히 일치해야합니다. 그러나 &lt;code&gt;MINIMAL&lt;/code&gt; pragma는 논리적으로 함께 OR되며 기본 서명이있는 메소드는 그렇지 않은 메소드와 성공적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용하여 구축 된 추상화의 공정성 속성을 제공하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에서 여러 스레드가 차단되면 FIFO 순서로 깨어납니다. 이것은 사용하여 생성 된 추상화의 공정성을 제공하는 데 유용합니다 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">cfg 기반 blocklayout 레이아웃을 사용하지 않는 경우 기본 블록의 마지막 점프 또는 cfg에서 블록의 가장 큰 나가는 모서리에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">과부하가 관련되면 결과가 약간 직관적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">해제되지 않은 배열 유형을 외부 C 호출에 인수로 전달할 때 외부 함수는 배열을 포함하는 &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; 힙 개체가 아닌 배열의 페이로드를 참조하는 포인터를 봅니다.&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt; 1&lt;/a&gt; . 반대로 &lt;code&gt;foreign import prim&lt;/code&gt; 에 의해 도입 된 &lt;a href=&quot;#ffi-prim&quot;&gt;외부 Cmm 호출&lt;/a&gt; 은 페이로드뿐만 아니라 힙 객체를 봅니다. 이는 일부 상황에서 외부 C 함수가 RTS 클로저 유형에 대한 지식이 필요하지 않을 수 있음을 의미합니다. 다음의 예는 최초의 3 바이트 요약 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; 에서 아무것도 사용하지 않고 &lt;code&gt;Rts.h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">패턴 일치시 각 패턴 일치는 각 존재 유형 변수에 대해 새롭고 고유 한 유형을 도입합니다. 이러한 유형은 다른 유형과 통합 할 수 없으며 패턴 일치 범위에서 벗어날 수도 없습니다. 예를 들어, 이러한 조각은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">패턴 일치시 이러한 제한 조건을 사용하여 일치 본문에서 제한 조건을 해제 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">GADT에서 가져온 데이터 생성자 (예 : &lt;code&gt;case&lt;/code&gt; 표현식) 에 대한 패턴 일치시 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">레코드 구성에 레코드 와일드 카드를 사용하는 경우 &lt;code&gt;f&lt;/code&gt; 가 범위 내에 있고 최상위 레벨에서 가져 오거나 바인드되지 않은 경우에만 필드 &lt;code&gt;f&lt;/code&gt; 가 초기화됩니다 . 예를 들어, &lt;code&gt;f&lt;/code&gt; 는 둘러싸는 패턴 일치 또는 let / where-binding에 의해 바인딩 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">입력 된 구멍을보고 할 때 범위 내에있는 구속 조건도 인쇄하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">프로그램에 &lt;code&gt;-hr&lt;/code&gt; 옵션 을 제공하여 보유자 프로파일 링을 요청하면 보유자 세트별로 분류 된 그래프가 생성됩니다. 리테이너 세트는 비용 중심 스택 세트로 표시됩니다. 이는 일반적으로 프로파일 그래프에 맞추기에는 너무 커서 각 보유자 세트의 번호가 매겨지고 그래프에 약어로 표시되며 보유자 세트의 전체 목록이 &lt;code&gt;prog.prof&lt;/code&gt; 파일에 덤프됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">대화식 콘솔 프로세스 (예 : 셸, 콘솔 기반 텍스트 편집기 또는 ghci)를 실행할 때 일반적으로 해당 프로세스가 Ctl-C 키보드 인터럽트를 처리하는 방식을 처리 할 수 ​​있기를 원합니다. 예를 들어, 대부분의 프로그램은 단순히 Ctl-C를 종료하지만 일부는 특수하게 처리합니다. 이를 가능하게하려면 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 옵션에서 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">이 파일에서 언어 옵션을 설정하는 경우 일반적으로 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 ( &lt;a href=&quot;#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">Safe Haskell 추론은 언제 사용해야하며 명시적인 &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; 플래그 는 언제 사용해야 합니까? 후자의 경우는 모듈이 안전해야한다는 어려운 요구 사항이있을 때 사용해야합니다. &lt;a href=&quot;#safe-use-cases&quot;&gt;Safe Haskell&lt;/a&gt; 의 Safe Haskell 사용 : 신뢰할 수없는 코드 실행에 가장 유용 합니다. 안전한 추론은 일반 Haskell 프로그래머가 사용해야합니다. Safe Haskell에 관심이없는 사용자</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">경고를 제어하는 ​​플래그를 표시 할 때 경고가 포함 된 각 경고 그룹 플래그도 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">제약 조건을 해결할 때 사용 가능한 사전을 사용하여 수퍼 클래스를 열심히 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; 를 지정할 때 pragma를 모든 패턴의 결과 유형이 서로 일치해야합니다. 유형이 일치하지 않으면 모든 패턴에서 일치하는 것이 불가능하므로 이는 완전성 점검입니다.</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 를 사용 하여 패턴 동의어 유형을 명시 적으로 지정하는 경우 유니버설, 실재 또는 컨텍스트 중 하나가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">중단 점 또는 단일 단계에서 중지되면 GHCi는 변수 &lt;code&gt;_result&lt;/code&gt; 를 현재 활성 표현식의 값에 바인드합니다 . 평가를 중단했기 때문에 &lt;code&gt;_result&lt;/code&gt; 의 값은 아직 사용할 수 없지만 아마도 강제 될 수 있습니다. 유형이 알려지고 표시 가능한 경우 프롬프트에서 &lt;code&gt;_result&lt;/code&gt; 를 입력 하면 표시됩니다. 그러나이 작업을 수행 할 때 한 가지주의 할 사항이 있습니다. &lt;code&gt;_result&lt;/code&gt; 를 평가 하면 현재 중단 된 중단 점부터 시작하여 추가 중단 점을 트리거 할 가능성이 높습니다 ( &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; 아닌 실제 중단 점에서 중단 된 경우 ). 따라서 평가할 때 즉시 &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; 를 발행해야합니다 &lt;code&gt;_result&lt;/code&gt; 를. 또는 사용할 수 있습니다&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;중단 점을 무시하는 : force .</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">중단 점에서 중지했을 때 이미 평가중인 변수를 평가하려고하면 두 번째 평가가 중단됩니다. 그 이유는 GHC가 변수가 평가 중이라는 것을 알고 있기 때문에 새로운 평가는 계속하기 전에 결과를 기다리지 만 첫 번째 평가가 중단 점에서 중지되기 때문에 발생하지 않을 것입니다. Control-C는 중단 된 평가를 중단하고 프롬프트로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어, 모듈이 신뢰 여부를 특정 패키지가 신뢰할 수있는 경우에 따라 달라집니다. 패키지 신뢰는 GHC를 호출하는 클라이언트 C (즉, 귀하)에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">때 &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; 플래그가 사용되는 &lt;em&gt;패키지 P에서 모듈 M을 클라이언트 C 신뢰&lt;/em&gt; 의 경우 만</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">때 &lt;code&gt;*&lt;/code&gt; 가 사용되고, GHCi는 미리 컴파일 된 오브젝트 코드를 해석하는 모듈을 무시한다. 이미 많은 수의 모듈을 객체 코드로로드하고 전체 모듈을 다시로드하는 대신 모듈 중 하나를 해석하려는 경우 &lt;code&gt;:add *M&lt;/code&gt; 을 사용하여 &lt;code&gt;M&lt;/code&gt; 을 해석 하도록 지정할 수 있습니다 ( 컴파일 된 모듈은 해석 된 모듈에 의존 할 수 없기 때문에 다른 모듈도 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">때 &lt;code&gt;GADTSyntax&lt;/code&gt; 의 확장이 활성화되어, GHC는 명시 적으로 생성자의 유형 서명을함으로써 대수 데이터 형식을 선언 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">때 &lt;code&gt;OverloadedLists&lt;/code&gt; 의 확장이 설정되어 다음과 같이 언급 한 일곱 표기법 desugared 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">컴파일러 유형이 소스 코드를 확인하면 &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices 및 &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; 은 소스 코드에서 생성 된 구문 트리 조각으로 대체됩니다. 그러나 소스 코드에서 작동하는 도구의 경우 코드 생성기는 일반적으로 생성 된 코드보다 흥미 롭습니다. 이러한 이유로 &lt;code&gt;spliceRunAction&lt;/code&gt; 을 포함 시켰 습니다 . 이 필드는 평가되기 전에 각 표현식에서 호출됩니다. 입력은 유형 검사되므로 이러한 구문 트리 조각에 대한 의미 정보가 사용 가능합니다. 다른 식을 반환하면 생성 된 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">플래그 경우 &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; 내지 An 설정된 &lt;code&gt;n&lt;/code&gt; 보다 큰 &lt;code&gt;0&lt;/code&gt; , GHC는 최대 필요한 유효 정공 적합하다 유효한 정제 정공 맞는 목록까지 제공한다 &lt;code&gt;n&lt;/code&gt; 추가적인 정교화 레벨 각 레벨은 구멍이 뚫린 구멍을 추가로 채워야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그 가 활성화되면 왼쪽 패턴에서 언급되었지만 오른쪽에서는 사용되지 않은 유형 변수가보고됩니다. 왼쪽에서 여러 번 발생하는 변수도 사용 된 것으로 간주됩니다. 경고를 표시하지 않으려면 사용하지 않는 변수를 밑줄로 바꾸거나 접두사를 붙여야합니다. 밑줄 ( &lt;code&gt;_x&lt;/code&gt; )로 시작하는 유형 변수 는 일반 유형 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">마지막 유형 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt; 참조 ) 일반적인 알고리즘을 사용하여 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스가 생성되지 않습니다. 대신, 전체 가치가 강요됩니다.</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">데이터 또는 형식 인스턴스 선언의 형식 인수 이름이 중요하지 않은 경우 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 와 링크되면 여러 OS 스레드에서 동시에 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출 할 수 있습니다 . 런타임 시스템은 &lt;code&gt;hs_init()&lt;/code&gt; 를 호출하여 평상시와 같이 초기화해야 하며이 호출은 &lt;code&gt;foreign export&lt;/code&gt; 기능을 호출하기 전에 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">프로그램이 &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; 옵션 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )으로 링크 되면 런타임 이벤트는 여러 가지 방법으로 로그 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">세분화 수준을 설정하지 않으면 유효한 구멍 맞춤 제안 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 표현식 의 명령문 사이에 종속성이 있고 &lt;code&gt;ApplicativeDo&lt;/code&gt; 가 &lt;code&gt;Applicative&lt;/code&gt; 유형을 유추 할 수없는 경우 휴리스틱 알고리즘을 사용하여 가능한 한 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하려고 합니다. 이 알고리즘은 일반적으로 최상의 솔루션을 찾지 만 드문 복잡한 경우에는 기회를 놓칠 수 있습니다. 옵션으로 제공되는 최적의 솔루션을 찾는 알고리즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">형식에 생성자가 없으면 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 은 가능한 가장 느린 인스턴스를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 (참조 &lt;a href=&quot;#roles&quot;&gt; Roles&lt;/a&gt; ) &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 은 간단한 인스턴스를 파생합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">type 매개 변수에 팬텀 역할이있는 경우 ( &lt;a href=&quot;#roles&quot;&gt;역할&lt;/a&gt; 참조) ) &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 이&lt;/a&gt; 해당 인수를 강제합니다. 예를 들어이 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">사용자가 쓸 때</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="translated">오른쪽이있을 때 GHC는 오른쪽과 일치하는 가장 다형성 종류를 추론합니다. 예 : 일반 데이터 유형 및 GADT 선언, 클래스 선언. 클래스 선언의 경우 &quot;오른쪽&quot;의 역할은 클래스 메서드 서명에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="translated">오른쪽이없는 경우 GHC 는 종류 서명에 의해 달리 지시되는 경우를 제외하고 인수 및 결과 종류를 &lt;code&gt;Type&lt;/code&gt; 으로 기본 설정 합니다. 예 : 데이터 및 개방형 패밀리 선언.</target>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">일련의 명령문에서 엄격한 패턴 일치가있는 경우 &lt;code&gt;ApplicativeDo&lt;/code&gt; 는 해당 명령문과 그 뒤에 오는 명령문 사이에 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 를 배치 합니다. 시퀀스는 다른 곳에서 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 를 사용하도록 변환 될 수 있지만 엄격한 패턴 일치 및 다음 명령문은 표준 do-notation과 동일한 엄격 의미론을 유지하기 위해 항상 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 와 연결 됩니다. 이것을 원하지 않으면 단순히 패턴 일치에 &lt;code&gt;~&lt;/code&gt; 를 붙이면 게으르게됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">이 플래그가 활성화되고 &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt; 가 비활성화되면 블록 레이아웃은 8.6 이전 버전과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">이 플래그가 설정되면, 변수는 &lt;code&gt;it&lt;/code&gt; 더 이상 이전에 평가 식의 결과로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">이 최적화가 활성화되면 코드 생성기는 모든 자체 재귀 포화 테일 호출을 함수 호출이 아닌 로컬 점프로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 활성화되면, 기능 \ (i \)에 대한 OS 스레드는 스레드 선호도를 설정하기 위해 OS에서 제공하는 API를 사용하여 CPU 코어 \ (i \)에 바인딩됩니다. 예를 들어 Linux GHC에서는 &lt;code&gt;sched_setaffinity()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">이 옵션을 지정하면 중간 부동 소수점 값 이 최종 유형 &lt;em&gt;보다&lt;/em&gt; 정밀도 / 범위가 &lt;em&gt;더 클&lt;/em&gt; 수 있습니다 . 일반적으로 이것은 좋은 일이지만 일부 프로그램은 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 값 의 정확한 정밀도 / 범위에 의존 할 수 있으므로 컴파일에이 옵션을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">이 경고가 활성화되면 다음 조건이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">전원을 &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt; 하여 모듈별로 억제 할 수 있습니다 . 간혹 API를 변경하지 않고 구현을 변경할 수있는 공간을 남기기 위해 함수가 필요 이상으로 제한적인 서명을 갖기를 원할 수 있습니다. 이 경우 데드 바인딩의 호출을 사용하여 기능별로 경고를 표시하지 않을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">모듈을 타입 검사 할 때, GHC는 제약 해결이 시작되기 전에 &lt;code&gt;tcPluginInit&lt;/code&gt; 를 한 번 호출 합니다. 이를 통해 플러그인은 컨텍스트에서 사물을 찾거나 변경 가능한 상태를 초기화하거나 외부 프로세스 (예 : 외부 SMT 솔버)에 대한 연결을 열 수 있습니다. 플러그인은 원하는 모든 유형의 결과를 반환 할 수 있으며 결과는 다른 두 필드로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">유형의 인스턴스 선언에 의하면 &lt;code&gt;F a&lt;/code&gt; , 우리는 슈퍼 클래스의 것을 확인해야 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;F&lt;/code&gt; 가 보유하고 있습니다. 따라서 다음을 포함하는 이론 하에서 제약 조건 &lt;code&gt;C a&lt;/code&gt; 를 수반하려고한다 .</target>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 파생을 기반으로하는 인스턴스와 정의한 인스턴스의 순서를 바꿉니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">safe 키워드를 사용하여 가져올 모듈은 신뢰할 수있는 모듈이어야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 안전한 가져 오기 확장은 &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; 또는 &lt;code&gt;-XUnsafe&lt;/code&gt; 플래그 중 하나에 의해 사용 가능 합니다. 때 &lt;code&gt;-XSafe&lt;/code&gt; 플래그를 사용하는 경우, &lt;code&gt;safe&lt;/code&gt; 모든 가져 오기가 안전한 수입으로 처리됩니다 같은 키워드는 허용하지만 의미한다.</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; A의 (해시 기호의 메이크업에 사용하는 등 확장) &lt;code&gt;.hsc&lt;/code&gt; 의 파일 (참조 &lt;a href=&quot;utils#hsc2hs&quot;&gt;C 코드 작성 하스켈 인터페이스 : hsc2hs을&lt;/a&gt; ), 해시 표지판 (쓰기 배가해야 &lt;code&gt;##foo&lt;/code&gt; 는 대신 &lt;code&gt;#foo&lt;/code&gt; 을 피하기 위해를) &lt;code&gt;hsc2hs&lt;/code&gt; 지시어 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">&lt;code&gt;-dynamic-too&lt;/code&gt; 를 사용할 때 &lt;code&gt;-dyno&lt;/code&gt; , &lt;code&gt;-dynosuf&lt;/code&gt; 및 &lt;code&gt;-dynhisuf&lt;/code&gt; 옵션 은 각각 &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-osuf&lt;/code&gt; 및 &lt;code&gt;-hisuf&lt;/code&gt; 의 대응 항목 이지만 동적 컴파일에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">&lt;code&gt;capi&lt;/code&gt; 를 사용하면 함수가 아닌 값을 가져올 수도 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 를 사용할 때 일반적인 경험 규칙은 나중에 스파크 계산이 필요하지만 너무 빠르지는 않다는 것입니다. 또한 스파크 계산은 너무 작아서는 안됩니다. 그렇지 않으면 병렬로 계산하는 비용이 병렬 처리량에 비해 너무 클 것입니다. 이러한 요소를 올바르게 얻는 것은 실제로 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 입력 문자 바로 다음에 사용 가능한 경우 개행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때 문자를 읽기 전에 &lt;code&gt;EOF&lt;/code&gt; 가 발생 하면 이 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">파일 스타일 상호 작용을 사용할 때이 기능은 입력 라인을 읽는 동안 에코를 끕니다.</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">레코드를 사용할 때 다음과 같이 레코드 필드와 이름이 같은 변수를 바인딩하는 패턴을 작성하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">터미널 스타일의 상호 작용을 사용할 때 줄 바꿈을 기다리지 않고 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">터미널 스타일의 상호 작용을 사용할 때 입력 텍스트가 비어있을 때 사용자가 &lt;code&gt;Ctrl-D&lt;/code&gt; 를 누르면 이러한 함수는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="translated">플래그를 사용할 때 &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;GHC가 생성되고 파이프를 사용하여 별도의 프로세스와 통신합니다. 네트워크를 통해 통신이 이루어지는 것이 유리한 시나리오 (예 : 크로스 컴파일 링)가 있습니다. GHC는이를 위해 두 가지 유틸리티를 제공하며 &lt;code&gt;utils&lt;/code&gt; 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="translated">값이 FFI 호출에 대한 인수로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">그러나 다른 시스템에서 실행중인 다른 프로세스간에 값이 전달되면 각 프로세스가 다른 주소를 사용하여 지정된 값을 저장할 수 있으므로 주소가 더 이상 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">나중에 렌더링 할 때이 셀이 몇 개의 열 또는 행에 걸쳐 있는지 확인하고 올바른 colspan / rowspan 명령을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 레이블을 작성할 때 해시 부호와 다음 식별자 사이에 공백이 없어야합니다. &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 의&lt;/a&gt; 확장 차종은 접미사 해시 기호의 사용; 만약 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; 이&lt;/a&gt; 둘은 활성화 &lt;code&gt;x#y&lt;/code&gt; 의미 &lt;code&gt;x# y&lt;/code&gt; 하지만에만 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; 다음 수단 활성화 &lt;code&gt;x #y&lt;/code&gt; . &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 확장 차종 &lt;code&gt;(#&lt;/code&gt; 때 하나의 어휘, 그래서 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; 가&lt;/a&gt; 활성화되어 당신이 여는 괄호와 오버로드 된 라벨 사이에 공백을 작성해야합니다. 혼동을 피하기 위해, 당신은 강력하게 사용하는 경우 해시 앞에 공백을 넣어하는 것이 좋습니다 &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; 을&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">때 당신은 &lt;em&gt;정말&lt;/em&gt; 속도에 대한 절망, 당신은에서 오른쪽으로 내려 싶다 &quot;원시 비트를.&quot; 비 &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;박스형 유형 사용에&lt;/a&gt; 대한 자세한 내용은 비 박스형 유형 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">&lt;code&gt;safe&lt;/code&gt; (기본값)으로 주석이 달린 &lt;code&gt;foreign import&lt;/code&gt; 함수 를 호출 하고 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용하여 링크 된 경우, 호출은 실행중인 다른 Haskell 스레드와 동시에 실행됩니다. 프로그램이 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 없이 링크 된 경우 호출이 리턴 될 때까지 다른 Haskell 스레드가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">템플릿 Haskell 스플 라이스가 포함 된 간단한 모듈을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">&lt;code&gt;Wibble&lt;/code&gt; 을 가져 오는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">지정된 엔티티를 가져오고 사용하는 모듈을 컴파일하면 GHC가 지정된 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; 을 사용하여 추상 유형을 정의 할 때 새 유형이 해당 표현에서 일부 인스턴스를 상속하도록 할 수 있습니다. Haskell 98에서는 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 인스턴스를 파생시켜 상속받을 수 있지만 다른 클래스의 경우 명시 적 인스턴스 선언을 작성해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">Haskell 소스 모듈을 GHCi에로드하면 일반적으로 바이트 코드로 변환되고 인터프리터를 사용하여 실행됩니다. 그러나 해석 된 코드는 GHCi에서 컴파일 된 코드와 함께 실행될 수도 있습니다. 실제로, 일반적으로 GHCi가 시작되면 &lt;code&gt;Prelude&lt;/code&gt; 를 포함하는 &lt;code&gt;base&lt;/code&gt; 패키지 의 컴파일 된 사본을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="translated">그런 다음 다음을 포함하는 모듈을 컴파일하면</target>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">프롬프트에 표현식을 입력하면 GHCi는 즉시 결과를 평가하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">프롬프트에서 표현식을 입력하면 범위에 속하는 식별자와 유형은 무엇입니까? GHCi는 표현식의 컨텍스트 구성 방식을 정확하게 제어 할 수있는 유연한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">패턴 일치를 사용하면 바운드 변수에 다형성 유형이있을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">당신은 자원을 획득 할 때, 몇 가지 일을하고 리소스를 해제, 그것은 사용에 좋은 아이디어이다 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 때문에, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 예외가 동안 발생하는 경우에 리소스를 해제하는 데 필요한 예외 처리기를 설치합니다 계산. 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 는 (릴리스를 수행 한 후) 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">소스 코드에 대한 의미 정보가 필요한 플러그인을 정의하려면 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 필드를 사용하십시오 . 예를 들어, 플러그인이 두 이름이 동일한 정의를 참조하는지 여부를 결정해야하거나 의미 정보를 사용하는 함수의 유형을 확인해야하는 경우입니다. 이 경우 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 또는 &lt;code&gt;renamedResultAction&lt;/code&gt; 을 사용하여 구문 트리의 이름이 바뀌거나 유형이 확인 된 버전에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">소스 코드의 구문 트리를 사용하는 플러그인을 정의하려는 경우 &lt;code&gt;parsedResultAction&lt;/code&gt; 필드 를 대체 하려고 합니다. 이 액세스 포인트를 사용하면 소스 코드의 어휘 토큰 및 주석에 대한 정보와 컴파일 된 모듈의 원래 구문 트리에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">Haskell 프로그램이 시작되면 RTS는 &lt;code&gt;+RTS&lt;/code&gt; 와 &lt;code&gt;-RTS&lt;/code&gt; 사이에 괄호로 묶인 명령 줄 인수를 자체적 으로 추출 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">프롬프트에 표현식 (또는 비 바인드 명령문)이 입력 될 때마다 GHCi는 값을 변수에 내재적으로 바인드 &lt;code&gt;it&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">내보내기 목록이없고 데이터 인스턴스가 정의 될 때마다 데이터 패밀리가 로컬로 정의되어 있는지 또는 다른 모듈에 정의되어 있는지에 관계없이 해당 데이터 패밀리 유형 생성자가 새 데이터 생성자와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">어디 &lt;code&gt;@Int&lt;/code&gt; 이 보이는 유형의 응용 프로그램 (이용하여 &lt;a href=&quot;#visible-type-application&quot;&gt;눈에 보이는 유형의 응용 프로그램&lt;/a&gt; 이 instantiate하는) &lt;code&gt;b&lt;/code&gt; 의 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 입니다. 이 형식 응용 프로그램이 작동 하려면 &lt;code&gt;bar&lt;/code&gt; 의 기본 형식 서명이 기본 이 아닌 서명과 형식 변수 순서가 같아야합니다! 그러나 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;C'&lt;/code&gt; 가 동일 해야 할 의무는 없습니다 ( 예 를 들어, 위 의 &lt;code&gt;Enum&lt;/code&gt; 예 참조).</target>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="translated">어디 &lt;code&gt;TypedHole&lt;/code&gt; 은 오류 발생시 GHC 사용할 수있는 구멍에 대한 모든 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">어디 &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; 에 제공되는 convencience 기능입니다 &lt;code&gt;TcHoleErrors&lt;/code&gt; 가 내부 상태를 필요로하지 않는 플러그인을 정의, 모듈을.</target>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;v&lt;/code&gt; 는 이진 인코딩 된 데이터 구조입니다. 원본 데이터를 재구성하기 위해 우리는 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt; 을 사용합니다</target>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">GHC가 확장 인스턴스 선언을 허용하는 경우 우리는이 새로운 형태의 &lt;code&gt;class&lt;/code&gt; 에 대해 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 를 사용&lt;/a&gt; 하면 구문이</target>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">GHC가 확장 인스턴스 선언을 허용하는 경우, 우리는이 새로운 &lt;code&gt;class&lt;/code&gt; 의 클래스 와 정확히 동일한 확장을 허용합니다 . 특히 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; 를 사용 하면 구문이</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">가능한 경우 응용 프로그램은 대신 일반 공용 인터페이스 모듈 (예 : &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe)&lt;/a&gt; 의 기능을 사용해야합니다 . ByteString 시스템을 낮은 수준으로 확장하는 패키지는이 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">사용자 제공 라이브러리를 찾을 수있는 곳&amp;hellip; ⟨dir⟩ 디렉토리를 라이브러리 디렉토리 경로 앞에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">각 라인 입력 세션의 시작과 끝에서 히스토리를 읽고 쓰는 위치.</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">여기서 &quot;식별자&quot;는 현재 GHCi에로드 된 해석 된 모듈의 최상위 기능 이름을 나타냅니다 (자격이 지정된 이름이 사용될 수 있음). 중단 점은 함수가 완전히 적용되었지만 패턴 일치가 이루어지기 전에 함수 본문에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 는 함수 응용 프로그램 인 반면 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 위로 들어온 함수 응용 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">Haskell에서 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 가 값을 포함하거나 생성하는 것으로 생각할 수있는 반면 , 반 변형 Functor는 &lt;em&gt;소비&lt;/em&gt; 가치 로 생각할 수있는 Functor입니다 .</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">리스트가 유한하거나 무한 할 수있는 반면, 시퀀스는 항상 유한합니다. 결과적으로 시퀀스의 길이는 엄격합니다. 효율성을 무시하고 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 가 정의 되었다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">하이퍼 스레딩 코어를 계산해야하는지 여부는 미심쩍은 질문입니다. 자유롭게 실험 해보고 찾은 결과를 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">비용 센터가 CAF (Constant Applicative Form)인지 여부</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">일치가 원래의 데이터 생성자 집합 또는 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 에서 발생하는지 (후자를 우선)</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">이것이 보류되는지 여부는 사용중인 GHC 버전, 작업중인 플랫폼, 작업중인 데이터 및 사용중인 인코딩에 따라 달라 지므로 직접 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">이 단어 뒤에 공백, 끝 따옴표 등이 와야하는지 여부</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">양수에 대해 더하기 부호를 요구할지 여부.</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">필드를 왼쪽으로 조정할지 또는 제로 패드로할지 여부입니다. &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; 가 우선적 으로 상호 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">원본 소스 코드의 스 니펫 표시 여부</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에서 패턴의 적용 범위를 확인할 때 어떤 &lt;code&gt;COMPLETE&lt;/code&gt; pragma를 사용해야 합니까? 우리가 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2&lt;/code&gt; , 다음 &lt;code&gt;f&lt;/code&gt; 철저한이지만, 우리는 다른 선택하는 경우 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 커버하는 것이 &lt;code&gt;MkT1&lt;/code&gt; 및 &lt;code&gt;MkT2Internal&lt;/code&gt; 은 다음 &lt;code&gt;f&lt;/code&gt; 하다 &lt;em&gt;하지&lt;/em&gt; 가 일치하지 때문에, 철저한 &lt;code&gt;MkT2Internal&lt;/code&gt; 을 . 이 딜레마를 해결하는 직관적 인 방법은 이전의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트 를 선택하면 발견되지 않은 패턴 절 수가 가장 적으므로 더 나은 선택 임을 인식하는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">보다 깔끔한 스타일로 함수를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">가비지 수집중인 세대</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">이는 구멍이 &lt;code&gt;foldl1 _&lt;/code&gt; 로 대체 될 수 있음을 보여줍니다 . 구멍을 고정시키지 않으면 서 사용자가 자신이 가진 옵션을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
