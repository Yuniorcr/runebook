<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="5e7e07a35842fb9e4e49f081c6500aa5f24d9520" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 lexeme 구문 분석기는 자연수 (양수)를 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="ace0ef235b44c04e9847cae55d4c39fc3655ea48" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 lexeme 구문 분석기는 자연수 (양수)를 구문 분석합니다. 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="5b51da9dfdc6deacb56625f72d3743f1f276426c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">이 lexeme 파서는 단일 리터럴 문자를 구문 분석합니다. 리터럴 문자 값을 리턴합니다. 이 파서는 이스케이프 시퀀스를 올바르게 처리합니다. 리터럴 문자는 Haskell 보고서에 정의 된 문법 규칙 (대부분의 프로그래밍 언어와 매우 일치)에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="df49a67e0891da13df2aeac391d3a61690541ebd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 exeme 파서는 정수 (정수)를 구문 분석합니다. 이 파서는 기호 앞에 접두사를 붙일 수 있다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 습니다 (예 : '-'또는 '+'). 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0065c43e88f0ea0be37c852f441cefb8de14a7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">이 exeme 파서는 정수 (정수)를 구문 분석합니다. 이 파서는 기호 앞에 접두사를 붙일 수 있다는 점을 제외하면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 습니다 (예 : '-'또는 '+'). 숫자 값을 반환합니다. 숫자는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 진수 로 지정할 수 있습니다 . 숫자는 Haskell 보고서의 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7d3fe039b607009e325c09fadc027724bbba18" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 을 구문 분석합니다 . 숫자 값을 반환합니다. 이 파서는 자연수와 수레에 대한 문법 규칙의 중복을 처리합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc0de1ff1da25f44b1ba64f4600fc6b2f58174a" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">이 lexeme 파서는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 을 구문 분석합니다 . 숫자 값을 반환합니다. 이 파서는 자연수와 수레에 대한 문법 규칙의 중복을 처리합니다. 숫자는 Haskell 보고서에 정의 된 문법 규칙에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="8b3e538648d90a568eed7b3e4b7980db877318e7" translate="yes" xml:space="preserve">
          <source>This lexer is not completely faithful to the Haskell lexical syntax in the following respects:</source>
          <target state="translated">이 어휘 분석기는 다음과 같은 측면에서 Haskell 어휘 구문에 충실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba0c905e7229e2d42cfbc9060686e3e8b51c3edc" translate="yes" xml:space="preserve">
          <source>This library defines parser combinators for precedence parsing.</source>
          <target state="translated">이 라이브러리는 우선 순위 구문 분석을위한 구문 분석기 결합기를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="26d58c3f8313372fb9a5712eb67174707d34b82e" translate="yes" xml:space="preserve">
          <source>This library provides facilities for parsing the command-line options in a standalone program. It is essentially a Haskell port of the GNU &lt;code&gt;getopt&lt;/code&gt; library.</source>
          <target state="translated">이 라이브러리는 독립형 프로그램에서 명령 행 옵션을 구문 분석하기위한 기능을 제공합니다. 기본적으로 GNU &lt;code&gt;getopt&lt;/code&gt; 라이브러리 의 Haskell 포트입니다 .</target>
        </trans-unit>
        <trans-unit id="dd805dfecd7f77257c432c66329c165e81f0fc28" translate="yes" xml:space="preserve">
          <source>This library provides support for &lt;em&gt;strict&lt;/em&gt; state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt;.</source>
          <target state="translated">이 라이브러리는 John Launchbury와 Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt; 의 PLDI '94 논문에 설명 된대로 &lt;em&gt;엄격한&lt;/em&gt; 상태 스레드를 지원합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8126030a0db08f6efcbf327884b71cf1e6318582" translate="yes" xml:space="preserve">
          <source>This limitation is easily subvertible, so please ask if you get stuck on it.</source>
          <target state="translated">이 제한은 쉽게 바꿀 수 있으므로 문제가 발생했는지 물어보십시오.</target>
        </trans-unit>
        <trans-unit id="21a515f07e3c656c64c893fcd677dfba412563b8" translate="yes" xml:space="preserve">
          <source>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</source>
          <target state="translated">이 목록은 쉽게 확장 될 수 있습니다. 포함되지 않은 로트를 사용하는 Prelude 기능이있는 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="c9d77f7a9ab7e1d50b50bd600bb71a7967ecbbfb" translate="yes" xml:space="preserve">
          <source>This list is for GHC users to chat among themselves. If you have a specific question about GHC, please check the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; first.</source>
          <target state="translated">이 목록은 GHC 사용자가 서로 대화 할 수 있도록하기위한 것입니다. GHC에 대한 특정 질문이 있으면 먼저 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="29a814259d6babfac9ea76d85ac921a5f02baa19" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of &lt;code&gt;pkgname&lt;/code&gt; that is exposed for module import. It is identical in behavior to the &lt;code&gt;VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">이 매크로는 GHC 8.0부터 사용할 수 있습니다. 노출 된 모든 패키지에 대해 정의됩니다. 이 매크로 는 모듈 가져 오기에 노출 되는 &lt;code&gt;pkgname&lt;/code&gt; 버전을 기록하는 문자열로 확장됩니다 . Cabal이 정의한 &lt;code&gt;VERSION_pkgname&lt;/code&gt; 매크로와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a74c45d8cbbb98f3219b81a76db9cbe9b302bc7d" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is &lt;code&gt;x.y.z&lt;/code&gt; or later. It is identical in behavior to the &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">이 매크로는 GHC 8.0부터 사용할 수 있습니다. 노출 된 모든 패키지에 대해 정의됩니다. 이 매크로는 패키지 버전이 &lt;code&gt;x.y.z&lt;/code&gt; 이상인 경우 CPP 조건부 테스트를 편리하게 작성할 수 있도록 제공됩니다 . Cabal이 정의한 &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; 매크로 와 동작은 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="369c31dee13e7ebf7250f99f560cae58a6ec67ab" translate="yes" xml:space="preserve">
          <source>This macro is available starting with GHC 7.10.1.</source>
          <target state="translated">이 매크로는 GHC 7.10.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b70fd2d98680d3ba8f51b750ceee956a98a51c" translate="yes" xml:space="preserve">
          <source>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version &lt;code&gt;x.y.z.z'&lt;/code&gt; or later.</source>
          <target state="translated">이 매크로는 사용 된 GHC 버전이 버전 &lt;code&gt;x.y.z.z'&lt;/code&gt; 이상 인지 여부를 테스트하는 CPP 조건부 테스트를 편리하게 작성하기 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ccb8c1a1ef41b359721ee50eeb5b0ffe5456b94" translate="yes" xml:space="preserve">
          <source>This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">이 매크로는 Haskell 모듈에서 생성 된 C 소스 (예 : &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; 및 &lt;code&gt;.hc&lt;/code&gt; 파일)를 포함하여 Haskell 소스 및 C 소스를 사전 처리 할 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="126816cfbceb17265259c1bfd692cfa851e88117" translate="yes" xml:space="preserve">
          <source>This makes a copy, so does not retain the input string.</source>
          <target state="translated">이렇게하면 복사본이 만들어 지므로 입력 문자열이 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="409b9c14a753a56835750678eec0ceed50896009" translate="yes" xml:space="preserve">
          <source>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example here we print the value of the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">이것은 함수 안에서 흥미로운 변수 나 표현식의 값을 인쇄하는데 편리합니다. 예를 들어 변수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 값을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d154b682a58894f927011c8dcf1525090a6bca45" translate="yes" xml:space="preserve">
          <source>This may take real work, but&amp;hellip; There exist piles of massively-tuned library code, and the best thing is not to compete with it, but link with it.</source>
          <target state="translated">이 작업에는 실제 작업이 필요할 수 있지만 ... 엄청나게 조정 된 라이브러리 코드가 많이 있으며, 가장 좋은 점은 경쟁하지 않고 링크하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e305a9c2249a611331558008a6864ebdcc9df92" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 성능이 우수 합니다.</target>
        </trans-unit>
        <trans-unit id="a2f7283b2f57776282bb867fc6a49c83c2f23c8b" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 성능이 우수 합니다.</target>
        </trans-unit>
        <trans-unit id="1d65304cb52af71023e15bd45422c06447d534f9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9f79e70de4e10cc28ee0029d0a6a35c1bbea2e78" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5f2b22c1be27f1ee28d05bb2aade303875940243" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;f&lt;/code&gt; 는 고유 한 원래 키를 고유 한 결과 키에 매핑합니다. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 보다 약간 더 나은 성능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9c92fe3388c138613ddb9738050b4232a8c3e292" translate="yes" xml:space="preserve">
          <source>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it &lt;code&gt;safe&lt;/code&gt; and use &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;. Some library functions make such calls internally; their documentation should indicate when this is the case.</source>
          <target state="translated">즉, 시간이 오래 걸리거나 무기한으로 차단되는 함수에 대한 외래 호출을해야하는 경우이를 &lt;code&gt;safe&lt;/code&gt; 표시하고 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다. 일부 라이브러리 함수는 이러한 호출을 내부적으로 수행합니다. 이 경우에는 해당 문서에 해당 내용이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c345f7d8502440fe1972767e0230a2d484f96fc3" translate="yes" xml:space="preserve">
          <source>This means that many operations on sequences are stricter than those on lists. For example,</source>
          <target state="translated">이는 시퀀스에 대한 많은 작업이 목록에있는 작업보다 엄격하다는 것을 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="512d8c4339c4e152167f7ed6529861156bdd0ce2" translate="yes" xml:space="preserve">
          <source>This means that the usual string syntax can be used, e.g., for &lt;code&gt;ByteString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</source>
          <target state="translated">즉, 일반적인 문자열 구문을 사용할 수 있습니다 (예 : &lt;code&gt;ByteString&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 및 기타 유형의 문자열 유사). 문자열 리터럴은 정수 리터럴과 매우 유사하게 작동합니다. 즉, 표현식과 패턴 모두에 사용할 수 있습니다. 패턴에 사용될 경우 리터럴은 정수 리터럴과 같은 방식으로 동등 테스트로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6e84b7b55ab4e53c7918a9eed0f0386ae7086f12" translate="yes" xml:space="preserve">
          <source>This means we're all done. All the builder data has now been written.</source>
          <target state="translated">이것은 우리 모두 끝났음을 의미합니다. 모든 빌더 데이터가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a699a362a2564a3c76496bfcaced4dda0fd71569" translate="yes" xml:space="preserve">
          <source>This mechanism makes use of GHC's efficient built-in generics support.</source>
          <target state="translated">이 메커니즘은 GHC의 효율적인 내장 제네릭 지원을 활용합니다.</target>
        </trans-unit>
        <trans-unit id="ed8ed8da55dd83a0ef130774f673009214846879" translate="yes" xml:space="preserve">
          <source>This method is surprisingly useful. Where both instances exist and are lawful we have the following laws:</source>
          <target state="translated">이 방법은 놀랍게도 유용합니다. 두 경우 모두 존재하고 합법적 인 경우 다음과 같은 법률이 있습니다.</target>
        </trans-unit>
        <trans-unit id="917ff2b24c3401ef265e4f82c89c8ae89e4dbe83" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; as its default implementation (which ought to be equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; for types which possess a 0th bit).</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; 을 기본 구현으로 사용합니다 ( 0 비트를 소유 한 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; 와 동일해야 함 ).</target>
        </trans-unit>
        <trans-unit id="a56c576252b7c2f659be8b6306ca50d283138678" translate="yes" xml:space="preserve">
          <source>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; option can be omitted.</source>
          <target state="translated">이 모드는 명령 행에 언급 된 Haskell 소스 파일이있는 경우 기본값이며,이 경우 &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 옵션을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa78e5fdb695de8a1ddc90859fa15ef056bc6c5" translate="yes" xml:space="preserve">
          <source>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">이 모드는 &lt;code&gt;-e&lt;/code&gt; 옵션 의 인수로 명령 행에 지정된 단일 표현식이 있다는 점을 제외하고 대화식 모드와 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c36679dee1440f17c5d2fe66c1ebdd875fd933fe" translate="yes" xml:space="preserve">
          <source>This module also contains generalisations of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to work with any &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">이 모듈에는 모든 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 인스턴스 와 작동하기위한 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; 의 일반화도 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d1e1a6706fb58eb88829be1d42c2470d6cd3f3" translate="yes" xml:space="preserve">
          <source>This module can be imported for defining forward compatible &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instances:</source>
          <target state="translated">이 모듈은 앞으로 호환 가능한 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의하기 위해 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="288e7f4f57a0ee94cf817604c968d8d8274a39d6" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. &lt;strong&gt;&lt;em&gt;As such, the types presented on this page reflect the&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;platform on which the documentation was generated and may&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;not coincide with the types on your platform.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e27f3d7a593111ec01d1dd70cd801444f3e1d34" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. __/As such the types presented on this page reflect the platform on which the documentation was generated and may not coincide with the types on your platform./__</source>
          <target state="translated">이 모듈에는 유형에 대한 플랫폼 별 정보가 포함되어 있습니다. __ /이 페이지에 제시된 이러한 유형은 문서가 생성 된 플랫폼을 반영하며 플랫폼의 유형과 일치하지 않을 수 있습니다 ./__</target>
        </trans-unit>
        <trans-unit id="69fea24c1770ed9b0390c085efc99817f8d87553" translate="yes" xml:space="preserve">
          <source>This module contains support for pooled memory management. Under this scheme, (re-)allocations belong to a given pool, and everything in a pool is deallocated when the pool itself is deallocated. This is useful when &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; with its implicit allocation and deallocation is not flexible enough, but explicit uses of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; are too awkward.</source>
          <target state="translated">이 모듈은 풀링 된 메모리 관리를 지원합니다. 이 체계에서 (재) 할당은 주어진 풀에 속하며 풀 자체의 할당이 해제 될 때 풀의 모든 할당이 해제됩니다. 이것은 암시 적 할당과 할당 해제가있는 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; 가 충분히 유연하지 않지만 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 사용하는 것이 너무 어색한 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="13d5f93e40c79a18376dc00ca5c87434053f0a7f" translate="yes" xml:space="preserve">
          <source>This module currently does not expose functions that require the special properties of fixed-size primitives. They are useful for prefixing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s with their size or for implementing chunked encodings. We will expose the corresponding functions in future releases of this library.</source>
          <target state="translated">이 모듈은 현재 고정 크기 프리미티브의 특수 속성이 필요한 기능을 노출하지 않습니다. 그것들은 크기가 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 인 접두사 또는 청크 인코딩을 구현 하는 데 유용합니다 . 이 라이브러리의 이후 릴리스에서 해당 기능을 공개 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5142c08054d9871661f7f0d130cb3d6fdd9407d3" translate="yes" xml:space="preserve">
          <source>This module defines a &quot;Fixed&quot; type for fixed-precision arithmetic. The parameter to &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; is any type that's an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; has a single method that gives the resolution of the &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈은 고정밀 산술을위한 &quot;고정&quot;유형을 정의합니다. &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 에 대한 매개 변수 는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 의 인스턴스 인 모든 유형입니다 . &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 유형 의 해상도를 제공하는 단일 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c812190315e834b8c95ed3f2997592b7564b3fdf" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="748c4571f3ce28ef125886641fac7bef9890107e" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f0e64e356523d1a0c9eb699ad805d54ab82048" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a495bc59840aa160735fbc988dd7aa12e8ba85b8" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">이 모듈은 두 개의 맵을 병합하는 함수를 작성하기위한 API를 정의합니다. 주요 기능은 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 입니다. 이들 각각은 여러 가지 &quot;병합 전술&quot;과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af9c5e66541cb60627fc011c4ff85f664b7cc4ed" translate="yes" xml:space="preserve">
          <source>This module defines bitwise operations for signed and unsigned integers. Instances of the class &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; types are available from this module, and instances for explicitly sized integral types are available from the &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; modules.</source>
          <target state="translated">이 모듈은 부호있는 정수와 부호없는 정수에 대한 비트 단위 연산을 정의합니다. 클래스의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 위한 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 타입은이 모듈에서 사용할 수 있으며, 명백하게 크기 일체형 타입 인스턴스로부터 가능한 &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; 및 &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="64cded15389022e2237acadfc2c3eed972bdb24d" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="translated">이 모듈은 &lt;code&gt;OverloadedRecordFields&lt;/code&gt; 확장에서 사용되는 &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; 클래스를 정의합니다 . 자세한 내용은 &amp;lt; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; 위키 페이지&amp;gt;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="606c7646766e3b5fdd5c9d30e4081494c51f94fc" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/records/overloaded-record-fields&quot;&gt;https://gitlab.haskell.org/ghc/ghc/wikis/records/overloaded-record-fields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6eb416164cb4715d4e03695cde3fb980e473a9" translate="yes" xml:space="preserve">
          <source>This module defines the basic operations on I/O &quot;handles&quot;. All of the operations defined here are independent of the underlying device.</source>
          <target state="translated">이 모듈은 I / O &quot;핸들&quot;에 대한 기본 조작을 정의합니다. 여기에 정의 된 모든 작업은 기본 장치와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="d59bda9eaeaf5c1e3a36e9b88b617c773901fa3b" translate="yes" xml:space="preserve">
          <source>This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor). Compared with monads, this interface lacks the full power of the binding operation &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, but</source>
          <target state="translated">이 모듈은 functor와 monad (기술적으로는 강력한 lax monoidal functor) 사이의 중간 구조를 설명합니다. 모나드와 비교할 때이 인터페이스에는 바인딩 작업의 모든 기능이 부족 하지만 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6da3e730b43c82c0b85f8ebac281848e3fc9fe3b" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">이 모듈 은 모든 파일 경로와 환경 문자열이 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;ByteString&lt;/code&gt; 으로 표시된다는 점을 제외하고 &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; 와 정확히 동일한 API를 내 보냅니다 . &lt;a href=&quot;system-posix&quot;&gt;System.Posix의&lt;/a&gt; API를이 버전이 더 인코딩을하지 않습니다 또는 디코딩 및 원시 바이트의 관점에서 직접 작동하는 반면 API는 암시 적으로 모든 파일 경로 및 로케일 인코딩을 사용하여 환경 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="432a06fcd12fe64c315d994b347ca09ea56e286d" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">이 모듈 은 모든 파일 경로와 환경 문자열이 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;ByteString&lt;/code&gt; 으로 표시된다는 점을 제외하면 &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; 와 정확히 동일한 API를 내 보냅니다 . &lt;a href=&quot;system-posix&quot;&gt;System.Posix의&lt;/a&gt; API를이 버전이 더 인코딩을하지 않습니다 또는 디코딩 및 원시 바이트의 관점에서 직접 작동하는 반면 API는 암시 적으로 모든 파일 경로 및 로케일 인코딩을 사용하여 환경 문자열을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ae57a29c16b708a5f862b98209ca33ec88b9833b" translate="yes" xml:space="preserve">
          <source>This module exposes the &lt;em&gt;portable&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. See &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; for the &lt;code&gt;integer-gmp&lt;/code&gt;-specific internal representation of &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; as well as optimized GMP-specific operations.</source>
          <target state="translated">이 모듈은 &lt;em&gt;이식 가능한 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API를 제공합니다. &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 의 정수 &lt;code&gt;integer-gmp&lt;/code&gt; 특정 내부 표현 과 최적화 된 GMP 특정 작업에 대해서는 &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a94829165fdca15372f0126fd78a0b495ce0522" translate="yes" xml:space="preserve">
          <source>This module implements permutation parsers. The algorithm used is fairly complex since we push the type system to its limits :-) The algorithm is described in:</source>
          <target state="translated">이 모듈은 순열 파서를 구현합니다. 사용 된 알고리즘은 타입 시스템을 한계로 밀어 넣기 때문에 상당히 복잡합니다 :-) 알고리즘은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c272683515777617630ed062550e54f1e41af5ba" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 기능에 대한 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화 하기 위한 GHC 다시 쓰기 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 단 , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 것보다 시간이 오래 걸립니다. 시간이 매우 많이 소요될 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96caa6e7405bbcf705758c402e5dc69c91123112" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 펑터에 대해 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화하는 GHC 재 작성 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 경우보다 시간이 더 오래 걸린다는 것입니다. 이것이 매우 많은 시간 동안 발생할 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="480d93e68fd6dc10a57cdf9aae6e88c254901353" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 기능에 대한 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화 하기 위한 GHC 다시 쓰기 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 단 , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 것보다 시간이 오래 걸립니다. 시간이 매우 많이 소요될 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="824034cfb4513aba4aa1c338187313dac84e67aa" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">이 모듈에는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 펑터에 대해 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 를 최적화하는 GHC 재 작성 규칙이 포함되어 있습니다. 일반적으로 이러한 규칙은 성능을 향상시킵니다. 유일한 예외는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 를 사용할 때 이미없는 키를 삭제하면 규칙이없는 경우보다 시간이 더 오래 걸린다는 것입니다. 이것이 매우 많은 시간 동안 발생할 것으로 예상되는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 유형 의 개인용 사본 사용을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7db164d6a986565222e119d577ff5c229ba8b29b" translate="yes" xml:space="preserve">
          <source>This module includes everything you need to get started writing a parser.</source>
          <target state="translated">이 모듈에는 파서 작성을 시작하는 데 필요한 모든 것이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0f68392cbf21d07cf104e09ea0593872ccee43" translate="yes" xml:space="preserve">
          <source>This module is GHC-only and should not be considered portable.</source>
          <target state="translated">이 모듈은 GHC 전용이므로 휴대용으로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="84656ba40cd08703f7a3e8f512a38792e056d9c4" translate="yes" xml:space="preserve">
          <source>This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.</source>
          <target state="translated">이 모듈은 내부 GHC 모듈입니다. 타입 레벨의 자연수 구현에 사용되는 상수를 선언합니다. 타입 레벨 내츄럴로 작업하기위한 프로그래머 인터페이스는 별도의 라이브러리에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3afde49cd7420849dc0a50c7430aa7753bf402f" translate="yes" xml:space="preserve">
          <source>This module is considered &lt;strong&gt;internal&lt;/strong&gt;.</source>
          <target state="translated">이 모듈은 &lt;strong&gt;내부&lt;/strong&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="32342dd868ac356dff4bac50bb615e44b16dffd8" translate="yes" xml:space="preserve">
          <source>This module is inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">이 모듈은 &lt;em&gt;과부하 및 고차 다형성을 이용한 기능적 프로그래밍&lt;/em&gt; , Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) 1995 년 고급 기능성 스쿨 (School School of Functional Programming) 이라는 논문에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="7096f5bf81e4fc89257ced2d74b5c3eaad60b08c" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 기능 과의 이름 충돌을 피하기 위해 &lt;code&gt;qualified&lt;/code&gt; 가져 오기 위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eee7efdf6521c2a0678812a45bb80ea8d0fd2ac6" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 기능 과 이름 충돌을 피하기 위해 &lt;code&gt;qualified&lt;/code&gt; 되어 가져 오기위한 것입니다. 예.</target>
        </trans-unit>
        <trans-unit id="10a0983bc8a8704f481851ed07cafa7a10dc5324" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3534379c86106e1fb6aab32dbe9ba4e8065b07" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">이 모듈은 수입하기위한 것입니다 &lt;code&gt;qualified&lt;/code&gt; 과 이름이 충돌하지 않도록, &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;서곡의&lt;/a&gt; 기능을. 예.</target>
        </trans-unit>
        <trans-unit id="93e00704b6043d91bc0b1a65e596b7ceb43c33c8" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</source>
          <target state="translated">이 모듈은 Prelude 기능과 이름 충돌을 피하기 위해 가져 오기 자격을 갖도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="c97f8a3f89d9890b95b69a48863882918e86fa8c" translate="yes" xml:space="preserve">
          <source>This module is part of the Foreign Function Interface (FFI) and will usually be imported via the module &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 FFI (Foreign Function Interface)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="461f2e382a01bf00f47b644a6f12f006c2e2728e" translate="yes" xml:space="preserve">
          <source>This module only defines the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad; you probably want to import &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (which exports &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 모나드 만 정의합니다 . &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; ( &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt; 내보내기 ) 을 가져오고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fcaff35e4331afea7bccc306685504864f4b033e" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; operations until a value depending on them is required.</source>
          <target state="translated">이 모듈 은 모나드가 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 연산에 대한 값이 필요할 때까지 ST 연산의 평가를 지연 시킨다는 점을 제외하고 &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; 와 동일한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="785b925d63da4b41979c13438250f723b3f36584" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of state operations until a value depending on them is required.</source>
          <target state="translated">이 모듈 은 모나드가 그에 따른 값이 필요할 때까지 상태 연산의 평가를 지연 시킨다는 점을 제외하고 &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; 와 동일한 인터페이스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5d29751e61c6eafcb5fbfdc53fe9336d12c4e225" translate="yes" xml:space="preserve">
          <source>This module provides &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;&lt;em&gt;primitives&lt;/em&gt;, which are lower level building blocks for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. You don't need to go down to this level but it can be slightly faster.</source>
          <target state="translated">이 모듈은 제공 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 프리미티브&lt;/em&gt; 구성에 대한 낮은 수준의 빌딩 블록, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 들. 이 수준으로 내려갈 필요는 없지만 약간 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4ed2fc38393aca2df37326ba9f3afba3af1d5c" translate="yes" xml:space="preserve">
          <source>This module provides a low-level API to the line history stored in the &lt;code&gt;InputT&lt;/code&gt; monad transformer.</source>
          <target state="translated">이 모듈은 &lt;code&gt;InputT&lt;/code&gt; 모나드 변환기에 저장된 회선 히스토리에 저수준 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f1d3e88a44dc84dd2e2655daf9dcf215e0055df4" translate="yes" xml:space="preserve">
          <source>This module provides a low-level interface to the C functions of the terminfo library.</source>
          <target state="translated">이 모듈은 terminfo 라이브러리의 C 함수에 대한 저수준 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dcfa8281ead615b485cbc67a44a0d67023dd3214" translate="yes" xml:space="preserve">
          <source>This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module.</source>
          <target state="translated">이 모듈은 외부 명령을 실행하기위한 간단한 인터페이스를 제공합니다. 더 복잡하지만 더 강력한 인터페이스는 &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a90fd78951dfe7db7ffb984d132da2184a51611f" translate="yes" xml:space="preserve">
          <source>This module provides a stateful, IO-based interface to Haskeline, which may be easier to integrate into some existing programs or libraries.</source>
          <target state="translated">이 모듈은 Haskeline에 상태 기반 IO 기반 인터페이스를 제공하여 기존의 일부 프로그램이나 라이브러리에 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7665bb8888c593637beee8ce6f79ca4404cc5473" translate="yes" xml:space="preserve">
          <source>This module provides a version of pretty that allows for annotations to be attached to documents. Annotations are arbitrary pieces of metadata that can be attached to sub-documents.</source>
          <target state="translated">이 모듈은 주석을 문서에 첨부 할 수있는 pretty 버전을 제공합니다. 주석은 하위 문서에 첨부 할 수있는 임의의 메타 데이터 조각입니다.</target>
        </trans-unit>
        <trans-unit id="c1a38449e4b89f12a5a25525a42c36b9312c0f84" translate="yes" xml:space="preserve">
          <source>This module provides access to internal garbage collection and memory usage statistics. These statistics are not available unless a program is run with the &lt;code&gt;-T&lt;/code&gt; RTS flag.</source>
          <target state="translated">이 모듈은 내부 가비지 수집 및 메모리 사용 통계에 대한 액세스를 제공합니다. 프로그램이 &lt;code&gt;-T&lt;/code&gt; RTS 플래그 와 함께 실행되지 않으면이 통계를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3add7a2fb1719164d2ace74420d665a5258e75" translate="yes" xml:space="preserve">
          <source>This module provides capabilities for moving the cursor on the terminal.</source>
          <target state="translated">이 모듈은 터미널에서 커서를 이동하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e18030012ebf6800ca52122e711e5ae7b02da7e6" translate="yes" xml:space="preserve">
          <source>This module provides efficient containers-based functions on the list type.</source>
          <target state="translated">이 모듈은 목록 유형에서 효율적인 컨테이너 기반 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1f668197932586f66f5efc5d3fb7ae4c036d630e" translate="yes" xml:space="preserve">
          <source>This module provides overloaded functions, such as &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt;, for fully evaluating data structures (that is, evaluating to &quot;Normal Form&quot;).</source>
          <target state="translated">이 모듈은 데이터 구조를 완전히 평가하기 위해 (즉, &quot;정상 형식&quot;으로 평가하기 위해) &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 와 같은 오버로드 된 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="582a828ee9bdf70b77d17ebec335ad7850fb4e35" translate="yes" xml:space="preserve">
          <source>This module provides scalable event notification for file descriptors and timeouts.</source>
          <target state="translated">이 모듈은 파일 디스크립터 및 시간 종료에 대한 확장 가능한 이벤트 알림을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="854a2eebed7e5e3bcde5ed1dde2b3bcda6e0ef76" translate="yes" xml:space="preserve">
          <source>This module provides support for raising and catching both built-in and user-defined exceptions.</source>
          <target state="translated">이 모듈은 내장 예외 및 사용자 정의 예외를 발생시키고 포착하는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="779b1cd1a00e8f21b85e9635dbc10c2617ea3dc3" translate="yes" xml:space="preserve">
          <source>This module provides text encoding/decoding using iconv</source>
          <target state="translated">이 모듈은 iconv를 사용하여 텍스트 인코딩 / 디코딩을 제공합니다</target>
        </trans-unit>
        <trans-unit id="bd39e9a11c79866d26b9bd27b7ee858d0e154873" translate="yes" xml:space="preserve">
          <source>This module provides the various sorting implementations for &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;. Further notes are available in the file sorting.md (in this directory).</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence에&lt;/a&gt; 대한 다양한 정렬 구현을 제공합니다 . 추가 정보는 sorting.md 파일 (이 디렉토리에 있음)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c752cac235dedd97d14389620cb23346095a0f16" translate="yes" xml:space="preserve">
          <source>This module provides typed pointers to foreign data. It is part of the Foreign Function Interface (FFI) and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">이 모듈은 외부 데이터에 대한 형식화 된 포인터를 제공합니다. 외부 기능 인터페이스 (FFI)의 일부이며 일반적으로 &lt;a href=&quot;foreign&quot;&gt;외부&lt;/a&gt; 모듈을 통해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8127ca85318ff1824be538551fa1fd1e340e9ab9" translate="yes" xml:space="preserve">
          <source>This module re-exports &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;, which produces XHTML 1.0 Transitional. Use &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt; if you want XHTML 1.0 Strict, and &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt; if you want to produce XHTML 1.0 Frameset.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional을&lt;/a&gt; 다시 내보내 XHTML 1.0 Transitional을 생성합니다. XHTML 1.0 Strict 를 원하면 &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Strict를&lt;/a&gt; , XHTML 1.0 프레임 셋을 생성 하려면 &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Frameset을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8ec7f9f123682eb0cc274e7c52cca0f3a5f423e" translate="yes" xml:space="preserve">
          <source>This module re-exports the value lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API, plus several deprecated value strict functions. Please note that these functions have different strictness properties than those in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;: they only evaluate the result of the combining function. For example, the default value to &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; is only evaluated if the combining function is called and uses it.</source>
          <target state="translated">이 모듈은 lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API 값과 더 이상 사용되지 않는 몇 가지 값 엄격한 함수를 다시 내 보냅니다 . 이러한 함수는 &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; 와 다른 엄격 속성을 갖습니다 . 결합 함수의 결과 만 평가합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; 의 기본값 은 결합 함수가 호출되어 사용되는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="652efe48d7f69bcc3c5490c01c5c8cb0efb0564b" translate="yes" xml:space="preserve">
          <source>This module redefines some of the functions in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; to work for more general monads built on top of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception의&lt;/a&gt; 일부 기능을 재정 의하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 위에 구축 된보다 일반적인 모나드에 대해 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6ca5d2535d9794227136b6b0c705ce4e24c48c" translate="yes" xml:space="preserve">
          <source>This module satisfies the following strictness property:</source>
          <target state="translated">이 모듈은 다음과 같은 엄격 성을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="d8eb2deb7a56d67d9c957df553d23a112baecc39" translate="yes" xml:space="preserve">
          <source>This module should be considered GHC internal.</source>
          <target state="translated">이 모듈은 GHC 내부로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="29e73688c548bf0c2243628b3c05e4e5e0b07e48" translate="yes" xml:space="preserve">
          <source>This module should be used as opposed to the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; module. Both are equivalent though as this module simply re-exports the other.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 모듈 과 반대로 사용해야 합니다. 이 모듈은 단순히 다른 모듈을 다시 내보내므로 둘 다 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f659376b4585d9e16031991a83545eeadf08cc89" translate="yes" xml:space="preserve">
          <source>This module supplies a 'pure' monad transformer that can be used for mock-testing code that throws exceptions, so long as those exceptions are always thrown with &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:throwM&quot;&gt;throwM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c093cde768913c2b7ff4e222653e852525c2bd9" translate="yes" xml:space="preserve">
          <source>This module supports monads that can throw extensible exceptions. The exceptions are the very same from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, and the operations offered very similar, but here they are not limited to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ad027c5fc678b3f6724e2d8a2c3619f02ad834" translate="yes" xml:space="preserve">
          <source>This modules provides access to the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; constructors and exposes some highly optimized GMP-operations.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 생성자에 대한 액세스를 제공하고 고도로 최적화 된 GMP 작업을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="1130e146d0ff983a031a0a8522c8725e170d0829" translate="yes" xml:space="preserve">
          <source>This monad transformer adds the ability to fail or throw exceptions to a monad.</source>
          <target state="translated">이 모나드 변환기는 모나드에 예외를 던지거나 예외를 던지는 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2a98bbb5afc9600bb6b74cc7f447cb8e1866b15b" translate="yes" xml:space="preserve">
          <source>This monad transformer extends a monad with the ability to throw exceptions.</source>
          <target state="translated">이 모나드 변압기는 예외를 던질 수있는 기능으로 모나드를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="bba2acb7a712203bd9458987272d1dea78c2f000" translate="yes" xml:space="preserve">
          <source>This monad transformer is similar to both state and writer monad transformers. Thus it can be seen as</source>
          <target state="translated">이 모나드 변압기는 상태 및 기록기 모나드 변압기와 유사합니다. 따라서 다음과 같이 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7f2bb8a9d0620b88f4451a6324781ede4a2121a7" translate="yes" xml:space="preserve">
          <source>This monad transformer provides append-only accumulation during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">이 모나드 변환기는 계산 중에 추가 전용 누적을 제공합니다. 보다 일반적인 액세스를 위해서는 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c53c5e051f564d4139a6d22099093a9506011e0" translate="yes" xml:space="preserve">
          <source>This monad transformer provides only limited access to the output during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">이 모나드 변환기는 계산 중에 출력에 대한 제한된 액세스 만 제공합니다. 보다 일반적인 액세스를 위해서는 &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e64b48298e57e04598190a3e73a7a420ac326928" translate="yes" xml:space="preserve">
          <source>This now re-exports &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="48569d17cf06edd49e682678e1dd43b354e7266d" translate="yes" xml:space="preserve">
          <source>This only happens if:</source>
          <target state="translated">다음과 같은 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c0b5dda6372d83897c8a1df104f5345b0b4220f" translate="yes" xml:space="preserve">
          <source>This only shows the time zone name, or offset if the name is empty.</source>
          <target state="translated">시간대 이름 만 표시되거나 이름이 비어 있으면 오프셋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="48af544d61c79afa3a39e1cd49eb4f6213f4528d" translate="yes" xml:space="preserve">
          <source>This only stands a chance of working for an encoding which is an ASCII superset, as for security reasons we refuse to escape any bytes smaller than 128. Many encodings of interest are ASCII supersets (in particular, you can assume that the locale encoding is an ASCII superset) but many (such as UTF-16) are not.</source>
          <target state="translated">보안상의 이유로 128보다 작은 바이트를 이스케이프하지 않으려는 경우 ASCII 수퍼 셋 인 인코딩에 대해서만 작업 할 수 있습니다. 관심있는 많은 인코딩은 ASCII 수퍼 셋입니다 (특히 로케일 인코딩은 ASCII 수퍼 셋)이지만 UTF-16과 같은 많은 것은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6ecf6dcbeadf01a7014b13f5a368ef88d650353" translate="yes" xml:space="preserve">
          <source>This only works for &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">이는 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 형식, 단일 문자 군 시간대 및 &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</target>
        </trans-unit>
        <trans-unit id="d7c1d4016c14da3ba1514123886da29a32443086" translate="yes" xml:space="preserve">
          <source>This only works for a &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">이것은 단지 작동 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 형식, 단일 문자 군용 시간 영역 및이 시간 영역 : &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot; CDT &quot;,&quot;MST &quot;,&quot;MDT &quot;,&quot;PST &quot;,&quot;PDT &quot;.</target>
        </trans-unit>
        <trans-unit id="23816db6dd8bea367310677e3bfbcb17ade64070" translate="yes" xml:space="preserve">
          <source>This operation acquires a unit from the semaphore (i.e. decreases the internal counter) and blocks (via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;) if no units are available (i.e. if the counter is &lt;em&gt;not&lt;/em&gt; positive).</source>
          <target state="translated">이 작업은 세마포어에서 장치를 획득하고 (즉, 내부 카운터를 감소시킵니다) 사용 가능한 장치가없는 경우 (즉 카운터가 양수 가 &lt;em&gt;아닌&lt;/em&gt; 경우) &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 를 통해 차단 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7014f780887d062aecc25cade39318f1f4267c3d" translate="yes" xml:space="preserve">
          <source>This operation adds/releases a unit back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">이 작업은 장치를 세마포어에 다시 추가 / 해제합니다 (즉, 내부 카운터를 증가시킵니다).</target>
        </trans-unit>
        <trans-unit id="bbef804c0feb5706c138bd85cf6a98a3ae663039" translate="yes" xml:space="preserve">
          <source>This operation adds/releases multiple units back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">이 작업은 여러 장치를 세마포에 다시 추가 / 해제합니다 (즉, 내부 카운터를 증가시킵니다).</target>
        </trans-unit>
        <trans-unit id="23431b855341eca76cdc24f413dd7563b100983c" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">이 연산은 주로 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값을 직접 구성하는 테스트 슈트 및 / 또는 코드에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="49d93c809fbddf9cf81dbda4c05507ecf14db03e" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">이 연산은 주로 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값을 직접 구성하는 테스트 슈트 및 / 또는 코드에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3297c146519190d66c5419366b511b5ce250ad" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">이 작업은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 정의 에서 IO 작업이 여러 번 실행되는 것을 방지하기 위해 사용되며 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f6053c6fe980d3303ab7779a6c30bf3b23e441" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">이 작업은 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 정의 에서 IO 작업이 여러 번 실행되는 것을 방지하기 위해 사용되며 일반적으로 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ee46adec231f99964d238f6075b76987a604b31" translate="yes" xml:space="preserve">
          <source>This operation may fail with:</source>
          <target state="translated">이 작업은 다음과 같이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a481371f0ca2e52248cb4d557f65d6db3c681c94" translate="yes" xml:space="preserve">
          <source>This optimisation isn&amp;rsquo;t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</source>
          <target state="translated">이 최적화가 항상 유익하지는 않습니다 (따라서 GHC는 일부 휴리스틱을 적용하여 적용시기를 결정합니다). 세부 사항은 복잡하지만 간단한 예는 여러 let 바인딩이 더 큰 단일 let 바인딩으로 그룹화되어 할당을 효과적으로 일괄 처리하고 가비지 수집기 및 할당자를 도와 줄 수 있도록 let 바인딩을 바깥쪽으로 옮기는 것이 종종 유리하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="daf337b821cabcc31b64cb93551eb620a65ef97d" translate="yes" xml:space="preserve">
          <source>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</source>
          <target state="translated">이 최적화는 바인딩을 사용 사이트에 더 가깝게 만듭니다. 여기서 이점은 이제 let이있는 분기가 실행되지 않으면 불필요한 할당을 피할 수 있다는 것입니다. 또한 로컬에 더 많은 정보가 있으므로 다른 최적화 단계가 더 효과적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc0b111503fc7f964b8ba8ae4f63543b67f459b" translate="yes" xml:space="preserve">
          <source>This optimisation specializes recursive functions according to their argument &amp;ldquo;shapes&amp;rdquo;. This is best explained by example so consider:</source>
          <target state="translated">이 최적화는 인수 &quot;모양&quot;에 따라 재귀 함수를 전문화합니다. 이것은 예제로 가장 잘 설명되므로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3fa5960caadfa09849470cf6386b6072cc3ffa4f" translate="yes" xml:space="preserve">
          <source>This option affects the processing of RTS control options given either on the command line or via the &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable. There are three possibilities:</source>
          <target state="translated">이 옵션은 명령 행 또는 &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; 환경 변수 를 통해 제공된 RTS 제어 옵션 처리에 영향을줍니다 . 세 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f85a6ef1d8626265a37c882bf54d7b55e6bccf" translate="yes" xml:space="preserve">
          <source>This option allows you to set the default RTS options at link-time. For example, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the &lt;code&gt;-rtsopts&lt;/code&gt; option, the user might not have the ability to change RTS options at run-time, in which case &lt;code&gt;-with-rtsopts&lt;/code&gt; would be the &lt;em&gt;only&lt;/em&gt; way to set them.)</source>
          <target state="translated">이 옵션을 사용하면 링크 타임에 기본 RTS 옵션을 설정할 수 있습니다. 예를 들어, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; 은 기본 힙 크기를 128MB로 설정합니다. 사용자가이를 무시하지 않는 한 항상이 프로그램의 기본 힙 크기가됩니다. ( &lt;code&gt;-rtsopts&lt;/code&gt; 옵션 의 설정에 따라 런타임시 RTS 옵션을 변경하는 기능이 사용자에게 없을 수 있습니다.이 경우 &lt;code&gt;-with-rtsopts&lt;/code&gt; 가 옵션 을 설정 하는 &lt;em&gt;유일한&lt;/em&gt; 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f91f71cb98fa24b36d5d90d1dbeb3041d935c33b" translate="yes" xml:space="preserve">
          <source>This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 내부 범위 값이 외부 범위 값과 같은 이름을 가질 때마다 경고가 발생합니다. 즉, 내부 값이 외부 값을 가리게됩니다. 예를 들어, &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt; 재귀 호출이 무엇인지 실수로 캡처하는 경우 찾기 어려운 버그로 바뀌는 인쇄상의 오류를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed96edbbc25b6f1208ec75b666dd489af6409055" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &amp;ldquo;!&amp;rdquo;) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;) to every strict constructor field that fulfils the size restriction.</source>
          <target state="translated">이 옵션을 사용하면 엄격하게 표시된 (예 :&amp;ldquo;!&amp;rdquo;) 모든 가능한 생성자 필드와 가능한 경우 포인터의 크기보다 작거나 같은 표현이 풀립니다. 그것은 추가 동등 &lt;code&gt;UNPACK&lt;/code&gt; 래그를 (참조 &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;언팩 프라그가&lt;/a&gt; 크기 제한을 만족마다 엄격한 생성자 필드).</target>
        </trans-unit>
        <trans-unit id="e2cd4133d01d71e89460c606007690e42b1fcee7" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &lt;code&gt;!&lt;/code&gt;) to be unpacked if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma to every strict constructor field (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 엄격한 (즉, &lt;code&gt;!&lt;/code&gt; )으로 표시된 모든 생성자 필드가 가능하면 압축이 풀립니다. 모든 엄격한 생성자 필드에 &lt;code&gt;UNPACK&lt;/code&gt; pragma 를 추가하는 것과 같습니다 ( &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fc09848f730f75b415b16f985abe5f3c3b0d4c17" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 설치 패키지 ⟩pkg⟩가 GHC에 의해 노출되고 신뢰할 수 없게됩니다. 이 명령은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 명령 과 매우 유사한 방식으로 작동 하지만 또한 패키지 데이터베이스의 내용에 관계없이 선택된 패키지를 GHC에서 신뢰할 수 없도록 설정합니다. ( &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;안전 하스켈&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e900a6603015890af3c88ede22e351087bcb2f4c" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">이 옵션을 사용하면 설치 패키지 ⟨pkg⟩가 GHC에 의해 노출되고 신뢰됩니다. 이 명령은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 명령 과 매우 유사한 방식으로 작동 하지만 패키지 데이터베이스의 내용에 관계없이 선택한 패키지를 GHC에서 신뢰하도록 설정합니다. ( &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;안전 하스켈&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d7d9bf3c24fe2f83f01a2a1fe6e2465277d625b8" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt;&lt;code&gt;-hide-all-plugin-packages&lt;/code&gt;&lt;/a&gt; was not specified, then all other versions will become hidden. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 설치된 패키지 ⟩pkg⟩가 &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; 과 같은 플러그인에 노출됩니다 . 패키지 ⟨pkg⟩는 버전 번호 (예 : &lt;code&gt;network-1.0&lt;/code&gt; ) 로 완전히 지정 하거나 하나의 패키지 버전 만 설치된 경우 버전 번호를 생략 할 수 있습니다. 여러 버전의 ⟨pkg⟩가 설치되어 있고 &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt; &lt;code&gt;-hide-all-plugin-packages&lt;/code&gt; &lt;/a&gt; 가 지정되지 않은 경우 다른 모든 버전이 숨겨집니다. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning 및 &lt;/a&gt;Renaming 모듈에 설명 된 Thinning 및 Renaming을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ef5788126155cc03138f5109c85138baa08f3cb" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</source>
          <target state="translated">이 옵션을 사용하면 설치된 패키지 ⟨pkg⟩가 노출됩니다. 패키지 ⟨pkg⟩는 버전 번호 (예 : &lt;code&gt;network-1.0&lt;/code&gt; ) 로 완전히 지정 하거나 버전 번호를 생략 할 수 있습니다.이 경우 GHC는 설치된 최신 버전의 패키지에서 최신의 최신 버전을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a0e41ab6d83305de686a095b3332cab6407d1ce0" translate="yes" xml:space="preserve">
          <source>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error. See &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 예외가 발생할 때마다 런타임에서 현재 비용 센터 스택을 인쇄합니다. 이는 악명 높은 &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error 와 같은 예외 위치를 디버깅하는 데 특히 유용 할 수 있습니다 . &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;해커, 디버거 및 관심이 많은 영혼을위한 RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b57872a61028ef8c64baf35e07feb3f3f77cf233" translate="yes" xml:space="preserve">
          <source>This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we&amp;rsquo;ll wait until it grows to 4M before collecting it again.</source>
          <target state="translated">이 옵션은 이전 세대 (및 두 공간 콜렉터의 경우 할당 영역 크기)에 예약 된 메모리 양을 라이브 데이터 양의 계수로 제어합니다. 예를 들어, 가장 오래된 세대에 2M의 라이브 데이터가 마지막으로 수집 된 경우 기본적으로 4M으로 커질 때까지 기다렸다가 다시 수집합니다.</target>
        </trans-unit>
        <trans-unit id="fb38d77df4357efae92d504cd6786c9d8c4e6bf3" translate="yes" xml:space="preserve">
          <source>This option disables RTS suggestions about linking with &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either &lt;code&gt;-rtsopts&lt;/code&gt; or &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 사용 가능하지 않을 때 &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; 와의 링크에 대한 RTS 제안을 비활성화 합니다. 사용자가 패키지 관리자를 통해 Haskell 프로그램을 설치 한 경우 이러한 제안은 도움이되지 않습니다. 이 옵션을 사용하면 이러한 제안이 나타나지 않습니다. 바이너리를 배포하는 사람들은 &lt;code&gt;-rtsopts&lt;/code&gt; 또는 &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt; 로 빌드하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="956ede657ecee5ab5112379453aca532a83df0ab" translate="yes" xml:space="preserve">
          <source>This option displays the currently installed packages, for each of the databases known to &lt;code&gt;ghc-pkg&lt;/code&gt;. That includes the global database, the user&amp;rsquo;s local database, and any further files specified using the &lt;code&gt;-f&lt;/code&gt; option on the command line.</source>
          <target state="translated">이 옵션은 &lt;code&gt;ghc-pkg&lt;/code&gt; 로 알려진 각 데이터베이스에 대해 현재 설치된 패키지를 표시합니다 . 여기에는 글로벌 데이터베이스, 사용자의 로컬 데이터베이스 및 명령 행 에서 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하여 지정된 추가 파일이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a08204879e3c5670124e4d3fa4df08f09c2c5827" translate="yes" xml:space="preserve">
          <source>This option does not put a &lt;em&gt;limit&lt;/em&gt; on the heap size: the heap may grow beyond the given size as usual.</source>
          <target state="translated">이 옵션은 힙 크기에 &lt;em&gt;제한&lt;/em&gt; 을 두지 않습니다 . 힙은 평소와 같이 지정된 크기 이상으로 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177e417c340a66f0470d8511743420a60bcc5fbb" translate="yes" xml:space="preserve">
          <source>This option does the opposite of &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell &lt;code&gt;import&lt;/code&gt; directives.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 의 반대입니다 . 지정된 패키지가 숨겨 지므로 Haskell &lt;code&gt;import&lt;/code&gt; 지시문으로 가져올 수있는 모듈이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1560370f0ba5d1fdfc6dfeeacc2a54b30787c270" translate="yes" xml:space="preserve">
          <source>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using &lt;code&gt;UNPACK&lt;/code&gt; pragmas might be better. An alternative is to use &lt;code&gt;-funbox-strict-fields&lt;/code&gt; to turn on unboxing by default but disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 약간의 망치입니다. 때때로 상황이 악화 될 수 있습니다. &lt;code&gt;UNPACK&lt;/code&gt; pragma 를 사용하여 필드를 선택적으로 개봉 하면 더 나을 수 있습니다. 대안은 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 를 사용하여 기본적으로 unboxing을 설정하지만 &lt;code&gt;NOUNPACK&lt;/code&gt; pragma를 사용하여 특정 생성자 필드에 대해 사용하지 않도록 설정하는 것입니다 ( &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3c07ac232f23724b3889cefd06b22eb4683d2f7a" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. Consider recompiling the objects with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and using the &lt;code&gt;-xp&lt;/code&gt; flag instead. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">이 옵션은 메모리 할당 문제를 해결하기위한 것입니다. GHCi가&amp;ldquo; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; &amp;rdquo; 와 같은 메시지와 함께 실패하지 않는 한 사용하지 마십시오 . &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; 로 오브젝트를 다시 컴파일하고 대신 &lt;code&gt;-xp&lt;/code&gt; 플래그를 사용하는 것을 고려하십시오 . 이 옵션을 사용하여 GHCi가 컴퓨터에서 작동하도록하려면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="0ac262cc50deac3cfae652d65a7a869356b40b86" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">이 옵션은 메모리 할당 문제를 해결하기위한 것입니다. &quot; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; &quot;와 같은 메시지와 함께 GHCi가 실패하지 않으면 사용하지 마십시오 . 이 옵션을 사용하여 컴퓨터에서 GHCi를 작동 시키려면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="1c1ed9c302993c8a254ff902df0dbce38b594005" translate="yes" xml:space="preserve">
          <source>This option is less of a sledgehammer than &lt;code&gt;-funbox-strict-fields&lt;/code&gt;: it should rarely make things worse. If you use &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; to turn on unboxing by default you can disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 보다 슬레지 해머가 적습니다 . 당신이 사용하는 경우 &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; 기본적으로 개봉기를 켭니다 당신은 사용하여 특정 생성자 필드를 비활성화 할 수 있습니다 &lt;code&gt;NOUNPACK&lt;/code&gt; 의 (참조 프라그를 &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK 프라그를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fd49d1f76860f1c44d6c219e62e7f40bc9c2382" translate="yes" xml:space="preserve">
          <source>This option is most often used when creating an executable file, to set the filename of the executable. For example:</source>
          <target state="translated">이 옵션은 실행 파일을 만들 때 실행 파일 이름을 설정하기 위해 가장 자주 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ec4e8819778435da9e1806c3a1ad92e747cbb70" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="267371a5e841319f6a790d155fb592c269a41960" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0235b6cb10974ea14ea0574ec14232194a831212" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 이제 &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wredundant-constraints&lt;/code&gt; &lt;/a&gt; 를 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d62299c9dde524b1ef3bb3933973aa22ff0ff398" translate="yes" xml:space="preserve">
          <source>This option is off by default.</source>
          <target state="translated">이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4293e9fab7792eac1853c48400535b8a8b77123a" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있으며 인스턴스 선언에 하나 이상의 메소드가 누락되고 해당 클래스 선언에 기본 선언이없는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="aeda602ded05cab94ca86a41b88530e26ba7b489" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever the construction of a labelled field constructor isn&amp;rsquo;t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</source>
          <target state="translated">이 옵션은 기본적으로 설정되어 있으며 레이블이 지정된 필드 생성자의 구성이 완료되지 않고 하나 이상의 필드에 대한 초기자가 누락 될 때마다 경고합니다. 오류는 아니지만 누락 된 필드는 맨 아래로 초기화되지만 종종 프로그래머 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa97f50ca584638ac24325128130ef5efe4b2fbf" translate="yes" xml:space="preserve">
          <source>This option is on by default.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2fe70b27b67051a789b82f4eb4f639ee630173" translate="yes" xml:space="preserve">
          <source>This option is on by default. As usual you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 기본적으로 켜져 있습니다. 평소처럼 &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; 하여 모듈 단위로 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccde2620c81cc8f927379b68565101df835bced2" translate="yes" xml:space="preserve">
          <source>This option is only useful when running in parallel (&lt;code&gt;-N2&lt;/code&gt; or greater). It allows the processor cores to make better use of the available allocation area, even when cores are allocating at different rates. Without &lt;code&gt;-n&lt;/code&gt;, each core gets a fixed-size allocation area specified by the &lt;code&gt;-A&lt;/code&gt;, and the first core to exhaust its allocation area triggers a GC across all the cores. This can result in a collection happening when the allocation areas of some cores are only partially full, so the purpose of the &lt;code&gt;-n&lt;/code&gt; is to allow cores that are allocating faster to get more of the allocation area. This means less frequent GC, leading a lower GC overhead for the same heap size.</source>
          <target state="translated">이 옵션은 병렬로 실행할 때만 유용합니다 ( &lt;code&gt;-N2&lt;/code&gt; 이상). 코어가 다른 속도로 할당되는 경우에도 프로세서 코어가 사용 가능한 할당 영역을 더 잘 활용할 수 있습니다. &lt;code&gt;-n&lt;/code&gt; 이 없으면 각 코어는 &lt;code&gt;-A&lt;/code&gt; 로 지정된 고정 크기 할당 영역을 가져오고 할당 영역 을 소진하는 첫 번째 코어는 모든 코어에서 GC를 트리거합니다. 이로 인해 일부 코어의 할당 영역이 일부만 가득 찼을 때 수집이 발생할 수 있으므로 &lt;code&gt;-n&lt;/code&gt; 의 목적은 더 빨리 할당되는 코어가 더 많은 할당 영역을 가져 오도록하는 것입니다. 즉, GC 빈도가 낮아서 동일한 힙 크기에 대해 GC 오버 헤드가 낮아집니다.</target>
        </trans-unit>
        <trans-unit id="8d9c254d7b78a3a3ecbc5027783e6457d1d482ef" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt; 으로 CPU에 스레드를 명시 적으로 예약하는 동시 프로그램에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="95f6bdd8b0e33deb9f64ace0ba5f278fa7702c9e" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt; 을 사용하여 스레드를 CPU에 명시 적으로 예약하는 동시 프로그램에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f35434e6bd52920e5c48189b8cfc8e504aad6697" translate="yes" xml:space="preserve">
          <source>This option is there mainly to stop the program eating up all the available memory in the machine if it gets into an infinite loop.</source>
          <target state="translated">이 옵션은 프로그램이 무한 루프에 빠지면 기계에서 사용 가능한 모든 메모리를 차지하지 않도록 주로 중지합니다.</target>
        </trans-unit>
        <trans-unit id="57d29d5e7df4da4169fdb64e362ca3677dd89e06" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be a bit noisy, and it doesn&amp;rsquo;t always indicate a bug in the program. However, it&amp;rsquo;s generally considered good practice to cover all the cases in your functions, and it is switched on by &lt;a href=&quot;#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 약간 시끄럽기 때문에 기본적으로 활성화되어 있지 않으며 프로그램의 버그를 나타내는 것은 아닙니다. 그러나 일반적으로 함수의 모든 경우를 다루는 것이 좋으며 &lt;a href=&quot;#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 에 의해 켜집니다 .</target>
        </trans-unit>
        <trans-unit id="9f98751831a4a39977803e9637f7e77e2e14db0e" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be very noisy, and it often doesn&amp;rsquo;t indicate a bug in the program.</source>
          <target state="translated">이 옵션은 소음이 심할 수 있으며 프로그램의 버그를 나타내지 않기 때문에 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="674da51224e4596bdb3744f26e1f9a1fbcb8b81f" translate="yes" xml:space="preserve">
          <source>This option lists registered packages exposing module ⟨M⟩. Examples:</source>
          <target state="translated">이 옵션은 ⟨M⟩ 모듈을 노출시키는 등록 된 패키지를 나열합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c794703287cedcb0e1c47b116ac501bee05de960" translate="yes" xml:space="preserve">
          <source>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</source>
          <target state="translated">이 옵션은 평가 된 최상위식이 많은 양의 공간을 소비하거나 반복 가능한 성능 측정이 필요한 경우에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ff2c217eff8117af9178fc8b3897c5316f401a" translate="yes" xml:space="preserve">
          <source>This option provides a &amp;ldquo;suggested heap size&amp;rdquo; for the garbage collector. Think of &lt;code&gt;-Hsize&lt;/code&gt; as a variable &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-A ⟨size⟩&lt;/code&gt;&lt;/a&gt; option. It says: I want to use at least ⟨size⟩ bytes, so use whatever is left over to increase the &lt;code&gt;-A&lt;/code&gt; value.</source>
          <target state="translated">이 옵션은 가비지 수집기에 &quot;추천 힙 크기&quot;를 제공합니다. &lt;code&gt;-Hsize&lt;/code&gt; 를 변수 &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-A ⟨size⟩&lt;/code&gt; &lt;/a&gt; 옵션 으로 생각하십시오 . 그것은 말합니다 : 적어도 ⟨size⟩ 바이트를 사용하고 싶습니다. 남은 것을 사용하여 &lt;code&gt;-A&lt;/code&gt; 값 을 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="8853a9d72e715d15e409a53251078ae18153a456" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">이 옵션은 할당 제한과 관련이 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit를&lt;/a&gt; 참조하십시오 . 스레드가 할당 제한에 도달하면 RTS는 스레드에 예외를 throw하고 예외가 다시 발생하기 전에 스레드가 추가 할당량을 얻습니다. 이는 스레드가 예외 처리기를 실행할 수 있도록하는 아이디어입니다. &lt;code&gt;-xq&lt;/code&gt; 은 이 추가 할당량의 크기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5d0cb54597e16fb360f23cd6c09d2b5b66dd5dd4" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">이 옵션은 할당 제한과 관련이 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit을&lt;/a&gt; 참조하십시오 . 스레드가 할당 제한에 도달하면 RTS는 스레드에 예외를 던지고 스레드는 예외가 다시 발생하기 전에 추가 할당 할당량을 얻습니다. 이는 스레드가 예외 처리기를 실행할 수 있도록하는 것입니다. &lt;code&gt;-xq&lt;/code&gt; 은 이 추가 할당량의 크기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ea918ac03fd189d0258f1a47317cf8c206c5d32" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (although they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">이 출력은 현재 세션의 컨텍스트 (예 : &lt;code&gt;Prelude&lt;/code&gt; 범위 )에서 &lt;code&gt;Data.Maybe&lt;/code&gt; 의 첫 번째 항목 그룹이 범위 내에 있지 않음을 보여줍니다 (GHCi 세션에서 정규화 된 형식으로 사용할 수 있음에도 불구하고-What &lt;a href=&quot;#ghci-scope&quot;&gt;'s&lt;/a&gt; 참조). 실제로 프롬프트에서 범위에 있습니까? ), 두 번째 항목 그룹은 범위 ( &lt;code&gt;Prelude&lt;/code&gt; 를 통해 )에 있으므로 제한되지 않거나 &lt;code&gt;Prelude.&lt;/code&gt; 와 함께 사용할 수 있습니다 . 한정자.</target>
        </trans-unit>
        <trans-unit id="363c890a3de72dcec771b7f4c76b67f54a27050f" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (althought they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">(의 범위, 즉 현재 세션의 맥락에서,이 출력 쇼 &lt;code&gt;Prelude&lt;/code&gt; )에서 항목의 첫 번째 그룹 &lt;code&gt;Data.Maybe&lt;/code&gt; 는 그들이 GHCi 세션에서 완전한 형태로 사용할 수 있습니다 althought (범위에없는은 - 참조 &lt;a href=&quot;#ghci-scope&quot;&gt;무엇입니까 실제로 프롬프트 범위?&lt;/a&gt; ), 항목의 두 번째 그룹은 비아 범위 (반면에 &lt;code&gt;Prelude&lt;/code&gt; ) 때문에 가능 하나 비정규 또는 함께있는 &lt;code&gt;Prelude.&lt;/code&gt; 한정자.</target>
        </trans-unit>
        <trans-unit id="d32fd0e1a9f5bf7e2d98a725ace2312b41fff634" translate="yes" xml:space="preserve">
          <source>This package provides both strict and lazy &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; types. The strict type is provided by the &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; module, while the lazy type is provided by the &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; module. Internally, the lazy &lt;code&gt;Text&lt;/code&gt; type consists of a list of strict chunks.</source>
          <target state="translated">이 패키지는 엄격한 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형 과 지연된 텍스트 유형을 모두 제공합니다 . 엄격한 유형은 &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; 모듈에서 제공되는 반면, 지연 유형은 &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; 모듈에서 제공 합니다. 내부적으로 게으른 &lt;code&gt;Text&lt;/code&gt; 유형은 엄격한 청크 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c301e63fdee476a49263ba8163281e72adf6b96" translate="yes" xml:space="preserve">
          <source>This package uses the term &lt;em&gt;character&lt;/em&gt; to denote Unicode &lt;em&gt;code points&lt;/em&gt;.</source>
          <target state="translated">이 패키지는 &lt;em&gt;문자&lt;/em&gt; 라는 용어를 사용하여 유니 &lt;em&gt;코드 코드 포인트&lt;/em&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="aae5addb116c887a46f27acc513b2117c6d86f14" translate="yes" xml:space="preserve">
          <source>This parameter is reserved. You should pass just &lt;em&gt;nullPtr&lt;/em&gt;.</source>
          <target state="translated">이 매개 변수는 예약되어 있습니다. &lt;em&gt;nullPtr&lt;/em&gt; 만 전달 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="15f0fa32e677164a596a3b41ef5acc2c4991ec87" translate="yes" xml:space="preserve">
          <source>This parameter requires to use Windows 7 or later.</source>
          <target state="translated">이 매개 변수는 Windows 7 이상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b0fc7a248b7324fafef584b213680e79287e0c9" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b70e45e4186d009ec916862fca7c137404104fc" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4dfbf340dce50dc9038b479329f38e8ec299cf61" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 파서는 입력이 끝날 때만 성공합니다. 이것은 원시 파서가 아니지만 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9300de657d2872adc67fa41e5ab353e07ce88a2d" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of identifiers. For example &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">이 파서는 식별자의 유효한 꼬리 문자를 허용해야합니다. 예를 들어 &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8528eebabb9825d0176f24d442e7c8b026df63e" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">이 파서는 연산자의 유효한 꼬리 문자를 허용해야합니다. 언어가 사용자 정의 연산자를 지원하지 않는 경우에도이 구문 분석기를 정의해야 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 구문 분석기가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00d8c7a0c04c027e82791e73a94a73041f724be2" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">이 파서는 연산자의 유효한 꼬리 문자를 허용해야합니다. 언어가 사용자 정의 연산자를 지원하지 않는 경우에도이 구문 분석기를 정의해야 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 구문 분석기가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d983e2b71ccf1f3a26f0aff85466bf1e651e9beb" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of identifiers. For example &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">이 파서는 식별자의 시작 문자를 받아 들여야합니다. 예를 들어 &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b9eeef0a0daf3a30997aca44251904a3bc4ace8" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of operators. For example &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</source>
          <target state="translated">이 파서는 연산자의 시작 문자를 받아 들여야합니다. 예를 들어 &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9db4088868263aaafdfa869a0f8e2314217323d7" translate="yes" xml:space="preserve">
          <source>This parser succeeds for any character. Returns the parsed character.</source>
          <target state="translated">이 파서는 모든 문자에 성공합니다. 파싱 ​​된 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a306a889dc9a52a42b11381f826b2d7630214d4b" translate="yes" xml:space="preserve">
          <source>This pragma is similar to C&amp;rsquo;s &lt;code&gt;#line&lt;/code&gt; pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</source>
          <target state="translated">이 pragma는 C의 &lt;code&gt;#line&lt;/code&gt; pragma 와 유사하며 주로 자동 생성 된 Haskell 코드에 사용됩니다. 원본 코드의 줄 번호와 파일 이름을 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca88c24656a8d8661c565a0c56d31be0ec21660f" translate="yes" xml:space="preserve">
          <source>This primitive is only available when the underlying GMP library supports it (GMP &amp;gt;= 5). Otherwise, it internally falls back to &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt;, and a warning will be emitted when used.</source>
          <target state="translated">이 기본 요소는 기본 GMP 라이브러리가이를 지원하는 경우에만 사용할 수 있습니다 (GMP&amp;gt; = 5). 그렇지 않으면 내부적으로 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 로 폴백 되며 사용시 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dceb51efdb1a52e7502aaf8f2f6a2f14168bc8e4" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">이 문제는 GHCi에만 영향을주는 것이 아니라 콘솔 이벤트를 포착하려는 GHC 컴파일 프로그램에 영향을 미칩니다. &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a497560db9bd41df0e1b95425a2c75d218c8ec8" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">이 문제는 GHCi에만 영향을 미치는 것이 아니라 콘솔 이벤트를 포착하려는 GHC 컴파일 프로그램에 영향을줍니다. &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c277562015915ae2718208c757d99e3c4a5c2ea5" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">이것은 각 키에 대해 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="520ac415055f1c0bf4aa6e9c1ae9d27830756102" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">그러면 각 키에 대해 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="d113cd0a06b95adde252febb8a83dc6d268b9573" translate="yes" xml:space="preserve">
          <source>This program will be rejected as ambiguous because GHC will not unify the type variables &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 GHC가 유형 변수 &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;i&lt;/code&gt; 를 통합하지 않기 때문에 모호한 것으로 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="e24c8bfbcd524c9aaee115418d115977f5d18a8a" translate="yes" xml:space="preserve">
          <source>This program will be rejected, because &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; does not scope over the definition of &amp;ldquo;&lt;code&gt;g&lt;/code&gt;&amp;rdquo;, so &amp;ldquo;&lt;code&gt;x::a&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;x::forall a. a&lt;/code&gt;&amp;rdquo; by Haskell&amp;rsquo;s usual implicit quantification rules.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;가&amp;ldquo; &lt;code&gt;g&lt;/code&gt; &amp;rdquo; 의 정의를 다루지 않기 때문에이 프로그램은 거부 될 것이므로&amp;ldquo; &lt;code&gt;x::a&lt;/code&gt; &amp;rdquo;는&amp;ldquo; &lt;code&gt;x::forall a. a&lt;/code&gt; &amp;rdquo;를 의미 합니다. &quot;하스켈의 일반적인 암시 정량화 규칙에 의해.</target>
        </trans-unit>
        <trans-unit id="d583e97443b28f0723fcc05e1353f50d62ca3ee1" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="39080170230fd9e748e118da55a46cb1b209f144" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="8c3070f1819b5144ee0019a42b9364d5b62ac534" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">이 프로그램은 코어 덤프됩니다. 다형성 참조에 대한이 문제는 ML 커뮤니티에서 잘 알려져 있으며 참조를 일반적으로 사용하는 경우에는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용하면 불가능한 쉬운 방법이 없습니다 . 실제로 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의 도움으로 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; a- &amp;gt; b 를 작성할 수 있습니다. 그러니 조심해!</target>
        </trans-unit>
        <trans-unit id="8edf15b81edbb17eae494e16b7d0533a271e50da" translate="yes" xml:space="preserve">
          <source>This provides a type-indexed type representation mechanism, similar to that described by,</source>
          <target state="translated">이것은 타입 인덱스 타입 표현 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="77d3447bc17b046a19fec0f3cc3c7ab330fb5b15" translate="yes" xml:space="preserve">
          <source>This reduces the allocation and trimming overhead, as all generated &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s fit into the first buffer and there is no trimming required, if more than 64 bytes and less than 128 bytes are written.</source>
          <target state="translated">이렇게하면 생성 된 모든 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 첫 번째 버퍼에 맞고 64 바이트 이상 128 바이트 미만이 기록되는 경우 트리밍이 필요하지 않으므로 할당 및 트리밍 오버 헤드가 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="79b2e379cd0f1eaf600da24618a21f3bffdedc96" translate="yes" xml:space="preserve">
          <source>This relative path technique can be used with either of the two &lt;code&gt;-dynload&lt;/code&gt; modes, though it makes most sense with the &lt;code&gt;deploy&lt;/code&gt; mode. The difference is that with the &lt;code&gt;deploy&lt;/code&gt; mode, the above example will end up with an ELF &lt;code&gt;RUNPATH&lt;/code&gt; of just &lt;code&gt;$ORIGIN&lt;/code&gt; while with the &lt;code&gt;sysdep&lt;/code&gt; mode the &lt;code&gt;RUNPATH&lt;/code&gt; will be &lt;code&gt;$ORIGIN&lt;/code&gt; followed by all the library directories of all the packages that the program depends on (e.g. &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages etc.) which are typically absolute paths. The unix tool &lt;code&gt;readelf --dynamic&lt;/code&gt; is handy for inspecting the &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries in ELF shared libraries and executables.</source>
          <target state="translated">이 상대 경로 기술은 두 개의 &lt;code&gt;-dynload&lt;/code&gt; 모드 중 하나와 함께 사용할 수 있지만 &lt;code&gt;deploy&lt;/code&gt; 모드 에서는 가장 적합 합니다. 차이점은 함께한다는 것입니다 &lt;code&gt;deploy&lt;/code&gt; 모드, 위의 예는 ELF와 함께 종료됩니다 &lt;code&gt;RUNPATH&lt;/code&gt; 단지의 &lt;code&gt;$ORIGIN&lt;/code&gt; 동안 함께 &lt;code&gt;sysdep&lt;/code&gt; 의 모드 &lt;code&gt;RUNPATH&lt;/code&gt; 이 될 것입니다 &lt;code&gt;$ORIGIN&lt;/code&gt; 프로그램에 의존하는 모든 패키지의 모든 라이브러리 디렉토리 다음에 ( 예를 들어 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;rts&lt;/code&gt; 패키지 등)은 일반적으로 절대 경로입니다. 유닉스 도구 &lt;code&gt;readelf --dynamic&lt;/code&gt; 검사 용에 편리 &lt;code&gt;RPATH&lt;/code&gt; 를 / &lt;code&gt;RUNPATH&lt;/code&gt; ELF 공유 라이브러리 및 실행 파일의 RUNPATH 항목</target>
        </trans-unit>
        <trans-unit id="370040cae2bc778368a6b92c807c4b5827ecb99e" translate="yes" xml:space="preserve">
          <source>This representation is generated automatically if a &lt;code&gt;deriving Generic&lt;/code&gt; clause is attached to the datatype. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Standalone deriving&lt;/a&gt; can also be used.</source>
          <target state="translated">&lt;code&gt;deriving Generic&lt;/code&gt; 표현 조항이 데이터 유형에 첨부 되면이 표현이 자동으로 생성됩니다 . &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립형 파생&lt;/a&gt; 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30dd0b304103583a22935853ab5fa131cea21cbe" translate="yes" xml:space="preserve">
          <source>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the &lt;code&gt;Int&lt;/code&gt; type, respectively:</source>
          <target state="translated">이 표현은 특별한 처리가 제공되지 않는 점에서 매우 일반적입니다. 그러나 일부 함수는 일부 알려진 유형을 특별히 처리해야 할 수 있습니다. 예를 들어 다음 두 함수는 (중첩 된) 화살표 유형의 모든 인수 유형을 수집하고 각각 &lt;code&gt;Int&lt;/code&gt; 유형을 인식합니다 .</target>
        </trans-unit>
        <trans-unit id="54c505cd157188eeaeea208a88996c170f20c5ef" translate="yes" xml:space="preserve">
          <source>This resembles the wildcards that can be used in &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; have any effect.</source>
          <target state="translated">이는 &lt;a href=&quot;#partial-type-signatures&quot;&gt;부분 형식 서명에&lt;/a&gt; 사용할 수있는 와일드 카드와 유사합니다 . 그러나 약간의 차이가 있습니다. 유추 된 유형을보고하는 오류 메시지가 생성되지 않으며 &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt; 확장 도 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05658b8ed19f8a18e37b401843f9f1390a5fc067" translate="yes" xml:space="preserve">
          <source>This results in the variable &lt;code&gt;output&lt;/code&gt; taking on the value below:</source>
          <target state="translated">변수 &lt;code&gt;output&lt;/code&gt; 은 아래 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="faeb3724827d317e7530a6953ccd1a741efde90d" translate="yes" xml:space="preserve">
          <source>This rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">이 규칙은 데이터 유형 선언에도 적용됩니다. 예를 들어 &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; 있고 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;k&lt;/code&gt; 종류가 할당됩니다 . 여기서 &lt;code&gt;k&lt;/code&gt; 는 새로운 종류 변수입니다. &lt;code&gt;k&lt;/code&gt; 는 사용자가 작성하지 않았기 때문에 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형의 유형 응용 프로그램에는 사용할 수 없습니다 . 단지 &lt;code&gt;a&lt;/code&gt; 는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ab2f281f7fbf2bff47d327fa4cfe489acb61e45" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;#10132&lt;/a&gt;).</source>
          <target state="translated">이 규칙은 때때로 놀라운 결과를 가져 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;옵니다&lt;/a&gt; ( # 10132 참조 ).</target>
        </trans-unit>
        <trans-unit id="0dae13ecc0c945a796e78580e4456aee9006b862" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue #10132&lt;/a&gt;.</source>
          <target state="translated">이 규칙은 때때로 놀라운 결과를 초래합니다 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;문제 # 10132&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f8a75e7f4aae139decf4dbddc8f92f07f78b73ed" translate="yes" xml:space="preserve">
          <source>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">이 규칙은 플래그에 관계없이 적용됩니다. 보다 이국적인 컨텍스트를 원한다면 &lt;a href=&quot;#stand-alone-deriving&quot;&gt;독립형 파생 메커니즘을&lt;/a&gt; 사용하여 직접 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9ad35ca09458fcaf673d419d014807d6053c2a9" translate="yes" xml:space="preserve">
          <source>This rule will cause the compiler to go into an infinite loop.</source>
          <target state="translated">이 규칙은 컴파일러가 무한 루프로 들어가게합니다.</target>
        </trans-unit>
        <trans-unit id="2d325df582f925494ea658de7dc04323c3323bae" translate="yes" xml:space="preserve">
          <source>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</source>
          <target state="translated">이 규칙은 다형성 종류의 유형 생성자를 포함하여 모든 구체적인 유형 생성자에 적용됩니다. 유일하게 제한되는 것은 타입 생성자가 다형성 종류를 가진다면 모든 종류의 매개 변수에 적용되어야하고, 이러한 종류는 구체적이어야합니다 (즉, 종류 변수를 언급 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="012cf785712f9f58baa44a19777eaca31580d1fc" translate="yes" xml:space="preserve">
          <source>This runs the interpreted code in a separate process (see &lt;a href=&quot;#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;) and runs it in profiling mode to collect call stack information. Note that because we&amp;rsquo;re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The &lt;code&gt;-prof&lt;/code&gt; flag to GHCi only works in conjunction with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;.</source>
          <target state="translated">해석 된 코드를 별도의 프로세스에서 &lt;a href=&quot;#external-interpreter&quot;&gt;실행하고&lt;/a&gt; (별도의 프로세스 에서 인터프리터 실행 참조 ) 호출 모드 정보를 수집하기 위해 프로파일 링 모드에서 실행합니다. 프로파일 링 모드에서 해석 된 코드를 실행하기 때문에 사용하는 모든 패키지가 프로파일 링을 위해 컴파일되어야합니다. GHCi에 대한 &lt;code&gt;-prof&lt;/code&gt; 플래그는 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 와 함께 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0e7a2ad40c566ce0f6643ee923a3e30a05545bee" translate="yes" xml:space="preserve">
          <source>This says that &lt;code&gt;modify (+1)&lt;/code&gt; acts over any Monad that is a member of the &lt;code&gt;MonadState&lt;/code&gt; class, with an &lt;code&gt;Int&lt;/code&gt; state.</source>
          <target state="translated">이것은 &lt;code&gt;modify (+1)&lt;/code&gt; 이 &lt;code&gt;MonadState&lt;/code&gt; 클래스 의 멤버 인 Monad 에 대해 &lt;code&gt;Int&lt;/code&gt; 와 함께 작동한다는 것을 나타냅니다. 상태 냅니다.</target>
        </trans-unit>
        <trans-unit id="aeefc346ad248407772de61eb44c91ebc62b1dff" translate="yes" xml:space="preserve">
          <source>This section defines the layout of these events. The &lt;code&gt;String&lt;/code&gt; type below is defined to be a UTF-8 encoded NUL-terminated string.</source>
          <target state="translated">이 섹션에서는 이러한 이벤트의 레이아웃을 정의합니다. &lt;code&gt;String&lt;/code&gt; 아래의 형식은 UTF-8 인코딩 NUL 종료 문자열로 정의된다.</target>
        </trans-unit>
        <trans-unit id="426477ffd0f3109ffb983e296577e866ad83653a" translate="yes" xml:space="preserve">
          <source>This section describes &lt;em&gt;data type promotion&lt;/em&gt;, an extension to the kind system that complements kind polymorphism. It is enabled by &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, and described in more detail in the paper &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;, which appeared at TLDI 2012.</source>
          <target state="translated">이 섹션에서는 종류 다형성을 보완하는 종류 시스템의 확장 인 &lt;em&gt;데이터 형식 승격에&lt;/em&gt; 대해 설명 &lt;em&gt;합니다&lt;/em&gt; . 그것은 &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; 에 의해 가능하며 , TLDI 2012에 출연 한 &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Haskell a Promotion&lt;/a&gt; 이라는 논문에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb974cf5a36706fbeb443061b653e868010df89d" translate="yes" xml:space="preserve">
          <source>This section describes GHC&amp;rsquo;s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC&amp;rsquo;s kind system.</source>
          <target state="translated">이 섹션에서는 버전 8.0 이상에서 나타나는 GHC 종류 시스템에 대해 설명합니다. 여기에 설명 된 종류 시스템은 표준 Haskell을 넘어서는 보수적 인 확장 임에도 불구하고 항상 확장이 있든 없든 적용됩니다. 위의 확장은 구문을 활성화하고 추론 알고리즘을 조정하여 사용자가 GHC 종류 시스템의 추가 표현성을 활용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d4d58a26ba3b02f1db1fe2de0ac14aa3d6a048b5" translate="yes" xml:space="preserve">
          <source>This section describes features specific to GHC's implementation of Concurrent Haskell.</source>
          <target state="translated">이 섹션에서는 GHC의 Concurrent Haskell 구현과 관련된 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bdd49ffb73a3731ac6d967fc14496c16e1567101" translate="yes" xml:space="preserve">
          <source>This section describes how to create DLLs to be called from other languages, such as Visual Basic or C++. This is a special case of &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;; we&amp;rsquo;ll deal with the DLL-specific issues that arise below. Here&amp;rsquo;s an example:</source>
          <target state="translated">이 섹션에서는 Visual Basic 또는 C ++과 같은 다른 언어에서 호출 할 DLL을 만드는 방법에 대해 설명합니다. 이것은 &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;외부 코드에서 호출 할 수있는 Haskell 라이브러리를 만드는&lt;/a&gt; 특별한 경우입니다 . 아래에서 발생하는 DLL 관련 문제를 다룰 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c716f59912a3ade4c8a600a747406892f16105cd" translate="yes" xml:space="preserve">
          <source>This section describes other program(s) which we distribute, that help with the Great Haskell Programming Task.</source>
          <target state="translated">이 섹션에서는 Great Haskell Programming Task에 도움이되는 우리가 배포하는 다른 프로그램에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd9343002ee7f20ea72481ff97c75ea4a9503720" translate="yes" xml:space="preserve">
          <source>This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</source>
          <target state="translated">이 섹션에서는 GHC가 찾은 파일, 생성 된 파일, 파일이 저장된 위치 및이 옵션에 어떤 옵션이 영향을 미치는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1c1c7aa4c4b76ef9244f133c648760bb4ada19e" translate="yes" xml:space="preserve">
          <source>This section documents GHC&amp;rsquo;s take on various issues that are left undefined or implementation specific in Haskell 98.</source>
          <target state="translated">이 절에서는 GHC가 정의하지 않았거나 Haskell 98에 특정 구현 된 다양한 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d1b5cee4b5290696273cb8636327d9703229eadc" translate="yes" xml:space="preserve">
          <source>This section documents the encodings of the events emitted to GHC&amp;rsquo;s &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt;. These events can include information about the thread scheduling events, garbage collection statistics, profiling information, user-defined tracing events.</source>
          <target state="translated">이 섹션에서는 GHC의 &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;이벤트 로그로 생성&lt;/a&gt; 된 이벤트의 인코딩을 설명합니다 . 이러한 이벤트에는 스레드 스케줄링 이벤트, 가비지 콜렉션 통계, 프로파일 링 정보, 사용자 정의 추적 이벤트에 대한 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b978b97b7476bee1ad03a8af2ae4346819b8abd7" translate="yes" xml:space="preserve">
          <source>This section is a quick-reference for GHC&amp;rsquo;s command-line flags. For each flag, we also list its mode/dynamic status (see &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;), and the flag&amp;rsquo;s opposite (if available).</source>
          <target state="translated">이 섹션은 GHC의 명령 행 플래그에 대한 빠른 참조입니다. 각 플래그에 대해 모드 / 동적 상태 ( &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;동적 및 모드 옵션&lt;/a&gt; 참조 )와 플래그의 반대 (사용 가능한 경우) 도 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="e5d224e7441e3fb869faddf4a0821bffaff71c9b" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events.</source>
          <target state="translated">이 섹션은 이러한 이벤트를 소비하는 툴링 구현자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2631d568425721367141e5ca16a0dc349ee46597" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events. GHC ships with a C header file (&lt;code&gt;EventlogFormat.h&lt;/code&gt;) which provides symbolic names for the event type IDs described in this file.</source>
          <target state="translated">이 섹션은 이러한 이벤트를 사용하는 도구 구현자를위한 것입니다. GHC 는이 파일에 설명 된 이벤트 유형 ID에 대한 기호 이름을 제공 하는 C 헤더 파일 ( &lt;code&gt;EventlogFormat.h&lt;/code&gt; )과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4793c1dfb931aabba357e67757e80e8fe4a49b96" translate="yes" xml:space="preserve">
          <source>This section lists Glasgow Haskell infelicities in its implementation of Haskell 98 and Haskell 2010. See also the &amp;ldquo;when things go wrong&amp;rdquo; section (&lt;a href=&quot;gone_wrong#wrong&quot;&gt;What to do when something goes wrong&lt;/a&gt;) for information about crashes, space leaks, and other undesirable phenomena.</source>
          <target state="translated">이 섹션에는 Haskell 98 및 Haskell 2010 구현에서 Glasgow Haskell의 부적절 함이 나열되어 있습니다. 충돌, 공간 누출 및 기타 바람직하지 않은 현상에 대한 정보 &lt;a href=&quot;gone_wrong#wrong&quot;&gt;는&lt;/a&gt; &amp;ldquo;일이 잘못 되었을 때 수행 할 작업 &amp;rdquo;섹션 (문제 가 발생했을 때 수행 할 작업 )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d329579f2386fca40f0668d94a24284cae13ec1" translate="yes" xml:space="preserve">
          <source>This section, and the next one, documents GHC&amp;rsquo;s type-class extensions. There&amp;rsquo;s lots of background in the paper &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Type classes: exploring the design space&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer).</source>
          <target state="translated">이 섹션과 다음 섹션에서는 GHC의 유형 클래스 확장에 대해 설명합니다. 논문 &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;유형 클래스에는 디자인 공간 탐색&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer) 에 대한 배경 지식이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b1a90dce5c453c0f69c1639a0cce7223844a1ff" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">이것은 표준 &lt;code&gt;$&lt;/code&gt; 연산자 의 일반화처럼 보입니다 . 그러나 이것을 실행 가능한 코드로 컴파일하려고하면 문제가 발생합니다. 특히, 우리가 &lt;code&gt;bad&lt;/code&gt; 를 호출 할 때 , 우리는 어떻게 든 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;bad&lt;/code&gt; 에 전달해야합니다 . &lt;code&gt;x&lt;/code&gt; 의 폭 (즉, 몇 비트) 입니까? 포인터입니까? 어떤 종류의 레지스터 (부동 소수점 또는 정수)한다 &lt;code&gt;x&lt;/code&gt; 갈? &lt;code&gt;x&lt;/code&gt; 의 타입, &lt;code&gt;a :: TYPE r1&lt;/code&gt; 때문에 말할 수는 없습니다. 은 다형성 . 따라서 다음과 같은 간단한 규칙을 통해 이러한 구성을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="36e8a4554348a6c067a922b4fe362601f76eb118" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">이것은 표준 &lt;code&gt;$&lt;/code&gt; 연산자 의 일반화처럼 보입니다 . 그러나 이것을 실행 가능한 코드로 컴파일하는 것에 대해 생각하면 문제가 나타납니다. 특히, &lt;code&gt;bad&lt;/code&gt; 를 호출 할 때 어떻게 든 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;bad&lt;/code&gt; 로 전달해야합니다 . &lt;code&gt;x&lt;/code&gt; 는 얼마나 넓습니까 (즉, 몇 비트) ? 포인터입니까? 어떤 종류의 레지스터 (부동 소수점 또는 정수)한다 &lt;code&gt;x&lt;/code&gt; 갈? &lt;code&gt;x&lt;/code&gt; 의 유형 인 &lt;code&gt;a :: TYPE r1&lt;/code&gt; 이 levity 다형성 이기 때문에 모두 말할 수 없습니다 . 따라서 우리는 다음과 같은 간단한 규칙을 통해 이러한 구성을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="c863740ea2de0c5a648f81c5a1a438b882986762" translate="yes" xml:space="preserve">
          <source>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</source>
          <target state="translated">이것은 개발자에게 가장 직관적이고 투명한 접근 방식으로 보이며 더 이상 코드에 중복되는 공리가 있거나 인스턴스 컨텍스트의 순서와 관련이 있다는 사실에 더 이상 신경 쓸 필요가 없습니다. 그러나 역 추적은 일반적인 인스턴스 선택 (겹치는 인스턴스가있는 경우)에 동일하게 적용되므로 훨씬 유포 된 변경이며 형식 유추 엔진에 상당한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="8048706f7c05b6021df5922e0299f8cdba50f03b" translate="yes" xml:space="preserve">
          <source>This should &lt;em&gt;never&lt;/em&gt; be used in combination with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. Think of &lt;code&gt;&lt;a href=&quot;control-monad-catch-pure#t:CatchT&quot;&gt;CatchT&lt;/a&gt;&lt;/code&gt; as an alternative base monad for use with mocking code that solely throws exceptions via &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:throwM&quot;&gt;throwM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bbd3a27d52a3a851dbfdab4b9ab18c81125223" translate="yes" xml:space="preserve">
          <source>This should call &lt;code&gt;error&lt;/code&gt; but actually prints &lt;code&gt;True&lt;/code&gt;. Reason: GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</source>
          <target state="translated">이것은 &lt;code&gt;error&lt;/code&gt; 를 호출해야 하지만 실제로는 &lt;code&gt;True&lt;/code&gt; 를 인쇄합니다 . 이유 : GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</target>
        </trans-unit>
        <trans-unit id="7ab63a2693cd6c7a45c1f790143037cd6507bc64" translate="yes" xml:space="preserve">
          <source>This should produce a file named &lt;code&gt;fib.dSYM&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fib.dSYM&lt;/code&gt; 이라는 파일이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="739e32040ecc4d2911d13031c9ae018167e3429f" translate="yes" xml:space="preserve">
          <source>This should work, as long as your GHCi was built with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; switch, which is the default. Consult whoever supplied your GHCi installation.</source>
          <target state="translated">이것은 한 당신의 GHCi가로 구축되면서 작동합니다 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; 기본입니다 스위치. GHCi 설치를 제공 한 사람에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="58d6ca6d530436d6559c489e7dd370e9564a3d34" translate="yes" xml:space="preserve">
          <source>This simple plugin takes over the execution of Template Haskell code, replacing any expression splice it encounters by &lt;code&gt;0&lt;/code&gt; (at type &lt;code&gt;Int&lt;/code&gt;), and errors out on any other type of splice.</source>
          <target state="translated">이 간단한 플러그인은 Template Haskell 코드의 실행을 인계 받아서 만나는 표현식 스플 라이스를 &lt;code&gt;0&lt;/code&gt; ( &lt;code&gt;Int&lt;/code&gt; 유형에서 )으로 바꾸고 다른 유형의 스플 라이스에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="689b2645ac8c6757ff69fc4ca6accdc5ec8ea0cb" translate="yes" xml:space="preserve">
          <source>This slightly odd-looking rule instructs GHC to replace &lt;code&gt;genericLookup&lt;/code&gt; by &lt;code&gt;intLookup&lt;/code&gt;&lt;em&gt;whenever the types match&lt;/em&gt;. What is more, this rule does not need to be in the same file as &lt;code&gt;genericLookup&lt;/code&gt;, unlike the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragmas which currently do (so that they have an original definition available to specialise).</source>
          <target state="translated">이 약간 이상한 규칙은 GHC가 &lt;em&gt;형식이 일치 할 때마다 &lt;/em&gt; &lt;code&gt;genericLookup&lt;/code&gt; 을 &lt;code&gt;intLookup&lt;/code&gt; 으로 바꾸 도록 지시 합니다. 또한이 규칙은 현재 수행 하는 &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma 와 달리 &lt;code&gt;genericLookup&lt;/code&gt; 과 동일한 파일에있을 필요는 없습니다 (전문화 할 수있는 원래 정의를 갖도록).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="074a31f4d9e16cb86e220f5f40a063ee59b833fe" translate="yes" xml:space="preserve">
          <source>This stack structure means that the order of &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; flags or &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</source>
          <target state="translated">이 스택 구조는 &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; 플래그 또는 &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 의 순서&lt;/a&gt; 가 중요 함을 의미합니다. 스택의 각 하위 스택은 올바르게 구성되어야합니다 (스택의 상단에있는 데이터베이스의 패키지는 아래 패키지를 참조 할 수 있지만 그 반대는 아닙니다).</target>
        </trans-unit>
        <trans-unit id="e66c29e8f81778a2aa9684e85767a00ebb262ce6" translate="yes" xml:space="preserve">
          <source>This statement requires that f have the type forall a. [a] -&amp;gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</source>
          <target state="translated">이 문장은 f가 모든 유형을 갖도록 요구한다. [a]-&amp;gt; [a]. 이 양식이 take 5를 적용하는 데 사용되므로 동기 부여 예제에서 그 사용 예제를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61c78a7e665855a92db9c5e9ffaec8226aba79b6" translate="yes" xml:space="preserve">
          <source>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (&amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;\\&quot;&lt;/code&gt;, depending on the system), and ⟨extension⟩ is a source extension (&lt;code&gt;hs&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;) if we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, or ⟨hisuf⟩ otherwise.</source>
          <target state="translated">이 전략은 다음과 같습니다. GHC는 검색 경로라는 디렉토리 목록을 유지합니다. 이러한 각 디렉토리 에 대해 디렉토리에 &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; 을 추가하려고 시도 하고 파일이 존재하는지 확인합니다. ⟨basename⟩의 값은 디렉토리 구분 기호 ( 시스템에 따라 &quot; &lt;code&gt;/&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;\\&quot;&lt;/code&gt; ) 로 대체 된 점이있는 모듈 이름 이며, ⟨extension⟩은 소스 확장자 ( &lt;code&gt;hs&lt;/code&gt; , &lt;code&gt;lhs&lt;/code&gt; )입니다. &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모드 또는 GHCi 또는 그렇지 않으면 ⟨hisuf⟩.</target>
        </trans-unit>
        <trans-unit id="11ed97c596e1d0bcc228efb8114c48f030b93b3b" translate="yes" xml:space="preserve">
          <source>This tells you:</source>
          <target state="translated">이것은 당신에게 알려줍니다 :</target>
        </trans-unit>
        <trans-unit id="07d8f00faa3ae75b40703b0528f229ea480038a2" translate="yes" xml:space="preserve">
          <source>This thread has exceeded its allocation limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드는 할당 제한을 초과했습니다. &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c243ec7e03c31ba25363993635c259a833d99359" translate="yes" xml:space="preserve">
          <source>This translates to:</source>
          <target state="translated">이것은 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="e21f274a51f9949f29f1cc84b56dc845f3250ad2" translate="yes" xml:space="preserve">
          <source>This trick isn&amp;rsquo;t foolproof, because there might be other &lt;code&gt;B&lt;/code&gt; closures in the heap which aren&amp;rsquo;t the retainers we are interested in, but we&amp;rsquo;ve found this to be a useful technique in most cases.</source>
          <target state="translated">우리가 관심있는 리테이너가 아닌 힙에 다른 &lt;code&gt;B&lt;/code&gt; 클로저 가있을 수 있기 때문에이 트릭은 절대 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7eedf2bab1365e54cbd4693945639257ad4fb0f2" translate="yes" xml:space="preserve">
          <source>This trivial type constructor serves two purposes:</source>
          <target state="translated">이 간단한 유형 생성자는 두 가지 목적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="628155b5f0687904716807bcd6409248a6482468" translate="yes" xml:space="preserve">
          <source>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</source>
          <target state="translated">GHC는 현재 전기 및 보유자 정보를 동시에 사용하여 프로파일 링 할 수 없으므로이 2 단계 프로세스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="da64adf134879e08323ed89e3b1e4948df137364" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level natural numbers.</source>
          <target state="translated">이 유형은 알려지지 않은 유형 수준의 자연수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63e71d7f0b07e2f8017ecf6cb7990bb372b6c369" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level symbols.</source>
          <target state="translated">이 유형은 알려지지 않은 유형 수준 기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc9fd430c3e406e9bfda4395aaf8dea448b92e37" translate="yes" xml:space="preserve">
          <source>This type signature contains a kind error which cannot be deferred.</source>
          <target state="translated">이 형식 서명에는 지연 될 수없는 종류 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1458226daed690560f642a2591b54664bcd7099" translate="yes" xml:space="preserve">
          <source>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see &lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;).</source>
          <target state="translated">유형 패턴에서 와일드 카드에 밑줄을 사용하는 것은 언어라는 용어에서 패턴 일치와 정확히 동일하지만 부분 유형 서명에 밑줄을 사용하는 것과는 다릅니다 ( &lt;a href=&quot;#type-wildcards&quot;&gt;유형 와일드 카드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="843b161d44b1dbfe532489a8737416458e734625" translate="yes" xml:space="preserve">
          <source>This uses the above tree rendering function, and displays the Html as a tree structure, allowing debugging of what is actually getting produced.</source>
          <target state="translated">위의 트리 렌더링 기능을 사용하고 Html을 트리 구조로 표시하여 실제로 생성되는 것을 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="115cfdee365c54682223fbca3e4f895eb1f6e102" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">이 하스켈의 사실 사용 &lt;code&gt;let&lt;/code&gt; 소개하고이 바인딩을 재귀. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 를 사용하여이 정의를 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1be3ce1530bcdc820d6c90501be79827a35abad" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">이 하스켈의 사실 사용 &lt;code&gt;let&lt;/code&gt; 소개하고이 바인딩을 재귀. &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 를 사용하여이 정의를 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f88835ef04d1f3754243e8cd078d29d91f94c0a" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">이것은 일반적으로 문제가되지 않으며, GHC 런타임 시스템이 OS 스레드 리소스를 효율적으로 사용할 수 있도록합니다. 그러나 스레드 로컬 상태를 사용하는 외래 코드를 호출 할 때 사용되는 OS 스레드를보다 잘 제어하는 ​​것이 유용한 경우가 있습니다. 이와 같은 경우 에는 특정 OS 스레드에 묶인 Haskell 스레드 인 &lt;em&gt;바운드 스레드를&lt;/em&gt; 제공 합니다. 바운드 스레드에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1160e9ee24dc05017fdb7f0fab69b46a37237f1" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">이것은 일반적으로 문제가되지 않으며 GHC 런타임 시스템이 OS 스레드 리소스를 효율적으로 사용할 수 있도록합니다. 그러나 스레드 로컬 상태를 사용하는 외래 코드를 호출 할 때와 같이 사용되는 OS 스레드를 더 많이 제어하는 ​​것이 유용한 경우가 있습니다. 이와 같은 경우 에는 특정 OS 스레드에 연결된 Haskell 스레드 인 &lt;em&gt;바운드 스레드를&lt;/em&gt; 제공 합니다. 바인딩 된 스레드에 대한 자세한 내용은 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 모듈에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6fe6c899f31bf735023aed7edade5c845bb20c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 변형은 완성 된 포인터 외에 환경을 기대하는 종료자를 추가합니다. finalizer에 전달 될 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="73272fcd0ad868eb9d7204167149b902a10e97d9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 변형은 완성 된 포인터 외에 환경을 기대하는 종료자를 추가합니다. finalizer에 전달 될 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9448bed87d0380afdfc5a0e85ab115284bc4a12f" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; appears at the type level.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 변종은 유형 레벨에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d456ce198372e2f1c13a10638b827f2a19ffc595" translate="yes" xml:space="preserve">
          <source>This version builds its output lazily; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;.</source>
          <target state="translated">이 버전은 출력을 느리게 빌드합니다. 거의 동일한 인터페이스를 가진 고정 공간 버전은 &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bbca1b395d2fc0bccc520c78f768d92dd9c439e" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly and uses continuation-passing-style to achieve constant space usage. This transformer can be used as a drop-in replacement for &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt;.</source>
          <target state="translated">이 버전은 출력을 엄격하게 빌드하고 연속 전달 스타일을 사용하여 일정한 공간 사용을 달성합니다. 이 변압기는 &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt; 의 드롭 인 대체품으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="930ffaae31f052ddd842b0cc0750e75bde4d30d4" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; instead.</source>
          <target state="translated">이 버전은 출력을 엄격하게 빌드합니다. 동일한 인터페이스의 게으른 버전은 &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy를&lt;/a&gt; 참조하십시오 . 출력이 엄격하게 구축되었지만이 변환기를 사용하여 일정한 공간 동작을 수행 할 수는 없습니다 . 대신 &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c43334581b0313064f9793791ae64d3cd9cb11bb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="04cd97504e7c7c2b93f2ad23f730e7e0477bfefc" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b59dda432be30bd0d16af2bacfdfe2d0f94c9cd" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f67494c6dd16fe58429c914e2600fd861b46bc50" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="67c8e6fa4d8cd33fa64562f0db26d801a347a4eb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 의이 버전은 IO가 단일 스레드에서만 수행되고 있는지 확인하지 않기 때문에보다 효율적입니다. 따라서 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 를 사용할 때 IO 조치가 여러 번 (멀티 프로세서에서) 수행 될 수 있으므로 매번 동일한 결과를 제공해야합니다. 복제 된 IO 작업 중 하나가 부분적으로 만 실행 된 다음 예외가 발생하지 않고 중간에 중단 될 수도 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 같은 기능은 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 내에서 안전하게 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4d88c16a70afcd9d0a8c3fb7463a254c46bdefe" translate="yes" xml:space="preserve">
          <source>This version requires going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, which can be inefficient. However, &lt;code&gt;toIntegralSized&lt;/code&gt; is optimized to allow GHC to statically determine the relative type sizes (as measured by &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt;) and avoid going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for many types. (The implementation uses &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is itself optimized with rules for &lt;code&gt;base&lt;/code&gt; types but may go through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for some type pairs.)</source>
          <target state="translated">이 버전은 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거쳐야 하는데 비효율적 일 수 있습니다. 그러나 &lt;code&gt;toIntegralSized&lt;/code&gt; 는 GHC가 상대 크기를 정적으로 결정하고 ( &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt; 에 의해 측정 된 ) 여러 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거치지 않도록 최적화 되었습니다. (이 구현은 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용 하는데 , 이는 &lt;code&gt;base&lt;/code&gt; 유형에 대한 규칙으로 자체적으로 최적화 되지만 일부 유형 쌍에 대해서는 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 거칠 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="1713051baed32864f550a4d0ea48ed3f725fb1d1" translate="yes" xml:space="preserve">
          <source>This warning allows to detect such uses of &lt;code&gt;*&lt;/code&gt; before the actual breaking change takes place. The recommended fix is to replace &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;Type&lt;/code&gt; imported from &lt;code&gt;Data.Kind&lt;/code&gt;.</source>
          <target state="translated">이 경고를 통해 실제 파손 변경이 발생하기 전에 이러한 &lt;code&gt;*&lt;/code&gt; 사용을 감지 할 수 있습니다 . 권장되는 수정 프로그램을 대체하는 것입니다 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;Type&lt;/code&gt; 에서 수입 &lt;code&gt;Data.Kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8dcf8302d1086b7ab10e1c70ed396a42e5a77b9" translate="yes" xml:space="preserve">
          <source>This warning can be addressed by either adding an explicit import list or using a &lt;code&gt;qualified&lt;/code&gt; import.</source>
          <target state="translated">이 경고는 명시 적 가져 오기 목록을 추가하거나 &lt;code&gt;qualified&lt;/code&gt; 가져 오기를 사용하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78b29ba7cfb3d2918f39c1441e99d9f4ce1287c2" translate="yes" xml:space="preserve">
          <source>This warning can be turned off with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wno-missing-methods&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wno-missing-methods&lt;/code&gt; &lt;/a&gt; 플래그로 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f18c523e2627209783834547bda765478c64d4a5" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">이 경고는 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; 모드 에서 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="72dcfecc8d5494d290ee1b21677961cb5175c2ed" translate="yes" xml:space="preserve">
          <source>This warning is off by default.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e25d5e92b85c829fac2f9477e4538faeeb61aa6" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다. 그러나 &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6ab34268e22349a8e7d47871cb222ede5f058bf5" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">이 경고는 기본적으로 꺼져 있습니다. 그러나 &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; 옵션 그룹의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="90f45b839bbf6248dce6eb6cd816c8aef78b200f" translate="yes" xml:space="preserve">
          <source>This warning is on by default.</source>
          <target state="translated">이 경고는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a4aecbf183fdb5c42584066dc8c58f74eb0df7" translate="yes" xml:space="preserve">
          <source>This warning message:</source>
          <target state="translated">이 경고 메시지 :</target>
        </trans-unit>
        <trans-unit id="f2d8282f3131ab448c2e8fe1cea01afde1138b09" translate="yes" xml:space="preserve">
          <source>This will be translated to:</source>
          <target state="translated">이것은 다음과 같이 번역됩니다 :</target>
        </trans-unit>
        <trans-unit id="67139a4dd79ac7320ecf17b1941945dc01b22766" translate="yes" xml:space="preserve">
          <source>This will generate a derived instance for &lt;code&gt;(Foo [a])&lt;/code&gt; and &lt;code&gt;(Foo (Maybe a))&lt;/code&gt;, but other types such as &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; will not be an instance of &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;(Foo [a])&lt;/code&gt; 및 &lt;code&gt;(Foo (Maybe a))&lt;/code&gt; 에 대한 파생 인스턴스를 생성 하지만 &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; 과 같은 다른 유형 은 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a8f28dc06b16f7d92df21079a2ca982f57eeedb1" translate="yes" xml:space="preserve">
          <source>This will generate code to the effect of:</source>
          <target state="translated">이렇게하면 다음과 같은 효과가있는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c07dbdd03a5f971eb5b11d111347c944fa4be0b3" translate="yes" xml:space="preserve">
          <source>This will generate the derived instance:</source>
          <target state="translated">그러면 파생 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd17e4450ac723145ea38f572707911ae4592ad5" translate="yes" xml:space="preserve">
          <source>This will not actually evaluate &lt;code&gt;[|1|]&lt;/code&gt;, but instead replace it with the &lt;code&gt;0 :: Int&lt;/code&gt; literal.</source>
          <target state="translated">이것은 실제로 &lt;code&gt;[|1|]&lt;/code&gt; 평가하지 않고 대신 &lt;code&gt;0 :: Int&lt;/code&gt; 리터럴로 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="2f9635805f734d6a6ddee1819b851b9ba1e60653" translate="yes" xml:space="preserve">
          <source>This will sometimes exit with &quot;interrupted&quot; and code 0, because the main thread is given a chance to shut down when the child thread calls safeExit. There is a race to shut down between the main and child threads.</source>
          <target state="translated">하위 스레드가 safeExit를 호출 할 때 기본 스레드가 종료 될 수 있기 때문에 때때로 &quot;중단됨&quot;및 코드 0으로 종료됩니다. 메인 스레드와 자식 스레드 사이를 종료하는 경쟁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e043ff52775ea24499678e808e45c2c181b6a4d7" translate="yes" xml:space="preserve">
          <source>This will take &lt;code&gt;1 + 1 + 3&lt;/code&gt; words (the &lt;code&gt;ThingId&lt;/code&gt; constructor + unpacked &lt;code&gt;Int&lt;/code&gt; + unpacked &lt;code&gt;ShortByteString&lt;/code&gt;), plus the words for the string data.</source>
          <target state="translated">이 소요됩니다 &lt;code&gt;1 + 1 + 3&lt;/code&gt; 단어합니다 ( &lt;code&gt;ThingId&lt;/code&gt; 생성자 + 압축을 푼 &lt;code&gt;Int&lt;/code&gt; + 압축을 푼 &lt;code&gt;ShortByteString&lt;/code&gt; 문자열 데이터), 플러스 말을.</target>
        </trans-unit>
        <trans-unit id="ffb0c676449de8bbdd669f772c381c5dd02a2d1b" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00447b8aa68db10f55c7e645117a8e9f6fffe839" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fc96ce3bb24d77dd77c6af32ec3bc111b921f5" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf6f8f26d3df6178377eb2f4bcb17017279b918" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa41044d20ae1ba84ba01e6410c48a361f0588d" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a6c139763138b599cb7bbf37ebd6c6563d7c63" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 차단 된 상태에서 파일 디스크립터가 닫히면 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 와 함께 사용 된 파일 디스크립터를 안전하게 닫으려면 closeFdWith 를 사용 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434dd08be079cc0bd5826173db52237398cf0bd7" translate="yes" xml:space="preserve">
          <source>This will yield a list containing every prefix of the word &amp;ldquo;hello&amp;rdquo; written out 5 times:</source>
          <target state="translated">이렇게하면 &quot;hello&quot;라는 단어의 모든 접두어가 5 번 쓰여진 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5b7edf0cfa8817128eb97357c0b339d3968afe03" translate="yes" xml:space="preserve">
          <source>This works even if the type of the expression is more general, provided it can be &lt;em&gt;instantiated&lt;/em&gt; to &lt;code&gt;IO a&lt;/code&gt;. For example</source>
          <target state="translated">이 식의 유형이 될 수있다 제공,보다 일반적인 경우에도 작동 &lt;em&gt;인스턴스화&lt;/em&gt; 에 &lt;code&gt;IO a&lt;/code&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="8a8c5448116287ce4d1ddb842a2e4bddd7bd26ff" translate="yes" xml:space="preserve">
          <source>This would generate the following instances:</source>
          <target state="translated">다음과 같은 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8b2e3b821f17047f04dce70c983fcb5b75e25f" translate="yes" xml:space="preserve">
          <source>Thread stacks (including the main thread&amp;rsquo;s stack) live on the heap. As the stack grows, new stack chunks are added as required; if the stack shrinks again, these extra stack chunks are reclaimed by the garbage collector. The default initial stack size is deliberately small, in order to keep the time and space overhead for thread creation to a minimum, and to make it practical to spawn threads for even tiny pieces of work.</source>
          <target state="translated">스레드 스택 (기본 스레드 스택 포함)은 힙에 존재합니다. 스택이 커짐에 따라 필요에 따라 새 스택 청크가 추가됩니다. 스택이 다시 축소되면 가비지 수집기에서 이러한 추가 스택 청크를 회수합니다. 기본 초기 스택 크기는 스레드 작성에 필요한 시간과 공간 오버 헤드를 최소화하고 작은 작업에도 스레드를 생성하는 것이 실용적 이도록 의도적으로 작습니다.</target>
        </trans-unit>
        <trans-unit id="afb01736a569cf800957c75c764e7b08e4d42882" translate="yes" xml:space="preserve">
          <source>ThreadDied</source>
          <target state="translated">ThreadDied</target>
        </trans-unit>
        <trans-unit id="b5249abe5125d8129b1f6094e27ca24e5dfd7b53" translate="yes" xml:space="preserve">
          <source>ThreadFinished</source>
          <target state="translated">ThreadFinished</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="cbacd9f0811868fee2692211c0f50253994d843c" translate="yes" xml:space="preserve">
          <source>ThreadId#</source>
          <target state="translated">ThreadId#</target>
        </trans-unit>
        <trans-unit id="210277f1f5be789fa38d99bf66d700f891a72b7b" translate="yes" xml:space="preserve">
          <source>ThreadKilled</source>
          <target state="translated">ThreadKilled</target>
        </trans-unit>
        <trans-unit id="1aacc5025242586267973269d42242e70a03c918" translate="yes" xml:space="preserve">
          <source>ThreadRunning</source>
          <target state="translated">ThreadRunning</target>
        </trans-unit>
        <trans-unit id="03539ff112c319a9993d65dc00b7fc1e80ba7832" translate="yes" xml:space="preserve">
          <source>ThreadStatus</source>
          <target state="translated">ThreadStatus</target>
        </trans-unit>
        <trans-unit id="c415b82d91d35c84fcc4655fc993abc0a3ab34c8" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca92e3299d152bebbdb5564f0db2b030aafcd93c" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 이것은 비동기 예외가 수신되기 전에 분기 된 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 생성하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a5f845685a6adcb61487ea721a7c03d396057a" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ddbb9a27e7d4b8d61317f07ad835b30faeee84" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만든 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 는 상속 &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 부모의를; 즉, &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 상태 에서 스레드를 시작 하려면 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . 비동기 예외를 수신하기 전에 분기 스레드에서 예외 처리기를 설정해야하는 경우 특히 유용합니다. 마스크되지 않은 상태에서 새 스레드를 작성하려면 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="581562d7fdd77f3436334b5a7259e674b4960049" translate="yes" xml:space="preserve">
          <source>Threads with affinity</source>
          <target state="translated">선호도가있는 스레드</target>
        </trans-unit>
        <trans-unit id="1831f9d9a0a484604033e790590c1ca2132ad8fe" translate="yes" xml:space="preserve">
          <source>Three handles are allocated during program initialisation, and are initially open.</source>
          <target state="translated">프로그램 초기화 중에 세 개의 핸들이 할당되며 처음에는 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cfb69dc1eee67ef7ef938e002c1dcccfc372df6" translate="yes" xml:space="preserve">
          <source>Three kinds of buffering are supported: line-buffering, block-buffering or no-buffering. These modes have the following effects. For output, items are written out, or &lt;em&gt;flushed&lt;/em&gt;, from the internal buffer according to the buffer mode:</source>
          <target state="translated">라인 버퍼링, 블록 버퍼링 또는 버퍼링 없음의 세 가지 버퍼링이 지원됩니다. 이 모드는 다음과 같은 효과가 있습니다. 출력 을 위해 버퍼 모드에 따라 내부 버퍼에서 항목을 쓰거나 &lt;em&gt;플러시&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="67de4025637fbb0de0ee6f5d57e06c1db2d37ad2" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if decoding fails.</source>
          <target state="translated">드로 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 를 복호가 실패하면.</target>
        </trans-unit>
        <trans-unit id="530bb7b54f06bf2237068556f8b41935da4566c0" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if encoding fails.</source>
          <target state="translated">드로 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 를 부호화가 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="a88939f2bc16a79d5911956081588d78806af274" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c86385b37440a2c4d1929356fdf6fd642b72d158" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업이 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 반환 하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5653f6b091b3b56dbab455fefe64b2589e61e727" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, but retry in case of an interrupted operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 처리하고 조작이 중단 된 경우 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="34d7cc6341315d979ebf0a280e2812fcea684005" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치가 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 을 리턴 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="79cea3439c030b18b5417d5220cf8e7402498869" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;, but retries in case of an interrupted operation.</source>
          <target state="translated">던져 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 현재의 값에 대응 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 경우 생성 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 된 액션의 결과를 반환 &lt;code&gt;-1&lt;/code&gt; 있지만 재시 인터럽트 동작시.</target>
        </trans-unit>
        <trans-unit id="4caf9e3403704122998dcd2e56f9c103bccc209c" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 액션이 &lt;code&gt;-1&lt;/code&gt; 의 결과를 반환 하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="036abf121e52aab2f60490c26b79ff2ead7c1e41" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the result value of the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action meets the given predicate.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 조치 의 결과 값이 주어진 술어를 충족하면 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="64aa8ce5d4c7d3f7f49e076896c60b8c7ef43c89" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 의 현재 값에 해당 하는 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6a07ee5048c29ff28ddf4e5f424d1fa111508ece" translate="yes" xml:space="preserve">
          <source>Throw an error when an illegal sequence is encountered</source>
          <target state="translated">잘못된 시퀀스가 ​​발생하면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="4479756108b443a98b7354d085dbc835dc21aeb8" translate="yes" xml:space="preserve">
          <source>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">예외를 던지십시오. 순전히 기능적인 코드에서 예외가 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 내에서만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="355438224b8f7cd13662d722c3e953c3cab93377" translate="yes" xml:space="preserve">
          <source>Throw an exception. Note that this throws when this action is run in the monad &lt;code&gt;m&lt;/code&gt;, not when it is applied. It is a generalization of &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9dd6f4bbcbd9abdc92b3911d6713b369a19e14" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2e15244ee40229604b0e667942ba71e6efbddfe9" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="62d516dc1db40b86d1546ce065ac2b133fff005a" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">&lt;code&gt;STM&lt;/code&gt; 에서 예외를 발생 시키면 트랜잭션이 중단되고 예외가 전파됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 를 통해 예외가 발견 되면 catch로 묶인 변경 사항 만 롤백됩니다. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 외부에서 변경 한 내용은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3c57924c9d0ac14d868ac4b1686bc50ff51630e3" translate="yes" xml:space="preserve">
          <source>Throwing and catching I/O errors</source>
          <target state="translated">I / O 오류 발생 및 포착</target>
        </trans-unit>
        <trans-unit id="7506d1dc91f2739ca014aacfd180c12f7a3cf7ce" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="translated">예외 던지기</target>
        </trans-unit>
        <trans-unit id="7f06faf78ca599a5c5c8ba7a35902fe72d473ba2" translate="yes" xml:space="preserve">
          <source>Thrown when the program attempts to call &lt;code&gt;atomically&lt;/code&gt;, from the &lt;code&gt;stm&lt;/code&gt; package, inside another call to &lt;code&gt;atomically&lt;/code&gt;.</source>
          <target state="translated">프로그램 이 &lt;code&gt;stm&lt;/code&gt; 패키지에서 &lt;code&gt;atomically&lt;/code&gt; 다른 호출 내부 에서 &lt;code&gt;atomically&lt;/code&gt; 호출하려고 할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="153488b4e16cb9e06414f6864aee37a111104fae" translate="yes" xml:space="preserve">
          <source>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</source>
          <target state="translated">런타임 시스템에서 계산이 종료되지 않는다는 것을 감지하면 발생합니다. 런타임 시스템이 주어진 계산이 종료되는지 여부를 알 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e18cad06fc314dbe98850c48826dae1e000f1a31" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;ctermid(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="63e549a9e7a930bc1cd82834decb9a2bd163ce62" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fdatasync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="b4fc88eb1e2da00b43f2c50a60cc44995e0823b9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fsync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="a9d629909206eee0dbcf9f3ef3c94be04cfef1d6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &quot;지원되지 않는 작업&quot;) 플랫폼이 제공하지 않는 경우 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e500df7fdd7f0b1291a3902735fde41700da58" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;tcdrain(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="9e328518c0ae7f5df305277a12db24a54f0d6efe" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;ctermid(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="c41ac56fe434c624b1c17bcefea186ed1bdc1b6f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fdatasync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="c4e26076fb50ee8c52870cfd73b0440602f666fd" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;fsync(2)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="12e34fcbe929eb8dbb817a0cb66109a820af381c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &quot;지원되지 않는 작업&quot;) 플랫폼이 제공하지 않는 경우 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec30f6587d00e8236ddbc556fd0ce8c29324a9f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 플랫폼이 제공하지 않는 경우 ( &quot;지원되지 않는 작업을&quot;) &lt;code&gt;tcdrain(3)&lt;/code&gt; (사용 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; 가용성을 감지하는 CPP 가드).</target>
        </trans-unit>
        <trans-unit id="da37849b4252a8c8814bc0fdc57bbfa1e662b4c6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; when the channel is empty and no other thread holds a reference to the channel.</source>
          <target state="translated">채널이 비어 있고 다른 스레드가 채널에 대한 참조를 보유하지 않으면 &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 를 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="26e7a0586580fb90b1858fbd0f15fd38c47f7010" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is the empty string or contains an equals sign.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; 이는 경우 &lt;code&gt;name&lt;/code&gt; 빈 문자열 또는 등호 기호가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ad0dcfc452814fa2ec2a379a00e78d0cb0ada8" translate="yes" xml:space="preserve">
          <source>Throws a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; if the terminfo database could not be read.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; 을 terminfo 데이터베이스를 읽을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="dc4f4955b1364895c982cfed4f338a952c52b050" translate="yes" xml:space="preserve">
          <source>Throws exceptions into the base monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="cef8354a2187206dae84b0978cfa2cac783fc184" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f4111a9574afc73ad4fb9aa2d80eb12106046f" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20ffe6f7fbe373d959e03833b11abe8e7b589cd" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7038c652bd8ef014d4a0872642e6726ba19bc5" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 에 개행 많은 요소로서 적어도 포함 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e24cd4910ef566d3177761fb96a3a2e10793cb" translate="yes" xml:space="preserve">
          <source>Thus rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">따라서 규칙은 데이터 유형 선언에도 적용됩니다. 예를 들어, &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; 있고 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우 &lt;code&gt;a&lt;/code&gt; 에 kind &lt;code&gt;k&lt;/code&gt; 가 할당됩니다 . 여기서 &lt;code&gt;k&lt;/code&gt; 는 새로운 종류 변수입니다. &lt;code&gt;k&lt;/code&gt; 는 사용자가 작성하지 않았기 때문에 생성자 &lt;code&gt;Proxy&lt;/code&gt; 의 유형에서 유형 애플리케이션에 사용할 수 없습니다 . 단지 &lt;code&gt;a&lt;/code&gt; 는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1b4b67a9b45e5176c700a1accff9ef1d36429d" translate="yes" xml:space="preserve">
          <source>Thus, a common invocation would be:</source>
          <target state="translated">따라서 일반적인 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10617fc5bcf1b09fbc9f71f965511f582f11805a" translate="yes" xml:space="preserve">
          <source>Thus, if we call &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; we will get a formatted call-stack alongside our string.</source>
          <target state="translated">따라서 &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; 을 호출하면 문자열과 함께 형식이 지정된 콜 스택이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e5c7ac32fac38f64112fb32061b44ba48e48877f" translate="yes" xml:space="preserve">
          <source>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use &lt;code&gt;App&lt;/code&gt; at a variety of kinds:</source>
          <target state="translated">따라서 종류 다형성의 주요 이점은 이제 가장 일반적인 종류를 추론 하고 다양한 종류의 &lt;code&gt;App&lt;/code&gt; 을 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="78f6be9afb4189596518c56574c13c30720db0d1" translate="yes" xml:space="preserve">
          <source>Thus, the instance triggers only when the implicit parameter to &lt;code&gt;UnEx&lt;/code&gt; matches the implicit parameter to &lt;code&gt;MkEx&lt;/code&gt;. Because &lt;code&gt;k&lt;/code&gt; is actually a parameter to &lt;code&gt;UnEx&lt;/code&gt;, the kind is not escaping the existential, and the above code is valid.</source>
          <target state="translated">따라서 &lt;code&gt;UnEx&lt;/code&gt; 에 대한 암시 적 매개 변수가 &lt;code&gt;MkEx&lt;/code&gt; 에 대한 암시 적 매개 변수와 일치하는 경우에만 인스턴스가 트리거됩니다 . &lt;code&gt;k&lt;/code&gt; 는 실제로 &lt;code&gt;UnEx&lt;/code&gt; 의 매개 변수 이기 때문에 종류가 실존 을 벗어나지 않으며 위의 코드가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="96728018a51a18d78a6c7c7a21bb29d195c725bd" translate="yes" xml:space="preserve">
          <source>TickyFlags</source>
          <target state="translated">TickyFlags</target>
        </trans-unit>
        <trans-unit id="e426b9f760c1a38c2bacbad2f64c53212cc3ffbf" translate="yes" xml:space="preserve">
          <source>Time as measured by the Earth.</source>
          <target state="translated">지구가 측정 한 시간.</target>
        </trans-unit>
        <trans-unit id="de35e180cbf98fcc51757a7d0eeb7aa8703d0daf" translate="yes" xml:space="preserve">
          <source>Time locale.</source>
          <target state="translated">시간 로캘.</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">시간</target>
        </trans-unit>
        <trans-unit id="311ad74f1246fe76fb5e13a02593b243dfa01e4b" translate="yes" xml:space="preserve">
          <source>Time of day as represented in hour, minute and second (with picoseconds), typically used to express local time of day.</source>
          <target state="translated">시간, 분 및 초로 표시되는 시간 (피코 초 포함)으로, 일반적으로 현지 시간을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="674eca31894fe11111cc9e95a912f546b20cfa4c" translate="yes" xml:space="preserve">
          <source>Time of last access in sub-second resolution.</source>
          <target state="translated">1 초 미만의 최종 액세스 시간.</target>
        </trans-unit>
        <trans-unit id="bf5b7ea4cfe40f929342452c57b6445e307ff98f" translate="yes" xml:space="preserve">
          <source>Time of last access.</source>
          <target state="translated">마지막 액세스 시간.</target>
        </trans-unit>
        <trans-unit id="dd0e25f4fa1eea55d5c7dc261f690719e80e92b5" translate="yes" xml:space="preserve">
          <source>Time of last modification in sub-second resolution.</source>
          <target state="translated">1 초 미만의 해상도에서 마지막 수정 시간.</target>
        </trans-unit>
        <trans-unit id="d3ed1832d868c8126249a2fb407fc69507dfb189" translate="yes" xml:space="preserve">
          <source>Time of last modification.</source>
          <target state="translated">마지막 수정 시간.</target>
        </trans-unit>
        <trans-unit id="8a1b24f9546d48f74a1fc1f2be79cc16e32ce4b8" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.) in sub-second resolution.</source>
          <target state="translated">1 초 미만의 해상도에서 마지막 상태 변경 시간 (예 : 소유자, 그룹, 링크 수, 모드 등)</target>
        </trans-unit>
        <trans-unit id="de40af977c44da7ce142082cfbcc26c6ffe0cb65" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.).</source>
          <target state="translated">마지막 상태 변경 시간 (예 : 소유자, 그룹, 링크 수, 모드 등)</target>
        </trans-unit>
        <trans-unit id="37cc2e4553f3b7c4572077f6ce8dcd7260d2fd48" translate="yes" xml:space="preserve">
          <source>Time values from the RTS, using a fixed resolution of nanoseconds.</source>
          <target state="translated">고정 된 나노초 분해능을 사용하는 RTS의 시간 값.</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">시간대</target>
        </trans-unit>
        <trans-unit id="3694fd8d8502573c050c12c21dfc64202808f47a" translate="yes" xml:space="preserve">
          <source>TimeExpired</source>
          <target state="translated">TimeExpired</target>
        </trans-unit>
        <trans-unit id="54ca8d2ae2173c38ac3276efe44835c04bf7b464" translate="yes" xml:space="preserve">
          <source>TimeLocale</source>
          <target state="translated">TimeLocale</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="a4208dd784207f8d84ef4fa31bd30bdd2b432c1d" translate="yes" xml:space="preserve">
          <source>TimeZone</source>
          <target state="translated">TimeZone</target>
        </trans-unit>
        <trans-unit id="30a4ddc2d1e47c72524d2ae1195d49334429ec48" translate="yes" xml:space="preserve">
          <source>TimeoutCallback</source>
          <target state="translated">TimeoutCallback</target>
        </trans-unit>
        <trans-unit id="03a9149686779469a820b3f21f5f3096edd2e773" translate="yes" xml:space="preserve">
          <source>TimeoutKey</source>
          <target state="translated">TimeoutKey</target>
        </trans-unit>
        <trans-unit id="554c6dbe0800fb90ce862ee9b17611f1be40e742" translate="yes" xml:space="preserve">
          <source>TimerManager</source>
          <target state="translated">TimerManager</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e0f0bc7f2e5196ca0e12562d2fea3c45abb35a55" translate="yes" xml:space="preserve">
          <source>TitlecaseLetter</source>
          <target state="translated">TitlecaseLetter</target>
        </trans-unit>
        <trans-unit id="2234a4a2c47c8ff0b64637496c3e6c3bfefcacba" translate="yes" xml:space="preserve">
          <source>Tix</source>
          <target state="translated">Tix</target>
        </trans-unit>
        <trans-unit id="a74eb4584cb5c18ee809ed00eb188fdec5bb579c" translate="yes" xml:space="preserve">
          <source>TixModule</source>
          <target state="translated">TixModule</target>
        </trans-unit>
        <trans-unit id="fe0563e640d1279bce1fac48bf8a1b5e02bcb7ab" translate="yes" xml:space="preserve">
          <source>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like &lt;code&gt;pthread_create&lt;/code&gt; or &lt;code&gt;CreateThread&lt;/code&gt;.</source>
          <target state="translated">외부 라이브러리의 경우 바운드 스레드는 &lt;code&gt;pthread_create&lt;/code&gt; 또는 &lt;code&gt;CreateThread&lt;/code&gt; 와 같은 OS 함수를 사용하여 작성된 일반 운영 체제 스레드와 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="ff80debaf5b64e3919c264f8e4e883f22ace9ad9" translate="yes" xml:space="preserve">
          <source>To abandon the current evaluation, use &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt;&lt;code&gt;:abandon&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 평가를 포기하려면 &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt; &lt;code&gt;:abandon&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d87be1eb54b07a48c8e89e1267bd4da7830b639e" translate="yes" xml:space="preserve">
          <source>To accumulate a value without using it on the way, see &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;.</source>
          <target state="translated">도중에 값을 사용하지 않고 값을 누적하려면 &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e5f8467c41adb6b14b429081219eab2c60a0901" translate="yes" xml:space="preserve">
          <source>To achieve these properties, in the safe language dialect we disable completely the following features:</source>
          <target state="translated">이러한 속성을 달성하기 위해 안전한 언어 방언에서 다음 기능을 완전히 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2aa92551218d14a1f44f24fb7177ce7a2bf713bc" translate="yes" xml:space="preserve">
          <source>To add modules to the scope, use ordinary Haskell &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">범위에 모듈을 추가하려면 일반적인 Haskell &lt;code&gt;import&lt;/code&gt; 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e2f3886d316e1e619156706746a8dfbb48e79115" translate="yes" xml:space="preserve">
          <source>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in &lt;code&gt;:{&lt;/code&gt; and &lt;code&gt;:}&lt;/code&gt; (each on a single line of its own):</source>
          <target state="translated">이 문제를 완화하기 위해 GHCi 명령을 &lt;code&gt;:{&lt;/code&gt; 및 &lt;code&gt;:}&lt;/code&gt; (각각 한 줄씩)으로 묶어 여러 줄로 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de30b4286a2929bfdff88d5ee52a322ecb634497" translate="yes" xml:space="preserve">
          <source>To allow for such an instance, we would have to define &lt;code&gt;(:~~:)&lt;/code&gt; as follows:</source>
          <target state="translated">이러한 인스턴스를 허용하려면 다음과 같이 &lt;code&gt;(:~~:)&lt;/code&gt; 을 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="14c677f99c3ebfb083d5ba45347b3df00c07e009" translate="yes" xml:space="preserve">
          <source>To also set the directory in which to run &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 를 실행할 디렉토리를 설정하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ef0b5766dccbebaac045d8e4e6bded46db835a3" translate="yes" xml:space="preserve">
          <source>To always compile everything to object code and never use the interpreter, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;#ghci-obj&quot;&gt;Compiling to object code inside GHCi&lt;/a&gt;).</source>
          <target state="translated">항상 모든 것을 객체 코드로 컴파일하고 인터프리터를 사용하지 않으려면 &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 ( GHCi&lt;a href=&quot;#ghci-obj&quot;&gt; 내에서 객체 코드로 컴파일&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5df8df6d3cdb1b8cf45eb7ff8b8e9438a9330317" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종류와 종류의 중복을 피하기 위해 동일하게 정의됩니다. 당연히 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 이고 절대 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 가 아니지만 다른 생성자가 많이 공유됩니다. 종류 있습니다 &lt;code&gt;Bool&lt;/code&gt; 로 표시되어 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 하지 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . 마찬가지로 튜플 종류는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 로 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="9bbefb7d7331de5a028c9b6fdc70e6d980c4f650" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">종류와 종류의 중복을 피하기 위해 동일하게 정의됩니다. 당연히 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 이고 절대 유형이 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 가 아니지만 다른 생성자가 많이 공유됩니다. 종류 있습니다 &lt;code&gt;Bool&lt;/code&gt; 로 표시되어 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 하지 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . 마찬가지로 튜플 종류는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 가 아닌 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 로 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="b6771efdf3a686f294db18bd2d14bac4e3dba651" translate="yes" xml:space="preserve">
          <source>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: &lt;code&gt;-ohi /dev/null&lt;/code&gt;, for example.</source>
          <target state="translated">인터페이스를 전혀 생성하지 않으려면이 옵션을 사용하여 인터페이스를 비트 버킷으로 리디렉션 할 수 있습니다 ( 예 : &lt;code&gt;-ohi /dev/null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7aaccb0bd8d229ee1d19d9e75f8795d4cf2370af" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">미묘한 코딩 오류를 방지하려면, 손으로 쓴 마샬링 코드는 바람직하게 사용해야합니다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 을 오히려 조합보다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . 그러나 후자의 루틴은 도구 생성 마샬링 코드에서 선호되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa34733b5e19e7e6a87e5c91b392ff0b0780aa0b" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">미묘한 코딩 오류를 방지하려면, 손으로 쓴 마샬링 코드는 바람직하게 사용해야합니다 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 을 오히려 조합보다 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . 그러나 후자의 루틴은 도구 생성 마샬링 코드에서 선호되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b35e7282d157dcf47660cd59431c4a8fca882cba" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 문제를 피하려면 대신 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93dbcc0e48dafb4a864c6c8fc82578cf9d42f26f" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 문제를 피하려면, 대신 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d32eef552977a76650b6db7fd84bb68cb4c9bdee" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;&lt;a href=&quot;ghc-exts#v:resizeSmallMutableArray-35-&quot;&gt;resizeSmallMutableArray#&lt;/a&gt;&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; in case a new &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; had to be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c0704d5dd80ea4a49e31c8c21b3410ffa34f67" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;MutableByteArray#&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;MutableByteArray#&lt;/code&gt; in case a new &lt;code&gt;MutableByteArray#&lt;/code&gt; had to be allocated.</source>
          <target state="translated">정의되지 않은 동작을 피하기 위해 &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; 가 수행 된 후에는 원래 &lt;code&gt;MutableByteArray#&lt;/code&gt; 더 이상 액세스 할 수 없습니다 . 또한 새 &lt;code&gt;MutableByteArray#&lt;/code&gt; 를 할당 해야하는 경우 원래 &lt;code&gt;MutableByteArray#&lt;/code&gt; 의 가비지 수집을 허용하기 위해 이전 항목을 참조하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d67bfc1538ab33d21305009ebcc630714c1858" translate="yes" xml:space="preserve">
          <source>To be precise, if the class being derived is of the form</source>
          <target state="translated">정확하게 말하면 파생 클래스가 다음 형식 인 경우</target>
        </trans-unit>
        <trans-unit id="c0d9f8d6315eb7cbdcbf50a9f874b3aee61aa5d5" translate="yes" xml:space="preserve">
          <source>To be precise, the annotation &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; is well staged if and only if &lt;code&gt;$(e)&lt;/code&gt; would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - &lt;code&gt;$([|1|])&lt;/code&gt; is fine as an annotation, albeit redundant).</source>
          <target state="translated">정확하게 말하면, &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; 주석은 &lt;code&gt;$(e)&lt;/code&gt; 가 될 경우에만 잘 준비됩니다. (접합 구문의 일반적인 유형 제한과 접합 내부의 접합에 대한 일반적인 제한을 무시합니다- &lt;code&gt;$([|1|])&lt;/code&gt; 은 주석으로도 사용 가능하지만 중복적임).</target>
        </trans-unit>
        <trans-unit id="28876308b2232e888282a46a9f2647185f20da23" translate="yes" xml:space="preserve">
          <source>To build Haskell modules that export a C API into a shared library use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">C API를 공유 라이브러리로 내보내는 Haskell 모듈을 빌드하려면 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99edfbf2248bb2a627dfdcc360ffdb881b08cb4d" translate="yes" xml:space="preserve">
          <source>To build a simple program and have it use shared libraries for the runtime system and the base libraries use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">간단한 프로그램을 빌드하고 런타임 시스템 및 공유 라이브러리를위한 공유 라이브러리를 사용하려면 &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="007ba52a2d8fb965e0b5df4e486442e39607c309" translate="yes" xml:space="preserve">
          <source>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">패턴 동의어를 형식 생성자와 번들로 묶기 위해 형식 생성자를 내보내는 모듈의 내보내기 목록에 패턴 동의어를 나열합니다. 예를 들어, &lt;code&gt;Zero&lt;/code&gt; 를 &lt;code&gt;MyNum&lt;/code&gt; 과 번들로 제공하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5aae458adadd6ea36810e5833a7811c73bd6831" translate="yes" xml:space="preserve">
          <source>To check whether your &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; setting is doing the right thing, &lt;code&gt;ghc-pkg list&lt;/code&gt; will list all the databases in use, in the reverse order they are searched.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 설정이 올바른지 확인하기 위해 &lt;code&gt;ghc-pkg list&lt;/code&gt; 는 사용중인 모든 데이터베이스를 검색된 순서와 반대로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d99b230674f283901189e80464c11bff12827985" translate="yes" xml:space="preserve">
          <source>To compile a module which is to be part of a new package, use the &lt;code&gt;-package-name&lt;/code&gt; (to identify the name of the package) and &lt;code&gt;-library-name&lt;/code&gt; (to identify the version and the version hashes of its identities.) options (&lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the &lt;code&gt;.hi&lt;/code&gt; file.</source>
          <target state="translated">새 패키지의 일부가 될 모듈을 컴파일하려면 &lt;code&gt;-package-name&lt;/code&gt; (패키지 이름 식별) 및 &lt;code&gt;-library-name&lt;/code&gt; (버전 및 해당 버전의 버전 해시 식별) 옵션 ( &lt;a href=&quot;#using-packages&quot;&gt;패키지 사용&lt;/a&gt; ). 패키지를 컴파일 할 때 이러한 옵션을 사용하지 않으면 재난이 발생할 수 있지만 나중에 패키지에서 모듈을 가져 오려고 할 때만 발견됩니다. 이 시점에서 GHC는 모듈에서 오는 패키지 이름이 &lt;code&gt;.hi&lt;/code&gt; 파일에 저장된 패키지 이름과 동일하지 않다고 불평 합니다.</target>
        </trans-unit>
        <trans-unit id="12fd6ddf28c5285fa1983ff47d370bb4e33b05da" translate="yes" xml:space="preserve">
          <source>To compile the program, use GHC like this:</source>
          <target state="translated">프로그램을 컴파일하려면 다음과 같이 GHC를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="485c5e401e6a134f4abe73897df6824e3409a20e" translate="yes" xml:space="preserve">
          <source>To compile these three files, issue the following commands:</source>
          <target state="translated">이 세 파일을 컴파일하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8a91e9bb879d47c785fc61c253926f7398d2eae9" translate="yes" xml:space="preserve">
          <source>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword. The pragma may be one of: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt;, or &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt;.</source>
          <target state="translated">인스턴스 선택을 제어하기 위해 &lt;code&gt;instance&lt;/code&gt; 키워드 바로 뒤에 쓰여진 pragma를 사용하여 개별 인스턴스에 대한 오버랩 동작을 지정할 수 있습니다 . pragma는 &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt; 또는 &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc0d1e2f710041d917fa9128128d16f4e0b579c" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt;, use the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 으로 변환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1c0964746ae7b2a2f00992a848001548495aecef" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="5d067decf6925ff18738730cccec299d546abf35" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="fea7f792e37393718cca4a9b6921cb08aba10fa5" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 값을 해당 Haskell 함수 로 변환 하기 위해 특정 외부 유형에 대한 &lt;em&gt;동적&lt;/em&gt; 스텁을 정의 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="2acaa5dea000cc74154c0f402c3febbfb83f1a58" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="786657e4c88a725db3968f98b13dce85d65db23b" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="d7130a3be670709f03cd81a58cb2b61282e0d6dd" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 유니 코드로 정의 된 해당 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값으로 변환 하거나 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 각각 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 (또는 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="13a465a9773b015ffc884872ada910d6f797abb7" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; 에서 변환하려면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3196791a7a1592e7daa80285f0558ede2e0d6d" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; 에서 변환하려면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1659f84a77c9a2443a59423cc658f61a338f3abe" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩이 전혀없는 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 만들려면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 기존 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 추가 인코딩 또는 디코딩을 중지하려면 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f153e244215130d9c4edb53cdcbba15630d42840" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인코딩이 전혀없는 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 만들려면 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 사용 하십시오 . 기존 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 추가 인코딩 또는 디코딩을 중지하려면 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1171deb859f0f29f6aacadc46ea52378fb28f5f8" translate="yes" xml:space="preserve">
          <source>To create a pipe from which to read the output of &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 의 출력을 읽을 파이프를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="96af4537bfd12fadb83763899a123cc096a36017" translate="yes" xml:space="preserve">
          <source>To define the &lt;code&gt;item&lt;/code&gt; parser, we need to lift the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; operations through the &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 파서 를 정의하려면 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 변환기를 통해 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 작업 을 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61b1e6de56b01e5140d8cba3ed36c3acb9b257dc" translate="yes" xml:space="preserve">
          <source>To delete a breakpoint, use the &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt;&lt;code&gt;:delete&lt;/code&gt;&lt;/a&gt; command with the number given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">중단 점을 삭제하려면 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; 의 출력에 제공된 번호와 함께 &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt; &lt;code&gt;:delete&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea8e294886bade8bd7cc5b83aa9ec115d1403bbc" translate="yes" xml:space="preserve">
          <source>To delete all breakpoints at once, use &lt;code&gt;:delete *&lt;/code&gt;.</source>
          <target state="translated">모든 중단 점을 한 번에 &lt;code&gt;:delete *&lt;/code&gt; 하려면 : delete *를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="20c69ea8d7a8119ee63218b8c507949aacadde61" translate="yes" xml:space="preserve">
          <source>To derive &lt;code&gt;Eq&lt;/code&gt; in the standard way we would need to have equality between the single component of two &lt;code&gt;MkT&lt;/code&gt; constructors:</source>
          <target state="translated">표준 방식으로 &lt;code&gt;Eq&lt;/code&gt; 를 도출하려면 두 &lt;code&gt;MkT&lt;/code&gt; 생성자 의 단일 구성 요소간에 동등성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f0219713c4b957a1c6e5e311515abfddd97e7be" translate="yes" xml:space="preserve">
          <source>To disable one or several defined breakpoint, use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command with one or several blank separated numbers given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:. To disable all breakpoints at once, use &lt;code&gt;:disable *&lt;/code&gt;.</source>
          <target state="translated">하나 또는 여러 개의 정의 된 중단 점을 비활성화하려면 &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; : 의 출력에 주어진 하나 또는 여러 개의 공백으로 구분 된 숫자와 함께 &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 . 모든 중단 점을 한 번에 &lt;code&gt;:disable *&lt;/code&gt; 하려면 : disable *을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9be5e62141d987ac491830af48130b4bb8a0121e" translate="yes" xml:space="preserve">
          <source>To examine one of the steps in the history, use &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">히스토리의 단계 중 하나를 검사하려면 &lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="66eef0e4ec6c04a45dd59938c23022bba82ff967" translate="yes" xml:space="preserve">
          <source>To export them on their own, in an export or import specification, you must prefix pattern names with the &lt;code&gt;pattern&lt;/code&gt; keyword, e.g.:</source>
          <target state="translated">내보내기 또는 가져 오기 스펙에서 자체적으로 내보내려면 패턴 이름 앞에 &lt;code&gt;pattern&lt;/code&gt; 키워드를 접두어로 붙여야 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="059e3de99f2d80caf2d89e7201f6c7c557017928" translate="yes" xml:space="preserve">
          <source>To figure out what exactly they do, the least bad way is to grep the rts/ directory in the ghc code for macros like &lt;code&gt;DEBUG(scheduler&lt;/code&gt; or &lt;code&gt;DEBUG_scheduler&lt;/code&gt;.</source>
          <target state="translated">정확히 무엇을하는지 알아 내려면 가장 나쁜 방법은 &lt;code&gt;DEBUG(scheduler&lt;/code&gt; 또는 &lt;code&gt;DEBUG_scheduler&lt;/code&gt; 와 같은 매크로에 대해 ghc 코드에서 rts / 디렉토리를 grep하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="373832b60bccf6816963a2a722042fdc637fe0c9" translate="yes" xml:space="preserve">
          <source>To figure out which part of the compiler is badly behaved, the &lt;code&gt;-v2&lt;/code&gt; option is your friend.</source>
          <target state="translated">컴파일러의 어느 부분이 잘못 작동하는지 파악하려면 &lt;code&gt;-v2&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="617e8f413888e2a59390516c4594fefa6467d4c8" translate="yes" xml:space="preserve">
          <source>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use &lt;code&gt;cabal-install&lt;/code&gt;, or download the packages from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; and build and install them as normal.</source>
          <target state="translated">문제를 해결하려면 새 종속성에 대해 손상된 패키지를 다시 컴파일해야합니다. 가장 쉬운 방법 은 &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;cabal &lt;/a&gt; &lt;code&gt;cabal-install&lt;/code&gt; 을 사용 하거나 HackageDB 에서 패키지를 다운로드하여 정상적으로 빌드하고 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1fadbae3a14577a0f008fefc32f335b95527ef3" translate="yes" xml:space="preserve">
          <source>To further explain this example, the right-hand side of the default type signature for &lt;code&gt;bar&lt;/code&gt; must be something that is alpha-equivalent to &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (where &lt;code&gt;a&lt;/code&gt; is bound by the class itself, and is thus free in the methods&amp;rsquo; type signatures). So this would also be an acceptable default type signature:</source>
          <target state="translated">이 예제를 자세히 설명하려면 &lt;code&gt;bar&lt;/code&gt; 에 대한 기본 유형 서명의 오른쪽 이 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 와 알파벳과 같아야합니다 . a-&amp;gt; b-&amp;gt; b (여기서 &lt;code&gt;a&lt;/code&gt; 는 클래스 자체에 의해 바인딩되므로 메소드의 유형 시그니처에서 자유 롭습니다). 따라서 이것은 허용되는 기본 유형 서명이기도합니다.</target>
        </trans-unit>
        <trans-unit id="1e54d546d02ad4863886b9ee73d1e131e1c71a9f" translate="yes" xml:space="preserve">
          <source>To gain access to a much larger family of encodings, use the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">훨씬 더 큰 인코딩 제품군에 액세스하려면 &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7552595f3e9f52aba2ce1ac4224b4fd08998d77" translate="yes" xml:space="preserve">
          <source>To generate a heap profile from your program:</source>
          <target state="translated">프로그램에서 힙 프로파일을 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5c213d8e1ad0bf625f6921a8437f98eeb3f4a1b0" translate="yes" xml:space="preserve">
          <source>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between &lt;code&gt;+RTS ... -RTS&lt;/code&gt; as usual):</source>
          <target state="translated">시간 및 할당 프로파일을 생성하려면 컴파일 할 때 다음 RTS 옵션 중 하나를 컴파일 된 프로그램에 제공하십시오 (RTS 옵션은 평소와 같이 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 사이에 포함되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="34cea9b35b2bfd8b0bd668c0b07e2825a95e1c3d" translate="yes" xml:space="preserve">
          <source>To get a list of the bindings currently in scope, use the &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt;&lt;code&gt;:show bindings&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">현재 범위 내에있는 바인딩 목록을 가져 오려면 &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt; &lt;code&gt;:show bindings&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="584aacfb52fdd9de92b4db69f120bc255bd58b9a" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">보다 유용한 &lt;code&gt;Collects&lt;/code&gt; 클래스 버전을 얻기 위해 GHC는 프로그래머가 여러 매개 변수 클래스의 매개 변수 사이의 종속성을 지정할 수있는 메커니즘을 제공합니다 (이론적 기초 및 이전 연구에 관심이있는 독자의 경우 : 종속성 정보의 사용을 볼 수 있음) Chen, Hudak 및 Odersky가 제시 한 &quot;매개 변수 유형 클래스&quot;제안의 일반화 또는 자격이있는 유형의 &quot;개선&quot;을위한 Mark Jones의 후일 프레임 워크의 특별한 사례로 사용됩니다. 원고에서보다 이론적이고 추상적 인 설정 &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;여기서 암시 적 매개 변수화 시스템을위한 일반 설계 공간에서 한 지점으로 식별됩니다. 추상 예제로 시작하려면 다음과 같은 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3b643a5f53fe92a51d4d6cc04833d6658ab9e142" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">&lt;code&gt;Collects&lt;/code&gt; 클래스 의보다 유용한 버전을 얻기 위해 GHC는 프로그래머가 다중 매개 변수 클래스의 매개 변수 간의 종속성을 지정할 수있는 메커니즘을 제공합니다 (이론적 기초 및 이전 작업에 관심이있는 독자를 위해 : 종속성 정보의 사용을 볼 수 있습니다. Chen, Hudak 및 Odersky가 제안한 &quot;파라 메트릭 유형 클래스&quot;에 대한 제안의 일반화 또는 정규화 된 유형의 &quot;개선&quot;을위한 Mark Jones의 이후 프레임 워크의 특수 사례로서의 기본 아이디어도 다음에서 논의됩니다. &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt; [Jones1999]&lt;/a&gt;묵시적 매개 변수화 시스템을위한 일반적인 디자인 공간의 한 지점으로 식별 되는 원고의 더 이론적이고 추상적 인 설정 ). 추상적 인 예제로 시작하려면 다음과 같은 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2dd4283dabd7adbbf3b3fa6217759a91e02bf006" translate="yes" xml:space="preserve">
          <source>To get better errors, it is recommended to use #line pragmas when emitting C files, e.g.</source>
          <target state="translated">더 나은 오류를 얻으려면 C 파일을 내보낼 때 #line pragma를 사용하는 것이 좋습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="c4c508962468a9bf469857dfae6ad15a1e12b86c" translate="yes" xml:space="preserve">
          <source>To get maximum performance when building lazy &lt;code&gt;Text&lt;/code&gt; values using a builder, associate &lt;code&gt;mappend&lt;/code&gt; calls to the right. For example, prefer</source>
          <target state="translated">빌더를 사용하여 지연 &lt;code&gt;Text&lt;/code&gt; 값을 빌드 할 때 최대 성능을 얻으려면 &lt;code&gt;mappend&lt;/code&gt; 호출을 오른쪽으로 연관 시키십시오 . 예를 들어 선호</target>
        </trans-unit>
        <trans-unit id="e54b5b21677328842d1e9a6b9afb2745752f58b5" translate="yes" xml:space="preserve">
          <source>To get the annotations of a single binder, you can use &lt;code&gt;getAnnotations&lt;/code&gt; and specify the proper type. Here&amp;rsquo;s an example that will print out the name of any top-level non-recursive binding with the &lt;code&gt;SomeAnn&lt;/code&gt; annotation:</source>
          <target state="translated">단일 바인더의 주석을 얻으려면 &lt;code&gt;getAnnotations&lt;/code&gt; 를 사용하고 적절한 유형을 지정하십시오. 다음은 &lt;code&gt;SomeAnn&lt;/code&gt; 주석을 사용하여 최상위 비 재귀 바인딩의 이름을 인쇄하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="427028b92998e9d2972ad20dfdc92870e2d3c450" translate="yes" xml:space="preserve">
          <source>To help understand the use of these functions, consider the Unicode string &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt;. If encoded as UTF-8, this becomes &lt;code&gt;&quot;hi
 \xe2\x98\x83&quot;&lt;/code&gt;; the final &lt;code&gt;'☃'&lt;/code&gt; is encoded as 3 bytes.</source>
          <target state="translated">이러한 기능의 사용을 이해하려면 유니 코드 문자열 &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt; 을 고려하십시오 . UTF-8로 인코딩 된 경우 &lt;code&gt;&quot;hi \xe2\x98\x83&quot;&lt;/code&gt; . 마지막 &lt;code&gt;'☃'&lt;/code&gt; 은 3 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="99872510dc191d4452db56bf22957570e23b92b9" translate="yes" xml:space="preserve">
          <source>To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into &lt;code&gt;Main.hs&lt;/code&gt; and &lt;code&gt;Printf.hs&lt;/code&gt;:</source>
          <target state="translated">자신감의 장벽을 극복 할 수 있도록이 골격 작동 예제를 사용해보십시오. 먼저 아래 두 모듈을 잘라 &lt;code&gt;Main.hs&lt;/code&gt; 및 &lt;code&gt;Printf.hs&lt;/code&gt; 에 붙여 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="48b1aabf0c4a191f672c0b44cca67c4f38a6d577" translate="yes" xml:space="preserve">
          <source>To hopefully illuminate the role of the different data structures, here are the command-line options for a (very simple) compiler, done in two different ways. The difference arises because the type of &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; is parameterized by the type of values derived from flags.</source>
          <target state="translated">다른 데이터 구조의 역할을 희망적으로 밝히기 위해 두 가지 다른 방식으로 수행되는 (매우 간단한) 컴파일러의 명령 행 옵션이 있습니다. &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 의 유형이 플래그에서 파생 된 값의 유형으로 매개 변수화 되기 때문에 차이가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="d8ae72f545b1ce82b2cfe09ab991783beb655542" translate="yes" xml:space="preserve">
          <source>To implement &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findLast&lt;/code&gt; on any &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;find&lt;/code&gt; 또는 &lt;code&gt;findLast&lt;/code&gt; 를 구현하려면 다음을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="458751b9fab299d8f4e8789e1128f4827ef9c961" translate="yes" xml:space="preserve">
          <source>To import a qualified module usually you must specify &lt;code&gt;qualified&lt;/code&gt; in prepositive position : &lt;code&gt;import qualified M&lt;/code&gt;. This often leads to a &amp;ldquo;hanging indent&amp;rdquo; (which is automatically inserted by some autoformatters and common in many code bases. For example:</source>
          <target state="translated">자격을 갖춘 모듈을 가져 오려면 보통 지정해야 &lt;code&gt;qualified&lt;/code&gt; 전치 위치 : &lt;code&gt;import qualified M&lt;/code&gt; . 이로 인해 종종 &quot;내어 쓰기&quot;가 발생합니다 (일부 자동 서식 지정 도구에 의해 자동으로 삽입되고 많은 코드베이스에서 일반적입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2c7c52e770ffa8a6b97378d2c5e459f4d2e43a4e" translate="yes" xml:space="preserve">
          <source>To install LLVM and Clang:</source>
          <target state="translated">LLVM 및 Clang을 설치하려면</target>
        </trans-unit>
        <trans-unit id="f4755fa59e195e04ee11ff89504edf74eae51201" translate="yes" xml:space="preserve">
          <source>To invoke &lt;code&gt;foo()&lt;/code&gt; from C, just &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; and call &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">C에서 &lt;code&gt;foo()&lt;/code&gt; 를 호출하려면 &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; 와 &lt;code&gt;foo()&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="67c620f61de0b4e8243389340a761b127a5420c3" translate="yes" xml:space="preserve">
          <source>To learn more about this decision and the design of GHC under the hood please see the &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;paper&lt;/a&gt; introducing this kind system to GHC/Haskell.</source>
          <target state="translated">이 결정 및 GHC 디자인에 대한 자세한 내용은 이러한 종류의 시스템을 GHC / Haskell에 소개 하는 &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aae76ecf649e9d0d8a82065b74e94e13fc57f2d4" translate="yes" xml:space="preserve">
          <source>To load a Haskell source file into GHCi, use the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Haskell 소스 파일을 GHCi에 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 하려면 : load 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="84282ca7b4af31d8f72f41e5b0309bfeef77e8b2" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">패키지 &lt;code&gt;foo&lt;/code&gt; 를로드하기 위해 &lt;code&gt;libHSfoo.a&lt;/code&gt; 는 libHSfoo.a 라이브러리를 직접로드 할 수 있지만, 사전 링크 된 단일 &lt;code&gt;HSfoo.o&lt;/code&gt; 파일 형식으로 패키지를로드 할 수도 있습니다. &lt;code&gt;.o&lt;/code&gt; 파일을 로드하는 것은 약간 빠르지 만 컴파일 된 패키지의 다른 사본이 필요합니다. 경험상 패키지의 모듈이 &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 경우 패키지를 GHCi에로드 할 때 시간이 절약되므로 &lt;code&gt;HSfoo.o&lt;/code&gt; 를 작성하는 것이 좋습니다. 없이 &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; , 사이로드 시간에 큰 차이가없는 &lt;code&gt;.o&lt;/code&gt; 인 과 &lt;code&gt;.a&lt;/code&gt; 는 디스크 공간을 절약 만 유지하는 것이 좋습니다 그래서 라이브러리는, &lt;code&gt;.a&lt;/code&gt; 주변. GHC 배포판 에서는 GHC 패키지 자체를 제외한 대부분의 패키지에 &lt;code&gt;.o&lt;/code&gt; 파일을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ab99b40605f7da9e4eebad8eb504404bd0faa1f0" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">패키지 &lt;code&gt;foo&lt;/code&gt; 를로드하기 위해 &lt;code&gt;libHSfoo.a&lt;/code&gt; 는 libHSfoo.a 라이브러리를 직접로드 할 수 있지만 사전 링크 된 단일 &lt;code&gt;HSfoo.o&lt;/code&gt; 파일 형식으로 패키지를로드 할 수도 있습니다. &lt;code&gt;.o&lt;/code&gt; 파일을 로드하는 것이 약간 더 빠르지 만 컴파일 된 패키지의 다른 사본이 필요합니다. 경험상 패키지의 모듈이 &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt; 로 컴파일 된 경우 &lt;code&gt;HSfoo.o&lt;/code&gt; 를 빌드하면 GHCi 로 패키지를로드 할 때 시간을 절약 할 수 있으므로 가치가 있습니다. 없이 &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt; &lt;code&gt;-split-sections&lt;/code&gt; &lt;/a&gt; , 사이로드 시간에 큰 차이가없는 &lt;code&gt;.o&lt;/code&gt; 인 및 &lt;code&gt;.a&lt;/code&gt; 라이브러리이므로 디스크 공간을 절약하고 &lt;code&gt;.a&lt;/code&gt; 만 유지하는 것이 좋습니다 . GHC 배포판 에서는 GHC 패키지 자체를 제외한 대부분의 패키지에 대해 &lt;code&gt;.o&lt;/code&gt; 파일을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="d2e3260144403e14ad423568ae3ce8f12c1a164c" translate="yes" xml:space="preserve">
          <source>To make an executable program, the GHC system compiles your code and then links it with a non-trivial runtime system (RTS), which handles storage management, thread scheduling, profiling, and so on.</source>
          <target state="translated">실행 가능한 프로그램을 만들기 위해 GHC 시스템은 코드를 컴파일 한 다음 스토리지 관리, 스레드 스케줄링, 프로파일 링 등을 처리하는 사소한 런타임 시스템 (RTS)과 코드를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="409b50b71b1cf04f14989a6bebb5d1b08c15a045" translate="yes" xml:space="preserve">
          <source>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit &lt;code&gt;import qualified&lt;/code&gt; declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; flag.</source>
          <target state="translated">GHCi 프롬프트는 약간의 편의성을 높이기 위해 모든 패키지의 모든 모듈과 현재 GHCi에로드 된 모든 모듈에 대해 내재 된 &lt;code&gt;import qualified&lt;/code&gt; 선언 이있는 것처럼 작동합니다 . 이 동작은 &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; 플래그 로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3811e1546e787ed220aa8285f2fd305ece22386" translate="yes" xml:space="preserve">
          <source>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; language extension. A deriving strategy can be specified in a deriving clause</source>
          <target state="translated">이를 더욱 강력하게하기 위해 GHC에는 파생 전략이라는 개념이 있으며,이를 통해 사용자는 인스턴스를 파생시킬 때 사용할 접근 방식을 명시 적으로 요청할 수 있습니다. 이 기능을 활성화하려면 &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; 언어 확장을 활성화해야합니다 . 파생 전략에 파생 전략을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b64615441fb8a751e6636d849ab82db0727aa6e0" translate="yes" xml:space="preserve">
          <source>To make use of the profiling system &lt;em&gt;all&lt;/em&gt; modules must be compiled and linked with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option. Any &lt;code&gt;SCC&lt;/code&gt; annotations you&amp;rsquo;ve put in your source will spring to life.</source>
          <target state="translated">프로파일 링 시스템을 사용하려면 &lt;em&gt;모든&lt;/em&gt; 모듈을 컴파일하고 &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; 옵션 과 연결해야합니다 . 모든 &lt;code&gt;SCC&lt;/code&gt; 의 당신이 당신의 소스에 넣어 한 주석 생활에 봄 것입니다.</target>
        </trans-unit>
        <trans-unit id="cadd792349a4de388974151ed3334973779b0aae" translate="yes" xml:space="preserve">
          <source>To make use of these hidden fields, we need to create some helper functions:</source>
          <target state="translated">이러한 숨겨진 필드를 사용하려면 도우미 함수를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a354e65731baf61d210fdcef00d7fcaebe03d2c" translate="yes" xml:space="preserve">
          <source>To provide more control over the compiler&amp;rsquo;s verbosity, the &lt;code&gt;-v&lt;/code&gt; flag takes an optional numeric argument. Specifying &lt;code&gt;-v&lt;/code&gt; on its own is equivalent to &lt;code&gt;-v3&lt;/code&gt;, and the other levels have the following meanings:</source>
          <target state="translated">컴파일러의 세부 정보를보다 강력하게 제어하기 위해 &lt;code&gt;-v&lt;/code&gt; 플래그는 선택적 숫자 인수를 사용합니다. &lt;code&gt;-v&lt;/code&gt; 자체를 지정 하는 것은 &lt;code&gt;-v3&lt;/code&gt; 과 동일 하며 다른 레벨은 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e09a1d373d13bfd1fe833239f80a4362b6548f69" translate="yes" xml:space="preserve">
          <source>To recover after an exception and do something else, the best choice is to use one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; family.</source>
          <target state="translated">예외 후에 복구하고 다른 작업을 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 제품군 중 하나를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="14e26ca731fed1a65d734c4805ba32c05da97880" translate="yes" xml:space="preserve">
          <source>To remove an existing directory symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 디렉토리 기호 링크를 제거하려면 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. .</target>
        </trans-unit>
        <trans-unit id="902b5e7fc39d15c95b3964399bd08b53ff7a117f" translate="yes" xml:space="preserve">
          <source>To remove an existing file symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 파일 기호 링크를 제거하려면 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. .</target>
        </trans-unit>
        <trans-unit id="0eb5610465d9a35f189f4445a996d1ae11b587c8" translate="yes" xml:space="preserve">
          <source>To safely use this API you must either extract the list of vertices directly from the graph or first call &lt;code&gt;vertexFromKey k&lt;/code&gt; to check if a vertex corresponds to the key &lt;code&gt;k&lt;/code&gt;. Once it is known that a vertex exists you can use &lt;code&gt;nodeFromVertex&lt;/code&gt; to access the labelled node and adjacent vertices. See below for examples.</source>
          <target state="translated">이 API를 안전하게 사용하려면 그래프에서 직접 정점 목록을 추출하거나 &lt;code&gt;vertexFromKey k&lt;/code&gt; 를 먼저 호출 하여 정점이 키 &lt;code&gt;k&lt;/code&gt; 에 해당하는지 확인해야합니다 . 정점이 존재하는 것으로 알려진 후에는 &lt;code&gt;nodeFromVertex&lt;/code&gt; 를 사용할 수 있습니다 를 사용하여 레이블이 지정된 노드 및 인접한 정점에 액세스 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e1113a1ceca8ac3b9f3aacd5ed4c7c86f2fc6d" translate="yes" xml:space="preserve">
          <source>To see whether you&amp;rsquo;re making good use of all the memory reseverd for the allocation area (&lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;), look at the output of &lt;code&gt;+RTS -S&lt;/code&gt; and check whether the amount of memory allocated between GCs is equal to &lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;. If not, there are two possible remedies: use &lt;code&gt;-n&lt;/code&gt; to set a nursery chunk size, or use &lt;code&gt;-AL&lt;/code&gt; to increase the limit for large objects.</source>
          <target state="translated">당신이 (할당 영역에 대한 모든 메모리 reseverd 잘 활용하고 있는지 여부를 확인하려면 &lt;code&gt;-A&lt;/code&gt; 의 시간이 &lt;code&gt;-N&lt;/code&gt; 의 출력에서) 살펴 &lt;code&gt;+RTS -S&lt;/code&gt; 와 GC를 사이에 할당 된 메모리의 양이 같은지 여부를 확인 &lt;code&gt;-A&lt;/code&gt; 시간 &lt;code&gt;-N&lt;/code&gt; . 그렇지 않은 경우 두 가지 가능한 해결 방법이 있습니다. &lt;code&gt;-n&lt;/code&gt; 을 사용하여 보육 청크 크기를 설정하거나 &lt;code&gt;-AL&lt;/code&gt; 을 사용 하여 큰 오브젝트의 한계를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="7f2b1743b3c15e52d49c7a46f47317e7b211afa8" translate="yes" xml:space="preserve">
          <source>To see which modules are provided by a package use the &lt;code&gt;ghc-pkg&lt;/code&gt; command (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;):</source>
          <target state="translated">패키지에서 제공하는 모듈을 확인하려면 &lt;code&gt;ghc-pkg&lt;/code&gt; 명령을 사용 하십시오 ( &lt;a href=&quot;#package-management&quot;&gt;패키지 관리 (ghc-pkg 명령) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d20768e5351c559b7b7519dd0d6001dcac049eb" translate="yes" xml:space="preserve">
          <source>To see which packages are currently available, use the &lt;code&gt;ghc-pkg list&lt;/code&gt; command:</source>
          <target state="translated">현재 사용 가능한 패키지를 확인하려면 &lt;code&gt;ghc-pkg list&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a70566dabf5a41f2019632020db79dab54902519" translate="yes" xml:space="preserve">
          <source>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived &lt;code&gt;Functor&lt;/code&gt; instance, let&amp;rsquo;s suppose that a &lt;code&gt;Functor ContraFun1&lt;/code&gt; instance exists. The implementation would look something like this:</source>
          <target state="translated">마지막 유형 매개 변수의 반 변형이있는 데이터 유형이 파생 된 &lt;code&gt;Functor&lt;/code&gt; 인스턴스를 가질 수없는 이유를 확인하려면 &lt;code&gt;Functor ContraFun1&lt;/code&gt; 이라고 가정 하십시오. 인스턴스가 . 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dd1e599c7b99d0ef6415d16c2b63820670b8ef4" translate="yes" xml:space="preserve">
          <source>To serialise a custom type, an instance of Binary for that type is required. For example, suppose we have a data structure:</source>
          <target state="translated">사용자 정의 유형을 직렬화하려면 해당 유형의 이진 인스턴스가 필요합니다. 예를 들어, 데이터 구조가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ec5ac163ebb0f97a307be294a6581754c5f32393" translate="yes" xml:space="preserve">
          <source>To serialise this to a bytestring, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;, which packs the data structure into a binary format, in a lazy bytestring</source>
          <target state="translated">이것을 바이트 문자열로 직렬화하려면 &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 를 사용하십시오. , 데이터 구조를 이진 형식으로 지연 바이트 문자열로 압축하는 합니다</target>
        </trans-unit>
        <trans-unit id="8c4bb74fa2bda9539f0db58684ace13bfcd04704" translate="yes" xml:space="preserve">
          <source>To set a package&amp;rsquo;s trust property in the package database please refer to &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;.</source>
          <target state="translated">패키지 데이터베이스에 패키지의 신뢰 속성을 설정하려면을 참조하십시오 &lt;a href=&quot;packages#packages&quot;&gt;패키지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a25ac21c6d3b62631dd08b42b9fae80c8727be0" translate="yes" xml:space="preserve">
          <source>To skip to the first occurence of a string:</source>
          <target state="translated">문자열의 첫 항목으로 건너 뛰려면</target>
        </trans-unit>
        <trans-unit id="edb758d0d6990d34bd2a170aea31bb2ebe72017b" translate="yes" xml:space="preserve">
          <source>To solve such concern, the references provided by this module offer a key that can be used to locate the values on each process. Each process maintains a global table of references which can be looked up with a given key. This table is known as the Static Pointer Table. The reference can then be dereferenced to obtain the value.</source>
          <target state="translated">이러한 문제를 해결하기 위해이 모듈에서 제공하는 참조는 각 프로세스에서 값을 찾는 데 사용할 수있는 키를 제공합니다. 각 프로세스는 주어진 키로 조회 할 수있는 전역 참조 테이블을 유지 관리합니다. 이 테이블을 정적 포인터 테이블이라고합니다. 그런 다음 참조를 역 참조하여 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c68944d2e59e0a66846b50f57d32b2ca1f9acb" translate="yes" xml:space="preserve">
          <source>To solve this, GHC provides a single type-level function,</source>
          <target state="translated">이를 해결하기 위해 GHC는 단일 유형 레벨 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf25b9f1720e9ac7d0d7fdd7aee2f1ed9e0566fe" translate="yes" xml:space="preserve">
          <source>To start with an example, suppose you had a module &lt;code&gt;A&lt;/code&gt; which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</source>
          <target state="translated">예를 들어, 일부 문자열 연산을 사용 하는 모듈 &lt;code&gt;A&lt;/code&gt; 가 있다고 가정합니다 . 일반적인 모듈 가져 오기를 사용하면 특정 문자열 구현 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c4479e20c71a25f4dfb43028231f4a734bfcce" translate="yes" xml:space="preserve">
          <source>To take the parts of a string before a delimiter:</source>
          <target state="translated">구분 기호 앞에 문자열 부분을 가져 오려면</target>
        </trans-unit>
        <trans-unit id="e0c0e5556db2e9b3b7a23b8b7d2d49b51aa44349" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">Concurrent Haskell은 프로그래머에게 새로운 언어 구조를 도입하지 않습니다. 오히려 단순히 라이브러리 &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 로 나타납니다 . 이 라이브러리에서 내 보낸 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bfc70e59567edf696404769885739682f80dcc8" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">프로그래머에게 Concurrent Haskell은 새로운 언어 구조를 도입하지 않습니다. 오히려 단순히 라이브러리 인 &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 로 나타납니다 . 이 라이브러리에서 내 보낸 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c62456e79e21d498915acbcba13f52cb41593ec" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 와 함께 &lt;code&gt;+RTS&lt;/code&gt; 플래그 를 사용하려면 예제를 약간 수정해야합니다. 기본적으로 GHC의 RTS는 &quot;안전한&quot; &lt;code&gt;+RTS&lt;/code&gt; 플래그 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조) 만 허용 하고 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; 링크 시간 플래그가이를 무시합니다. 그러나 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; 은 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 이 사용 중일 때 효과가 없습니다 (그리고 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 도 마찬가지입니다 ). 이러한 옵션을 설정하려면 &lt;code&gt;hs_init()&lt;/code&gt; 대신 GHC 특정 API를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="23874375ac3170d79af0c71d4f8ee2bec3a32884" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; 와 함께 &lt;code&gt;+RTS&lt;/code&gt; 플래그 를 사용하려면 예제를 약간 수정해야합니다. 기본적으로 GHC의 RTS는 &quot;안전한&quot; &lt;code&gt;+RTS&lt;/code&gt; 플래그 만 허용하며 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; 참조 ) &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 링크 타임 플래그가이를 무시합니다. 그러나 &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; 이 사용 중일 때는 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 이 적용되지 않습니다 (그리고 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 도 마찬가지 ). 이러한 옵션을 설정하려면 &lt;code&gt;hs_init()&lt;/code&gt; 대신 GHC 특정 API를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="58ce08b9cab583ec1630da790acaeb1e4504d015" translate="yes" xml:space="preserve">
          <source>To use an &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt; the RTS API provides the following functions:</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; 를 사용하기 위해 RTS API는 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c832a5995effff9df59220a2bd9f7e56cfb4614f" translate="yes" xml:space="preserve">
          <source>To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">유니 코드 텍스트 (정규화, 정규식, 비표준 인코딩, 텍스트 분리 및 로캘 포함) 작업에 확장되고 매우 다양한 기능을 사용하려면 &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu 패키지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b96ac2af089bcd3267331bb1501aa1e1d197309c" translate="yes" xml:space="preserve">
          <source>To use relative paths for dependent libraries on Linux and Solaris you can pass a suitable &lt;code&gt;-rpath&lt;/code&gt; flag to the linker:</source>
          <target state="translated">Linux 및 Solaris에서 종속 라이브러리에 상대 경로를 사용하려면 적절한 &lt;code&gt;-rpath&lt;/code&gt; 플래그를 링커에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f309e398fff568b18e392785bde202981de0be5" translate="yes" xml:space="preserve">
          <source>To use this equality in practice, pattern-match on the &lt;code&gt;Coercion a b&lt;/code&gt; to get out the &lt;code&gt;Coercible a b&lt;/code&gt; instance, and then use &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; to apply it.</source>
          <target state="translated">실제로이 평등을 사용하려면에 패턴 일치 &lt;code&gt;Coercion a b&lt;/code&gt; 밖으로 얻을 &lt;code&gt;Coercible a b&lt;/code&gt; 인스턴스를 한 후 사용 &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa17a9e79c9dcc3ca39fe2b79ee583cccf33fc4" translate="yes" xml:space="preserve">
          <source>To use tracing, evaluate an expression with the &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command. For example, if we set a breakpoint on the base case of &lt;code&gt;qsort&lt;/code&gt;:</source>
          <target state="translated">추적을 사용하려면 &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; 명령으로 표현식을 평가하십시오 . 예를 들어 &lt;code&gt;qsort&lt;/code&gt; 의 기본 경우에 중단 점을 설정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efc675a1383ace97e3c2b8987f540eb58b6ceef5" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the documentation of the valid hole fits in the output.</source>
          <target state="translated">유효한 구멍 맞춤의 문서를 출력에 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="332b4115b5fb01dc68e2b60acec1f7d2ed0f11c6" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the provenance of the valid hole fits in the output.</source>
          <target state="translated">출력에 유효한 구멍 맞춤의 출처를 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="a7f408bf113ca084f529db4badbce821ff390f15" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type application of the valid hole fits in the output.</source>
          <target state="translated">유효한 구멍 맞춤 유형을 출력에 표시할지 여부를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="2c4d22b7c838a1ecfb6276f53708bb0e679bc1f9" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the additional holes in refinement hole fits.</source>
          <target state="translated">구체화 구멍 맞춤에 추가 구멍의 유형을 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="04756312abbe3334230e9fe9c79fe06f08cf1ef4" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the valid hole fits in the output.</source>
          <target state="translated">출력에 유효한 구멍 유형을 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="f88544b7c345be9bc6286319d7234499cb7a2281" translate="yes" xml:space="preserve">
          <source>Toggles whether to show what type each quantified variable takes in a valid hole fit.</source>
          <target state="translated">각 정량화 된 변수가 유효한 구멍 맞춤에서 어떤 유형을 사용하는지 표시할지 여부를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="8d4022d64adedc28fae75a3f895c4e8da81cd40c" translate="yes" xml:space="preserve">
          <source>Token pretty-printing function.</source>
          <target state="translated">예쁜 인쇄 기능 토큰.</target>
        </trans-unit>
        <trans-unit id="daef2147e79571af8d5a4f376f29fb535295e66d" translate="yes" xml:space="preserve">
          <source>TokenParser</source>
          <target state="translated">TokenParser</target>
        </trans-unit>
        <trans-unit id="de9a588a8ad015eb8d4acc3d2eccb5cd88ff7637" translate="yes" xml:space="preserve">
          <source>Top-level declaration splices break up a source file into &lt;em&gt;declaration groups&lt;/em&gt;. A &lt;em&gt;declaration group&lt;/em&gt; is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</source>
          <target state="translated">최상위 선언 스플 라이스는 소스 파일을 &lt;em&gt;선언 그룹&lt;/em&gt; 으로 나눕니다 . &lt;em&gt;선언 그룹은&lt;/em&gt; 최상위 선언 스플 라이스에 의해 만들어진 선언의 그룹입니다, 게다가 그 아래로, 그 다음 그러나 다음 최상위 선언 스플 라이스를 포함하지 않음. NB는 최상위 스플 라이스 만 선언 그룹을 구분하고 표현식 스플 라이스는 구분하지 않습니다. 모듈의 첫 번째 선언 그룹에는 첫 번째 최상위 선언 스플 라이스를 포함하지 않는 모든 최상위 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="64e70a05233381ae9b755ec9cdc13f4a77ee5cb1" translate="yes" xml:space="preserve">
          <source>Total CPU time (at the previous GC)</source>
          <target state="translated">총 CPU 시간 (이전 GC에서)</target>
        </trans-unit>
        <trans-unit id="8386f73231e1e92e73f6b519f210511ca9193151" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the GC</source>
          <target state="translated">GC에서 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="042e7e784ddb44e360a337daa72b2ae8ba023cf1" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the init phase @since 4.12.0.0</source>
          <target state="translated">초기화 단계 @since 4.12.0.0에서 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="d2dd5d438fb3dcc8fdc1f04bf55f6d2c501879d3" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the mutator</source>
          <target state="translated">뮤 테이터가 사용한 총 CPU 시간</target>
        </trans-unit>
        <trans-unit id="cd8f3ebd1cb51ba0810348d6c47b2fdc351d6519" translate="yes" xml:space="preserve">
          <source>Total amount of data copied during this GC</source>
          <target state="translated">이 GC 동안 복사 된 총 데이터 양</target>
        </trans-unit>
        <trans-unit id="9735e288f821d32fcba71a1a70c14b5cdc350199" translate="yes" xml:space="preserve">
          <source>Total amount of live data in compact regions</source>
          <target state="translated">컴팩트 한 지역의 총 라이브 데이터 양</target>
        </trans-unit>
        <trans-unit id="490b2f80ac8821885d90f86d57b7974bbf2682ad" translate="yes" xml:space="preserve">
          <source>Total amount of live data in large objects</source>
          <target state="translated">큰 객체의 총 라이브 데이터 양</target>
        </trans-unit>
        <trans-unit id="e6b177b175f265fd062fef05a1277c622c233454" translate="yes" xml:space="preserve">
          <source>Total amount of live data in the heap (incliudes large + compact data). Updated after every GC. Data in uncollected generations (in minor GCs) are considered live.</source>
          <target state="translated">힙에있는 총 라이브 데이터 양 (대용량 + 컴팩트 데이터 포함) 모든 GC 후에 업데이트됩니다. 수집되지 않은 세대 (소규모 GC)의 데이터는 실시간으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2439e747cf079533fc119f7f3372deeb2e6b3e0c" translate="yes" xml:space="preserve">
          <source>Total amount of memory in use by the RTS</source>
          <target state="translated">RTS에서 사용중인 총 메모리 양</target>
        </trans-unit>
        <trans-unit id="ae1cf3a5225a7fa4703cee57bd8a99cfbdc1fa37" translate="yes" xml:space="preserve">
          <source>Total amount of slop (wasted memory)</source>
          <target state="translated">총 슬로프 양 (메모리 낭비)</target>
        </trans-unit>
        <trans-unit id="381d3d3026564b15b98332086f85db8c9c5116c1" translate="yes" xml:space="preserve">
          <source>Total bytes allocated</source>
          <target state="translated">할당 된 총 바이트</target>
        </trans-unit>
        <trans-unit id="7ddb5932284e85cdb998a88ee61c45b3fb084550" translate="yes" xml:space="preserve">
          <source>Total elapsed time (at the previous GC)</source>
          <target state="translated">총 경과 시간 (이전 GC에서)</target>
        </trans-unit>
        <trans-unit id="5176bda3a891825313e991007cfcf6a2dfe321e1" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the GC</source>
          <target state="translated">GC에서 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="a76b13b30e1f96d1561f8aba9418764cdf896ec9" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the init phase @since 4.12.0.0</source>
          <target state="translated">초기화 단계 @ 4.12.0.0에서 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="f8dffa4e4bface78bbc47de7cc9c4f635615fd39" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the mutator</source>
          <target state="translated">뮤 테이터가 사용한 총 경과 시간</target>
        </trans-unit>
        <trans-unit id="c702e8f0d2bf491124a83b3aba7ca49be01b7437" translate="yes" xml:space="preserve">
          <source>Total number of GCs</source>
          <target state="translated">총 GC 수</target>
        </trans-unit>
        <trans-unit id="f31fc901ada0fd73f4d6d8746668c45f8b841486" translate="yes" xml:space="preserve">
          <source>Total number of major (oldest generation) GCs</source>
          <target state="translated">주요 (구세대) GC의 총 수</target>
        </trans-unit>
        <trans-unit id="5d0fb43e49fcfea4980958defc073241b65ca7be" translate="yes" xml:space="preserve">
          <source>Total width of the field.</source>
          <target state="translated">필드의 총 너비</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="26f445c1d8b2f4e101fdf56e72eb92189d409de2" translate="yes" xml:space="preserve">
          <source>Trace exhaustiveness checker</source>
          <target state="translated">철저한 철저 검사기</target>
        </trans-unit>
        <trans-unit id="8d94ec6e077733db6938cd196aa7260c918b123b" translate="yes" xml:space="preserve">
          <source>Trace interface files</source>
          <target state="translated">추적 인터페이스 파일</target>
        </trans-unit>
        <trans-unit id="fdbe7d47032190e46bbad6a5b35e468fcdd74e5e" translate="yes" xml:space="preserve">
          <source>Trace renamer</source>
          <target state="translated">추적 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="b6912fb740cfa5def4327273bd86af0baeb5f9b4" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference</source>
          <target state="translated">추적 런타임 유형 유추</target>
        </trans-unit>
        <trans-unit id="ea97ebbaf9290aacc9db9230d7d8410a1b17dde1" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference done by various interpreter commands.</source>
          <target state="translated">다양한 인터프리터 명령으로 수행되는 런타임 유형 유추를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="918226cc8c88c96d88772b200fb277ce2462c0b2" translate="yes" xml:space="preserve">
          <source>Trace typechecker</source>
          <target state="translated">추적 유형 검사기</target>
        </trans-unit>
        <trans-unit id="cac5cce622b33dcb41c89b31f1cab4a7d79e4ee1" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Mix</source>
          <target state="translated">Trace.Hpc.Mix</target>
        </trans-unit>
        <trans-unit id="4dc37d38ccb40ad731bd6b735a3d79a901047644" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Tix</source>
          <target state="translated">Trace.Hpc.Tix</target>
        </trans-unit>
        <trans-unit id="b9911dc4ca5e0e643713d12b25be14491d441daa" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Util</source>
          <target state="translated">Trace.Hpc.Util</target>
        </trans-unit>
        <trans-unit id="0ce5cee6755ef940551826d010c5c2ba3528d3db" translate="yes" xml:space="preserve">
          <source>TraceEventLog</source>
          <target state="translated">TraceEventLog</target>
        </trans-unit>
        <trans-unit id="8255bba6a712a935f53931169349c3bf3667e4e7" translate="yes" xml:space="preserve">
          <source>TraceFlags</source>
          <target state="translated">TraceFlags</target>
        </trans-unit>
        <trans-unit id="f45cd5da920597cccb919c43b85883e95c0eb5ba" translate="yes" xml:space="preserve">
          <source>TraceNone</source>
          <target state="translated">TraceNone</target>
        </trans-unit>
        <trans-unit id="95797df6040c41d1f62d4c30f5d575a3fde2b6e0" translate="yes" xml:space="preserve">
          <source>TraceStderr</source>
          <target state="translated">TraceStderr</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="c5de444a34d8e7310c292d5077a3f9fa1aea9197" translate="yes" xml:space="preserve">
          <source>Traditional expression quotes and splices let us construct ill-typed expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee76b0788bcc9e4d134c6e63c0f905595d53f415" translate="yes" xml:space="preserve">
          <source>Traditional record syntax, such as &lt;code&gt;C {f = x}&lt;/code&gt;, is enabled by default. To disable it, you can use the &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt;&lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">&lt;code&gt;C {f = x}&lt;/code&gt; 와 같은 기존 레코드 구문 은 기본적으로 사용됩니다. 비활성화하려면 &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt; &lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt; &lt;/a&gt; 확장을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e945a1a9931ffbae11e35d8dc13f62ffcd7e4996" translate="yes" xml:space="preserve">
          <source>TraditionalRecordSyntax</source>
          <target state="translated">TraditionalRecordSyntax</target>
        </trans-unit>
        <trans-unit id="07d54591052808d7665525ab9d03e9a8e6047941" translate="yes" xml:space="preserve">
          <source>Trailing slash functions</source>
          <target state="translated">후행 슬래시 기능</target>
        </trans-unit>
        <trans-unit id="5a701b108c7ddd010bd4e5e1046abd3e059fbfcd" translate="yes" xml:space="preserve">
          <source>Transactional variables.</source>
          <target state="translated">거래 변수.</target>
        </trans-unit>
        <trans-unit id="c6bd77f69d4cdf801791ad51b3a5613597cd452f" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">주어진 함수 ( &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 전문화)를 사용하여 계산에 의해 발생 된 예외를 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="aefaf0cd8aa07449321af97629ce4b3770e62358" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">주어진 함수 ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 전문화)를 사용하여 계산에 의해 발생 된 예외를 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4e682fcac2a4512b74e3dc63612d9586743f8e8" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 계산에 의해 발생 된 예외를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4578ae8d733586d0310337c8b520cee638a41571" translate="yes" xml:space="preserve">
          <source>Transform comprehensions</source>
          <target state="translated">이해력 향상</target>
        </trans-unit>
        <trans-unit id="6d9379f1a17e7f9d27b049266346529304db629e" translate="yes" xml:space="preserve">
          <source>Transform statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">(와 같은 문장을 변환 &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="34bbbf0593112d8021164739182249451cd348ed" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;MaybeT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MaybeT&lt;/code&gt; 안에서 계산을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e3add4bdcd20865c3718142bc9551385a370674" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;ReaderT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ReaderT&lt;/code&gt; 내부에서 계산을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="d94f891243caad66af3028997e36082e6d8dd8dc" translate="yes" xml:space="preserve">
          <source>Transform the value returned by a &lt;code&gt;Reader&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; 가 반환 한 값을 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="529ddea17b3a6fb911dfd08011006b0a6dba6150" translate="yes" xml:space="preserve">
          <source>TransformListComp</source>
          <target state="translated">TransformListComp</target>
        </trans-unit>
        <trans-unit id="28382f411cec0cea1fa0d72a330aaf42ace1a9fe" translate="yes" xml:space="preserve">
          <source>Transformation of at least one immediate subterm does not fail</source>
          <target state="translated">하나 이상의 즉각적인 하위 용어 변환이 실패하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6553c0c77ccd33d074aee1942550fc0f472cd3f4" translate="yes" xml:space="preserve">
          <source>Transformation of one immediate subterm with success</source>
          <target state="translated">하나의 즉각적인 하위 용어를 성공으로 변환</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="68c170c0011cf476eed353d994b12887940cfc96" translate="yes" xml:space="preserve">
          <source>Transformer</source>
          <target state="translated">Transformer</target>
        </trans-unit>
        <trans-unit id="bc40fc64b9787d7dac7665e7c80ced3be2f64e6a" translate="yes" xml:space="preserve">
          <source>Transformer class</source>
          <target state="translated">변압기 등급</target>
        </trans-unit>
        <trans-unit id="12656556988bc57237e887a0b3bd66131be270a9" translate="yes" xml:space="preserve">
          <source>Transforming ByteStrings</source>
          <target state="translated">바이트 문자열 변환</target>
        </trans-unit>
        <trans-unit id="64733f4060672520e5c156055aa404b5a2fff0ad" translate="yes" xml:space="preserve">
          <source>Transforms a parser into one that does the same, but in addition returns the exact characters read. IMPORTANT NOTE: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; gives a runtime error if its first argument is built using any occurrences of readS_to_P.</source>
          <target state="translated">파서를 동일한 작업으로 변환하지만, 읽은 정확한 문자를 반환합니다. 중요 참고 : 첫 번째 인수가 readS_to_P를 사용하여 빌드되면 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; 는 런타임 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8f321ea579e546977788ec7503fb201f9808151b" translate="yes" xml:space="preserve">
          <source>Transitional module providing the &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; class and primitive instances.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 클래스 및 기본 인스턴스를 제공하는 전환 모듈 .</target>
        </trans-unit>
        <trans-unit id="cf6c281c3321c220a2860f225e26547c6663a008" translate="yes" xml:space="preserve">
          <source>Transitivity</source>
          <target state="translated">Transitivity</target>
        </trans-unit>
        <trans-unit id="7bd7baf126db335320e85434af814c47329f4fb9" translate="yes" xml:space="preserve">
          <source>Transitivity of equality</source>
          <target state="translated">평등의 전이성</target>
        </trans-unit>
        <trans-unit id="ee21a36234c54ae6acecacce32dde8221553c2ab" translate="yes" xml:space="preserve">
          <source>Transitivity of representational equality</source>
          <target state="translated">표현 평등의 전이성</target>
        </trans-unit>
        <trans-unit id="e98e003d090d824a54f132e10d2d3a1b2abb08a4" translate="yes" xml:space="preserve">
          <source>TransliterateCodingFailure</source>
          <target state="translated">TransliterateCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dcc95f8a9883fb6fa511276e0d2f0bd822f6472" translate="yes" xml:space="preserve">
          <source>TransmitStart</source>
          <target state="translated">TransmitStart</target>
        </trans-unit>
        <trans-unit id="d2cf87c31932f3da157ec8f3b86b864b9e7f88fd" translate="yes" xml:space="preserve">
          <source>TransmitStop</source>
          <target state="translated">TransmitStop</target>
        </trans-unit>
        <trans-unit id="59ababde52e8e86da31349f66a50ec3bb7819a93" translate="yes" xml:space="preserve">
          <source>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">역사에서 ⟨n⟩ 걸음 여행. ⟨n⟩는 생략하면 하나입니다. GHCi의 디버깅 기능에 대한 자세한 내용은 &lt;a href=&quot;#tracing&quot;&gt;추적 및 기록&lt;/a&gt; 을 참조하십시오 . : &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b795f17232474b10e4eb05eb081a307e9d9dfa5d" translate="yes" xml:space="preserve">
          <source>Traversable</source>
          <target state="translated">Traversable</target>
        </trans-unit>
        <trans-unit id="9c8ab9d8f52e3cebde865983061e92e1572d8906" translate="yes" xml:space="preserve">
          <source>Traversal</source>
          <target state="translated">Traversal</target>
        </trans-unit>
        <trans-unit id="7b1817a217845dfc3e24c8c230b82767b4c56356" translate="yes" xml:space="preserve">
          <source>Traverse from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="977ae6d655ca9f1978129e8ccbfa10a6559b3561" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="5e48e3b92b1820252cbfde816e12e1a271b17cb1" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b18e053b42f93b44a5abf294af55c3136c4f408d" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7200db17563eaefb9847d8db2d6e8155f2a4676c" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 탐색하고 선택적으로 결과에 넣을 값을 생성합니다. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d03af00b13b95140684e72553fba4a01106b42c9" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가없는 항목을 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="30dc152103c6133db322f634f929327d30f349a1" translate="yes" xml:space="preserve">
          <source>Traverses in order of increasing key.</source>
          <target state="translated">키 증가 순서로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7e92b229a11c1c4e925555ecc443d546f7203f39" translate="yes" xml:space="preserve">
          <source>Treat &lt;code&gt;*&lt;/code&gt; as &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 으로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd46d6f300df9c79faeae4e756e06e57fe755cd8" translate="yes" xml:space="preserve">
          <source>Treat the unqualified uses of the &lt;code&gt;*&lt;/code&gt; type operator as nullary and desugar to &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 유형 연산자 의 규정되지 않은 사용을 nullary로 취급하고 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 에 대한 설탕을 제거 하십시오 .</target>
        </trans-unit>
        <trans-unit id="99f5ff6378a0b48f815677894306b090ee036726" translate="yes" xml:space="preserve">
          <source>Tree</source>
          <target state="translated">Tree</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d6ebaccbb7b2994140dcf46fc8cbd5a71b52292c" translate="yes" xml:space="preserve">
          <source>Trees and Forests</source>
          <target state="translated">나무와 숲</target>
        </trans-unit>
        <trans-unit id="d1f88855d73f9050543090a479c62b476a835f18" translate="yes" xml:space="preserve">
          <source>Tried to encode a character that could not be represented under the given encoding, or ran out of input in mid-encode.</source>
          <target state="translated">주어진 인코딩으로 표현할 수 없거나 미드 인코딩으로 입력이 부족한 문자를 인코딩하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="dcf41f4658aee61513347d3d72256ba068f1cb3d" translate="yes" xml:space="preserve">
          <source>Tries to find the definition site of the name at the given source-code span, e.g.:</source>
          <target state="translated">주어진 소스 코드 범위에서 이름의 정의 사이트를 찾으려고 시도합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6d6761d1d070e2158059fdae1344762916cfe5cd" translate="yes" xml:space="preserve">
          <source>Triggers an immediate major garbage collection.</source>
          <target state="translated">즉시 주요 가비지 수집을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="5211c258ae504b8bbd5a65143e1ffaccbfaf5d21" translate="yes" xml:space="preserve">
          <source>Triggers an immediate minor garbage collection.</source>
          <target state="translated">즉시 사소한 가비지 수집을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="97bfbacf53c224ce01bb87815c2b91e603df8ea4" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions and related functions.</source>
          <target state="translated">삼각법 및 쌍곡선 함수 및 관련 함수</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="6842273367fb0a7314d3db77e80a4246de4d0209" translate="yes" xml:space="preserve">
          <source>True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;compact all the time&quot;</source>
          <target state="translated">True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;항상 컴팩트&quot;</target>
        </trans-unit>
        <trans-unit id="ff0a01862c74c77c6757cf7463f92a3698aca6ec" translate="yes" xml:space="preserve">
          <source>Truncate the destination file and then copy the contents of the source file to the destination file. If the destination file already exists, its attributes shall remain unchanged. Otherwise, its attributes are reset to the defaults.</source>
          <target state="translated">대상 파일을 자른 다음 소스 파일의 내용을 대상 파일로 복사하십시오. 대상 파일이 이미 존재하는 경우 해당 속성은 변경되지 않습니다. 그렇지 않으면 해당 속성이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="32877d96f4471ac3d62c45d19e818182f461981a" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b645724bb0724739a37a0f389e05496a29a993a0" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 를 가장 중요하지 않은 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="a4191815c130347968d06550006d8bef069d5483" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Double#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Double#&lt;/code&gt; 값을 가장 가까운 &lt;code&gt;Int#&lt;/code&gt; 로 자릅니다 . 잘림 인 경우 잘림이 &lt;code&gt;Int#&lt;/code&gt; 범위 밖의 값을 생성하면 잘림이 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f6d495ffdebdce795d559dc7a00814f02a9ed4a" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Float#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Float#&lt;/code&gt; 값을 가장 가까운 &lt;code&gt;Int#&lt;/code&gt; 로 자릅니다 . 잘림 인 경우 잘림이 &lt;code&gt;Int#&lt;/code&gt; 범위 밖의 값을 생성하면 잘림이 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c24171999adb97c4a8f884ec45a305760feb8353" translate="yes" xml:space="preserve">
          <source>Truncates the file down to the specified length. If the file was larger than the given length before this operation was performed the extra is lost.</source>
          <target state="translated">파일을 지정된 길이로 자릅니다. 이 작업을 수행하기 전에 파일이 지정된 길이보다 길면 추가 파일이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="e5062783e7bc3741e7a3f6f2e923c1f2ca0f5891" translate="yes" xml:space="preserve">
          <source>Trust the used plugins and no longer mark the compiled module as unsafe</source>
          <target state="translated">사용 된 플러그인을 신뢰하고 더 이상 컴파일 된 모듈을 안전하지 않은 것으로 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bc4bdf5385df47149206feaa36c849748d83b64" translate="yes" xml:space="preserve">
          <source>Trustworthy</source>
          <target state="translated">Trustworthy</target>
        </trans-unit>
        <trans-unit id="c3d3c6266583689c8044755f6755946b22e2e727" translate="yes" xml:space="preserve">
          <source>Try alternatives in the same order as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 와 같은 순서로 대안을 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="649615639f9b9c6ba5bc23c5c62fdf483263edda" translate="yes" xml:space="preserve">
          <source>Try downcasting &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; value. Returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if value doesn't fit in &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 값으로 다운 캐스트하십시오 . value가 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 에 맞지 않으면 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9f32a8bcb3ae56ab6fee54ca560a7075df79e35e" translate="yes" xml:space="preserve">
          <source>Try to use local disks when linking:</source>
          <target state="translated">연결할 때 로컬 디스크를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="0fae6c283b56ecb589a1f52cbd69ed8461516cd4" translate="yes" xml:space="preserve">
          <source>Tuple data constructor</source>
          <target state="translated">튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="fe995f3be3d2ff04b4539a5c33f7f5265c5ec905" translate="yes" xml:space="preserve">
          <source>Tuple type constructor</source>
          <target state="translated">튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="f3571e8acb567c55596ec89e11c3c7590fcd1efb" translate="yes" xml:space="preserve">
          <source>Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; treats it as a product of distinct types. In other words, the following code:</source>
          <target state="translated">튜플 타입. 데이터 선언의 오른쪽에 비 단위 튜플이 사용되면 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 는이를 고유 한 유형의 곱으로 취급합니다. 즉, 다음 코드는</target>
        </trans-unit>
        <trans-unit id="07bc188bc9976952fc0cc95ef067281f658cb805" translate="yes" xml:space="preserve">
          <source>TupleSections</source>
          <target state="translated">TupleSections</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="0090b6abe499cb5c3a21cf4b91f82b1dc060fb8b" translate="yes" xml:space="preserve">
          <source>Tuples are currently limited to size 100. However, standard instances for tuples (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;) are available &lt;em&gt;only&lt;/em&gt; up to 16-tuples.</source>
          <target state="translated">튜플은 현재 크기가 100으로 제한되어 있습니다. 그러나 튜플의 표준 인스턴스 ( &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; 및 &lt;code&gt;Show&lt;/code&gt; )는 최대 16 개의 튜플 &lt;em&gt;만&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb72a46d788e7aaf184a3a1b039183884ebc8ddf" translate="yes" xml:space="preserve">
          <source>Tuples, all of whose component types have kind &lt;code&gt;Constraint&lt;/code&gt;. So for example the type &lt;code&gt;(Show a, Ord a)&lt;/code&gt; is of kind &lt;code&gt;Constraint&lt;/code&gt;.</source>
          <target state="translated">구성 요소 유형이 모두 &lt;code&gt;Constraint&lt;/code&gt; 인 튜플 . 예를 들어 &lt;code&gt;(Show a, Ord a)&lt;/code&gt; 유형은 &lt;code&gt;Constraint&lt;/code&gt; 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="208297b00f068e5585208c000785f0fce4f36c23" translate="yes" xml:space="preserve">
          <source>Tuples, lists, &lt;code&gt;Maybe&lt;/code&gt;, and all the other types from &lt;code&gt;Prelude&lt;/code&gt; continue to have their existing, lazy, semantics.</source>
          <target state="translated">&lt;code&gt;Prelude&lt;/code&gt; 의 튜플, 목록, &lt;code&gt;Maybe&lt;/code&gt; 및 기타 모든 유형 에는 계속 기존의 게으른 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="253a3d85a1beb3288a473dc352f001b3960133ba" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; &amp;ldquo;update-frame squeezing&amp;rdquo; at garbage-collection time. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">돌려 &lt;em&gt;오프&lt;/em&gt; 가비지 수집 시간에 &quot;업데이트 프레임 짜내을&quot;. (썽크 항목 수와 관련하여 수집 된 특정 데이터의 정확성을 보장하는 경우를 제외하고는이를 해제 할 특별한 이유가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="275633f17b4e4cf83d036cacf3592d3d73e3ed05" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; update frame squeezing on context switch. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">돌려 &lt;em&gt;오프&lt;/em&gt; 컨텍스트 스위치에 업데이트 프레임 짜내합니다. (청크 항목 수와 관련하여 수집 된 특정 데이터의 정확성을 보장하는 것을 제외하고는 끄는 특별한 이유가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="46ed6208974a650db0bd1f82cc0c70d6411a0c0e" translate="yes" xml:space="preserve">
          <source>Turn a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; into its initial &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">차례 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 초기에 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="99920f5c3b939caebceea45731d8b9d3427458f2" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell expression, suitable for use in a splice.</source>
          <target state="translated">스플 라이스에 사용하기에 적합한 값을 Template Haskell 식으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="37562d7dab36ae171d42f81239370113e8ede575" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell typed expression, suitable for use in a typed splice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c10b159949d028b9e59ba53a57b08c8fed29bf" translate="yes" xml:space="preserve">
          <source>Turn an existing Handle into a file descriptor. This function throws an IOError if the Handle does not reference a file descriptor.</source>
          <target state="translated">기존 핸들을 파일 설명 자로 바꿉니다. Handle이 파일 설명자를 참조하지 않으면이 함수는 IOError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ff88efd554e6e2bbf0d6b57ed109bd14bff32a19" translate="yes" xml:space="preserve">
          <source>Turn an existing file descriptor into a Handle. This is used by various external libraries to make Handles.</source>
          <target state="translated">기존 파일 디스크립터를 핸들로 바꿉니다. 이것은 다양한 외부 라이브러리에서 핸들을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af1ea6cee0d8a6d561bf79d4ae3fe34c934b40bb" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining</source>
          <target state="translated">사전 인라인 끄기</target>
        </trans-unit>
        <trans-unit id="d635f6906b908f74109d28ae4ecba3d5b4cf43a2" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining.</source>
          <target state="translated">사전 인라인을 끕니다.</target>
        </trans-unit>
        <trans-unit id="17471888502443f29d90093ff7b1d13417c48663" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing &lt;code&gt;.o&lt;/code&gt; file in place, if it can be determined that the module does not need to be recompiled.</source>
          <target state="translated">재 컴파일 검사를 해제합니다 (기본적으로 켜져 있음). 재 컴파일 검사 는 모듈을 다시 컴파일 할 필요가 없다고 판단 될 경우 기존 &lt;code&gt;.o&lt;/code&gt; 파일을 그대로두고 컴파일을 일찍 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">재 컴파일 검사를 끕니다. 이것은 단일 파일을 컴파일 할 때 (즉, &lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 를&lt;/a&gt; 사용할 때) &lt;code&gt;-ddump-X&lt;/code&gt; 옵션에 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">인수로 &lt;code&gt;State#&lt;/code&gt; 토큰 이있는 모든 람다 는 단일 항목으로 간주되므로 내부 항목을 인라인하는 것으로 간주 되는 &quot;state hack&quot;을 끄십시오 . 이는 IO 및 ST 모나드 코드의 성능을 향상시킬 수 있지만 공유를 줄일 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">강제 옵티 마이저 끄기</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">강제 옵티 마이저를 끕니다.</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">인수로 간주되는 실제 상태 토큰이있는 람다는 단일 항목으로 간주되는 상태 핵을 끄십시오. 따라서 내부의 내용을 인라인해도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;열성적인 블랙홀 링&lt;/a&gt; 켜기</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다.</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수요 분석가에서 CPR 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Haskell 프로그램 적용 범위 계측 켜기</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">통화 패턴 전문화를 켭니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskell 프로그램의 콜 패턴 전문화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">디버그 인쇄 켜기 (보다 자세한 정보)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게으름을 완전히 켭니다 (유동 바인딩을 바깥쪽으로). &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">코어 수준에서 GHC 내에서 헤비급 인트라 패스 위생 검사를 켭니다. (그것은 당신의 GHC의 정신 상태를 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">내부 위생 검사 켜기</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">GHCi에서 제본 결과 인쇄 켜기</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">다른 모듈에서 가져온 오버로드 된 기능의 특수화를 켭니다.</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">펼칠 수있는 경우 크기에 관계없이 오버로드 된 기능의 전문화</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버로드 된 기능의 전문화를 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를&lt;/a&gt; 의미합니다.</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">엄격 성 분석을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 . &lt;code&gt;-fworker-wrapper&lt;/code&gt; 를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SpecConstr 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float-in 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자유 사례 변환을 켭니다. &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">자유 사례 변환을 켭니다. 이것은 자유 변수의 반복적 인 사례 분석을 피하기 위해 자체 RHS에서 재귀 함수를 한 번 풀어줍니다. 콜 패턴 스페셜 &lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt; ( -fspec-constr )와 비슷하지만 인수가 아닌 자유 변수입니다.</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">정적 인수 변환을 켜면 재귀 함수가 로컬 재귀 루프가있는 비 재귀 함수로 바뀝니다. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos의 PhD 논문&lt;/a&gt; 7 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">정적 인수 변환을 켜십시오.</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">까다로운 프로파일 링 켜기</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성 된 어셈블리에서 포화 자체 재귀 테일 콜을 로컬 점프로 전환합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">유형 오류를 경고로 바꾸고 &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;런타임까지 오류를 연기하십시오&lt;/a&gt; . 의미 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . 참조 &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">특수 구문을 활성화하는 옵션을 설정하면 예약 된 단어가 된 변수 이름을 사용하기 때문에 Haskell 98 코드 작업이 컴파일되지 않을 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 섹션에는 언어 확장에 의해 &quot;도난 된&quot;구문이 나열되어 있습니다. 우리는 Haskell 98 어휘 구문에서 표기법과 비 터미널 이름을 사용합니다 (Haskell 98 보고서 참조). 여기에는 기존 작업 프로그램에 영향을 줄 수있는 구문 변경 사항 만 나열됩니다 (예 : &quot;도난&quot;구문). 이러한 확장 중 상당수는 새로운 컨텍스트 프리 구문도 사용할 수 있지만 모든 경우에 새 구문을 사용하도록 작성된 프로그램은 옵션을 사용하지 않으면 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">패턴을 반박 할 수없는 패턴으로 바꾸려면 &lt;code&gt;Strict&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;~(~p)&lt;/code&gt; 또는 &lt;code&gt;(~ ~p)&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">모나드 연산으로 지정된 종료자를 참조와 연결하여 일반 메모리 참조를 외부 객체로 변환합니다. 스토리지 관리자는 &lt;code&gt;ForeignPtr&lt;/code&gt; 에 대한 마지막 참조 가 삭제 된 후 얼마 후에 별도의 스레드에서 종료자를 시작합니다 . 신속 함을 보장 할 수 없으며 실제로 최종자가 결국 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반 메모리 참조를 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 를 사용하여 종료 자 와 연관 될 수있는 외부 포인터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">일반 메모리 참조를 외부 포인터로 변환하고 종료자를 참조와 연관시킵니다. 외부 객체에 대한 마지막 참조가 삭제 된 후 종료자가 실행됩니다. 프롬프트가 보장되지는 않지만 프로그램이 종료되기 전에 종료자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">모든 텍스트 속성을 끕니다. 이 기능은 항상 성공하지만 텍스트 속성을 지원하지 않는 터미널에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">표준 경고 및 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; 에서 사용&lt;/a&gt; 하지 않는 경고를 포함하여 모든 경고를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">의심스러운 코드를 나타내는 모든 경고 옵션을 설정합니다. &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; 에 의해 활성화 &lt;em&gt;되지 않은&lt;/em&gt; 경고 는</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 굵게 모드를 켠 다음 모든 속성을 끕니다.</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 모든 단일 경고를 켭니다.</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">지정된 텍스트를 출력하기 전에 스탠드 아웃 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">주어진 텍스트를 출력하기 전에 밑줄 모드를 켠 다음 끕니다.</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">향후 기본적으로 활성화 될 예정인 경고를 설정하지만 당분간은 정상적인 컴파일 상태를 유지하지 않습니다. 이를 통해 라이브러리 작성자는 경고를 생성하기 전에 새로운 기능에 적응할 수 있도록 향후 코드를 호환 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">두 가지 명령 줄 옵션은 시작 파일 파일을 읽을 지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">주의해야 할 두 가지 :</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">가능한 모든 대체에 대해 유형이 공통 리 덕트로 환원 될 수없는 경우 두 유형이 분리 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">두 가지 유형의 메시지가 생성됩니다. &lt;code&gt;***&lt;/code&gt; 로 시작하는 메시지는 컴파일 단계의 시작을 나타내는 반면 &lt;code&gt;!!!&lt;/code&gt; 로 시작하는 메시지는 !!! 패스의 끝을 표시하고 할당 및 런타임 통계를 동반합니다.</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">문자 리터럴</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">인수 이름이 중요하지 않은 경우 유형 인수를 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 바꿀 수 있습니다 . 이것은 고유 한 이름으로 유형 변수를 작성하는 것과 같습니다. &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 플래그가 사용 가능한 경우 경고를 피하기 위해 사용하지 않는 유형 인수를 밑줄로 대체하거나 접 두부를 붙일 수 있습니다 . &lt;a href=&quot;#data-instance-declarations&quot;&gt;데이터 인스턴스 선언&lt;/a&gt; 과 동일한 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">유형 검사기는 구멍에 대해 유추 된 유형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I / O 제공자를위한 유형 클래스.</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 파생시켜야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;추가 클래스의 인스턴스 파생 (데이터 등) 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; 와 같이 자체 확장을 활성화해야하는 유형 클래스 ( &lt;a href=&quot;#deriving-extra&quot;&gt;예 : 추가 클래스 (데이터 등)의 파생 인스턴스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; - all 과 관련된 유형에 적용된 형식 생성자 ( ImpredicativeTypes 가 해제 된 경우)</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">타입 생성자</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">타입 생성자와 클래스; 하스켈은 현재 같은 이름 공간에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">forall 아래의 형식 평등은 연기 할 수 없습니다 (# 14605 참조).</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">forall 아래의 유형 평등은 연기 될 수 없습니다 (참조 Trac # 14605).</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">유형 평등</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">유형 패밀리는 세 가지 맛으로 나타납니다. 연관된 유형 동의어라고합니다). 최상위 색인 패밀리는 유형 색인이 클래스 매개 변수와 일치하지 않아도되므로보다 일반적입니다. 그러나 일부 유형 인스턴스가 실수로 생략 된 경우 연관된 유형 동의어가보다 명확하게 구조화 된 코드 및 컴파일러 경고를 유발할 수 있습니다. 다음에서 우리는 항상 일반 최상위 양식을 먼저 논의한 다음 관련 유형에 대한 추가 제약 조건을 다룹니다. 닫힌 연관된 유형 동의어가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">언어 패밀리는 &lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; 언어 확장으로 활성화됩니다 . GHC에서 유형 군 사용에 대한 추가 정보는 유형 군에 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;관한 Haskell 위키 페이지에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">유형 패밀리는 인스턴스 헤드의 규칙에 대한 규칙을 확장해야 &lt;a href=&quot;#flexible-instance-head&quot;&gt;하며, 인스턴스 헤드의 완화 규칙에 나와&lt;/a&gt; 있습니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">유형 패밀리 선언에는 오른쪽이 없지만 GHC는 여전히 &lt;code&gt;F&lt;/code&gt; 에 대한 종류를 유추해야합니다 . 제약 조건이 없으므로, 모든 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; 유추 할 수 있습니다. k1-&amp;gt; k2 이지만 &lt;em&gt;너무&lt;/em&gt; 다형성으로 보입니다 . 따라서 GHC는 완전히 제한되지 않은 종류 변수를 &lt;code&gt;Type&lt;/code&gt; 으로 기본 설정 하고 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; 얻습니다 . 종류 시그니처를 사용하여 &lt;code&gt;F&lt;/code&gt; 를 종류가 다형성으로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">클래스 패밀리 인스턴스 선언은 적절한 패밀리 선언이 범위 내에있을 때만 합법적입니다. 클래스 인스턴스가 클래스 선언을 표시해야하는 것처럼 말입니다. 또한 각 인스턴스 선언은 패밀리 선언에 의해 결정된 종류를 따라야하며 인스턴스 선언의 유형 매개 변수 수는 패밀리 선언의 유형 매개 변수 수와 일치해야합니다. 마지막으로, 유형 인스턴스의 오른쪽은 단일 유형이어야하며 (즉, 모든 유형을 포함하지 않을 수 있음) 모든 포화 바닐라 유형 동의어가 확장 된 후에는 패밀리 동의어를 제외하고 동의어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">유형 가족 결과</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">유형 군 결과 서명</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="translated">입력 된 스플 라이스에 구멍 입력 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;# 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;# 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">타이핑 된 스플 라이스의 타이핑 구멍 ( &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;문제 # 10945&lt;/a&gt; 및 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;문제 # 10946 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="276b31a5f89d022c33dce55c2768f21e907ef802" translate="yes" xml:space="preserve">
          <source>Type lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 백업하는 데 사용할 수있는 장치의 유형입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; 참조 ). 표준 라이브러리 는 기본 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 인스턴스 가 FD 인 파일 디스크립터 ( &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; 참조 )를 사용 하여 Posix 파일 조작을 통해 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 작성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">형식 문자열에서 수정 자 문자를 구문 분석 할 함수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">타입 표현</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">&lt;em&gt;원시&lt;/em&gt; 임의 정밀도 Naturals를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">GMP 사지를 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">임의 정밀도의 음이 아닌 정수를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">유형 스플 라이스 : 유형 스플 라이스에서는 익명 와일드 카드 만 지원됩니다. 명명 된 및 추가 제약 조건 와일드 카드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">유형 동의어 패밀리가 인스턴스 헤드에 전혀 나타나지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr #의&lt;/a&gt; 유형 동의어</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int #에&lt;/a&gt; 대한 동의어</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word #의&lt;/a&gt; 동의어</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">생성자를위한 메타 정보 인코딩을위한 타입 동의어</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">데이터 유형의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">레코드 선택기의 메타 정보를 인코딩하기위한 유형 동의어</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">재귀를 인코딩하기위한 형식 동의어 ( &lt;code&gt;Type&lt;/code&gt; 종류 )</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">타입 동의어</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">유형 동의어는 유형 수준의 매크로와 비슷하지만 Haskell 98은 개별 동의어 선언에 많은 규칙을 적용합니다. &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt; 확장을 사용하면 GHC는 &lt;em&gt;유형 동의어를 확장 한 후에 만&lt;/em&gt; 유형에 대한 유효성 검사를 수행합니다 . 이는 GHC가 Haskell 98보다 유형 동의어에 대해 훨씬 더 자유로울 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">밑줄에 식별자를 접미사 (예 : &lt;code&gt;_a&lt;/code&gt; ) 로 지정하여 유형 와일드 카드의 이름을 지정할 수도 있습니다 . 이를 &lt;em&gt;와일드 카드&lt;/em&gt; 라고 합니다. 하나의 유형 서명 내에서 동일한 이름의 와일드 카드가 발생하면 모두 동일한 유형으로 통합됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">유형 확인 및 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">타입 클래스와 암시 적 매개 변수 제약</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">타입 레벨 &quot;and&quot;</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">유형 수준 &quot;not&quot;. &lt;code&gt;4.10.0.0&lt;/code&gt; 이후의 인젝 티브 타입 패밀리 .</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">타입 레벨 &quot;또는&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">유형 레벨 &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt; . &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">타입 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">제안 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">표현 평등을 사용하는 유형 안전 캐스트</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="40fb2a246a44fdd76a25bc4dee91c9b12c42ad29" translate="yes" xml:space="preserve">
          <source>Typeclass</source>
          <target state="translated">Typeclass</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 가능 값의 유형 클래스입니다 . &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 의 방법은 값 필드 포맷 디스크립터를 받아 하나 실패로 인해 잘못된 설명하거나 생성 &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 결과한다. 기본 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 은 수정자를 기대하지 않습니다. 일반적인 경우입니다. 최소 예 : &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">유형이 지정된 표현식 스플 라이스 : 유형이 지정되지 않은 표현식 스플 라이스와 동일한 와일드 카드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">유형이 지정된 표현식</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">유형이 지정된 구멍은 GHC의 기능으로 밑줄 (예 : &quot; &lt;code&gt;_&lt;/code&gt; &quot;, &quot; &lt;code&gt;_foo&lt;/code&gt; &quot;, &quot; &lt;code&gt;_bar&lt;/code&gt; &quot;)로 작성된 특수 자리 표시자를 표현식으로 사용할 수 있습니다. 컴파일하는 동안 이러한 구멍은 구멍 위치에 어떤 유형이 예상되는지, 자유 유형 변수의 원점에 대한 정보 및 구멍을 채우는 데 도움이되는 로컬 바인딩 목록 및 유형에 맞는 범위의 바인딩을 설명하는 오류 메시지를 생성합니다. 실제 코드로 구멍을 채우는 데 도움이 될 수 있습니다. 타입 홀은 GHC에서 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTC 및 UT1의 유형 및 함수</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">유니 코드 텍스트의 인코딩 및 디코딩 오류를 처리하기위한 유형 및 기능</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">리모트 GHCi에서 리모트 오브젝트를 참조하기위한 유형. 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [외부 GHCi 포인터]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">텍스트 인코딩 / 디코딩 실패 방법을 지정하는 유형</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I / O 오류의 종류</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">유형과 클래스 제약 조건은 접두사로 쓸 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 : &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용법 : &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">일반적으로 GHCi는 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령 후에로드 한 모듈 수만 표시합니다 . 이 플래그를 사용하면 GHC는로드 된 모듈의 이름도 나열합니다. 이것은 GHC 8.2.1 이전의 기본 동작이며 일부 툴링 사용자에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">일반적으로이 &lt;code&gt;GSerialize&lt;/code&gt; 클래스는 표현 유형에 대한 인스턴스 만 갖는 것이 적합하므로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 자체를 입력 하면 현재 정의 된 매크로가 나열됩니다. &lt;code&gt;:def!&lt;/code&gt; 가 아니면 기존 명령 이름을 재정의하려고하면 오류가 발생합니다 . form이 사용되며,이 경우 해당 이름의 이전 명령을 자동으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; 를 입력 하면 현재 정의 된 매크로가 나열됩니다. 기존 명령 이름을 재정의하려고하면 &lt;code&gt;:def!&lt;/code&gt; 이 경우 해당 이름을 가진 이전 명령을 자동으로 덮어 씁니다. 그러나 내장 명령의 경우 명령 이름 앞에 이중 콜론 (예 : &lt;code&gt;::load&lt;/code&gt; )을 추가 하여 이전 명령을 계속 사용할 수 있습니다 . &lt;code&gt;:{&lt;/code&gt; , &lt;code&gt;:}&lt;/code&gt; 및 &lt;code&gt;:!&lt;/code&gt; 명령을 재정의 할 수 없습니다 . .</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">입력 : ⟨exp⟩ 유형이 ⟨T1⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩이고 ⟨pat⟩가 ⟨T2⟩와 일치하면 전체보기 패턴이 ⟨T1⟩과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">유닉스 스타일 포맷</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">유닉스 스타일 파싱</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE 환경 변수.</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTC는 시계로 측정 한 시간으로 &quot;도약 초&quot;라고하는 가끔씩 초를 추가하거나 제거하여 지구와 보조를 맞추도록 수정되었습니다. 이러한 수정 사항은 예측할 수 없으며 6 개월 전에 통지합니다. 이 수정 프로그램으로 컴파일 된 프로그램은 6 개월 후에 만료 될 수 있으므로 이러한 수정 사항에 대한 표는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16 (Windows 시스템에서 사용).</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-16 코덱</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16 서로 게이트 코드 포인트는 유니 코드 스칼라 값 세트에 포함되지 않지만 불행히도 Haskell에 의해 유효한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값으로 인정됩니다 . &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 로 표현할 수 없습니다 . 이 함수는 해당 코드 포인트를 유니 코드 대체 문자 (U + FFFD, '')로 다시 매핑하고 다른 코드 포인트는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62cdcaea7e563aff141140dcd64fe723c057ad8d" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32 (C 컴파일러는 &lt;code&gt;201605L&lt;/code&gt; 을 정의 함 ) 또는</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-32 코덱</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO 라이브러리 용 UTF-8 코덱</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">단항 부정.</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">단항 부정. 음의 &lt;code&gt;Int#&lt;/code&gt; 범위는 양의 범위보다 하나 더 확장 되므로 가장 음수 인 &lt;code&gt;negateInt#&lt;/code&gt; 는 항등 연산입니다. 이런 식으로 &lt;code&gt;negateInt#&lt;/code&gt; 는 항상 자체 역수입니다.</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">식에 사용 된 언 바운드 데이터 생성자는 위와 동일하게 동작합니다. 그러나 &lt;em&gt;패턴에&lt;/em&gt; 사용 된 바인딩되지 않은 데이터 생성자 는 지연 될 수 없으며 대신 컴파일을 중단합니다. (구현 용어에서는 유형 검사기 대신 이름 바꾸기 프로그램에 의해보고됩니다.)</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">이름이 같은 언 바운드 식별자는 동일한 기능 내에서도 통합되지 않지만 개별적으로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">무제한 채널.</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">박스형 배열</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">박스형 불변 배열.</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">박스형 표현 유형</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">박스형 합계 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">박스형 합계 유형 생성자</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">Unboxed sum은 힙에 sum을 할당하고 포인터로 값을 나타내는 대신 unboxed tuple과 같이 구성 요소로 표시된다는 의미에서&amp;ldquo;unboxed&amp;rdquo;입니다. 이러한&amp;ldquo;구성 요소&amp;rdquo;는 합계 유형의 대안에 따라 다릅니다. 박스형 튜플과 같이 박스형 합계는 리프팅 된 구성 요소에 게으르다.</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">박스형 튜플 데이터 생성자</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">박스형 튜플 타입 생성자</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">박스형 튜플은 여러 값을 반환해야하는 함수에 사용되지만 일반적으로 본격적인 튜플 사용과 관련된 힙 할당을 피합니다. 박스형 튜플이 반환되면 구성 요소는 레지스터 나 스택에 직접 저장됩니다. 박스형 튜플 자체에는 합성 표현이 없습니다. &lt;code&gt;primops.txt.pp&lt;/code&gt; 에 나열된 많은 기본 작업은 상자가 없는 튜플을 반환합니다. 특히, &lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;ST&lt;/code&gt; 모나드는 작동 순서 동안 불필요한 할당을 피하기 위해 상자없는 튜플을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">Unboxed 튜플은 실제로 &lt;code&gt;GHC.Exts&lt;/code&gt; ; 그것들은 구문 확장 ( &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; )입니다. 박스형 튜플은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">박스형 튜플은 다중 대치 대안에 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">박스형 유형은 C에서 사용하는 &quot;원시 기계&quot;유형에 해당합니다. &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *) 등 이러한 유형 의 &lt;em&gt;기본 작업&lt;/em&gt; (PrimOps)은 다음과 같습니다. 기대할 수 있습니다. 예를 들어, &lt;code&gt;(+#)&lt;/code&gt; 은 &lt;code&gt;Int#&lt;/code&gt; s 에 추가 된 것으로서, 우리 모두가 알고 사랑하는 기계 추가 (일반적으로 하나의 명령)입니다.</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">확인되지 않은 액세스</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">확인되지 않은 부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">불변 배열의 확인되지 않은 읽기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">변경 가능한 배열의 확인되지 않은 쓰기. 범위를 벗어난 액세스에서 가비지를 반환하거나 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">제안의 유형이나 응용 프로그램을 표시하지 않음으로써 유효한 구멍 맞춤 목록을 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">C 전 처리기에서 기호 정의</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">일반적인 방법으로 매크로 &quot;기호&quot;를 정의하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">사용자 정의 명령 ⟨name⟩을 정의 해제하십시오 ( 위의 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 이는 &lt;code&gt;Either * Char&lt;/code&gt; 와 같은 표현식이 &lt;code&gt;(*) Either Char&lt;/code&gt; 아닌 &lt;code&gt;Either (*) Char&lt;/code&gt; 로 구문 분석 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">아래 &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;*&lt;/code&gt; 종류는 운영자 나 심지어 이름이 아닙니다, 그것은 의미 특수 구문입니다 &lt;code&gt;Data.Kind.Type&lt;/code&gt; . 같은 식 수단이 있다는 &lt;code&gt;Either * Char&lt;/code&gt; 로 파싱 &lt;code&gt;Either (*) Char&lt;/code&gt; 아닌 &lt;code&gt;(*) Either Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10 이하에서는 시스템 I / O 라이브러리가 로케일 구분 I / O 또는 라인 종료 변환을 지원하지 않습니다. 이 버전의 GHC에서이 라이브러리의 함수는 모두 UTF-8을 사용합니다. 이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">GHC에서 다시 쓰기 규칙은 중단 (==)을 특수한 breakByte에 대한 호출로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">Mac OS X에서는 디버그 정보가 실행 파일과 떨어져 있습니다. 실행 파일을 컴파일 한 후 &lt;code&gt;dsymutil&lt;/code&gt; 유틸리티를 사용하여 디버깅 정보를 추출하여 디버그 아카이브에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">대부분의 상황에서 독립 실행 형 파생을 사용하여 생성자가 모두 범위에 속하지 않는 데이터 유형에 대한 인스턴스를 작성할 수는 없습니다. 파생 된 인스턴스가 배후에서 생성자를 사용하는 코드를 생성하기 때문에 추상화가 중단되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="c982cc09160648fab8b183af5c0c2149ea73000b" translate="yes" xml:space="preserve">
          <source>Underlying untyped Template Haskell expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">ByteString 펼치기</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">생성자 응용 프로그램 펼치기</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">불행히도 DWARF는 GHC가 생성하는 코드를 완전히 설명하기에 충분하지 않습니다. 이것은 라인 정보의 경우에 가장 분명합니다. GHC는 다양한 가능한 소스 위치 중에서 일부를 선택해야합니다. 이는 기존 통계 프로파일 링 도구로 DWARF 정보의 유용성을 제한합니다. 프로파일 링을 위해서는 확장 된 디버깅 정보를 사용하는 것이 좋습니다. 아래의 &lt;em&gt;프로파일 링&lt;/em&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">불행히도. 아직 구현하지 않았습니다. GHCi에로드하기 전에 문제가있는 모듈을 직접 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">유니 코드 표준 범주 (UnicodeData 테이블의 열 2)는 유니 코드 표준 (특히 유니 코드 문자 데이터베이스)에 나열된 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">유니 코드 로마 숫자도 &quot;숫자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">유니 코드 대안</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">유니 코드 문자는 문자, 숫자, 표시, 문장 부호, 기호, 구분 기호 (공백 포함) 및 기타 (제어 문자 포함)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">유니 코드 인코딩 / 디코딩</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">유니 코드 일반 범주</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">단방향 동의어는 패턴 컨텍스트에서만 사용할 수 있으며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​출력 기록으로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">새로운 모나드 에 대한 &lt;code&gt;callCC&lt;/code&gt; 작업 의 균일 한 리프팅 . 이 버전은 연속 입력시 원래 ​​상태로 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">무인 데이터 유형</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">프로그램 텍스트에 지정된 순서대로 1부터 계산하여 데이터 유형 생성자를위한 고유 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">독특한 개체</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">단위 : 인수가없는 생성자에 사용</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">세계시</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">범용 결합 기능</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">유닉스 시스템</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">달리 문서화되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="5b45d2b7d96fbef96a9bc758815c76e0e2e71a5f" translate="yes" xml:space="preserve">
          <source>UnliftedNewtypes</source>
          <target state="translated">UnliftedNewtypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">달리 &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 는&lt;/a&gt; 우측 함수 유형을 포함하는 데이터 타입에 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">달리 &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; 암시하지 않습니다 &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; . 이 결정의 근거는 용어 레벨 패턴 이름과 달리 유형 이름은 종종 문서화 목적으로 명시 적으로 선택되므로 유형 이름에 밑줄을 사용하면 문서를 읽기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">프로그램을 불완전하게 만들고 평가할 때 오류를 생성하는 &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; 과 달리 형식 서명에 구멍이있을 필요는 없습니다. 형식 검사기는 형식 서명이 있거나없는 바인딩을 형식 검사 할 수 있습니다 (대부분의 경우). 부분 타입 시그니처는 두 극단 사이의 간격을 메우고, 프로그래머는 어떤 유형의 부분에 주석을 달고 어떤 부분을 유형 검사기에 남겨 둘지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 와 달리이 옵션으로 인해 패키지 ⟨pkg be가 결과 실행 파일 또는 공유 객체에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 와 달리이 함수는 인수의 유니 코드 디코딩을 수행하지 않습니다. OS가 프로그램에 전달한 정확한 바이트를 얻습니다. 인수를 텍스트로 해석하려면 일부 유니 코드 디코딩을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 와 달리 요소를 강제하지 않고 검색하는 데 사용할 수 있습니다. 예를 들어, 시퀀스의 다섯 번째 요소 삽입 &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 키에서 &lt;code&gt;k&lt;/code&gt; , 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 타입 생성자에 매핑되지 않는 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; . 다음과 같이 직접 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 가 엄격 지칭 그 소스 코드에 기입 된 것과 상이 할 수있는 데이터 생성자 필드 용 컴파일러 선택한다. 자세한 정보는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 절대 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 와 달리이 기능은 실패하지 않습니다. 그것은 반환 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 능력이 거짓에 없거나 설정하고, 반환하면 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 과 달리 재귀 함수 에는 &lt;code&gt;INLINABLE&lt;/code&gt; pragma 를 사용하는 것이 좋습니다 . &lt;code&gt;SPECIALISE&lt;/code&gt; 나중에 사용할 수 있도록하는 주된 이유</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">달리 C에서 &lt;code&gt;printf(3)&lt;/code&gt; 이 본의 서식 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 인수의 형태에 의해 구동된다; 형식은 유형에 따라 다릅니다. 로 포맷 종류 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;상자 밖으로&quot;는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 GHC는 데이터 유형의 형식을 제한하지 않습니다. 대신 GHC는 단순히 지정된 클래스에 적합한 상용구 코드를 생성하고 유형을 확인합니다. 유형 오류가 있으면 문제입니다. (GHC는 유형 오류가있는 경우 문제 코드를 표시합니다.)</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 선언에 첨부 된 &lt;code&gt;deriving&lt;/code&gt; 선언 과 달리 인스턴스는 데이터 유형보다 더 구체적 일 수 있습니다 ( &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#instance-rules&quot;&gt;인스턴스 컨텍스트에 대해 완화 된 규칙을&lt;/a&gt; 사용한다고 가정) ). 예를 들어 고려</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">Haskell-98 스타일 데이터 형식 선언과 달리 &quot; &lt;code&gt;data Set a where&lt;/code&gt; &quot;헤더 의 형식 변수 에는 범위가 없습니다. 실제로, 대신에 친절한 서명을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">표현식 및 선언 유형 서명과 달리 패턴 유형 서명은 암시 적으로 일반화되지 않습니다. &lt;em&gt;패턴 바인딩&lt;/em&gt; 의 &lt;em&gt;패턴&lt;/em&gt; 은 이미 범위에있는 유형 변수 만 언급 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 과 달리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 의 인스턴스 는 &lt;code&gt;encode'&lt;/code&gt; 가 아니라 &lt;code&gt;encode&lt;/code&gt; '를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; 형식의 일반 선언 스플 라이스와 달리 선언 준 따옴표는 선언 그룹을 중단시키지 않습니다. 자세한 정보는 &lt;a href=&quot;#th-syntax&quot;&gt;구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">일반적인 선언 스플 라이스와 달리 선언 준 따옴표는 분리되지 않습니다. 이 준표자는 나머지 선언 그룹이 처리되기 전에 확장되고 생성 된 선언은 주변 선언 그룹에 병합됩니다. 따라서, 볼 타입 환경 &lt;code&gt;reify&lt;/code&gt; 선언의 quasiquoter에서이 quasiquoter의 선언 그룹에서 아무것도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">서명 파일에 선언 된 엔터티 만 범위로 가져 오는 다른 선언과 달리 구현의 인스턴스는 서명 파일에서 선언되지 않은 경우에도 항상 범위로 가져옵니다. 이것은 모듈이 서명에 대해서는 타입 검사를 할 수 있지만 일치하는 구현에 대해서는 검사 할 수 없음을 의미합니다. 서명이있는 패키지 내에 고아 인스턴스를 정의하지 않으면 이와 같은 상황을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">다른 제거 기능과 달리이 기능은 읽기 전용으로 표시되거나 권한으로 인해 제거 할 수없는 파일을 삭제하려고 시도합니다. 결과적으로 제거가 완료되지 않으면 나머지 파일의 권한 또는 속성이 변경 될 수 있습니다. 디렉토리에 하드 링크가 있으면 모든 관련 하드 링크에 대한 권한이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">비슷한 이름의 다른 함수와 달리 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 는 Win32 API의 &lt;code&gt;SearchPath&lt;/code&gt; 를 사용하지 않습니다 . 따라서 Windows에서이 기능의 동작은 Windows 이외의 플랫폼에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">일반 모듈과 달리 서명의 정의 된 엔터티에는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일에 작성된 엔터티 뿐만 아니라 상속 된 서명의 엔터티 도 포함됩니다 ( &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 플래그 에서 유추 ). 이러한 엔티티는 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일을 유형 검사 할 때 범위 내에서 고려되지 않지만 서명을 가져 오는 모듈 또는 서명으로 가져올 수 있습니다. 이 규칙의 예외는 아래에 설명 된 내보내기 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 묶인 타입 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 의 방정식 의 오른쪽에 걸쳐 있습니다. (따라서 구별 유형 변수 사용할 필요가 없다; 사용 &lt;code&gt;a&lt;/code&gt; . 동등한 것)를</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">달리 &lt;code&gt;forall&lt;/code&gt; 형태 가변형 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;f&lt;/code&gt; 의 범위를 통해 서명되지 &lt;code&gt;f&lt;/code&gt; 의 식 (S). 패턴 시그니처로 바인딩 된 유형 변수 &lt;code&gt;aa&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 방정식 의 오른쪽 범위로 지정 됩니다. (따라서 고유 한 유형 변수를 사용할 필요가 없습니다. &lt;code&gt;a&lt;/code&gt; 를 사용 하는 것은 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">연관된 유형 패밀리 선언 자체와 달리 기본 인스턴스의 유형 변수는 상위 클래스의 유형 변수와 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 의 기본 정의와 달리 0에 대해 정의되므로 가능하면 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전 예제와 달리 현재는 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용하여 모호성을 수동으로 해결할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="translated">일반 데이터 정의와 달리 데이터 계열의 결과 종류는 &lt;code&gt;Type&lt;/code&gt; 일 필요가 없습니다 . 또는 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">일반 데이터 정의와는 달리, 데이터 가족의 결과 종류 일 필요는 없습니다 &lt;code&gt;Type&lt;/code&gt; : 그것은 양자 택일 (와 종류의 변수가 될 수 있습니다 &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ). 그러나 데이터 인스턴스의 종류는 &lt;code&gt;Type&lt;/code&gt; 으로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">:-) GHC에 제공하는 유용한 편집증 옵션은 &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lint 옵션입니다. 이로 인해 각 코어에서 코어로의 변환 패스 후 &quot;보풀이없는&quot;패스가 오류 (특히 유형 오류)를 확인합니다. 우리는 &lt;code&gt;-dcore-lint&lt;/code&gt; 실행 합니다. 컴파일 시간이 약 5 %입니다.</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">세마포어를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">벡터의 요소를 언 박스 튜플에 풉니 다. #</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">압축 풀기 생성자 필드는 컴파일러에 펼침을 표시하여 가능한 한 자주 복싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">Unpacking 생성자 필드는 Unfolding을 컴파일러에 노출하여 가능한 한 자주 리 박싱을 제거 할 수 있도록 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt; 1&lt;/a&gt; 과 함께 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">활성 시간 초과를 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">등록되지 않은 컴파일은 GHC를 새로운 머신으로 포팅 할 때 유용 할 수 있습니다. 이는 사전 설치 도구를 &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 로 줄이며 그 외에는 더 이상 등록되지 않은 컴파일을 얻기 위해 작성해야하는 플랫폼 별 코드의 양을 줄여 주기 때문입니다. 가는 것은 보통 아주 작습니다.</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">컴파일 타임에는 등록되지 않은 컴파일을 선택할 수 없습니다. 적절한 옵션 세트로 GHC를 빌드해야합니다. 자세한 내용은 GHC 빌딩 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (첨자) 연산자, 0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 반환 반환 범위 검사를 생략합니다. 이는 프로그래머가 범위를 다른 방식으로 검사하도록 보장해야 할 의무가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">0부터 시작하여 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 을 반환하는 안전하지 않은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 인덱스 (아래 첨자) 연산자입니다. 이는 경계 검사를 생략합니다. 이는 프로그래머가 다른 방식으로 경계를 검사해야한다는 의무가 수반된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">안전하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 작업</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">안전하지 않은 API 만.</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">안전하지 않은 IO 작업</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 사이의 안전하지 않은 변환 . 이것은 no-op이며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성에 편의상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 간의 안전하지 않은 변환 . 이것은 작동하지 않으며 8 비트 Chars&amp;gt; '255'로 자동으로 잘립니다. ByteString 구성의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">안전하지 않은 변환 코드</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">소수 자릿수에 대한 안전하지 않은 변환.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">안전하지 않은 기능</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">안전하지 않은 일반 결합 기능</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">안전하지 않은 저수준 작업</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">안전하지 않은 작업</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 수준 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">안전하지 않은 기계 수준의 원자 단위 비교 및 ​​배열 내의 요소 교체.</target>
        </trans-unit>
        <trans-unit id="da875dda0af919ad5cb1b82f3bb406408186e93d" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array. See the documentation of &lt;code&gt;casArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">STM 모나드에서 IO를 안전하지 않게 수행합니다. 조심하십시오 : 이것은 매우 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">특정 옵션을 설정 해제합니다. 사용 가능한 옵션 목록은 &lt;a href=&quot;#ghci-set&quot;&gt;: set 및 : seti 명령&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">부호없는 정수 유형.</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">부호없는 정수 유형</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 소리</target>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="translated">불건전 불건전 불건전 불건전 불건전 불건전 불건전</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">불안정한 스냅 샷 릴리스의 이름은 &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; 입니다. 여기서 &lt;code&gt;YYYYMMDD&lt;/code&gt; 는 스냅 샷이 작성된 소스의 날짜입니다. 예를 들어, &lt;code&gt;6.7.20040225&lt;/code&gt; 는 &lt;code&gt;6.8&lt;/code&gt; 분기를 만들기 전에 HEAD의 스냅 샷입니다 .</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">상태 모나드 계산을 함수로 푸십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 (결과, 출력) 쌍으로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">라이터 계산을 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWST 계산을 함수로 랩핑 해제하십시오. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; 의 반대 )</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">누적 계산을 (결과, 출력) 쌍으로 래핑 해제합니다. (의 역 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">누적 계산을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">일련의 쌍을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">문자가 지정된 소스 위치를 업데이트하십시오. 문자가 개행 ( ​​'\ n') 또는 캐리지 리턴 ( '\ r') 인 경우 행 번호는 1 씩 증가합니다. 문자가 탭 ( 't') 인 경우 열 번호는 가장 가까운 8 '까지 증가합니다 열, 즉 &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; . 다른 모든 경우에는 열이 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">지정된 시간 (마이크로 초) 내에 실행되도록 활성 시간 초과를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">&quot; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &quot;을 사용하여 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; 대해 미리 작성된 정확한 바이트 수를 계산하십시오 . 경우 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 가 작성되고보고 제로 반면, 기록 된 바이트 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 에 보고 한 바이트.</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt; 사용할 프로그램을 선택 하려면 -pgmF ⟨cmd⟩ 를 사용하십시오 . ⟨cmd⟩ 프리 프로세서는 명령 행에 최소한 세 개의 인수가 제공됩니다. 첫 번째 인수는 원본 소스 파일의 이름이고, 두 번째는 입력을 보유한 파일의 이름이며, 세 번째는 ⟨cmd⟩가 출력을 기록해야하는 파일의 이름</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; 규칙이 해고되고 있는지 아주 자세하게 볼 수 있습니다. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">사용 &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt; 정의 된 규칙 확인 &lt;em&gt;이 모듈을&lt;/em&gt; . 여기에는 전문화 단계에서 생성 된 규칙이 포함되지만 다른 모듈에서 가져온 규칙은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실행중인 규칙을 확인하십시오. &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt; 를 추가 하면 더 자세한 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 를 사용 하고 중단 가능한 작업을 피 하십시오 . 이를 위해서는 인터럽트가 가능한 작업을 알아야합니다. 주어진 라이브러리 함수에 대해 내부적으로 인터럽트 가능한 조작을 호출 할 수 있는지 여부를 알 수 없습니다. 대신 아래에 보장 할 수없는 보장 가능한 작업 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 범위 동안 호출 된 인터럽트 가능 조작 이 단시간 동안 만 차단 될 수 있다는 것을 보장 할 수 없으면 일반적으로 권장되지 않습니다 . 그렇지 않으면, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 는 프로그램을 교착 상태로 만들고 사용자 인터럽트에 응답하지 않는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">이 문제를 피 하려면 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 의 동작을 얻으려면 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; 을 사용 하여 &lt;a href=&quot;data-monoid&quot;&gt;Data&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 의 동작을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">사용 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 모든 기능에 프라그으로 &lt;code&gt;foo&lt;/code&gt; 를 호출 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 을 . 호출이 인라인되면 I / O가 두 번 이상 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">실행 파일에 &lt;strong&gt;strip&lt;/strong&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">LLVM을 통해 컴파일하는 대신 GHC의 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;고유 코드 생성기를&lt;/a&gt; 사용하십시오 . &lt;code&gt;-fasm&lt;/code&gt; 이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="translated">일반 모듈에서 GHCi의 확장 된 기본 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">STM을 사용하십시오. 트랜잭션은 항상 완전히 실행되거나 전혀 실행되지 않기 때문에 트랜잭션은 비동기 (및 실제로 동기) 예외가있는 상태에서 변하지 않는 상태를 유지하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 를 입력 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 증거 로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">더 큰 힙을 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">가장 오래된 세대를 수집하려면 압축 알고리즘을 사용하십시오. 기본적으로 가장 오래된 세대는 복사 알고리즘을 사용하여 수집됩니다. 이 옵션을 사용하면 대신 해당 위치로 압축됩니다. 압축 알고리즘은 복사 알고리즘보다 속도가 느리지 만 메모리 사용량을 상당히 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">ApplicativeDo에 대해 느리지 만 더 나은 알고리즘 사용</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">제목에 작은 상자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">사전 선택기에 특수 수요 변압기를 사용하십시오. 항상 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">다음과 같이 레코드 표현식에 명시 적 유형 서명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">오류 메시지에 색상 사용</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">GHCi 명령 히스토리 파일 &lt;code&gt;.ghci-history&lt;/code&gt; 에 현재 디렉토리를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">사이의 값을 소수점 표기법을 사용하여 &lt;code&gt;0.1&lt;/code&gt; 및 &lt;code&gt;9,999,999&lt;/code&gt; 달리, 과학 표기법을.</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="babd2ff76089a3d1f8aa9f2a697eb17aef342e31" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">주어진 파일에서 입력을 읽고 파일 스타일 상호 작용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">외국 수출 신고를 사용하여 외부에서 호출하려는 Haskell 함수를 수출하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자원 제한으로 사용하십시오. &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 와 함께 간단한 프로파일 링 메커니즘으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">세대 Cgen⟩ 이상의 병렬 GC에서로드 밸런싱을 사용하십시오. ⟨gen⟩을 생략하면로드 밸런싱이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">더 많은 메모리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">이 유형의 사용은 권장하지 않습니다. 다음과 같은 내용을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">세대 ⟨gen⟩ 이상에서는 병렬 GC를 사용하십시오. ⟨gen⟩을 생략하면 병렬 GC가 완전히 꺼지고 순차적 GC로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">posix setgid를 사용하여 하위 프로세스의 그룹 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">posix setsid를 사용하여 새 세션에서 새 프로세스를 시작하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">posix setuid를 사용하여 하위 프로세스의 사용자 ID를 설정하십시오. 다른 플랫폼에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">이전 매개 변수를 사용하십시오. 기본적으로 PostScript 그래프는 페이지를 채울 수 있도록 가로 및 세로로 자동 배율이 조정됩니다. 그러나 프리젠 테이션에 사용할 일련의 그래프를 준비 할 때 이전 그래프와 동일한 스케일, 음영 및 순서를 사용하여 새 그래프를 그리는 것이 종종 유용합니다. &lt;code&gt;-p&lt;/code&gt; 플래그의 이전 실행에 의해 결정된 파라미터를 사용하여 그려 그래프 발생 &lt;code&gt;hp2ps&lt;/code&gt; 에 &lt;code&gt;file&lt;/code&gt; . 이들은 &lt;code&gt;file@.aux&lt;/code&gt; 에서 추출됩니다 .</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">정적 하스켈 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">엄격 주석을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 이 터미널이 아닌 경우에도 가능하면 터미널 스타일의 상호 작용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c701d48b2ddc2ad9f38319eaef995257ab48d8b" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;codegens#native-code-gen&quot;&gt;네이티브 코드 생성기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 블록 에서 반박 가능한 패턴을 제거 할 때 레거시 &lt;code&gt;Monad.fail&lt;/code&gt; 함수 대신 &lt;code&gt;MonadFail.fail&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="translated">C 코드 생성기를 사용하십시오. 등록되지 않은 GHC 빌드에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="translated">Haskell 2010 언어 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">OS 선호도 기능을 사용하여 OS 스레드를 CPU 코어에 고정하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
