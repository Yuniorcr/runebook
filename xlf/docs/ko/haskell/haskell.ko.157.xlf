<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="39accf2eb466f5f7950fa262a0b934abef85ea1f" translate="yes" xml:space="preserve">
          <source>Indicates if unlocking was successful, if not query getLastError.</source>
          <target state="translated">잠금 해제가 성공했는지 여부를 나타냅니다. 그렇지 않은 경우 getLastError를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">이 RunTH가 완료되었음을 나타내고 다음 메시지는 RunTH (QResult)의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">간접 지정에는 두 개의 특수 디렉토리가 포함 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;..&lt;/code&gt; 및 모든 심볼릭 링크 (및 Windows의 연결 지점). 입력 경로는 기존 파일 또는 디렉토리를 가리킬 필요가 없습니다. 정규화는 기존 파일 또는 디렉토리를 가리키는 경로의 가장 긴 접두사에서 수행됩니다. 기존 파일 또는 디렉토리를 가리 키지 않는 경로의 나머지 부분은 여전히 ​​정규화되지만 존재하지 않는 경로에서는 불가능하므로 대소 문자 표준화 및 간접 제거가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">생성자의 개별 필드 : &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">기본적으로 로컬 바인딩에 대해 다형성 유형이 적습니다.</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="0fb53a8fadb337cee5f4d84c1662f6c7a3cd7d5a" translate="yes" xml:space="preserve">
          <source>Inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example is &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">추론 된 변수는 중괄호로 인쇄됩니다. 따라서 이전 예제 의 데이터 생성자 &lt;code&gt;Proxy&lt;/code&gt; 유형 은 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; . GHCi 세션에서이 동작을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d01d742994f65d06832b042946ae6540ea435b" translate="yes" xml:space="preserve">
          <source>InferredSpec</source>
          <target state="translated">InferredSpec</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">다른 유형의 평등 추론</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">⟨type⟩의 종류를 유추하고 인쇄합니다. 후자는 &lt;code&gt;Either Int&lt;/code&gt; 와 같은 형식 생성자의 부분 응용 프로그램을 포함하여 임의 형식 식일 수 있습니다 . 실제로 &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt; 를 사용하면 형식 동의어의 일부 응용 프로그램 (일반적으로 허용되지 않음)을 작성할 수 있으므로 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b107164b72629a12fc9de20620c30233bc8a18cb" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;exts/type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">⟨expression⟩의 유형을 추론하고 인쇄하지만 유형 변수 또는 클래스 제약 조건을 다루지 않습니다. 이것은 &lt;a href=&quot;exts/type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용 하고 지정된 유형 변수 (유형 응용 프로그램에 사용 가능)와 유추 된 유형 변수 (사용할 수 없음) 간의 구별에 관심 이있을 때 유용합니다 . 이 모드는 때때로 쉽게 해결할 수있는 제약 조건 (예 : &lt;code&gt;Show Int&lt;/code&gt; )을 인쇄 하지만 이러한 제약 조건을 해결하면 유형 변수에 영향을 미칠 수 있으므로 GHC는 자제합니다.</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">⟨expression⟩의 유형을 유추하고 인쇄하지만 유형 변수 또는 클래스 제약 조건을 다루지 않습니다. 이는 &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 를 사용 하고 지정된 유형 변수 (유형 응용 프로그램에 사용 가능)와 유추 된 유형 변수 (사용할 수 없음) 사이의 구별에주의 할 때 유용합니다 . 이 모드는 때때로 쉽게 해결할 수있는 제약 조건 (예 : &lt;code&gt;Show Int&lt;/code&gt; )을 인쇄 하지만 이러한 제약 조건을 해결하면 유형 변수에 영향을 줄 수 있으므로 GHC가 다시 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">가능한 경우 기본 유형 변수 인 ⟨expression⟩의 유형을 유추하고 인쇄합니다. 이 모드에서 유추 된 유형이 대화식 클래스 ( &lt;code&gt;Num&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Foldable&lt;/code&gt; 또는 &lt;code&gt;Traversable&lt;/code&gt; )에 의해 제한되는 경우 제한 유형 변수는 &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; 에&lt;/a&gt; 설명 된 규칙에 따라 기본값이 설정됩니다 . 이 모드는 유추 된 유형이 매우 일반적인 경우 (예 : &lt;code&gt;foldr&lt;/code&gt; ) 에보다 유용하며보다 구체적인 인스턴스를 보는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">다형성 유형에 대한 모든 정량자를위한 명시 적 표현을 포함하여 표현 유형을 유추하고 인쇄합니다. 보고 된 유형은 표현식에 지정된 변수에 대해 유추되지만 단형 제한이 적용되지 않은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">무한 바이트 문자열</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">무한리스트</target>
        </trans-unit>
        <trans-unit id="51da236acb5f8cdb6fe7b72a8257afecb4400026" translate="yes" xml:space="preserve">
          <source>Infinite structures</source>
          <target state="translated">무한 구조</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="1a2524f2cdc191259a8cb8d6d990ea9482634447" translate="yes" xml:space="preserve">
          <source>Infix version of &lt;code&gt;&lt;a href=&quot;ghc-io-subsystem#v:conditional&quot;&gt;conditional&lt;/a&gt;&lt;/code&gt;. posix &lt;a href=&quot;!&quot;&gt;!&lt;/a&gt; windows == conditional posix windows</source>
          <target state="translated">의 중위 버전 &lt;code&gt;&lt;a href=&quot;ghc-io-subsystem#v:conditional&quot;&gt;conditional&lt;/a&gt;&lt;/code&gt; . posix &lt;a href=&quot;!&quot;&gt;! &lt;/a&gt;windows == 조건부 posix 창</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">비공식적으로 &lt;code&gt;Strict&lt;/code&gt; 언어 확장 기능은 기본적으로 함수, 데이터 유형 및 바인딩을 엄격하게 전환 하여 변수 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가하여 선택적 게으름을 허용 합니다. 이것은 본질적으로 게으름이 기본값이고 엄격함을 선택적으로 가질 수있는 현재 상황을 역전시킵니다 &lt;code&gt;!&lt;/code&gt; 변수 앞에.</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">비공식적으로 &lt;code&gt;StrictData&lt;/code&gt; 언어 확장은 기본적으로 필드 앞에 &lt;code&gt;~&lt;/code&gt; 를 추가하여 필드를 지연시킬 수 있도록 데이터 유형 선언을 엄격하게 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">비공식적으로 닫힌 표현이 있다면</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">정보 보존</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">수신 된 신호에 대한 정보 ( &lt;code&gt;siginfo_t&lt;/code&gt; 에서 파생 됨 ).</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">프로그램을 실행할만큼 운이 좋은 호스트 시스템의 특성에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">컴퓨터에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">특정 유형의 신호에 특정한 정보 ( &lt;code&gt;siginfo_t&lt;/code&gt; 에서 파생 됨 ).</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">부모로부터 상속 핸들</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">회선 지향 사용자 상호 작용 세션을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">주어진 터미널 항목으로 terminfo 라이브러리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TERM&lt;/code&gt; 환경 변수를 사용하여 terminfo 라이브러리를 초기화하십시오 . &lt;code&gt;TERM&lt;/code&gt; 이 설정되지 않은 경우 일반 최소 엔트리 &lt;code&gt;dumb&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 를&lt;/a&gt; 초기화합니다 . 이것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">모나 딕 타입에 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">인젝 티브 유형 패밀리는 &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; 언어 확장으로 사용 가능 합니다. 이 확장은 &lt;code&gt;-XTypeFamilies&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">주 입성 주석</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">사출 성 주석은 패밀리 헤드 유형 뒤에 추가되며 다음 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">인라인 &lt;code&gt;memcpy&lt;/code&gt; 는 &quot;nn&quot;유사 명령어를 생성하지 않으면 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">n 개의 의사 명령어를 생성하지 않는 인라인 &lt;code&gt;memset&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">입출력</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">입력 기능</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">입력 문자열.</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">텍스트를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">맨 아래 표현식 뒤에 &lt;code&gt;error&lt;/code&gt; 표현식을 삽입하십시오 . 컴파일러를 디버깅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">주어진 위치에 스칼라를 벡터로 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내부에서 &quot; &lt;code&gt;forall&lt;/code&gt; &quot;은 다른 플래그 설정에 관계없이 키워드로 처리됩니다. 또한 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내부 에서 언어 확장 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 가 자동으로 활성화됩니다. 사전 &lt;a href=&quot;#scoped-type-variables&quot;&gt;범위 유형 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94d741748ca5ae1bc40ce11d1afc506bcc3344ad" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내부에서 &quot; &lt;code&gt;forall&lt;/code&gt; &quot;은 다른 플래그 설정에 관계없이 키워드로 처리됩니다. 또한 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; 내 에서 언어 확장 &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 가 자동으로 활성화됩니다. &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically 범위 유형 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 내부의 &quot; &lt;code&gt;forall&lt;/code&gt; &quot;은 다른 플래그 설정에 관계없이 키워드로 취급됩니다. 또한 RULE 내에서 언어 확장 &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt; 가 자동으로 사용됩니다. 사 &lt;a href=&quot;#scoped-type-variables&quot;&gt;전적으로 범위가 지정된 유형 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">스플 라이스 내에서는 가져온 모듈에 정의 된 함수 만 호출 할 수 있으며 동일한 모듈의 다른 곳에 정의 된 함수는 호출 할 수 없습니다. 선언 스플 라이스는 최상위 수준 (다른 선언 제외) 이외의 다른 곳에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">&lt;em&gt;과부하 및 고차 다형성을 이용한 기능적 프로그래밍&lt;/em&gt; 논문 인 Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) ( 1995) 고급 기능성 스쿨.</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">&lt;em&gt;과부하 및 고차 다형성을 통한 기능적 프로그래밍&lt;/em&gt; 논문 인 Mark P Jones ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt; ) 1995 년 고급 기능성 프로그래밍 학교에서 영감을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">^ C를 잡기 위해 표준 시그널 핸들러를 설치하십시오. 이것은 타겟 스레드에서 예외를 던집니다. 현재 대상 스레드는 installSignalHandlers에 전달 된 MVar의 목록 헤드에있는 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">보안 제어판을 사용하여 시스템의 설치 프로그램 감지 기능을 전체적으로 끌 수도 있지만 GHC는 기본적으로 설치 프로그램 감지 기능을 해제 한 사용자에 의존하지 않는 바이너리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="221ab4fc522872824cd72443453566a64d62e095" translate="yes" xml:space="preserve">
          <source>Instance declarations</source>
          <target state="translated">인스턴스 선언</target>
        </trans-unit>
        <trans-unit id="799a53eb0cd003248b751073c77a5d5c34971dc1" translate="yes" xml:space="preserve">
          <source>Instance declarations are not allowed to be declared with nested &lt;a href=&quot;#id7&quot;&gt;&lt;span id=&quot;id8&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s or &lt;a href=&quot;#id9&quot;&gt;&lt;span id=&quot;id10&quot;&gt;``&lt;/span&gt;&lt;/a&gt;=&amp;gt;``s. For example, this would be rejected:</source>
          <target state="translated">인스턴스 선언은 중첩 된 &lt;a href=&quot;#id7&quot;&gt;&lt;span id=&quot;id8&quot;&gt;''&lt;/span&gt;&lt;/a&gt; forall &lt;a href=&quot;#id9&quot;&gt;&lt;span id=&quot;id10&quot;&gt;''&lt;/span&gt;&lt;/a&gt; 또는 &lt;span id=&quot;id10&quot;&gt;``&lt;/span&gt; =&amp;gt;`` 로 선언 할 수 없습니다 . 예를 들어 다음과 같이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">인스턴스 선언은 헤드가 정확히 동일한 경우에만 병합되므로 서명이없는 인스턴스가 겹치지 않는 방식으로 구현 된 경우에도 GHC가 시그니처의 인스턴스가 겹치는 것으로 생각하는 상황에 빠질 수 있습니다. 이것이 당신에게 문제를 낳고 있다면 우리에게 소리를 지르십시오.</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">데이터 및 newtype 패밀리의 인스턴스 선언은 표준 데이터 및 newtype 선언과 매우 유사합니다. 유일한 차이점은 키워드 &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; 다음에 &lt;code&gt;instance&lt;/code&gt; 있고 유형 인수의 일부 또는 전부가 변수가 아닌 유형일 수 있지만 모든 유형 또는 유형 동의어 패밀리를 포함 할 수는 없다는 것입니다. 그러나 데이터 패밀리는 일반적으로 유형 매개 변수에서 허용되며, 유형 동의어는 클래스 인스턴스 매개 변수에서 유형 동의어가 발생하는 데 필요한대로 완전히 적용되고 자체적으로 허용되는 유형으로 확장되는 한 허용됩니다. 예를 들어, &lt;code&gt;GMap&lt;/code&gt; 의 &lt;code&gt;Either&lt;/code&gt; 인스턴스 는</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">유형 패밀리의 인스턴스 선언은 표준 유형 동의어 선언과 매우 유사합니다. 단 두 가지 차이점은 키워드 &lt;code&gt;type&lt;/code&gt; 다음에 &lt;code&gt;instance&lt;/code&gt; 있고 유형 인수의 일부 또는 전부가 변수가 아닌 유형일 수 있지만 모든 유형 또는 유형 동의어 패밀리를 포함 할 수는 없다는 것입니다. 그러나 데이터 계열은 일반적으로 허용되며 형식 동의어는 완전히 적용되고 허용되는 형식으로 확장되는 한 허용됩니다. 이는 데이터 인스턴스와 정확히 동일한 요구 사항입니다. 예를 들어, &lt;code&gt;Elem&lt;/code&gt; 의 &lt;code&gt;[e]&lt;/code&gt; 인스턴스 는</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">인스턴스 세부 사항</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">인스턴스 조회</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 유사합니다 . 예를 들어 데이터 유형</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 와 유사합니다 . 예를 들어 데이터 유형</target>
        </trans-unit>
        <trans-unit id="85623227591bc8f2cac930639d86e2c526f030d5" translate="yes" xml:space="preserve">
          <source>Instances can be derived automatically by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; extension. For example, a derived instance for a binary tree might be:</source>
          <target state="translated">인스턴스는 &lt;code&gt;DeriveFoldable&lt;/code&gt; 확장 을 활성화하여 자동으로 파생 될 수 있습니다 . 예를 들어 이진 트리의 파생 인스턴스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">인스턴스 세부 사항</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">구성 유형이 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인 사용자 정의 데이터 유형에 대해 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 데이터 선언에서 생성자의 선언 순서는 파생 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 의 순서를 결정합니다 . &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 데이터 타입은 하나의 비교는 두 객체의 정확한 순서를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">인스턴스의 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 모든 열거 형에 대해 유도 될 수있다 (그 유형에는 생성자 필드가 없음). nullary 생성자는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;n-1&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 으로 왼쪽 에서 오른쪽으로 번호가 매겨진 것으로 가정합니다 . 자세한 내용은 &lt;em&gt;Haskell 보고서의&lt;/em&gt; 10 장 을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">인스턴스의 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 모든 열거 형에 대해 유도 될 수있다 (그 유형에는 생성자 필드가 없음). nullary 생성자는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;n-1&lt;/code&gt; 사이의 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 으로 왼쪽 에서 오른쪽으로 번호가 매겨진 것으로 가정합니다 . 자세한 내용은 &lt;em&gt;Haskell 보고서의&lt;/em&gt; 10 장 을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">의 인스턴스 &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 는 다음과 같은 법칙을 만족해야한다 : &lt;code&gt;fail s&lt;/code&gt; 에 대한 왼쪽 0이어야합니다 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">구성 유형이 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인 사용자 정의 데이터 유형에 대해 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스를 파생시킬 수 있습니다 . 데이터 선언에서 생성자의 선언 순서는 파생 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 인스턴스 의 순서를 결정합니다 . &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 데이터 타입은 하나의 비교는 두 객체의 정확한 순서를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">의 인스턴스 &lt;code&gt;Monoid&lt;/code&gt; 또한 인스턴스해야 &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">이진 인스턴스는 다음 속성을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">이러한 클래스의 인스턴스는 &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; 확장을 사용하여 GHC에 의해 파생 될 수 있으며 일반 인스턴스를 자동으로 정의 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="65c1e5f128f1f1839602ec922ecbb3d89a2bfa33" translate="yes" xml:space="preserve">
          <source>Instances should ensure that, in the following code:</source>
          <target state="translated">인스턴스는 다음 코드에서 다음을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="60ec83a7328fd0f4c726f4dd91a7d148a7b39c03" translate="yes" xml:space="preserve">
          <source>Instances should obey the following law:</source>
          <target state="translated">인스턴스는 다음 법률을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">인스턴스는 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 가 모나드 변환기 인 다음과 같은 법률을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">인스턴스는 다음 법률을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">인스턴스는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">인스턴스는 법을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">대신 두 번역 애플리케이션으로 화살표 (화살표 꼬리)의 단일 형태, 구현은 두 가지 형태로 제공 &lt;code&gt;-&amp;lt;&lt;/code&gt; (제 1 차) 및 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (높은 순서).</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">GHC는 실행 파일을 생성하는 대신이 링커 플래그를 사용하여 공유 객체를 생성합니다. 운영 체제 대상에 따라 ELF DSO, Windows DLL 또는 Mac OS dylib 일 수 있습니다. GHC는이 균일 플래그 아래에 운영 체제 세부 사항을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 소개합니다 . &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용될 때이 매개 변수는 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 인수 를 참조 하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="4d75fde1ad8ce1fe9457a9340d10b92d1fe2f1c4" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 도입합니다 . &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용되는 경우이 매개 변수는 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 의 인수를 참조하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 소개합니다 . &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용될 때이 매개 변수는 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 인수 를 참조 하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="f408254609f2594f75fbcdb0b71c211f8a49859f" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">재귀 호출을하는 대신 더미 매개 변수 &lt;code&gt;rec&lt;/code&gt; 를 도입합니다 . &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 내에서 사용되는 경우이 매개 변수는 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 의 인수를 참조하므로 재귀가 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 을 재사용하는 대신 별도의 데이터 패밀리 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; 을 사용하여 일반적인 리프팅되지 않은 유형의 발생을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">대신 &lt;code&gt;case&lt;/code&gt; 표현식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">대신 &lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 . 어떤이 실행 &lt;code&gt;main&lt;/code&gt; 인수와 범위에는, 예를 들어, 명령 줄 인수, 같은 치료를 받고 :</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 함수를 제공 하여 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">대신, 실제로 원하는 예외 만 정확하게 잡아야합니다. 이 경우 이는 &quot;모든 IO 예외&quot;보다 더 구체적 일 수 있습니다. 권한 오류는 다르게 처리되기를 원할 것입니다. 대신 다음과 같은 것을 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">대신 &lt;code&gt;foo&lt;/code&gt; 를 클래스 작업으로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="translated">지시 &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 사용하기 위하여 인쇄하십시오 &lt;code&gt;Show&lt;/code&gt; 가능한 Show 인스턴스 하십시오.</target>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">위치 독립적 인 실행 파일을 생성하도록 링커에 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">GHC가 값을 인라인하기에 특히 저렴한 것으로 간주하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수 호출 중에 벡터 인수를 전달하기 위해 플랫폼의 기본 벡터 레지스터를 사용하도록 GHC에 지시합니다. 모든 벡터 지원과 마찬가지로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">GHC 드라이버가 일반적으로 &lt;code&gt;/tmp&lt;/code&gt; 또는 다른 위치에 보관하는 임시 파일을 삭제하지 않도록 지시합니다 ( &lt;a href=&quot;#temp-files&quot;&gt;임시 파일 리디렉션&lt;/a&gt; 참조 ). &lt;code&gt;-v&lt;/code&gt; 와 함께 GHC를 실행 하면 어떤 임시 파일이 생성되었는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="translated">호출에서 &lt;code&gt;undef&lt;/code&gt; 대신 가비지로 사용 불능 STG 레지스터를 채우도록 LLVM 코드 생성기에 지시 합니다. 이를 통해 미묘한 코드 생성기 및 런타임 시스템 버그를 쉽게 포착 할 수 있습니다 (예 :&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt; 파악할 수 있습니다 # 11487&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">LLVM 코드 생성기에 불완전한 STG 레지스터를 호출시 &lt;code&gt;undef&lt;/code&gt; 대신 가비지로 채우도록 지시 합니다. 이를 통해 미묘한 코드 생성기 및 런타임 시스템 버그를 쉽게 잡을 수 있습니다 (예 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;이슈 # 11487&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">컴파일러가 값을 인라인하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">생성자 필드의 압축을 풀지 않도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">생성자 필드의 내용을 생성자 자체에 압축 해제하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">단순화기에 &lt;code&gt;error&lt;/code&gt; 를 방출하도록 지시합니다.빈 사례 분석 (하단 및 결과적으로 반환되지 않아야 함)을 계속할 때 표현 . 이는 때때로 세그먼트 결함으로 나타날 수있는 수요 분석 버그를 디버깅 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">작업을 수행 할 수있는 리소스가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">INT 결과</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="4764bca69c81c35d030020e51edddf17222f768e" translate="yes" xml:space="preserve">
          <source>Int32Rep</source>
          <target state="translated">Int32Rep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">정수 결과</target>
        </trans-unit>
        <trans-unit id="5b14f5b085db1d133e9ea53c0ae99ca5b12454fa" translate="yes" xml:space="preserve">
          <source>Integers are stored in a kind of sign-magnitude form, hence do not expect two's complement form when using bit operations.</source>
          <target state="translated">정수는 일종의 부호 크기 형식으로 저장되므로 비트 연산을 사용할 때 2의 보수 형식을 기대하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">정수 나누기를 지원하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">일체형</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">포인터와의 무손실 변환이 가능한 정수 유형</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">고정 배열과 함께 사용하도록 고안되었습니다. 그렇지 않으면 매우 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">대화식 모드-일반적으로 &lt;code&gt;ghci&lt;/code&gt; 를 실행하여 사용됩니다 . &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용을&lt;/a&gt; 참조하십시오 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ghci&lt;/strong&gt; 로도 사용할 수있는 대화식 모드 . 대화식 모드는 &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용에&lt;/a&gt; 자세히 설명되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">대화식 세션</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러가 생성 한 중간 C 파일.</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">처리 파이프 라인의 중간 결과.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">argv의 내부 인코딩</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">스파크를 실행하기 위해 RTS에서 사용하는 내부 기능.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">내부 구현</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다. 이 모듈의 내용은 플랫폼에 따라 다르므로 Hackage 설명서에 표시된 내용은 시스템에서 실제로 사용 가능한 내용과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">ShortByteString의 내부 표현</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">내부 자료 : ByteString FilePath 지원</target>
        </trans-unit>
        <trans-unit id="cd6b4c82116a3ab03a952912381612ba9253116d" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC의 내부는 아직 세 번째 평등 관계 &lt;code&gt;(~#)&lt;/code&gt; 입니다. 이기종 ( &lt;code&gt;~~&lt;/code&gt; 와 같은 )이며 내부적으로 만 사용됩니다. &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우에만 오류 메시지 및 기타 출력에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC 내부는 아직 세 번째 평등 관계 &lt;code&gt;(~#)&lt;/code&gt; 입니다. 이기종 ( &lt;code&gt;~~&lt;/code&gt; 같은 )이며 내부적으로 만 사용됩니다. &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 일&lt;/a&gt; 때만 오류 메시지 및 기타 출력에 나타날 수 있습니다. 가 활성화 된 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 버퍼 채우기 기능입니다. 그것들은 채워질 실제 버퍼를 제공 하는 &lt;em&gt;드라이버에&lt;/em&gt; 의해 실행됩니다 . 버퍼로 호출되면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는이를 채우고 드라이버에 신호를 리턴하여 완료되었거나 현재 버퍼를 채우거나 메모리 청크에 대한 참조를 직접 삽입하려고 함을 알려줍니다. 마지막 두 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 드라이버가 다음 버퍼를 채우기 위해 호출 할 수 있는 연속 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 여기서는 거의 모든 사용 사례를 만족시키는 두 가지 드라이버를 제공합니다. 미세 조정에 대한 정보는 &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">내부적으로 빌더는 배열을 하나씩 채우면서 게으른 &lt;code&gt;Text&lt;/code&gt; 를 구성합니다 . 각 버퍼가 채워지면 결과적으로 게으른 &lt;code&gt;Text&lt;/code&gt; 의 새로운 덩어리가되도록 '팝 오프'됩니다 . 이 모든 것은 &lt;code&gt;Builder&lt;/code&gt; 사용자에게 숨겨져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 &lt;code&gt;Word16&lt;/code&gt; UTF-16 코드 단위 의 배열로 표시됩니다 . 생성자의 오프셋 및 길이 필드 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 단위가 &lt;em&gt;아닌&lt;/em&gt; 이러한 단위 입니다.</target>
        </trans-unit>
        <trans-unit id="52f341c327dc6a2b9f9f6adb900102322209af62" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 &lt;code&gt;Word16&lt;/code&gt; UTF-16 코드 단위 의 배열로 표시됩니다 . 생성자의 오프셋 및 길이 필드 는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 단위가 &lt;em&gt;아니라&lt;/em&gt; 이러한 단위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a667adfd3c426aaf0343e5e70da079f910efcf93" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 &lt;code&gt;Word16&lt;/code&gt; UTF-16 코드 단위 의 배열로 표시됩니다 . 생성자의 오프셋 및 길이 필드 는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 단위가 &lt;em&gt;아니라&lt;/em&gt; 이러한 단위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">내부적으로이 함수는 하위 레벨 버퍼링 추상화에서 한 번에 청크를 읽고 전체 파일을 읽은 후에 청크를 단일 문자열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; 모듈의 내부</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">네이티브 코드와의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">통역사 모나드</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">플래그를 구체적인 값으로 해석</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">옵션 레코드의 변환으로 플래그 해석</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">인터럽트 가능한 작업</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="a6ee111a4a83b6eb2aa173dcd6b41a0a9e1f3bf2" translate="yes" xml:space="preserve">
          <source>Interrupts the current wait of the I/O manager if it is currently blocked. This instructs it to re-read how much it should wait and to process any pending events. @since 4.15</source>
          <target state="translated">현재 차단 된 경우 I / O 관리자의 현재 대기를 중단합니다. 이는 대기해야하는 시간을 다시 읽고 보류중인 이벤트를 처리하도록 지시합니다. @ 이후 4.15</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">소개 및 제거 &lt;code&gt;ByteString&lt;/code&gt; 의 들</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">정량화 된 제약 조건을 도입하면 두 가지 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">죽은 STG 레지스터를 쓰레기로 채우는 LLVM 도입</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">직관적으로 이것은 첫 번째와 두 번째 인수가 공변량 인 이중 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">직관적으로 공변량 유형이 &lt;em&gt;생성&lt;/em&gt; 되고 공변량 유형이 사용 &lt;em&gt;됩니다&lt;/em&gt; . Haskell의 대부분 유형은 공변량이지만 함수 유형의 왼쪽은 분산을 뒤집는 점에서 함수 유형이 특별합니다. 함수 타입 인 경우 &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 공변 위치에 표시 (예 &lt;code&gt;CovFun1&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; contravariant 위치에 있고 &lt;code&gt;b&lt;/code&gt; 공변 위치에있다. 만약 마찬가지로, &lt;code&gt;a -&amp;gt; b&lt;/code&gt; contravariant 위치에 표시 (예 &lt;code&gt;CovFun2&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; 이다 공변 위치와 &lt;code&gt;b&lt;/code&gt; contravariant 위치에있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="f30f94b5e7824cc91a857050e0c882e98ceaff86" translate="yes" xml:space="preserve">
          <source>Invariant (canonical representation): higher Word# is non-zero.</source>
          <target state="translated">불변 (표준 표현) : 더 높은 Word #은 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="aca711904cd0afb5b4429984b51cd06c6731bc80" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">불변 : 값이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt; 에 맞지 않는 경우 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4be325aac9fdf79f01267a725e7d6afb3b543711" translate="yes" xml:space="preserve">
          <source>Invariant: A &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; must not be associated with more than one set of finalizers. For example, this is sound:</source>
          <target state="translated">불변 : &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 는 둘 이상의 종료 자 집합과 연결 되어서 는 안됩니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들어, 이것은 소리입니다.</target>
        </trans-unit>
        <trans-unit id="e47339e1c6fcd41f40ed2907ae6002b9cec9f6cc" translate="yes" xml:space="preserve">
          <source>Invariant: The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; in the parent &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is an interior pointer into this &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">불변 : 부모 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 은이 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 대한 내부 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="668f4200fec0082e9da84453223afa7cc5f74c18" translate="yes" xml:space="preserve">
          <source>Invariant: The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; is pinned, so the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; does not get invalidated by the GC moving the byte array.</source>
          <target state="translated">불변 : &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 가 고정되어 있으므로 바이트 배열을 이동하는 GC에 의해 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 이 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d89008df010ecfe1f3e53e4fcbfa9a63476eae95" translate="yes" xml:space="preserve">
          <source>Invariant: numbers &amp;lt;= 0xffffffffffffffff use the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Natural.html#v:NS&quot;&gt;NS&lt;/a&gt;&lt;/code&gt; constructor</source>
          <target state="translated">불변 : 숫자 &amp;lt;= 0xffffffffffffffff &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Natural.html#v:NS&quot;&gt;NS&lt;/a&gt;&lt;/code&gt; 생성자 사용</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">모든 기능이 유지해야하는 불변량 :</target>
        </trans-unit>
        <trans-unit id="d29df8c63e237c937395d3a2b73f553b2eedce66" translate="yes" xml:space="preserve">
          <source>Invoke a finalizer once a foreign pointer becomes unreachable.</source>
          <target state="translated">외부 포인터에 도달 할 수 없게되면 종료자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2306eeb4a0ccc3ac5701782ba0b1a5d4ccbb6396" translate="yes" xml:space="preserve">
          <source>IoNative</source>
          <target state="translated">IoNative</target>
        </trans-unit>
        <trans-unit id="0ed195ad462ef61e760c5ac5c767ddb7f63f43d3" translate="yes" xml:space="preserve">
          <source>IoPOSIX</source>
          <target state="translated">IoPOSIX</target>
        </trans-unit>
        <trans-unit id="96608860edbeb0fe5691c8761e4f0a05b3d1fe32" translate="yes" xml:space="preserve">
          <source>Irrefutable patterns must be written in prefix form:</source>
          <target state="translated">반박 할 수없는 패턴은 접두사 형식으로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">입니다 &lt;code&gt;Tricky Nom Age&lt;/code&gt; 에 representationally 동일한 &lt;code&gt;Tricky Nom Int&lt;/code&gt; ? 아니! 전자는 &lt;code&gt;Char&lt;/code&gt; 를 저장 하고 후자는 &lt;code&gt;Bool&lt;/code&gt; 을 저장합니다 . 이에 대한 해결책은 변수를 입력하기 위해 모든 매개 변수가 역할 명목을 갖도록 요구하는 것입니다. 따라서, GHC는 대한 역할 표상을 추론 할 뿐만 역할 명목 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">FilePath가 유효합니까? 예를 들어 이와 같은 파일을 만들 수 있습니까? 이 함수는 유효하지 않은 이름과 유효하지 않은 문자를 검사하지만 일반적으로 파일 시스템에 따라 길이 제한이 초과되었는지 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">경로는 상대적입니까, 아니면 루트에 고정되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">드라이브 요소</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">항목이 디렉토리이거나 마지막 문자가 경로 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">이벤트 추적이 가능합니까?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 IOError . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 를 정의해야 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스)</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 , 당신은 또한을 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스를)</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="90aec48d5d510f6afeff95f6a4779d93a0f6d310" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우에서 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="a17deabcb706cd08d6fb17b66ea46acf00398ab4" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우에서 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="476e0bb47bf942bb152bfeaaa1e1a912cbba5ab8" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우에서 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">문자가 파일 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">캐릭터가 확장 캐릭터입니까?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">핸들이 터미널에 연결되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="0d2adc690f10a7f72a0ff52f81eef4c6e91e521a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity by looking at the surrounding whitespace:</source>
          <target state="translated">이것은 중위 함수&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;또는 뱅 패턴 이있는&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;의 정의입니까? GHC는 주변 공백을 살펴봄으로써이 모호성을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">이것은 삽입 함수&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;또는 뱅 패턴 이있는&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;의 정의입니까? GHC는이 모호성을 후자에 유리하게 해결합니다. bang-patterns가 활성화 된 상태에서 &lt;code&gt;(!)&lt;/code&gt; 를 정의 하려면 접두사 표기법을 사용하여 정의 해야합니다.</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">고아 모듈입니까? &lt;code&gt;T&lt;/code&gt; 는 동일한 모듈에서 선언 되었기 때문에 분명히 아닙니다 . 그러나 클래스 &lt;code&gt;E&lt;/code&gt; 에 기능적 종속성이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">이 프로그램은 GHC RTS와 연결되어 있습니까? (항상&amp;ldquo;예&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">이 시간대는 여름에만 지속됩니까?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">Proleptic Gregorian 달력에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">Proleptic Julian 일정에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">로 변환되어</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">모나 딕 계산 내에서 예외 처리를 시작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">고정 된 바이트 수로 작동하도록 디코더를 분리하고 더 적은 바이트를 사용하거나 더 많은 바이트를 사용하려고하면 실패합니다. 주어진 디코더가 실패하면 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 도 실패합니다. &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; 의 오프셋 은 입력의 절대 값이 아니라 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 시작에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">컴파일중인 모듈이 -XTrustworthy로 표시되었지만보다 유익한 범위 인 -XSafe로 표시 될 수있는 경우 경고를 발행하십시오. 종속성이 업데이트됨에 따라 Safe Haskell 바운드를 개선 할 수있는 경우 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하다고 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="translated">컴파일중인 모듈이 안전한 것으로 간주되면 경고를 발행합니다. 안전 추론을 사용할 때 모듈의 안전 유형을 확인하는 데 사용해야합니다. 모듈이 명시 적으로 안전하다고 표시되면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하지 않은 것으로 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">사용 된 하나 이상의 사용 된 변수를 바인딩하는 바인딩의 오른쪽에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">유형 수준 함수의 오른쪽에 배치하여 잘못된 경우에 오류를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">또한 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : platform-independent flags 참조&lt;/a&gt; )와 함께 사용하면 생성자에서 엄격한 필드를 언팩하거나 언 박스 할 수 있으며 하나 이상의 간접 레벨이있을 수 있습니다. 제거하십시오. 언 패킹은 단일 생성자 데이터 유형에 대해서만 발생합니다 ( &lt;code&gt;Int&lt;/code&gt; 는 좋은 후보입니다).</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">어떤 방식 으로든 슈퍼 클래스와 메서드를 사용하여 구현할 수 있습니다. 그러나 추상 클래스에 의존하는 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않습니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;# 13086&lt;/a&gt; 참조 ). 이러한 선언은 &lt;code&gt;Constraint&lt;/code&gt; 종류의 유형 동의어로 구현할 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하는 경우이 유형 동의어는 위의 서명의 유효한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">수퍼 클래스 및 메소드 세트를 사용하여 어떤 방식 으로든 구현할 수 있습니다. 그러나 추상 클래스에 따른 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않음, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;이슈 # 13086&lt;/a&gt; 참조 ). 이러한 선언은 종류 &lt;code&gt;Constraint&lt;/code&gt; 유형 동의어에 의해 구현 될 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하면이 형식 동의어는 위의 서명을 올바르게 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">복합 모나드를 구성하기 위해 일련의 모나드 변압기가 적용될 수있는베이스 모나드로 사용될 수 있습니다. 대부분의 모나드 변압기 모듈에는 변압기를 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함됩니다 . 예를 들어 &lt;code&gt;State s&lt;/code&gt; 는 &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">functor 또는 monad 클래스에 의해 매개 변수화 된 함수와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">유효한 구멍 맞춤의 이름과 유형이 맞춤의 의미를 실현하기에 충분하지 않은 경우가 있습니다. 이 플래그는 문서가 사용 가능한 경우 (및 함수가 제공되는 모듈이 &lt;code&gt;-haddock&lt;/code&gt; 플래그 로 컴파일 된 경우) 메시지에 적합한 문서를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">실재적으로 바인딩 된 유형 변수 &lt;em&gt;가&lt;/em&gt; 범위 내에 &lt;em&gt;있지&lt;/em&gt; 않아야 하는 것은 이상해 보입니다 . 일반적으로 이름 바인딩은 동일한 이름의 외부 변수 범위에서 단순히 그림자를 만듭니다 ( '구멍 만들기'). 그러나 이러한 유형 변수를 범위 내로 가져올 수 &lt;em&gt;있는&lt;/em&gt; 방법이 있어야합니다 . 그렇지 않으면 후속 유형 시그니처에서 기존에 바인딩 된 유형 변수의 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd0b20dc53b3f56118493854441da04b5d5caf19" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallel on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">이것은 수 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 스레드를 멀티 프로세서 또는 멀티 코어 시스템에 병렬로 실행할 수 있도록 사용되는이. &lt;a href=&quot;#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용될를. &lt;a href=&quot;#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용되는 RTS 옵션을. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">그것은 진행하기 전에 약한 머리 정상 형태에 각각의 힘을 가한 결과를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="6cc40bdad8257aec1a113a8cf6c4f9244f5bbe8e" translate="yes" xml:space="preserve">
          <source>It forces the result of each application of the function to weak head normal form (WHNF) before proceeding.</source>
          <target state="translated">계속하기 전에 함수의 각 적용 결과를 WHNF (weak head normal form)로 강제 적용합니다.</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 보다 메모리 오버 헤드가 낮으며 힙 조각화에 기여하지 않습니다. 문자열 데이터를 복사하는 비용으로 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 또는 ByteString 에서 변환 할 수 있습니다 . 다른 작업은 거의 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4477cc94d81fac95238764279438f0a0ecec3424" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 보다 메모리 오버 헤드가 적으며 힙 조각화에 기여하지 않습니다. 문자열 데이터를 복사 하는 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 또는 ByteString 에서 변환 할 수 있습니다 . 다른 작업을 거의 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="translated">압축 영역으로 복사되었습니다. &lt;code&gt;ghc-compact&lt;/code&gt; 및 &lt;code&gt;compact&lt;/code&gt; 에 대한 문서 는이 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">윤초를 무시하므로 반드시 고정 된 양의 클럭 시간 일 필요는 없습니다. 예를 들어 윤초가 개입되었는지 여부에 관계없이 23:00 UTC + 2 시간의 NominalDiffTime = 01:00 UTC (+ 1 일)입니다.</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">이다 &lt;em&gt;귀하의 책임&lt;/em&gt; 있는지 확인하기 위해 &lt;code&gt;intLookup&lt;/code&gt; 이 정말의 전문 버전으로 동작 &lt;code&gt;genericLookup&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;루트 세트&lt;/em&gt; 의 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 . &lt;em&gt;groupBy&lt;/em&gt; 보다 약 40 % 빠릅니다 &lt;em&gt;(==)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 개체입니다.</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">라이브러리 작성자가 GHC에게 콜 패턴 전문화를 매우 적극적으로 수행하도록 지시 할 수도 있습니다. 이것은 전문화의 수 또는 코드 크기에 관계없이 전문화하려는 일부 고도로 최적화 된 라이브러리에 필요합니다. 예를 들어, &lt;code&gt;vector&lt;/code&gt; 라이브러리 에서 단순화 된 사용 사례를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">전기에 의해 프로파일을 제한하여 다른 기준으로 하나 이상의 이러한 상태에서 힙을 분류 할 수도 있습니다. 예를 들어, 생산자에 의해 드래그 또는 빈 상태의 힙 부분을 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">런타임 정수 또는 문자열 값을 해당 유형 레벨 리터럴로 변환 할 수도 있습니다. 물론 결과 형식 리터럴은 컴파일 타임에 알 수 없으므로 기존 형식으로 숨겨집니다. 변환을 이용하여 수행 될 수있다 &lt;code&gt;someNatVal&lt;/code&gt; 을 정수와 위해 &lt;code&gt;someSymbolVal&lt;/code&gt; 문자열 :</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">레코드 생성자와 똑같이 동작하는 패턴 동의어를 정의 할 수도 있습니다. 이를 수행하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">내보내기 목록에서 특수 토큰 &lt;code&gt;..&lt;/code&gt; 을 사용하여 현재 번들로 생성 된 모든 생성자를 의미 할 수도 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="translated">&lt;code&gt;qualified&lt;/code&gt; 가 사전 및 사후 양성 위치에 모두 나타나면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">이 제한은 미래에 완화 될 것으로 생각되지만,이 시나리오와 관련된 어려움이 이론적인지 (이러한 의존성이 우리 유형 시스템에 주요 유형이 없음을 의미 할 것임) 또는 단순히 실제적인지 여부는 (작성 당시) 불분명합니다. (GHC의 구현을 고려할 때 이러한 의존성을 추론하는 것은 어렵다). 따라서 GHC는 손쉬운 방법으로 사용자의 도움을 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">현재 &lt;code&gt;Array ix (TVar e)&lt;/code&gt; 로 구현되어 있지만 향후보다 효율적인 구현으로 대체 될 수 있습니다 (그러나 인터페이스는 동일하게 유지됨 ).</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">약한 포인터 객체가 아닌 도달 가능한 객체가 직접 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">확장명 &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma로 사용 가능합니다. (같은 확장자로 &lt;code&gt;mdo&lt;/code&gt; - notation과 &lt;code&gt;do&lt;/code&gt; 표현식 안에서 &lt;code&gt;rec&lt;/code&gt; 블록을 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">이 연산자는 &lt;code&gt;e&lt;/code&gt; 에서 다형성이어야 하며 (명령에 대한 환경 입력과 하위 명령에 대한 환경 입력을 나타냄) 해당하는 고유 특성을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">이 작업은 향후 Haskell 개정판에서 대체 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">내보내거나</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">그것은이 될 괜찮지 &lt;em&gt;전위&lt;/em&gt; (두 선언 (A) 및 (B), 발언권을 포함하여)의 오버랩; 특정 제약 조건이 둘 이상 일치하는 경우에만 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">것이 중요합니다 &lt;code&gt;-O*&lt;/code&gt; 플래그의 조합과 거의 동등 &lt;code&gt;-f*&lt;/code&gt; 플래그. 이러한 이유로 &lt;code&gt;-O*&lt;/code&gt; 및 &lt;code&gt;-f*&lt;/code&gt; 플래그 의 효과 는 명령 행에서 발생하는 순서에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="translated">큽니다. 현재 GHC는 대형 객체를 4KB 블록의 80 % 이상 (즉, 3277 바이트 이상)으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">방정식 함수 정의를 사용하는 대신 사례를 반복해야합니다. 그리고 &lt;code&gt;t&lt;/code&gt; 와의 매칭 이 다른 패턴 안에 깊숙이 묻히면 상황이 더욱 악화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">그것은 사용하는 것보다 더 빠른 없다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 사용하는 것보다 빠르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">항상 모든 일반 표현 유형에 대한 인스턴스를 제공 할 필요는 없지만 인스턴스를 생략하면 함수가 작동 할 데이터 유형 세트가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">종료자가 결국 실행된다는 보장은 없으며 프로그램이 종료 될 때 미해결 종료자를 실행하려고 시도하지 않습니다. 따라서 종료자는 리소스를 정리하는 데 의존해서는 안됩니다. 종료 자와 함께 다른 방법 (예 : 예외 처리기)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">Makefile의 모든 내용을 소스 파일로 옮기는 것은 좋지 않지만 경우에 따라 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma가 올바른 것입니다. (당신이 사용하는 경우 &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt; 하고있는 &lt;code&gt;OPTION&lt;/code&gt; 모듈에 플래그의 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 는 생성에 넣어 얻을 것이다 &lt;code&gt;.hc&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">로드 된 모듈에도 해당 옵션을 적용하지 않고도 대화식 옵션을 변경하는 것이 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">새로운 &lt;code&gt;IsList&lt;/code&gt; 인스턴스를 선언하는 것이 좋습니다 . 따라서리스트 표기법은 완전히 새로운 데이터 유형에 유용합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">GADT 스타일 구문을 사용하여 일반적인 대수 데이터 형식을 선언 할 수 있습니다. GADT를 GADT로 만드는 것은 구문이 아니라 결과 유형이 &lt;code&gt;T a b&lt;/code&gt; 가 아닌 데이터 생성자의 존재입니다 .</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">스플 라이스는 스플 라이스 사이트에 포함되지 않은 이름이 포함 된 표현식으로 확장 될 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">연관된 유형을 정의하는 클래스가 연관된 유형 인스턴스의 기본값을 지정할 수 있습니다. 예를 들어, 이것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">패키지를 사용하면 동일한 이름을 가진 두 개의 모듈을 포함하는 프로그램으로 끝날 수 있습니다. 아마도 &lt;em&gt;숨겨진&lt;/em&gt; 모듈 &lt;code&gt;M&lt;/code&gt; 이있는 패키지 &lt;code&gt;P&lt;/code&gt; 를 사용했고 프로그램에 모듈 &lt;code&gt;M&lt;/code&gt; 이있을 수도 있습니다. 또는 사용한 패키지의 종속성에 일부 중복 모듈이 포함되어있을 수 있습니다. 다른 패키지의 종속성으로 인해 프로그램에 특정 패키지의 여러 버전이 포함되어있을 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">RTS에 자체 정보를 제공하도록 요청할 수 있습니다. 이렇게하려면 &lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 유형을 사용하여 모든 예외를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; 블록을 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 로 연결하는 것이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="de29d8a86d26aa4a500950a6e0de53b7d124ad27" translate="yes" xml:space="preserve">
          <source>It is possible to extract a value of type &lt;code&gt;m Exp&lt;/code&gt; from &lt;code&gt;Code m a&lt;/code&gt; using the &lt;code&gt;unTypeCode :: Code m a -&amp;gt; m Exp&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;unTypeCode :: Code m a -&amp;gt; m Exp&lt;/code&gt; 함수를 사용하여 &lt;code&gt;Code m a&lt;/code&gt; 에서 유형 &lt;code&gt;m Exp&lt;/code&gt; 의 값을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">형식 또는 클래스 선언에 도입 된 형식 변수간에 복잡한 종속성을 얻을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dedaac9870154cb1e43ca5bf912ba5696270690e" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;../runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">런타임 통계에서 &lt;code&gt;par&lt;/code&gt; 가 얼마나 잘 작동 하는지에 대한 약간의 정보를 얻을 수 있습니다 . &lt;a href=&quot;../runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하려면 RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 가 런타임 통계에서 얼마나 잘 작동 하는지에 대한 약간의 정보를 얻을 수 있습니다 . &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82c8e6ba79f13f4308db35903d0f8010b8c6598a" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;exts/ffi#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">GHC가 생성 한 공유 라이브러리를 Haskell로 작성되지 않은 다른 프로그램에서로드 할 수 있으므로 플러그인으로 사용하기에 적합합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 물론 플러그인을 구성하려면 FFI를 사용하여 C 함수를 내보내고 RTS 초기화 규칙을 따라야합니다. &lt;a href=&quot;exts/ffi#ffi-library&quot;&gt;외래 코드에서 호출 할 수있는 Haskell 라이브러리 만들기를&lt;/a&gt; 참조하십시오 . 특히 Haskell 함수가 호출되기 전에 플러그인을 초기화하기 위해 공유 라이브러리에서 C 함수를 내보내고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">Haskell로 작성되지 않은 다른 프로그램에서 GHC에 의해 생성 된 공유 라이브러리를로드 할 수 있으므로 플러그인으로 사용하기에 적합합니다. 물론 플러그인을 구성하려면 FFI를 사용하여 C 함수를 내보내고 RTS 초기화에 대한 규칙을 따라야합니다. &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;외부 코드에서 호출 할 수있는 Haskell 라이브러리 만들기를&lt;/a&gt; 참조하십시오 . 특히 Haskell 함수가 호출되기 전에 플러그인을 초기화하기 위해 공유 라이브러리에서 C 함수를 내보내고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1594eefc0a39a04b21198840922dcc7bcda370e" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;../debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt; 를 사용하여 실제 번역을 볼 수 있지만 출력은 매우 장황합니다.</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt; 를 사용하여 실제 번역을 볼 수 있지만 출력이 매우 장황하다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">디버거를 사용하여 함수 값을 검사 할 수 있습니다. 우리가 중단 점에 있고 함수가 범위 내에 있으면 디버거가 소스 코드를 표시 할 수 없습니다. 그러나 정보를 일부 인수에 적용하고 결과를 관찰하여 일부 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">구문 적으로 CUSK (위의 규칙에 따라)가 있지만 실제로 약간의 추론이 필요한 데이터 유형을 작성할 수 있습니다. 매우 고안된 예로써,</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">소스 파일의 이름을 모듈과 동일하게 가정하면 GHC와 함께 사용할 &lt;code&gt;Makefile&lt;/code&gt; 을 설정하는 것이 합리적 입니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 binary 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 바이너리 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9cf0e87fcc8c4aca3617d4a5dc0deb83f6cef9b" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; mode. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBuffering&quot;&gt;hSetBuffering&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 바이너리 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBuffering&quot;&gt;hSetBuffering&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉, &lt;code&gt;C&lt;/code&gt; 에 대한 마지막 누락 인수 는 &lt;code&gt;C&lt;/code&gt; 의 메소드 에서 명목상의 역할로 사용되지 않습니다 . &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dae310ee0c9c0d6c351f210e6b5d84bf1211c9d" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉, &lt;code&gt;C&lt;/code&gt; 에 대한 누락 된 마지막 인수 는 &lt;code&gt;C&lt;/code&gt; 의 메서드 에서 명목 역할로 사용되지 않습니다 . ( &lt;a href=&quot;roles#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉,에 누락 된 마지막 인자 &lt;code&gt;C&lt;/code&gt; 는 의 어떤에서 소액의 역할에서 사용되지 않는 &lt;code&gt;C&lt;/code&gt; 의 방법. ( &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">GHC는 외래 전화를 선점하지 않기 때문에 외래 전화 중 일시적으로 부동 소수점 단위 상태를 수정하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 느립니다. 장점은 C와 호환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을&lt;/a&gt; 통해 인스턴스를 파생시킬 때 추가 언어 확장을 활성화해야하는 경우가 있습니다. 예를 들어 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 구문을 사용하는 간단한 클래스 및 인스턴스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1600f03c1044e49fbd598b16e83434840c44835b" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을&lt;/a&gt; 통해 인스턴스를 파생 할 때 추가 언어 확장을 활성화해야하는 경우가 있습니다. 예를 들어, &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 구문을 사용하는 간단한 클래스와 인스턴스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">가능하면이 모듈의 명시 적 상태 관리 기능보다는 &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt; 의보다 안전한 monadic API를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">메모리에 많은 짧은 문자열을 유지해야하는 코드의 내부 표현으로 사용하기에 적합하지만 교환 유형으로 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; . 즉, 일반적으로 퍼블릭 API에서 사용해서는 안됩니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 종류는 일반적으로 인터페이스에 사용하기에 적합하다; 보다 유연하고 광범위한 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">순수한 코드에 사용하기에 적합합니다. IO 컨텍스트에서는 대신 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 객체의 값 또는 종료 자입니다.</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 f 가 최종적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 인라인 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 &lt;em&gt;최적화 된&lt;/em&gt; 버전의 &lt;code&gt;f&lt;/code&gt; 를 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS에 함수를 노출시키는 것입니다. 이러한 함수가 최적화되지 않았다면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 버전 이 궁극적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 INLINE 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 우리는 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;최적화 된&lt;/em&gt; 버전 을 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS 에서 함수를 노출하기 위한 것입니다. 이러한 함수가 최적화되어 있으면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3b833a6a7471fbafdafb50780dec24992986833" translate="yes" xml:space="preserve">
          <source>It is useful for modelling any computation that is allowed to fail.</source>
          <target state="translated">실패 할 수있는 계산을 모델링하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 비동기 예외를 완전히 방지하는 방법이 아니라 비동기 모드에서 폴링 모드로 전환하는 방법 으로 생각하면 유용 합니다. 비동기 예외의 주된 어려움은 일반적으로 어디에서나 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내에서 인터럽트 가능한 작업 (또는 다른 인터럽트 가능한 작업 호출)에 의해서만 비동기 예외가 발생한다는 것입니다. 대부분의 경우 이러한 작업 자체는 I / O 오류와 같은 예외를 발생시킬 수 있으므로 일반적으로 호출자는 작업에서 발생하는 예외를 처리 할 준비가됩니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부의 비동기 예외에 대해 명시 적 폴링을 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; 가&lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 데이터의 가족을 제공하는 데 필요한 자신과 관련된 종류의 반환 &lt;code&gt;TYPE&lt;/code&gt; 등으로, &lt;code&gt;FooKey&lt;/code&gt; 및 &lt;code&gt;BarType&lt;/code&gt; 의 위의 예제를. 확장은 위의 &lt;code&gt;FooKeyBoolC&lt;/code&gt; 및 &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; 와 같은 &lt;code&gt;newtype instance&lt;/code&gt; 선언 에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">각 패키지가 단일 공유 객체 파일로 빌드 될 때 공유 객체에 주목할 필요가 있습니다. 공유 객체에 대한 참조는 추가 간접 비용이 들기 때문에 패키지 내 참조는 패키지 간 참조보다 저렴합니다. 물론 이것은 &lt;code&gt;main&lt;/code&gt; 패키지 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="54a6b23a21fda9c044fe0d97ce9ef235ca220f49" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;../win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">Haskell 스레드를 강제로 종료하는 것이 항상 가능한 것은 아닙니다. 예를 들어 스레드가 현재 외부 호출을 실행 중일 수 있으며 외부 호출을 강제로 완료 할 방법이 없습니다. 또한 런타임은 최악의 경우 Haskell 코드와 런타임이 메모리에서 제거 될 것이라고 가정해야합니다 (예 : 이것이 &lt;a href=&quot;../win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt; 인 경우 일반적으로 DLL을 언로드하기 전에 &lt;code&gt;hs_exit()&lt;/code&gt; 가 호출 됨). 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 자신을 반환하기 전에 모든 미해결 외래 호출이 반환 될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">Haskell 스레드를 강제로 종료하는 것이 항상 가능한 것은 아닙니다. 예를 들어 스레드가 현재 외래 호출을 실행 중일 수 있으므로 외래 호출을 강제로 완료 할 방법이 없습니다. 게다가, 런타임은 최악의 경우 Haskell 코드와 런타임이 메모리에서 제거 될 예정이라고 가정해야합니다 (예를 들어, 이것이 &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt; 이면 &lt;code&gt;hs_exit()&lt;/code&gt; 은 DLL을 언로드하기 전에 정상적으로 호출됩니다). 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 모든 미해결 외래 호출이 리턴 될 때까지 기다려야 자체 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8458bc24663504817189be36256a7f90d9fdfdc9" translate="yes" xml:space="preserve">
          <source>It loops indefinitely; every time a key is pressed, it will print that key as it was recognized by Haskeline. Pressing Ctrl-C will stop the loop.</source>
          <target state="translated">무한 반복됩니다. 키를 누를 때마다 Haskeline이 인식 한 키를 인쇄합니다. Ctrl-C를 누르면 루프가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">또한 Haskell 모듈이 컴파일 될 C 코드와 C 파일로 C 코드에 포함되는 C 헤더와 함께 프로그램에 링크 될 추가 C 함수를 포함하는 C 파일을 출력 할 수 있습니다. . 이 두 파일은 &lt;code&gt;#def&lt;/code&gt; 구문이 사용될 때 생성 됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 은 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 는 (참조 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;# 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 이 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 가 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 (참조 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;이슈 # 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">추측하는 것이 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f48419fb8305c7fcc0e8958cac1ac07d41e90892" translate="yes" xml:space="preserve">
          <source>It may still terminate under one of the following conditions:</source>
          <target state="translated">다음 조건 중 하나에서 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; 및 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 는 비슷한 작업을 수행 하는 것처럼 보일 수 있습니다. 둘 다 사용하여 모듈을 범위로 가져올 수 있습니다. 그러나 매우 중요한 차이점이 있습니다. GHCi는 두 가지 모듈 세트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 또한 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;c&lt;/code&gt; 의 종류로 암시 적으로 선언됩니다 . 따라서 일반적인 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 있음을 유의하십시오 &lt;code&gt;b&lt;/code&gt; 는 암시 적으로 선언 된 &lt;code&gt;c&lt;/code&gt; 의 종류. 따라서 일반 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">실제로 읽은 바이트 수를 반환합니다. 데이터를 읽기 전에 EOF에 도달 한 경우 (또는 &lt;code&gt;count&lt;/code&gt; 가 0 인 경우) 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">이러한 재귀 바인딩은 실제로 다양한 모나드에 대해 의미가 있지만 모든 것은 아닙니다. 특히 이런 의미에서 재귀에는 다음과 같이 &lt;code&gt;Control.Monad.Fix&lt;/code&gt; 에 정의 된 &lt;code&gt;MonadFix&lt;/code&gt; 클래스 의 &lt;code&gt;mfix&lt;/code&gt; 메소드로 캡처 한 기본 모나드에 대한 고정 소수점 연산자가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newPinnedByteArray#&lt;/code&gt; 의해 할당되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">GHCi가 시작된 현재 폴더에 &lt;code&gt;.ghci-history&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">그런 다음 개별 항목과 항목 쌍을 &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 에 적절하게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">GHCi가 각 모듈의 기본 설정을 기록하고 '현재'모듈의 설정을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">원격으로 마운트 된 디스크를 사용하여 빠른 컴퓨터 에서 &lt;em&gt;컴파일&lt;/em&gt; 하는 것이 합리적 입니다. 그런 다음 디스크가 직접 장착 된 느린 시스템에 &lt;em&gt;연결&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7b6b7d9f87d44e8662ce4bef918aef2f8488ae" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;exts/let_generalisation#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">&lt;a href=&quot;exts/let_generalisation#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 가로&lt;/a&gt; 드 된 모듈에도 적용되는 경우 바람직하지 않습니다 . 컴파일 오류가 발생할 수 있지만 더 일반적으로 GHC는 플래그가 변경 되었기 때문에 모듈을 다시 컴파일해야한다고 생각하기 때문에 추가 재 컴파일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 가로&lt;/a&gt; 드 된 모듈에도 적용되는 경우 바람직하지 않습니다 . 컴파일 오류가 발생할 수 있지만 GHC는 플래그가 변경되어 모듈을 다시 컴파일해야한다고 생각하기 때문에 추가 재 컴파일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">단일 생성자 유형 (데이터 생성자가 하나 뿐인 유형 (예 : 튜플은 단일 생성자 유형))에서 함수가 엄격한 경우 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">다음 예제와 같이 새 &lt;code&gt;rec&lt;/code&gt; 키워드를 사용하여 상호 재귀 바인딩을 가질 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">&lt;code&gt;a==b&lt;/code&gt; 또는 &lt;code&gt;p==q&lt;/code&gt; 라고해도 괜찮지 만 &lt;code&gt;a==q&lt;/code&gt; 는 두 &lt;code&gt;Baz1&lt;/code&gt; 생성자 에서 발생하는 두 가지 유형이 같기 때문에 잘못되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">추악하고 느립니다.</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 현재 msbf에서 큰 정수로 변환하여 &lt;code&gt;mpz_export()&lt;/code&gt; 를 호출 하므로 작은 정수에 대해 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 를 호출하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">일부 &lt;code&gt;(x,y)&lt;/code&gt; 의 경우 &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt; 경우 결과 크기가 더 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">아이템 (IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">반복 건설</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">J. Nievergelt와 EM Reingold, &quot; 1973 년 3 월 SIAM 컴퓨팅 저널 2 (1),&quot; &lt;em&gt;경계 균형의 이진 탐색 트리&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">요한 티벨 &amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">드라이브와 나머지 경로를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">경로 요소를 다시 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell의 일반적인 파생 메커니즘&lt;/a&gt; . Haskell (Haskell'2010), pp. 37-48, ACM, 2010에서 세 번째 ACM Haskell 심포지엄의 절차.</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell에 대한 일반적인 파생 메커니즘&lt;/a&gt; . Haskell에 관한 세 번째 ACM Haskell 심포지엄 (Haskell'2010), pp. 37-48, ACM, 2010.</target>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">줄스 헤지스 &quot;역 추적 검색을위한 모나드 변압기&quot;. 에서 &lt;em&gt;MSFP 2014 논문집&lt;/em&gt; . &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;A.hs&lt;/code&gt; 를 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi&lt;/code&gt; 와 객체 파일 &lt;code&gt;A.o&lt;/code&gt; 생성되는 &lt;code&gt;A.hs-boot&lt;/code&gt; 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi-boot&lt;/code&gt; 와 의사 오브젝트 파일 &lt;code&gt;A.o-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">Template Haskell ( &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; ) 의 경우와 마찬가지로 GHC는 두 번째 문자가 따옴표 인 데이터 생성자 앞에 따옴표를 넣으면 혼란스러워집니다. 이 경우 프로모션 견적과 데이터 생성자 사이에 공백을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="2870800735c79017eac1d692e6e01d1292a30d03" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;template_haskell#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">Template Haskell ( &lt;a href=&quot;template_haskell#th-syntax&quot;&gt;Syntax&lt;/a&gt; ) 의 경우와 마찬가지로 두 번째 문자가 인용 부호 인 데이터 생성자 앞에 인용 부호를 넣으면 GHC가 혼란스러워집니다. 이 경우 프로모션 견적과 데이터 생성자 사이에 공백을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">타입 추론에서와 마찬가지로, 재귀 타입에 대한 친절한 추론은 &lt;em&gt;단형의&lt;/em&gt; 재귀 만 사용할 수 있습니다 . 이 (고려 된) 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">do-notation을 사용하여 &lt;code&gt;Monad&lt;/code&gt; 인스턴스를 정의하지 않는 것처럼 do-notation을 사용하여 ( &lt;code&gt;ApplicativeDo&lt;/code&gt; 사용시 ) &lt;code&gt;Functor&lt;/code&gt; 또는 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스를 정의하지 않아야 합니다. &lt;code&gt;Monad&lt;/code&gt; 와 관련하여 이러한 인스턴스를 정의하는 올바른 방법 은 &lt;code&gt;Monad&lt;/code&gt; 작업을 직접 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">값 수준 바인딩의 서명과 마찬가지로 패턴 동의어 서명은 둘 이상의 패턴에 적용될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 플러그인과 마찬가지로, &lt;code&gt;-fplugin-opt&lt;/code&gt; 플래그 를 사용하여 지정할 수있는 일부 옵션을 취하고 사용할 수있는 &lt;code&gt;DynFlags&lt;/code&gt; 플러그인을 작성할 수 있습니다 . 위의 &lt;code&gt;DynFlagsPlugin&lt;/code&gt; 코드에서 해당 옵션은 &lt;code&gt;hooksP&lt;/code&gt; 의 &lt;code&gt;opts&lt;/code&gt; 인수 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">x =&amp;gt;만으로 주어진 모드로 파일을 생성합니다. Nothing =&amp;gt; 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">&lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; 를 통한 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.hc&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.hc&lt;/code&gt; 파일은 &lt;a href=&quot;codegens#unreg&quot;&gt;등록되지 않은&lt;/a&gt; 컴파일러에 의해서만 생성됨 ).</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.hi&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.hi&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-hi-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM을&lt;/a&gt; 통해 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.ll&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.ll&lt;/code&gt; 파일은 기본 코드 생성기를 사용할 때 생성되지 않으므로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용하여 파일 을 강제로 생성해야 할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.o&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.o&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-o-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.s&lt;/code&gt; 파일을 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">클래스 중 하나 이상이 &lt;strong&gt;대화 형 클래스 인&lt;/strong&gt; 그룹 만 유지하십시오 (아래에 정의 됨).</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">&lt;code&gt;CPP&lt;/code&gt; 전 처리기 단계 의 출력을 &lt;code&gt;.hscpp&lt;/code&gt; 파일 로 유지 하십시오. &lt;code&gt;.hscpp&lt;/code&gt; 의 모듈이 컴파일 및 C의 전처리를 사용 들어가면 파일은, 생성된다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">주요 인수는 WHNF에 평가됩니다</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">충전 또는 패딩 종류.</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">종류 표현</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="translated">종류 변수는 &lt;em&gt;보이는&lt;/em&gt; 위치 에서도 정량화 할 수 있습니다 . 다음 두 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">예를 들어 종류 평등은 연기 될 수 없다</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">모나드의 Kleisli 화살.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 테일</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 더블 테일</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">LLVM 코드 &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;생성기&lt;/a&gt; 의 LLVM 코드</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">LLVM 코드 생성기</target>
        </trans-unit>
        <trans-unit id="3c49671b7e2363cd100d9148316191ae6da5ed49" translate="yes" xml:space="preserve">
          <source>LOCALESIGNATURE</source>
          <target state="translated">LOCALESIGNATURE</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">디코더에 라벨을 붙입니다. 디코더가 실패하면 오류 메시지 문자열에 새 줄에 레이블이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">라벨링 나무</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">언어 확장 조회</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">언어 확장</target>
        </trans-unit>
        <trans-unit id="b475046df5e047a5d324d26e9300cc370c2f256f" translate="yes" xml:space="preserve">
          <source>Language extensions can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;pragmas#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">언어 확장은 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, 따라서 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; 사용하여 활성화 할 수도 있습니다 ( &lt;a href=&quot;pragmas#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b09f9847980af7e4a3a6760441d9ffe569eb0c00" translate="yes" xml:space="preserve">
          <source>Language extensions can be controlled (i.e. allowed or not) in two ways:</source>
          <target state="translated">언어 확장은 다음 두 가지 방법으로 제어 할 수 있습니다 (예 : 허용 여부).</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">GHC에 알려진 언어 확장</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">언어 옵션은 두 가지 방법으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d88995321d1e03fc9c056aa2f0848cb14f687c1" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;exts/control#options-language&quot;&gt;Controlling extensions&lt;/a&gt;.</source>
          <target state="translated">언어 옵션은 명령 줄 옵션 &lt;code&gt;-Xblah&lt;/code&gt; 또는 파일 자체 의 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma 로 활성화 할 수 있습니다 . &lt;a href=&quot;exts/control#options-language&quot;&gt;확장 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">언어 옵션은 명령 행 옵션 &lt;code&gt;-Xblah&lt;/code&gt; 또는 파일 자체 의 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma에 의해 사용 가능합니다. &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;언어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Cabal이 인식하는 언어 옵션은 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma를 사용하여 활성화 할 수도 있으므로 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; ( &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="5f9b3e6bbd10362e192076519937e6af00547ec4" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.CodeDo</source>
          <target state="translated">Language.Haskell.TH.CodeDo</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal은 GHC와 Template Haskell의 통합에 내부적으로 사용되는 몇 가지 추가 기능을 제공합니다. 이것은 공개 API의 일부가 아니므로이 모듈에 대한 API 보증은 버전마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 플래그로 설정된 일반 할당 영역에서 큰 개체가 할당되지 않으므로 이러한 개체에 대해 별도의 제한이 있습니다. 큰 개체는 작은 개체보다 훨씬 드물기 때문에 대부분의 프로그램 은 &lt;code&gt;-AL&lt;/code&gt; 한계 보다 &lt;code&gt;-A&lt;/code&gt; 한계에 도달합니다. 그러나 &lt;code&gt;-A&lt;/code&gt; 한계는 &lt;code&gt;-AL&lt;/code&gt; 이며, -AL 한계는 전역이므로 &lt;code&gt;-N&lt;/code&gt; 이 커질수록 &lt;code&gt;-AL&lt;/code&gt; 한계에 먼저 도달 할 가능성이 높아집니다 . 이를 방지하려면 큰 &lt;code&gt;-N&lt;/code&gt; 을 사용할 때 더 큰 &lt;code&gt;-AL&lt;/code&gt; 한계 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">마지막으로 선언의 일반 유형 변수가 온다.</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">마지막으로,이 모든 것은 스톡 파생이 적용되는 &lt;code&gt;Read&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 이외의 클래스에만 적용됩니다 (Haskell 보고서의 섹션 4.3.3.). 표준 클래스 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 의 경우 스톡 방법을 사용하는지 또는 여기에 설명 된 방법을 사용하는지 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0fc455f2e488c46f4258275b73483dfdda67dc4" translate="yes" xml:space="preserve">
          <source>Laws</source>
          <target state="translated">Laws</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">그런 다음 레이아웃 필드는 겹치므로 최종 레이아웃은 가능한 한 작습니다. 예를 들어 상자에없는 합계가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">멀티 웨이 레이아웃은 다른 레이아웃 컨텍스트와 동일한 방식으로 작동하지만 멀티 웨이에서 가드 사이의 세미콜론은 선택 사항입니다. 따라서 모든 보호대를 같은 열에 배치 할 필요는 없습니다. 이것은 가드가 함수 정의 및 대소 문자 표현에서 작동하는 방식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9c161543e3be3df002213096ec26355269feb4c2" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e038a37a55536e01a6e93e7ead75ab34c8cde87f" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 느리게 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 읽기 완료 후 또는 오류에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4161b76a8d82e2a67a0cc9182fd41736687ceb1c" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 느리게 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 읽기 완료 후 또는 오류에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bf9b4f02596e6fd7b5e52ce1559424597d35ee1c" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 느리게 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 읽기 완료 후 또는 오류에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">값을 파일에 느리게 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="2e58d7db217f7ed5e5b534420eebdd649aef1451" translate="yes" xml:space="preserve">
          <source>Laziness in the second argument</source>
          <target state="translated">두 번째 주장의 게으름</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 생성 된 지연의 꼬리으로 사용할 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">오류가 발생해야하는 Haskell 98 사양과 달리 오류가 발생하면 Lazy I / O에서 예외가 발생합니다 (Haskell 98 보고서의 섹션 21.2.2 참조). throw되는 예외는 실패한 IO 작업이 IO 모나드에서 수행되고 &lt;code&gt;System.IO.Error.catch&lt;/code&gt; 또는 &lt;code&gt;Control.Exception.catch&lt;/code&gt; 에 의해 잡힐 수있는 일반적인 IO 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">게으른 RWS 모나드.</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">게으른 리더-라이터 상태 모나드</target>
        </trans-unit>
        <trans-unit id="d5489376c9d88deacb286105f787e1b38b636614" translate="yes" xml:space="preserve">
          <source>Lazy corecursive folds</source>
          <target state="translated">게으른 코어 커 시브 폴드</target>
        </trans-unit>
        <trans-unit id="cfe6c9b5652571971dc8bf8ed33e2fb436e96b8f" translate="yes" xml:space="preserve">
          <source>Lazy corecursive folds of unbounded structures are fine:</source>
          <target state="translated">제한되지 않은 구조의 게으른 코어 커 시브 폴드는 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">지연 상태 모나드는 계산을 통해 업데이트 가능한 상태를 전달합니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">게으른 상태 모나드.</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">게으른 작가 모나드.</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="0a2f5e69772acd39bb519e219d7512fd338af3bf" translate="yes" xml:space="preserve">
          <source>Left and right folds</source>
          <target state="translated">왼쪽 및 오른쪽 주름</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">구조에 왼쪽 연관 모나 딕 이중 체.</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">좌익</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">왼쪽 수축 (또는 조임)</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">구조의 왼쪽 연관 접힘이지만 연산자를 엄격하게 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9ad7cc2dc31661b7a9b7f1187d9b82b29af93328" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure, lazy in the accumulator. This is rarely what you want, but can work well for structures with efficient right-to-left sequencing and an operator that is lazy in its left argument.</source>
          <target state="translated">누산기에서 게으른 구조의 왼쪽 연관 폴드. 이것은 당신이 원하는 것은 거의 없지만 효율적인 오른쪽에서 왼쪽으로의 시퀀싱과 왼쪽 인수에서 게으른 연산자를 사용하는 구조에서 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">구조의 왼쪽 연관 접힘.</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">생성자 응용 프로그램에 대한 왼쪽 연결 접기 작업</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">좌우 구성</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">Kleisli 화살표의 왼쪽에서 오른쪽으로 구성.</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">레거시 폴드</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">SIMD 벡터 유형의 길이</target>
        </trans-unit>
        <trans-unit id="47460bf7f1b7a814e03f3e50d8835668cf96f2db" translate="yes" xml:space="preserve">
          <source>Length:</source>
          <target state="translated">Length:</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">레나르트 콜 모딘</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">레나르트 콜 모딘 로스 패터슨</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 의 CSV 테이블 렌더링 예제에서 이러한 개선 사항을 설명하겠습니다 . &quot;핫 코드&quot;는 테이블 셀의 렌더링으로, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API 의 함수 만 사용하여 다음과 같이 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">먼저 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">간단한 예를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">Hello World 프로그램을 만들어서 컴파일하고 실행 해 봅시다. 먼저 Haskell 코드가 포함 된 &lt;code&gt;hello.hs&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">먼저이 프로그램을 통해 실행이 어떻게 진행되는지 봅시다. 우리는 GHC에게 디버그 정보를 원한다고 말하면서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">예제 GHCi 세션부터 시작하겠습니다. ghci 명령으로 &lt;code&gt;ghci&lt;/code&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">위에서 예제를 가져 와서 독립형 C 프로그램에서 호출 해 봅시다. C 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">퀵 정렬을 실행 예제로 사용합시다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">여기에 표시된 이진 데이터를 디코딩합시다. 이 예에서 값은 리틀 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">먼저 많은 &lt;code&gt;Trade&lt;/code&gt; 를 해독하는 함수를 정의 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">정교하게 인쇄 된 출력의 세부 수준. 레벨 0이 가장 자세하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46ea3fc173ca6f3f7f2ab9f2d659dfe92c450434" translate="yes" xml:space="preserve">
          <source>Levity-polymorphic since &lt;em&gt;template-haskell-2.16.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;template-haskell-2.16.0.0&lt;/em&gt; 이후 Levity-polymorphic .</target>
        </trans-unit>
        <trans-unit id="52dcee87fcfc322421d1cb812971dd1afed2aeaf" translate="yes" xml:space="preserve">
          <source>Levity-polymorphic since &lt;em&gt;template-haskell-2.17.0.0&lt;/em&gt;. type TExpQ :: TYPE r -&amp;gt; Kind.Type</source>
          <target state="translated">&lt;em&gt;template-haskell-2.17.0.0&lt;/em&gt; 이후 Levity-polymorphic . type TExpQ :: TYPE r-&amp;gt; Kind.Type</target>
        </trans-unit>
        <trans-unit id="25799598a4e8c42a83738d367f796323e13b7b18" translate="yes" xml:space="preserve">
          <source>Lexeme</source>
          <target state="translated">Lexeme</target>
        </trans-unit>
        <trans-unit id="46ace3bdab1ce2e35c935ef17a0a57edf4886910" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;angles p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in angle brackets ('&amp;lt;' and '&amp;gt;'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;angles p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 각괄호 ( '&amp;lt;'와 '&amp;gt;')의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cc7d61ad991ca5dc420dbacf991b3321c23b4f3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;braces p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in braces ('{' and '}'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;braces p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 동봉 중괄호 ( &quot;{&quot;와 &quot;}&quot;)의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b05508eef449259c3da847ba5b8908b337a57ef" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;brackets p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in brackets ('[' and ']'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;brackets p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 괄호 ([및])의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6f01f6fd61a8c0bb200b1113e901859689cb574" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;colon&lt;/code&gt; parses the character ':' and skips any trailing white space. Returns the string &quot;:&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;colon&lt;/code&gt; 은 문자 ':'를 구문 분석하고 후행 공백을 건너 뜁니다. 문자열 &quot;:&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="906be22b3485d6af088c4586447a23867836a78c" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;comma&lt;/code&gt; parses the character ',' and skips any trailing white space. Returns the string &quot;,&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;comma&lt;/code&gt; 는 문자 ','를 구문 분석하고 후행 공백을 건너 뜁니다. &quot;,&quot;문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8fa5d226b4524a8f2606ab3fb7b4e7c3152035a2" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;commaSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8f0383ea5ef26d7b618c08586a182319e06433ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;commaSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3b0f682fe5ecece9ab074d848ae3efde0075785f" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commaSep1 p&lt;/code&gt; 구문 분석기 commaSep1 p 는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 된 &lt;em&gt;하나&lt;/em&gt; 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다. &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1527e1889e4d9db5a2a2a401431c80198a7ad8ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commaSep1 p&lt;/code&gt; 구문 분석기 commaSep1 p 는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 된 &lt;em&gt;하나&lt;/em&gt; 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다. &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a06e52077d648a539ce51fcce5464792168d2116" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;dot&lt;/code&gt; parses the character '.' and skips any trailing white space. Returns the string &quot;.&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;dot&lt;/code&gt; 는 문자 '.'를 구문 분석합니다. 후행 공백을 건너 뜁니다. 문자열 &quot;.&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c625c13a8a270d65b20ce25a79ef5d1e88e0c01" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;parens p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in parenthesis, returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;parens p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 괄호의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09775ca66fe1940d621ab83bb334774f062130fc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1fde367cf1acc73ec6e48dd7f44d104f7a0066d3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a56558ecec4b9b3865d84f3538f50974882790bc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep1 p&lt;/code&gt; 는 파싱 &lt;em&gt;하나 개&lt;/em&gt; 의 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f226487b67eb839b478eae118624bbb75f343207" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep1 p&lt;/code&gt; 는 파싱 &lt;em&gt;하나 개&lt;/em&gt; 의 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71ba5db9cf8b9d035392754516d0f0d298c6b31e" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;symbol s&lt;/code&gt; parses &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; and skips trailing white space.</source>
          <target state="translated">어휘 파서 &lt;code&gt;symbol s&lt;/code&gt; 파싱 된 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 후행 공백 문자는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1cae647ca5dc3e8507fd8b9a75e7e569807d779e" translate="yes" xml:space="preserve">
          <source>Lexeme parser |semi| parses the character ';' and skips any trailing white space. Returns the string &quot;;&quot;.</source>
          <target state="translated">Lexeme 파서 | semi | 문자 ';'를 구문 분석합니다 후행 공백을 건너 뜁니다. 문자열 &quot;;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a85bb6bdbe773df37163bd57f9f3cbce90e0583" translate="yes" xml:space="preserve">
          <source>Lexical type variables may be alpha-renamed freely, without changing the program.</source>
          <target state="translated">어휘 유형 변수는 프로그램을 변경하지 않고 자유롭게 알파 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa4917a631d5ad9efc7afed87e7e85e133625b5" translate="yes" xml:space="preserve">
          <source>LexicalNegation</source>
          <target state="translated">LexicalNegation</target>
        </trans-unit>
        <trans-unit id="acfd3fae981ce83b9a78f156f575113d42a472b8" translate="yes" xml:space="preserve">
          <source>LiberalTypeSynonyms</source>
          <target state="translated">LiberalTypeSynonyms</target>
        </trans-unit>
        <trans-unit id="57b431fa7c23fe6a92d842e080f85a382840075b" translate="yes" xml:space="preserve">
          <source>Libraries can specify this by using &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SPEC&quot;&gt;SPEC&lt;/a&gt;&lt;/code&gt; data type to inform which loops should be aggressively specialized.</source>
          <target state="translated">라이브러리는 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SPEC&quot;&gt;SPEC&lt;/a&gt;&lt;/code&gt; 데이터 유형을 사용하여 어떤 루프를 적극적으로 전문화해야하는지 알려 줌으로써이를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="150017bb5be516efb13183274c04717c3913f12c" translate="yes" xml:space="preserve">
          <source>Library functions</source>
          <target state="translated">라이브러리 기능</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8f40b70f72540e03b88378ef3507f6d84f38b8e2" translate="yes" xml:space="preserve">
          <source>Licensed under a BSD-style license (see top of the page).</source>
          <target state="translated">BSD 스타일 라이센스에 따라 라이센스가 부여되었습니다 (페이지 상단 참조).</target>
        </trans-unit>
        <trans-unit id="7c040e16c5971eb5c4f65496f4403ed7de94405d" translate="yes" xml:space="preserve">
          <source>Licensed under the Glasgow Haskell Compiler License.</source>
          <target state="translated">Glasgow Haskell 컴파일러 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="efd0976a0ad531b6453a3782b50f0f3ff5363b1e" translate="yes" xml:space="preserve">
          <source>Lift</source>
          <target state="translated">Lift</target>
        </trans-unit>
        <trans-unit id="69bd6ed6019d0841a40b7376c8be9d0e00a15a4a" translate="yes" xml:space="preserve">
          <source>Lift &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="28a4c297cb17de5189cf531fb8cff2247893efd7" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 을 BoundedPrim 으로 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b11a06f969ecc3525b7fd7eb5bd850c961745651" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 을 BoundedPrim 으로 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ad9a4be8766f89114fe4a089c39d2885ba04cb" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="57350b28e0ae1579635d1c5f5bfee71f12dc8af6" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 &lt;code&gt;callCC&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="e69559f09d367723fe7abf1f50e359886a0e8931" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;catchE&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">&lt;code&gt;catchE&lt;/code&gt; 조작을 새 모나드로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="9c3605ce5319733a98246b58994a1c7a3b22a3dc" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;listen&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 모나드에 대한 &lt;code&gt;listen&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="898de1bff1c29cda9790c0fed24117c87b00c641" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;pass&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 모나드 로 &lt;code&gt;pass&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="0d0feda6a4614b667af6e9eb00a72f0992d75a5c" translate="yes" xml:space="preserve">
          <source>Lift a IO operation</source>
          <target state="translated">IO 작업을 들어 올리십시오</target>
        </trans-unit>
        <trans-unit id="b9039d9d95aa49349189305fdf5c0f23de8d10bb" translate="yes" xml:space="preserve">
          <source>Lift a binary function to actions.</source>
          <target state="translated">이진 함수를 동작으로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="4fdb7ea3c747b4ff83d8fd93dbad25981db51967" translate="yes" xml:space="preserve">
          <source>Lift a computation from the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 계산을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="0e31379847177eab30d30f0126819d393b4805f7" translate="yes" xml:space="preserve">
          <source>Lift a computation from the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. This allows us to run IO computations in any monadic stack, so long as it supports these kinds of operations (i.e. &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; is the base monad for the stack).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 계산을 해제합니다 . 이를 통해 이러한 종류의 작업을 지원하는 한 모든 모나 딕 스택에서 IO 계산을 실행할 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 가 스택의 기본 모나드 임).</target>
        </trans-unit>
        <trans-unit id="6fb4cfd1308d8bc1fc2b8075cc399da8778ef019" translate="yes" xml:space="preserve">
          <source>Lift a computation from the argument monad to the constructed monad.</source>
          <target state="translated">인수 모나드에서 생성 된 모나드로 계산을 들어 올립니다.</target>
        </trans-unit>
        <trans-unit id="755e2bbeb43333564e4df3721333f2c5cb05f108" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">기능을 행동으로 들어 올리십시오. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65540f13b21961e922b1b042f1d167b1c9a2abf6" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">기능을 행동으로 들어 올리십시오. 이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3306c8d28d88915bd946a2603ec45578ecd138e" translate="yes" xml:space="preserve">
          <source>Lift a function to an arrow.</source>
          <target state="translated">기능을 화살표로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="70e5d47cad9c90bc5aea988bdcc449bc319bf871" translate="yes" xml:space="preserve">
          <source>Lift a monadic action producing code into the typed &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; representation</source>
          <target state="translated">코드를 생성하는 모나드 액션을 입력 된 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; 표현 으로 들어 올립니다.</target>
        </trans-unit>
        <trans-unit id="072c31ba78fc0ac74605cd75f183f4375e32d5b8" translate="yes" xml:space="preserve">
          <source>Lift a monadic action producing code into the typed &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; representation</source>
          <target state="translated">코드를 생성하는 모나드 액션을 입력 된 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; 표현 으로 들어 올립니다.</target>
        </trans-unit>
        <trans-unit id="34e1005428b4115e3bdc892cb79d78caeaad7d73" translate="yes" xml:space="preserve">
          <source>Lift a precedence-insensitive &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위에 영향을받지 않는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 를 ReadPrec 으로 들어 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a927363c52ab42f8173b13c6038ee007ad8a17e" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="9bff245d149ddf1ae6d16d98ebd9221f1ea4340f" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="29850a41c75e24ec5f1d7822fdd746419e6175d1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="a1f4ae6d40699215f86ae7acc6dbd638b4d640c8" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="50ae922d71481e0c500a4d32043520930c6c6f12" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="ef6d5d2890f728fc0dec424db983bea6034793d1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="d9bf2088ff3118acf5a0706a43b2ca5d9acc93eb" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="f3a10c09a2df5ee40736eca77b005327c3f502e1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="5e1fcf4cd57048cb7f11dc48a4d6b768b70babd3" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="55317bb47900a6c531bb57912283090eb69391dc" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="3c1bc5d6a5612d9590c702c04f8fbd95d193c275" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="b18efdb14898a61cd6bf3e53b88908b07c899338" translate="yes" xml:space="preserve">
          <source>Lift a ternary function to actions.</source>
          <target state="translated">삼항 함수를 동작으로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="1c6cfea669eba5bd426957f891847f721512f382" translate="yes" xml:space="preserve">
          <source>Lift a unary operation to the new monad.</source>
          <target state="translated">단항 조작을 새 모나드로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="46b3af654500c45d1bbe42552320fbf9acf7d7ab" translate="yes" xml:space="preserve">
          <source>Lift a value.</source>
          <target state="translated">가치를 높이십시오.</target>
        </trans-unit>
        <trans-unit id="1a088c3e62edefbbd612558fe95e26c16929b0cf" translate="yes" xml:space="preserve">
          <source>Lift an IO operation</source>
          <target state="translated">IO 작업을 들어 올리십시오</target>
        </trans-unit>
        <trans-unit id="f3531bf1113fe8b33ad38c7a7731990c8b025668" translate="yes" xml:space="preserve">
          <source>Lift an equality test through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 동등성 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d59a4331fe2b228402b5f804879977d4d2bdbdf8" translate="yes" xml:space="preserve">
          <source>Lift equality tests through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 동등성 테스트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ba141aacd2971ab64cd183f644499403aa27baf6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="2a5c11e919022ea17cf3e50538bb0b39ab267ca8" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">타입 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="a22f0b12039df26e38242ef4e1b27fd9a2aca7c5" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="cef4fc8589a89ebe3dab70e8896098b35542b102" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="81beb3415733b0127f91ccfbc68d75371f1bc17c" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="faeb2e4ce6194f3ee4155e1efd45893a2e939961" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="053aeb1412e2444b0b1a20409a35603dc721e057" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="408cf02de66cc6b705154fd2c661de60e644f5b6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="3004afec47fb6a84cae4d9e49047dab3af9ecdbb" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="f4fbea4d9b31cd33d7694749c6476d3a1af9a3ab" translate="yes" xml:space="preserve">
          <source>Lifted product of functors.</source>
          <target state="translated">펑터의 상승 된 제품.</target>
        </trans-unit>
        <trans-unit id="3b10925916ee44f531f851144318a3b5ce0f20aa" translate="yes" xml:space="preserve">
          <source>Lifted sum of functors.</source>
          <target state="translated">펑터의 합계를 올렸습니다.</target>
        </trans-unit>
        <trans-unit id="babef654d32e20b79299fbdb4e3acce1da353228" translate="yes" xml:space="preserve">
          <source>Lifted, heterogeneous equality. By lifted, we mean that it can be bogus (deferred type error). By heterogeneous, the two types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; might have different kinds. Because &lt;code&gt;~~&lt;/code&gt; can appear unexpectedly in error messages to users who do not care about the difference between heterogeneous equality &lt;code&gt;~~&lt;/code&gt; and homogeneous equality &lt;code&gt;~&lt;/code&gt;, this is printed as &lt;code&gt;~&lt;/code&gt; unless &lt;code&gt;-fprint-equality-relations&lt;/code&gt; is set.</source>
          <target state="translated">이기종 평등이 해제되었습니다. 해제하면 가짜 일 수 있습니다 (지연된 유형 오류). 이종으로 인해 두 유형 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 서로 다른 종류를 가질 수 있습니다. 때문에 &lt;code&gt;~~&lt;/code&gt; 이 이기종 평등의 차이에 대한 상관 없어 사용자에게 오류 메시지가 예기치 않게 나타날 수 있습니다 &lt;code&gt;~~&lt;/code&gt; 균일 평등 &lt;code&gt;~&lt;/code&gt; 이 같이 인쇄됩니다 &lt;code&gt;~&lt;/code&gt; 하지 않는 &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4bfbdd16cc189cc5129a0d8ec953d2317a224b0" translate="yes" xml:space="preserve">
          <source>LiftedRep</source>
          <target state="translated">LiftedRep</target>
        </trans-unit>
        <trans-unit id="12c2f75c3b26c4edac3b33e5c51db3b8e36394c9" translate="yes" xml:space="preserve">
          <source>Lifting an applicative</source>
          <target state="translated">응용 프로그램 해제</target>
        </trans-unit>
        <trans-unit id="e2c3b2b741daea57fdd436a0412a6ba2f18b6f68" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="44895603faea79f05cd37173f6a4597b6953146e" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="e0a82371cc12bbf7738745a43b619731d3611950" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="7d9b6f54af0f5e9694ecfd7ee7add7a2cc652087" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="ae55fc1bef97cadc36b9661bf1e25f7f4c7e352d" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="86c660f1a1c56586cead2935de6c64b3ef5324c5" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="b2e9206d787342e53328d0f894bfa7fc5940af4a" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="d56ab180af5b8c6b67cd1de105953549f78976c7" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="ef79daca18c86fc7acb004897eb034a72769183c" translate="yes" xml:space="preserve">
          <source>Lifting other operations</source>
          <target state="translated">다른 작업 해제</target>
        </trans-unit>
        <trans-unit id="70b315b20d2f0763f381b07677fe5fcdd427769f" translate="yes" xml:space="preserve">
          <source>Liftings of Prelude classes</source>
          <target state="translated">Prelude 클래스의 리프팅</target>
        </trans-unit>
        <trans-unit id="bbd32f90f691094d13a835f9d8bc070165c84480" translate="yes" xml:space="preserve">
          <source>Liftings of the &lt;code&gt;NFData&lt;/code&gt; class</source>
          <target state="translated">NFData 클래스 의 &lt;code&gt;NFData&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf36ebf7919530abaa3b7a585d3a7f483fb9666d" translate="yes" xml:space="preserve">
          <source>Liftings of the Prelude classes &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; to unary and binary type constructors.</source>
          <target state="translated">단항 및 이진 형식 생성자 에 대한 Prelude 클래스 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9662e4165cf70bc0656fd852ce8badb4bccd421" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98068ced479359302008df12305e0fa6226acf9" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533e09a9bf33161ccd152904f791f9b0ccd0dfa2" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f90827cfa26ca646d28cee985138fed19cc82be" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5521b87bdd2b2ba0107fa6810e0f9218d24ee9b" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d1efb767ef813dfdeb09404aab44cab82ce1aa2" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea5fc5a99bc5f43e32f54299e4add38a5941b11" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, but options set with &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; affect only expressions and commands typed at the prompt, and not modules loaded with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; (in contrast, options set with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; apply everywhere). See &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; 로&lt;/a&gt; 설정된 옵션 은 프롬프트에 입력 된 표현식과 명령에만 영향을 미치며 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 로&lt;/a&gt; 로드 된 모듈에는 영향을 미치지 않습니다 (반대로 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 으로 설정된&lt;/a&gt; 옵션 은 모든 곳에 적용됨). &lt;a href=&quot;#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3eb1542266aa6e78b551f4a66f99dca63eb84c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="3ee688d5e3686106a78a8c11143028e7c7c2d867" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 이진 모드로 엽니 다. 자세한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 은 openBinaryFile 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="171756990cca268601ff47e149f013f10d1f0b1d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="3e5d1ae0b75edd09252cda3ae684b700669426cc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 바이너리 모드로 파일을 엽니 다. 더 많은 주석은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1abb83e3fff00970acacf5a85cdb8ae50239c4a9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="e3c101ba4a684aa998861e15a7cff4ed12d0d488" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 바이너리 모드로 파일을 엽니 다. 더 많은 주석은 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e95f6be3cd220d7c265e9ff2d6eb81b829a783d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="315f04774b37e903ccef1fd017cf5e6c8fb19cad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="26af205331dd385348a903a75489cae5ac1bc8a2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, this sparks off a new thread to run the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation passed as the first argument, and returns the &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; of the newly created thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 , 이것은 새로운 스레드를 시작 하여 첫 번째 인수로 전달 된 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 을 실행 하고 새로 작성된 스레드 의 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e51a2d5c390f6fe2c3f06d7a141e356abf36b260" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is a bound thread, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 바운드 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5a0feb98209de5e446543c7ee38359b8a7b02e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894deb520e4932d4ccd6a7678d392f4657ad389a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 작업은 비동기 예외가 마스크되어 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b23d745348276319c0475e801e641228506e2414" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 작업은 비동기 예외가 마스크 된 상태로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cbaf69411b6e48d7f755fce6152d35bbf2f5117d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 동작은 비동기 예외가 마스크 된 상태로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf1b2d2d7438a64e06e7288f0b784895fdb2d25" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; but the function is a simple state transition that can return a side value which is passed on as the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; 와 유사 하지만이 함수는 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 의 결과로 전달되는 부수 값을 반환 할 수있는 간단한 상태 전이입니다 .</target>
        </trans-unit>
        <trans-unit id="c85aa7d7cdb5b9edc279fc62b53487dd9aa084bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the in-between computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 있지만 단지 그 사이 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="428edc72ad0acbe121d8494d1d65e4193ca597f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 있지만 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="58d823ae8a2d7d414c0d42e7b802e79575732ed8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ,하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="6caf66653eb22b299f52b1089ebb3605f273b200" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 있지만 마스크 연산 (참조 : 인터럽트없는 &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; ). 스레드 가 어떤 이유로 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 마스크에서 실행되는 스레드 인 경우 스레드 (및 아마도 주 스레드 인 경우 프로그램)가 응답하지 않고 종료 할 수 없으므로 GREAT CARE와 함께 사용해야합니다 . 이 기능은 인터럽트 가능한 작업 주위의 예외를 마스크해야하는 경우에만 필요하며 인터럽트 가능한 작업이 단기간 동안 만 차단되도록 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d8e2c728be8dff68d64c2a9d4e55d7a3457b7d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="d0c2cdb316924ad0cfcfbad4c5a54c0b89f7946f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b96efb08972b89ea81a161e65a91a252070d9475" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b6ab6604b14c9e57db46ecf0ddcd0256f914b9e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if an error is thrown by the in-between computation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 중간 계산에서 오류가 발생한 경우에만 최종 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b6a432005495b7136cfdf428a9a6ea3acfc5248a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ,하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="af33929c8b3cdd326c411d0878af278835603f2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. WARNING: Only use if you need to mask exceptions around an interruptible operation AND you can guarantee the interruptible operation will only block for a short period of time. Otherwise you render the program/thread unresponsive and/or unkillable.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 하지만, 마스크 계산합니다 (인터럽트하지 &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 당신이 인터럽트 동작 주위에 예외를 마스크해야하고 인터럽트 동작이 유일한 시간의 짧은 기간 동안 차단됩니다 보장 할 수있는 경우에만 사용 :. 경고. 그렇지 않으면 프로그램 / 스레드가 응답하지 않거나 죽일 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="ed29ac9ba7c3e179a54bf2966ac9ac7af76e7d0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. WARNING: Only use if you need to mask exceptions around an interruptible operation AND you can guarantee the interruptible operation will only block for a short period of time. Otherwise you render the program/thread unresponsive and/or unkillable.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 하지만, 마스크 계산합니다 (인터럽트하지 &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 당신이 인터럽트 동작 주위에 예외를 마스크해야하고 인터럽트 동작이 유일한 시간의 짧은 기간 동안 차단됩니다 보장 할 수있는 경우에만 사용 :. 경고. 그렇지 않으면 프로그램 / 스레드가 응답하지 않거나 죽일 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f3eb839ad43d64884f153d8e4355f1395cdc6c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="78cdc9f7942398d4390de39bd760476640cca3cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">전체 요청을 충족시키기 위해 즉시 사용 가능한 바이트가 충분하지 않은 경우 더 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 리턴 될 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 과 유사 합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="22204fd64f738ebaf8d59795481095728e60cafd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">전체 요청을 충족시키기 위해 즉시 사용 가능한 바이트가 충분하지 않은 경우 더 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 리턴 될 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 과 유사 합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="88bc8146cfaa55c674a416c3250cf7fde75cab90" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; but instead of giving the final size of the ByteString, it is just an upper bound. The inner action returns the actual size. Unlike &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; the ByteString is not reallocated if the final size is less than the estimated size.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 ByteString 의 최종 크기를 제공하는 대신 상한입니다. 내부 동작은 실제 크기를 반환합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; 과 달리 최종 크기가 예상 크기보다 작 으면 ByteString이 재 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5d3796594fc3ab685a758f79230f2378e0d143a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returning unit in an arbitrary &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context. Allows for convenient use in do-notation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 임의뿐만 돌아 단위 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 상황. do-notation에서 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14b22297f44f3b23085789ee54f433e3be99756" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returns the message instead of a third value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 세 번째 값 대신 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94f249d85e854bd365a2caf558548ba6a48c90f7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; ,하지만 사용은 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; A를 변환 할 수있는 인수에 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bda17b6fe85f48913bc5a5c73b83bf25335feb15" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 인수에 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4d4f7e6d83c6d859a27421bd667669770d5a90e1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; but returns the shown value instead of a third value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 세 번째 값 대신 표시된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3388029e6ebab6adb5dbdc535cdaa4a63773ee6d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종료 자에는 추가 환경 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7201461e77cbbffbf975483dea651ac9f115ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="61b50bda211ddddaf8be8d611e3ac6aceb8f889d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종료 자에는 추가 환경 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7debe615da856622a94fda2ea5817fa207e70f78" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="64ed7e2ac88ad404c757ebe2bf247c490e1bb7f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="86170fb3c040fb17cc898e1ff2e2691ab6d6babd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 특수 종료 요소를 보유 할 추가 위치를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1ab9de75683278e54e5c08a09c39dc2659dca6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 할당 된 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="31e8f4f3a29d9ebfdb6b5dd33afab7987daa7fac" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 특수 종료 요소를 보유 할 추가 위치를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e8798d35982e07ff23b6d4dd4f9bdb7568df53ad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 할당 된 메모리는 값이 0 인 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="56fea7f011d519c7d258e88b7f3d4ae54477fc85" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종결자는 배열이 끝나는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f5dc7b1ce9daa64f13a0b057b2f35119ac5cd95" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but the action gets the number of values as an additional parameter</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 액션은 추가 매개 변수로 값 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e4b7f2fe78306ea129c2aaf255ab760c2af8b59" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 종결자는 배열이 끝나는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="789fc518616c7bbb0baf7f9f6873e5ac8d47ec18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt; 처럼 결과를 버립니다</target>
        </trans-unit>
        <trans-unit id="c8a36a8d0834f745b3ab8c875279421ca4121094" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt; 하지만, 그 결과를 폐기</target>
        </trans-unit>
        <trans-unit id="6a1b2b22a37fbf26bc19da6800d4f4f4c18e9196" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , 값 범위가 확인하지 않고.</target>
        </trans-unit>
        <trans-unit id="fd6ed34fe3d856c29ed47ef21309ed222b27e308" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8a1ab1b4c3fc6205f7cbc119a5029f50c82ecfa2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="36c33ff708aca6f019cd5e4f36eb986bb33a1c42" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e718907739536fc11ccba60be322ece4a576f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="06b626d6d4d9cc23806065fb84e761850f571140" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="2074e4e1e1d435d659723420ae5b7066c75304a9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03378dafea3e612ebd75747dbec79dd54212c74e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종료 자에는 추가 환경 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3f4ecabff6e19ca899a6be2fc7069356485a28" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce27041c32b2c7b9dd00240cd18dbacb3f46271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, there is a class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; that defines a representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; and conversion functions &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt;, only that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; ranges over types of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. (More generally, it can range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;, if the &lt;code&gt;PolyKinds&lt;/code&gt; extension is enabled. More on this later.) The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class is also derivable.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; , 클래스가 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 표현 정의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 및 변환 기능 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt; 단 것으로, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 가 가지 유형 이상의 범위 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; . (일반적으로 &lt;code&gt;PolyKinds&lt;/code&gt; 확장이 활성화 된 경우 모든 종류의 &lt;code&gt;k&lt;/code&gt; 에 대해 종류 k- &lt;code&gt;k -&amp;gt; *&lt;/code&gt; 의 범위를 지정할 수 있습니다 . 나중에 더 자세히 설명합니다.) &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 클래스도 파생 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c6bccda987e33fe0bbf298a851536cd1b5e84ab8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ,하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="aad2536126d6403f4616d23d084d88d2eb347131" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 있지만 마스크 연산 (참조 : 인터럽트없는 &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; ). 스레드 가 어떤 이유로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 마스크에서 실행되는 스레드 인 경우 스레드 (및이 프로그램이 기본 스레드 인 경우 프로그램)가 응답하지 않고 종료 할 수 없으므로 GREAT CARE와 함께 사용해야합니다 . 이 기능은 인터럽트 가능한 작업 주위의 예외를 마스크해야하는 경우에만 필요하며 인터럽트 가능한 작업이 단기간 동안 만 차단되도록 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad819e37fccd377f4f7ea98ffe39aaa59462a5e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="8f34379fe53a8f49eef2d4d51e196bbfce89ed5a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 하지만, 바이너리 모드로 파일을 엽니 다. Windows에서 텍스트 모드 (기본값)에서 파일을 읽으면 CRLF가 LF로 변환되고 기록하면 LF가 CRLF로 변환됩니다. 이것은 일반적으로 텍스트 파일로 원하는 것입니다. 이진 파일의 경우 이는 바람직하지 않습니다. 또한 Microsoft 운영 체제에서 평소와 같이 텍스트 모드는 control-Z를 EOF로 취급합니다. 이진 모드는 줄 끝 및 파일 끝 문자의 모든 특수 처리를 끕니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6e447be1c8c5966385a7af2bdc9dacccc9d0191" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but opens the file in ordinary blocking mode. This can be useful for opening a FIFO for writing: if we open in non-blocking mode then the open will fail if there are no readers, whereas a blocking open will block until a reader appear.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 일반 차단 모드로 엽니 다. 쓰기를 위해 FIFO를 여는 데 유용 할 수 있습니다. 비 차단 모드에서 열면 리더가 없으면 열기가 실패하지만 리더가 나타날 때까지 차단 열기가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="d11ed8ec1f7d4a4f76c34befc3bc8a8f2cef6d9c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-ix#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-ix#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , 값 범위가 확인하지 않고.</target>
        </trans-unit>
        <trans-unit id="11412198fb2aebb6ae9a4f43a11db80ce5c58256" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; (expand escape characters using Haskell escape conventions), but * break the string into multiple lines * wrap the entire thing in double quotes Example: &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; : 예 (하스켈 탈출 규칙을 사용하여 이스케이프 문자를 확장),하지만 * * 따옴표로 전체 일을 감싸는 여러 행으로 문자열을 깰 &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; 반환 &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c39ac872c5a458945a6a2759691e5bcbdb98387" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but in the event of an exception that causes an exit, we don't shut down the system cleanly, we just exit. This is useful in some cases, because the safe exit version will give other threads a chance to clean up first, which might shut down the system in a different way. For example, try</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종료를 일으키는 예외가 발생하면 시스템을 완전히 종료하지 않고 종료합니다. 안전 종료 버전은 다른 스레드가 먼저 정리할 수있는 기회를 제공하므로 시스템이 다른 방식으로 종료 될 수 있기 때문에 일부 경우에 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="92a361d777b7468b2f4fc3ce94a02dd7971e288e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 있지만 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="d3dcb0071e2c488b5032fe8ef982a6ce42d875b4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, but can also read arguments supplied via response files.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 유사 하지만 응답 파일을 통해 제공된 인수를 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="524c7a43bda4a60c5d96c8d591c7b926a8919edd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;, but allows blank environment values and mimics the function signature of &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;unix&lt;/code&gt; package.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; ,하지만 빈 환경 가치와 모방을의 함수 서명 허용 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 로부터를 &lt;code&gt;unix&lt;/code&gt; 패키지 .</target>
        </trans-unit>
        <trans-unit id="b797f1a70d1f88521b8770e48825b66c385a7740" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt;, but allows for the removal of blank environment variables. May throw an exception if the underlying platform doesn't support unsetting of environment variables.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 비슷 하지만 빈 환경 변수를 제거 할 수 있습니다. 기본 플랫폼이 환경 변수 설정 해제를 지원하지 않으면 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8431a8f9693c397e4ecffa5b03a89b83f5c963c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt; 비슷 하지만 기본 파일 권한을 사용합니다</target>
        </trans-unit>
        <trans-unit id="ddc8a70da72ad8f7b98007cd07b86322fc708d18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 하지만, 바이너리 모드로 파일을 엽니 다. Windows에서 텍스트 모드 (기본값)에서 파일을 읽으면 CRLF가 LF로 변환되고 기록하면 LF가 CRLF로 변환됩니다. 이것은 일반적으로 텍스트 파일로 원하는 것입니다. 이진 파일의 경우 이는 바람직하지 않습니다. 또한 Microsoft 운영 체제에서 평소와 같이 텍스트 모드는 control-Z를 EOF로 취급합니다. 이진 모드는 줄 끝 및 파일 끝 문자의 모든 특수 처리를 끕니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="445dbb3aac3b63578f83ae7ca3264f9470654614" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 이진 모드로 엽니 다. 자세한 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 은 openBinaryFile 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42d2371aba08fe3ad0e461bdd5e9243b5d4ff47c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 기본 파일 권한을 사용합니다</target>
        </trans-unit>
        <trans-unit id="68e487cc9bcc812ffdd024d2959aeef2edcaff91" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 타임 스탬프는 1 초 미만의 해상도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd41ba6952859aa302482f390cdfdfc026468ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf41494a113002bf4517831272153ccf7cd29c3d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0b8c47891569804ad6ed4ae6fd8eda019375adc3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 처럼하지만 타임 스탬프는 1 초 미만의 해상도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33961ae29501aef7bf09af455c8576676e24ac35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5bbeb7f8e03e4906f3490fc206720d0eab71a223" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="662c747da0f04cde3ce2ca5a423c4b7f959d2f5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt; 하지만, 구문 분석 중 하나 이상 발생 &lt;code&gt;p&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f8ce7731553d62994a654a2d708daf3c75a28d74" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 하나 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="6fee7ff8239ed3fa9381ad7aca490952c09c187d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; ,하지만 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b3dabdc0b676ddd52428d8521d1cc42a6a7a8ded" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="a81f5f54f0cb0d0d364aaedc68e2c63bc094834c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;INLINE&lt;/code&gt;, the &lt;code&gt;INLINABLE&lt;/code&gt; pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.</source>
          <target state="translated">마찬가지로 &lt;code&gt;INLINE&lt;/code&gt; 의 &lt;code&gt;INLINABLE&lt;/code&gt; 프라그 무관 RHS의 사이즈, 인터페이스 파일에서 인라인 상업적 일본어 RHS의 복사 및 지속하여이를 보유한다.</target>
        </trans-unit>
        <trans-unit id="be5585db37b6a8bd5e1a92603fdbe92c2af65ed4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;compactAdd#&lt;/code&gt;, but retains sharing and cycles during compaction.</source>
          <target state="translated">&lt;code&gt;compactAdd#&lt;/code&gt; 처럼 만 유지 공유하고 압축하는 동안 사이클.</target>
        </trans-unit>
        <trans-unit id="211af64297aca58574fb18700a2e7f33892effcf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;createUpToN&lt;/code&gt;, but also returns an additional value created by the action.</source>
          <target state="translated">마찬가지로 &lt;code&gt;createUpToN&lt;/code&gt; 뿐만 아니라 작용에 의해 생성 된 추가 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee95b6c97dc7c4bdba6a1af63ea6a5ab1b1b563e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; bindings, name shadowing is not allowed within an &lt;code&gt;mdo&lt;/code&gt;-expression or a &lt;code&gt;rec&lt;/code&gt;-block; that is, all the names bound in a single &lt;code&gt;rec&lt;/code&gt; must be distinct. (GHC will complain if this is not the case.)</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;where&lt;/code&gt; 바인딩 과 마찬가지로 이름 섀도 잉은 &lt;code&gt;mdo&lt;/code&gt; -expression 또는 &lt;code&gt;rec&lt;/code&gt; -block 내에서 허용되지 않습니다 . 즉, 하나의 &lt;code&gt;rec&lt;/code&gt; 에 묶인 모든 이름 은 고유해야합니다. 그렇지 않은 경우 온실 가스가 불만을 제기합니다.</target>
        </trans-unit>
        <trans-unit id="a0a24c56e1b9f366848073186782d64a2635b134" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;seq&lt;/code&gt;, the argument of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; can have an unboxed type.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 인수 는 unboxed 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cafc4e6a3f71e112837260dfb933a8b2509697" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;setFileTimesHiRes&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;setFileTimesHiRes&lt;/code&gt; 처럼 하지만 경로 대신 파일 디스크립터를 사용합니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e4c941a2f6f4373225d42fc487a0f7d303ff143f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;touchFile&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;touchFile&lt;/code&gt; 과 유사 하지만 경로 대신 파일 설명자를 사용합니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="99cd3e5d292b4b23332a6b2a47c1eadf4be20341" translate="yes" xml:space="preserve">
          <source>Like all other GHCi commands, the output is always displayed in the current GHCi scope (&lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;).</source>
          <target state="translated">다른 모든 GHCi 명령과 마찬가지로 출력은 항상 현재 GHCi 범위에 표시됩니다 ( &lt;a href=&quot;#ghci-scope&quot;&gt;프롬프트의 범위는 무엇입니까?&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef089d2aac5aa17ae2f559d2e25f348c4bd6fbfe" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">다른 많은 Haskell 데이터 구조와 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 는 게으르다. 즉, 값 비싼 평가되지 않은 썽크를 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내부에 배치 하면이를 생성 한 스레드가 아니라이를 소비하는 스레드에 의해 평가됩니다. 반드시 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 에 배치 할 값을 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 엄격한 동시성 패키지에서 제공하는 엄격한 MVAR을 적절한 일반적인 형태로, 또는 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bc84715575b0fa376556544c5d2ef3d4d3ec50fb" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">다른 많은 Haskell 데이터 구조와 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 도 게으 릅니다 . 즉, 값 비싼 평가되지 않은 썽크를 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 안에 넣으면 그것을 생성 한 스레드가 아니라 소비하는 스레드에 의해 평가됩니다. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 적절한 정규 형식 으로 배치 할 값 을 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 하거나 엄격 동시성 패키지가 제공하는 엄격한 MVar를 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac2766b2f81ed2520ff46eac0020d43ebcf3f72" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">다른 많은 Haskell 데이터 구조와 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 는 게으르다. 즉, 값 비싼 평가되지 않은 썽크를 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 내부에 배치 하면이를 생성 한 스레드가 아니라이를 소비하는 스레드에 의해 평가됩니다. 반드시 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 에 배치 할 값을 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 엄격한 동시성 패키지에서 제공하는 엄격한 MVAR을 적절한 일반적인 형태로, 또는 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37c17ec186b7de612cb654acafdf92b9e7cdfb9b" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">다른 pragma와 마찬가지로 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma는 항상 범위 오류가 있는지 확인하고 유형 확인합니다. 유형 검사는 규칙의 LHS 및 RHS가 유형 검사되고 동일한 유형을 가져야 함을 의미합니다. 그러나 규칙은 &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt; 플래그가 켜져있는 경우 에만 &lt;em&gt;활성화&lt;/em&gt; 됩니다 ( &lt;a href=&quot;#rule-semantics&quot;&gt;시맨틱&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3447df87a2c63f15a9f31c14cbaf487254b0da44" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;code&gt;RULE&lt;/code&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">다른 pragma와 마찬가지로 &lt;code&gt;RULE&lt;/code&gt; pragma는 항상 범위 오류를 확인하고 형식을 확인합니다. 유형 검사는 규칙의 LHS 및 RHS가 유형 검사되며 동일한 유형을 가져야 함을 의미합니다. 그러나 &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt; 플래그가 켜져있는 경우 에만 규칙이 &lt;em&gt;활성화&lt;/em&gt; 됩니다 ( &lt;a href=&quot;#rule-semantics&quot;&gt;시맨틱&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8cd118e46b9ceb5fcb2a8499ea3916b27ce3f424" translate="yes" xml:space="preserve">
          <source>Like the function &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, but appends a stack trace to the error message if one is available.</source>
          <target state="translated">기능 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 처럼 하지만 스택 추적이있는 경우 오류 추적에 스택 추적을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2b393f82e4729c2fe510cc4df3e3b9d2a29de00f" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, it is possible to explicitly bind type and kind variables in default declarations with a &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">&lt;a href=&quot;#assoc-inst&quot;&gt;Associated 인스턴스&lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 &lt;code&gt;forall&lt;/code&gt; 을 사용하여 기본 선언의 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890d847e558aebfae92e81761cfeaf99e3ee4aed" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, it is possible to explicitly bind type and kind variables in default declarations with a &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">&lt;a href=&quot;#assoc-inst&quot;&gt;Associated 인스턴스&lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 &lt;code&gt;forall&lt;/code&gt; 을 사용하여 기본 선언의 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3d21a89ef91e153f239215fab5185af22cd639" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;&lt;a href=&quot;control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; operator in some &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functors, and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; in some monads are conditionally lazy and can &lt;em&gt;short-circuit&lt;/em&gt; a chain of computations. The below folds will terminate as early as possible, but even infinite loops can be productive here, when evaluated solely for their stream of IO side-effects. See &lt;a href=&quot;data-traversable#validation&quot;&gt;Data.Traversable&lt;/a&gt; for some additional discussion.</source>
          <target state="translated">마찬가지로 일부 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor 의 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 연산자 와 일부 모나드의 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 는 조건부로 게으르고 계산 체인을 &lt;em&gt;단락&lt;/em&gt; 시킬 수 있습니다 . 아래 폴드는 가능한 한 빨리 종료되지만 IO 부작용 스트림에 대해서만 평가할 때 무한 루프도 여기서 생산적 일 수 있습니다. 추가 논의는 &lt;a href=&quot;data-traversable#validation&quot;&gt;Data.Traversable&lt;/a&gt; 을 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24d948e4bdbe5b8224bbc0dfbab1923fab00b98e" translate="yes" xml:space="preserve">
          <source>Limit</source>
          <target state="translated">Limit</target>
        </trans-unit>
        <trans-unit id="70044be8751bf68d4de8b7945e5586e80acb7cb2" translate="yes" xml:space="preserve">
          <source>Limit the number of lines stored in the history.</source>
          <target state="translated">히스토리에 저장된 라인 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="ea9676003762818513c636984faeaa0ae356839a" translate="yes" xml:space="preserve">
          <source>Line</source>
          <target state="translated">Line</target>
        </trans-unit>
        <trans-unit id="16fd51c8ab5fd356a1d23d48f4531237b879e504" translate="yes" xml:space="preserve">
          <source>Line and character position</source>
          <target state="translated">선과 문자 위치</target>
        </trans-unit>
        <trans-unit id="702b953a8e73a9c6b4402eb231caf05c182af7f6" translate="yes" xml:space="preserve">
          <source>Line length.</source>
          <target state="translated">줄 길이.</target>
        </trans-unit>
        <trans-unit id="054f11de365cf7821b8d7f5863692c6cc9051ab6" translate="yes" xml:space="preserve">
          <source>Line number information necessary to map instruction addresses to line numbers in the source program.</source>
          <target state="translated">명령 프로그램 주소를 소스 프로그램의 행 번호에 매핑하는 데 필요한 행 번호 정보.</target>
        </trans-unit>
        <trans-unit id="8087784b605286ef9ef2960647bad3300431de2b" translate="yes" xml:space="preserve">
          <source>LineBuffering</source>
          <target state="translated">LineBuffering</target>
        </trans-unit>
        <trans-unit id="281752024edc1ab9c1f92c79633d55bc44eacd94" translate="yes" xml:space="preserve">
          <source>LineSeparator</source>
          <target state="translated">LineSeparator</target>
        </trans-unit>
        <trans-unit id="37ab103648f9cbe2c3ec3bdbc19ef7d8e446b187" translate="yes" xml:space="preserve">
          <source>Linear and multiplicity-polymorphic arrows are &lt;em&gt;always declared&lt;/em&gt;, never inferred. That is, if you don&amp;rsquo;t give an appropriate type signature to a function, it will be inferred as being a regular function of type &lt;code&gt;a -&amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">선형 및 다중 다형성 화살표는 &lt;em&gt;항상 선언&lt;/em&gt; 되며 추론되지 않습니다. 즉, 함수에 적절한 유형 시그니처를 제공하지 않으면 a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 유형 의 일반 함수로 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="6426e1d3a720f52e0ea553a3684fcfe15d605bda" translate="yes" xml:space="preserve">
          <source>Linear types are still considered experimental and come with several limitations. If you have read the full design in the proposal (see &lt;a href=&quot;#linear-types-references&quot;&gt;Design and further reading&lt;/a&gt; below), here is a run down of the missing pieces.</source>
          <target state="translated">선형 유형은 여전히 ​​실험적인 것으로 간주되며 몇 가지 제한 사항이 있습니다. 제안서의 전체 디자인을 읽은 경우 ( &lt;a href=&quot;#linear-types-references&quot;&gt;디자인 및&lt;/a&gt; 아래 추가 읽기 참조) 여기에 누락 된 부분이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34b558f3fd7232f2c7a2fa63c6617836c82a559" translate="yes" xml:space="preserve">
          <source>LinearTypes</source>
          <target state="translated">LinearTypes</target>
        </trans-unit>
        <trans-unit id="e3b93cdf9997876ced65e2c007d6364b7d627da6" translate="yes" xml:space="preserve">
          <source>LinesAffected</source>
          <target state="translated">LinesAffected</target>
        </trans-unit>
        <trans-unit id="eb1cda622d5b91f2847faea4f7c037e360353e7a" translate="yes" xml:space="preserve">
          <source>Link all passed files into a static library suitable for linking. To control the name, use the &lt;code&gt;-o ⟨file⟩&lt;/code&gt; option as usual. The default name is &lt;code&gt;liba.a&lt;/code&gt;.</source>
          <target state="translated">전달 된 모든 파일을 링크에 적합한 정적 라이브러리에 링크하십시오. 이름을 제어하려면 평소와 같이 &lt;code&gt;-o ⟨file⟩&lt;/code&gt; 옵션을 사용하십시오 . 기본 이름은 &lt;code&gt;liba.a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f4a6bdd90ed3ff452ae2e2964b9b2c357b03f32" translate="yes" xml:space="preserve">
          <source>Link in library ⟨lib⟩</source>
          <target state="translated">라이브러리의 링크 ⟨lib⟩</target>
        </trans-unit>
        <trans-unit id="d9cd1bd51d029ba12d6908919f6358ef8b55fb4f" translate="yes" xml:space="preserve">
          <source>Link in the ⟨lib⟩ library. On Unix systems, this will be in a file called &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; or &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; which resides somewhere on the library directories path.</source>
          <target state="translated">⟨lib⟩ 라이브러리에 링크하십시오. Unix 시스템에서는 라이브러리 디렉토리 경로의 어딘가에있는 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; 또는 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; 라는 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcaae5f3f12bcb52dc5f90152a65e0bdbec2c943" translate="yes" xml:space="preserve">
          <source>Link the program with a debugging version of the runtime system. The debugging runtime turns on numerous assertions and sanity checks, and provides extra options for producing debugging output at runtime (run the program with &lt;code&gt;+RTS -?&lt;/code&gt; to see a list).</source>
          <target state="translated">프로그램을 런타임 시스템의 디버깅 버전과 연결하십시오. 디버깅 런타임은 수많은 어설 션 및 온 전성 검사를 설정하고 런타임에 디버깅 출력을 생성하기위한 추가 옵션을 제공합니다 ( &lt;code&gt;+RTS -?&lt;/code&gt; 목록을 보려면 로 하십시오).</target>
        </trans-unit>
        <trans-unit id="aa02a71e52144b5208df7f7113d1f3bb6b6ff3a1" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;eventlog&amp;rdquo; version of the runtime system. A program linked in this way can generate a runtime trace of events (such as thread start/stop) to a binary file &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt;, which can then be interpreted later by various tools. See &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;Tracing&lt;/a&gt; for more information.</source>
          <target state="translated">프로그램을 런타임 시스템의 &quot;eventlog&quot;버전과 연결하십시오. 이러한 방식으로 링크 된 프로그램은 스레드 시작 / 중지와 같은 이벤트의 런타임 추적을 이진 파일 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; 에 생성 한 다음 나중에 다양한 도구로 해석 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;추적&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74630b9250c4419175d9406e09096a825645aee9" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;threaded&amp;rdquo; version of the runtime system. The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded.</source>
          <target state="translated">프로그램을 &quot;스레드&quot;버전의 런타임 시스템과 연결하십시오. 스레드 된 런타임 시스템은 단일 스레드 인 기본 런타임 시스템과 달리 여러 OS 스레드를 관리하기 때문에 소위 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e83840f20750c680ebae2cc09ff4df519b21aac5" translate="yes" xml:space="preserve">
          <source>Link the runtime when generating a shared or static library</source>
          <target state="translated">공유 또는 정적 라이브러리를 생성 할 때 런타임 연결</target>
        </trans-unit>
        <trans-unit id="a0ad1ef7b6972d54e70158733112a5d174213f28" translate="yes" xml:space="preserve">
          <source>LinkCount</source>
          <target state="translated">LinkCount</target>
        </trans-unit>
        <trans-unit id="05669bed092bbe0873ad6674e013a8667f68fe04" translate="yes" xml:space="preserve">
          <source>LinkLimit</source>
          <target state="translated">LinkLimit</target>
        </trans-unit>
        <trans-unit id="9fa999dc4d8eab9b8471e5d9aa06c5de2dbcdca7" translate="yes" xml:space="preserve">
          <source>Linking type and value level</source>
          <target state="translated">연결 유형 및 값 수준</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="2be1eb803afe605ac5bf0ed36710e67b7cf3ad56" translate="yes" xml:space="preserve">
          <source>List all enabled language extensions.</source>
          <target state="translated">사용 가능한 모든 언어 확장을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="4ada7d3f43f0d02ac75493517b3e3afc1c377d07" translate="yes" xml:space="preserve">
          <source>List all of the files or folders beginning with this path.</source>
          <target state="translated">이 경로로 시작하는 모든 파일 또는 폴더를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c60e0858274aa75bbb19a9a06cc630a1d46b1c" translate="yes" xml:space="preserve">
          <source>List all types collected for expressions and (local) bindings currently loaded (while &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; was active) with their respective source-code span, e.g.</source>
          <target state="translated">각각의 소스 코드 범위와 함께 현재로드 된 (로컬) 바인딩 ( &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; 가 활성화 된 동안)에 대해 수집 된 모든 유형을 나열합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="ba8a89a77fc9557b8e8c8d251c8ead9fbdaeb7a1" translate="yes" xml:space="preserve">
          <source>List comprehensions</source>
          <target state="translated">목록 이해</target>
        </trans-unit>
        <trans-unit id="3f051a8062e5fac28d61cc364f9f1acc708cd461" translate="yes" xml:space="preserve">
          <source>List index (subscript) operator, starting from 0. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt;, which takes an index of any integral type.</source>
          <target state="translated">0부터 시작하여 인덱스 (첨자) 연산자를 나열합니다.보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 정수 유형의 인덱스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="754adb8bd3be1191610eae9f21f2c4cd71a1162d" translate="yes" xml:space="preserve">
          <source>List notation, such as &lt;code&gt;[x,y]&lt;/code&gt; or &lt;code&gt;[m..n]&lt;/code&gt; can also be treated via rebindable syntax if you use &lt;code&gt;-XOverloadedLists&lt;/code&gt;; see &lt;a href=&quot;#overloaded-lists&quot;&gt;Overloaded lists&lt;/a&gt;.</source>
          <target state="translated">같은 표기에서, &lt;code&gt;[x,y]&lt;/code&gt; 또는 &lt;code&gt;[m..n]&lt;/code&gt; 가 또한 사용할 경우 rebindable 구를 통해 처리 될 수 &lt;code&gt;-XOverloadedLists&lt;/code&gt; 을 ; &lt;a href=&quot;#overloaded-lists&quot;&gt;오버로드 된 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f89f6b34299ebe78927d05ee13933db3f881f13b" translate="yes" xml:space="preserve">
          <source>List notation, such as &lt;code&gt;[x,y]&lt;/code&gt; or &lt;code&gt;[m..n]&lt;/code&gt; can also be treated via rebindable syntax if you use &lt;code&gt;-XOverloadedLists&lt;/code&gt;; see &lt;a href=&quot;overloaded_lists#overloaded-lists&quot;&gt;Overloaded lists&lt;/a&gt;.</source>
          <target state="translated">같은 표기에서, &lt;code&gt;[x,y]&lt;/code&gt; 또는 &lt;code&gt;[m..n]&lt;/code&gt; 가 또한 사용할 경우 rebindable 구를 통해 처리 될 수 &lt;code&gt;-XOverloadedLists&lt;/code&gt; 을 ; &lt;a href=&quot;overloaded_lists#overloaded-lists&quot;&gt;오버로드 된 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="920d73e463b5cf5eed14ea6d6e2da4031afeaa2c" translate="yes" xml:space="preserve">
          <source>List of associations</source>
          <target state="translated">협회 목록</target>
        </trans-unit>
        <trans-unit id="6b46c2d4b10caadfeb5b6a9c62ffb97de0f2b1d4" translate="yes" xml:space="preserve">
          <source>List of elements of a structure, from left to right.</source>
          <target state="translated">왼쪽에서 오른쪽으로 구조의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="33a6deba502bb1454d149d3118ad9c84618f053e" translate="yes" xml:space="preserve">
          <source>List of elements of a structure, from left to right. If the entire list is intended to be reduced via a fold, just fold the structure directly bypassing the list.</source>
          <target state="translated">구조의 요소 목록 (왼쪽에서 오른쪽으로). 전체 목록을 접기를 통해 축소하려는 경우 목록을 직접 우회하여 구조를 접으십시오.</target>
        </trans-unit>
        <trans-unit id="2d083b1175ab43fb5ee46569148ded37582637a2" translate="yes" xml:space="preserve">
          <source>List of lazy functions</source>
          <target state="translated">지연 함수 목록</target>
        </trans-unit>
        <trans-unit id="72682d906b86160d1433288b665aba1ecaebee43" translate="yes" xml:space="preserve">
          <source>List of short-circuit functions</source>
          <target state="translated">단락 기능 목록</target>
        </trans-unit>
        <trans-unit id="09c9b0a56436b310fefac1b1b89437d88df5a11b" translate="yes" xml:space="preserve">
          <source>List of strict functions</source>
          <target state="translated">엄격한 기능 목록</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">목록 작업</target>
        </trans-unit>
        <trans-unit id="5f897200e3f1c653befd6edfbddc4172f95a6a57" translate="yes" xml:space="preserve">
          <source>List patterns are also overloaded. When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, these definitions are desugared as follows</source>
          <target state="translated">목록 패턴도 오버로드됩니다. 때 &lt;code&gt;OverloadedLists&lt;/code&gt; 을 확장이 설정되어 다음과 같이 이러한 정의는 desugared된다</target>
        </trans-unit>
        <trans-unit id="76603bea3fde9f607769b026d910df0dfc04acfc" translate="yes" xml:space="preserve">
          <source>List the active breakpoints.</source>
          <target state="translated">활성 중단 점을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="bb72cfc84c631772e908d5b0c3a4205d0c9649a0" translate="yes" xml:space="preserve">
          <source>List the active evaluations that are stopped at breakpoints.</source>
          <target state="translated">중단 점에서 중지 된 활성 평가를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="d92d0a195ad4655dbddbf91fc436d0a6b999cd58" translate="yes" xml:space="preserve">
          <source>List the frames of a stack trace.</source>
          <target state="translated">스택 추적의 프레임을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b46a3709f9c0d5af2b972568db4b210d8669456f" translate="yes" xml:space="preserve">
          <source>List transformations</source>
          <target state="translated">리스트 변환</target>
        </trans-unit>
        <trans-unit id="105d6ef74784f6217af666c539a87096be10b1b3" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="f8e9efe55b79317a3e563e7e8e801673f73f1521" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="db73b7893f3af8f6c05605cf9251be842b275f8d" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="482dfe339c4f0977581fe5ee524fa53adc1e28ed" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="cfafdd602fb158738556497c46c51d6d60df9768" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="20bd5a0e4fabf718ca894fcb17f676efec0307ae" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ceba6d840aab502457ce42ae3fbfeab1ecc2414" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="66e7277f4ef344564d58e60d6ea51d7adf033fef" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3158aef4933628130f67b89a618bc8b174d8978" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="745ee4c2660329c820454e1ba2a47f402e1ce21f" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="5594bce20a5038736c0afcf0c55e2622caf81f60" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d0b7f90f7aacdb031c45cf80cdd404adafbe362" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="33a93596bb8da89147bd59e3fe1b97c2d66a5038" translate="yes" xml:space="preserve">
          <source>ListT</source>
          <target state="translated">ListT</target>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="781623c2be49bc87bb9e5a34fe84e216baf4b8b9" translate="yes" xml:space="preserve">
          <source>Lists the source code around the definition of ⟨identifier⟩ or the current breakpoint if not given. This requires that the identifier be defined in an interpreted module. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">지정되지 않은 경우 &quot;identifier&quot;정의 또는 현재 중단 점 주위의 소스 코드를 나열합니다. 이를 위해서는 식별자가 해석 된 모듈에서 정의되어야합니다. 출력 장치가 지원하는 경우 GHCi는 활성 하위 표현식을 굵게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="808589d62b1e1bf49e41bd4b6a92d4dc1a0d0f3a" translate="yes" xml:space="preserve">
          <source>Lists the source code around the given line number of ⟨module⟩. This requires that the module be interpreted. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">주어진 ⟨module⟩ 줄 번호 주위의 소스 코드를 나열합니다. 이를 위해서는 모듈을 해석해야합니다. 출력 장치가 지원하는 경우 GHCi는 활성 하위 표현식을 굵게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4a7facfa8bfb2e9078fe2cd6adc3a55c36788e6" translate="yes" xml:space="preserve">
          <source>Lists, but with an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor based on zipping.</source>
          <target state="translated">목록이지만 압축 기반 의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 케이 션 펑터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c730a293f109c2c9fe03256794b5a680b2406f1" translate="yes" xml:space="preserve">
          <source>Lit</source>
          <target state="translated">Lit</target>
        </trans-unit>
        <trans-unit id="1d45d75d6a3cc51b4987b3781a45f5c1345a4a98" translate="yes" xml:space="preserve">
          <source>LitSort</source>
          <target state="translated">LitSort</target>
        </trans-unit>
        <trans-unit id="3c7167176c55c32edbdb72649b122c134066cd84" translate="yes" xml:space="preserve">
          <source>Little-endian</source>
          <target state="translated">Little-endian</target>
        </trans-unit>
        <trans-unit id="0877eccb7ffb8474ab69b0fcf579d9b84daccdd0" translate="yes" xml:space="preserve">
          <source>Little-endian decoding</source>
          <target state="translated">리틀 엔디안 디코딩</target>
        </trans-unit>
        <trans-unit id="c7273f034919f3ef6168c89cba26b3bce836ba9e" translate="yes" xml:space="preserve">
          <source>Little-endian primitives</source>
          <target state="translated">리틀 엔디안 프리미티브</target>
        </trans-unit>
        <trans-unit id="1c321830ed633cc94628e1e65216ff4ba6a6ed76" translate="yes" xml:space="preserve">
          <source>Little-endian writes</source>
          <target state="translated">리틀 엔디안</target>
        </trans-unit>
        <trans-unit id="6fc67654e4796ae3f37595e79dd2e45c3625e5e5" translate="yes" xml:space="preserve">
          <source>LittleEndian</source>
          <target state="translated">LittleEndian</target>
        </trans-unit>
        <trans-unit id="2e67c31b2f3fdce36aeeb1f20caff4b304f70567" translate="yes" xml:space="preserve">
          <source>Ll: Letter, Lowercase</source>
          <target state="translated">Ll : 문자, 소문자</target>
        </trans-unit>
        <trans-unit id="58382029ac6f1e5383d7bade61f6a456488c6bbd" translate="yes" xml:space="preserve">
          <source>Llike &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">mallocBytes와 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 하지만 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4288785885201e9bb76e1d0199483effb5fe9f71" translate="yes" xml:space="preserve">
          <source>Lm: Letter, Modifier</source>
          <target state="translated">Lm : 문자, 수정 자</target>
        </trans-unit>
        <trans-unit id="2fdaaab4868bf18d8a809e1f5f7e47a37f964d96" translate="yes" xml:space="preserve">
          <source>Lo: Letter, Other</source>
          <target state="translated">Lo : 편지, 기타</target>
        </trans-unit>
        <trans-unit id="8accbc10b359e949cb147175bb580bf3e07dc786" translate="yes" xml:space="preserve">
          <source>Load a plugin exported by a given module</source>
          <target state="translated">지정된 모듈에서 내 보낸 플러그인로드</target>
        </trans-unit>
        <trans-unit id="51fa1bf18d44ef1d1248c602fa8dd72c62735eea" translate="yes" xml:space="preserve">
          <source>Load the plugin in the given module. The module must be a member of a package registered in GHC&amp;rsquo;s package database.</source>
          <target state="translated">주어진 모듈에 플러그인을로드하십시오. 모듈은 GHC의 패키지 데이터베이스에 등록 된 패키지의 구성원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="19f77727de15c8eb41a9504fa18fee15c5c48b61" translate="yes" xml:space="preserve">
          <source>Load-balancing shares out the work of GC between the available cores. This is a good idea when the heap is large and we need to parallelise the GC work, however it is also pessimal for the short young-generation collections in a parallel program, because it can harm locality by moving data from the cache of the CPU where is it being used to the cache of another CPU. Hence the default is to do load-balancing only in the old-generation. In fact, for a parallel program it is sometimes beneficial to disable load-balancing entirely with &lt;code&gt;-qb&lt;/code&gt;.</source>
          <target state="translated">로드 균형 조정은 사용 가능한 코어간에 GC 작업을 공유합니다. 힙이 크고 GC 작업을 병렬화해야하는 경우에 좋은 아이디어이지만 병렬 프로그램의 짧은 젊은 세대 콜렉션에도 적합합니다. 이는 CPU 캐시에서 데이터를 이동하여 로컬 성을 해칠 수 있기 때문입니다. 다른 CPU의 캐시에 사용되는 곳은 어디입니까? 따라서 기본값은 이전 세대에서만로드 밸런싱을 수행하는 것입니다. 사실, 병렬 프로그램의 경우 &lt;code&gt;-qb&lt;/code&gt; 로 로드 밸런싱을 완전히 비활성화하는 것이 때로는 유리합니다 .</target>
        </trans-unit>
        <trans-unit id="5baeca2bd84e4324195dfc5aa4a5d2fe832d33c9" translate="yes" xml:space="preserve">
          <source>Loading a multi-module program is just as straightforward; just give the name of the &amp;ldquo;topmost&amp;rdquo; module to the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command (hint: &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be abbreviated to &lt;code&gt;:l&lt;/code&gt;). The topmost module will normally be &lt;code&gt;Main&lt;/code&gt;, but it doesn&amp;rsquo;t have to be. GHCi will discover which modules are required, directly or indirectly, by the topmost module, and load them all in dependency order.</source>
          <target state="translated">멀티 모듈 프로그램을로드하는 것은 간단합니다. &quot;loadest&quot;모듈의 이름을 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령에 지정하십시오 (힌트 : &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;:l&lt;/code&gt; 로 축약 될 수 있음 ). 최상위 모듈은 일반적으로 &lt;code&gt;Main&lt;/code&gt; 이지만 반드시 그럴 필요는 없습니다. GHCi는 최상위 모듈이 직간접 적으로 어떤 모듈을 필요로하는지 발견하고 모든 모듈을 종속성 순서대로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3ca542db8dd842ccea2e2f49600e491d4a676f0a" translate="yes" xml:space="preserve">
          <source>Loc</source>
          <target state="translated">Loc</target>
        </trans-unit>
        <trans-unit id="94637a234d4833c0a67b7a4f6b5d70bd1cdd5712" translate="yes" xml:space="preserve">
          <source>Local Time</source>
          <target state="translated">현지 시각</target>
        </trans-unit>
        <trans-unit id="ab3cb665e2195c48dc51ad950c912c0fa2cb8e4a" translate="yes" xml:space="preserve">
          <source>Local allocation</source>
          <target state="translated">로컬 할당</target>
        </trans-unit>
        <trans-unit id="0478f8de1f3f270ad9e2bf09aa44262b4422de07" translate="yes" xml:space="preserve">
          <source>Local name bound outside of the TH AST</source>
          <target state="translated">TH AST 외부에 바인딩 된 로컬 이름</target>
        </trans-unit>
        <trans-unit id="93c22935b426d63080a636bc51d84b1a5c5cca31" translate="yes" xml:space="preserve">
          <source>Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used.</source>
          <target state="translated">로컬, 독점, 왼쪽 바이어스 선택 : 왼쪽 구문 분석기가 로컬로 결과를 생성하는 경우 오른쪽 구문 분석기가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478df254596a4a4a51b18fe7c43423e110e9c8b9" translate="yes" xml:space="preserve">
          <source>LocalMode</source>
          <target state="translated">LocalMode</target>
        </trans-unit>
        <trans-unit id="9cb40f7cd87e6348d6d2464d28eeaa1636f17835" translate="yes" xml:space="preserve">
          <source>LocalTime</source>
          <target state="translated">LocalTime</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="c72c9f7a9c187a5da0f209dc188fa32ae35d17f4" translate="yes" xml:space="preserve">
          <source>Locale representing American usage.</source>
          <target state="translated">미국 사용법을 나타내는 로케일.</target>
        </trans-unit>
        <trans-unit id="b7a9db328cdf327a87303972030f518b2e1143a4" translate="yes" xml:space="preserve">
          <source>Locale support</source>
          <target state="translated">로케일 지원</target>
        </trans-unit>
        <trans-unit id="6f1b4ce09e502ee2cc257e3b65eb100b21e07dcd" translate="yes" xml:space="preserve">
          <source>LocaleTestFlags</source>
          <target state="translated">LocaleTestFlags</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="04685f4c01bb7310cd3e866073d0858b658078ed" translate="yes" xml:space="preserve">
          <source>Location information about an address from a backtrace.</source>
          <target state="translated">역 추적의 주소에 대한 위치 정보.</target>
        </trans-unit>
        <trans-unit id="5131787646387f0d5f88f17ccb4880dde6ba21d3" translate="yes" xml:space="preserve">
          <source>Lock the semaphore, blocking until it becomes available. Since this is done through a system call, this will block the *entire runtime*, not just the current thread. If this is not the behaviour you want, use semThreadWait instead.</source>
          <target state="translated">세마포어를 잠그고 사용 가능해질 때까지 차단하십시오. 이는 시스템 호출을 통해 수행되므로 현재 스레드뿐만 아니라 * 전체 런타임 *을 차단합니다. 이것이 원하는 동작이 아닌 경우 semThreadWait를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79ad9e43cfdad7f13ded5dc73bb870eee73c9832" translate="yes" xml:space="preserve">
          <source>LockMode</source>
          <target state="translated">LockMode</target>
        </trans-unit>
        <trans-unit id="031e1faa819e43723677621db8e08752f93d196c" translate="yes" xml:space="preserve">
          <source>LockRequest</source>
          <target state="translated">LockRequest</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="f768a9742ff93e60b7bb02545b5b0dd507f52d9d" translate="yes" xml:space="preserve">
          <source>Locking mode</source>
          <target state="translated">잠금 모드</target>
        </trans-unit>
        <trans-unit id="3c518a9153977589254df029f9697c14bdd187b6" translate="yes" xml:space="preserve">
          <source>Locks a given range in a file handle, To lock an entire file use 0xFFFFFFFFFFFFFFFF for size and 0 for offset.</source>
          <target state="translated">파일 핸들에서 주어진 범위를 잠급니다. 전체 파일을 잠 그려면 크기에 0xFFFFFFFFFFFFFFFF를 사용하고 오프셋에 0을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db36a6985ae81e7f06f9b77a678b760e42fb6c81" translate="yes" xml:space="preserve">
          <source>Log base 2 (round down) of natural numbers. &lt;code&gt;Log 0&lt;/code&gt; is undefined (i.e., it cannot be reduced).</source>
          <target state="translated">자연수의 밑수 2 (내림차순)입니다. &lt;code&gt;Log 0&lt;/code&gt; 은 정의되어 있지 않습니다 (즉, 줄일 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="705364a478cdab0540a4c25854746a42ccf2183f" translate="yes" xml:space="preserve">
          <source>Log events as text to standard output, instead of to the &lt;code&gt;.eventlog&lt;/code&gt; file. The ⟨flags⟩ are the same as for &lt;code&gt;-l&lt;/code&gt;, with the additional option &lt;code&gt;t&lt;/code&gt; which indicates that the each event printed should be preceded by a timestamp value (in the binary &lt;code&gt;.eventlog&lt;/code&gt; file, all events are automatically associated with a timestamp).</source>
          <target state="translated">이벤트를 &lt;code&gt;.eventlog&lt;/code&gt; 파일 대신 표준 출력에 텍스트로 기록 하십시오. ⟨flags⟩는 &lt;code&gt;-l&lt;/code&gt; 과 동일하며 추가 옵션 &lt;code&gt;t&lt;/code&gt; 는 인쇄 된 각 이벤트 앞에 타임 스탬프 값이 와야 함을 나타냅니다 (이진 &lt;code&gt;.eventlog&lt;/code&gt; 파일에서 모든 이벤트는 자동으로 타임 스탬프와 연결됨 ).</target>
        </trans-unit>
        <trans-unit id="8c0b83ca797348a57e601331a800396f17173e34" translate="yes" xml:space="preserve">
          <source>Log events in binary format. Without any ⟨flags⟩ specified, this logs a default set of events, suitable for use with tools like ThreadScope.</source>
          <target state="translated">이진 형식으로 이벤트를 기록합니다. &quot;플래그&quot;를 지정하지 않으면 ThreadScope와 같은 도구와 함께 사용하기에 적합한 기본 이벤트 세트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="f61cb07b41e23ab1a79f15c05c0f8ba5b477ab22" translate="yes" xml:space="preserve">
          <source>Logarithmic-time access to any element with &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt; 를 사용하여 모든 요소에 로그 타임 액세스 , &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4382c3d779a065ce766f6771a0eda14473b0c8a" translate="yes" xml:space="preserve">
          <source>Logarithmic-time concatenation with &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와의 로그 시간 연결</target>
        </trans-unit>
        <trans-unit id="c70a3bed95e2afdacbd2edd9f3abf4bff06b5635" translate="yes" xml:space="preserve">
          <source>Logarithmic-time splitting with &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">와 대수 시간 분할 &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cebebf8637724ae58cb90aacf5d8022fb2074f2" translate="yes" xml:space="preserve">
          <source>Look at the Core syntax!</source>
          <target state="translated">핵심 구문을보십시오!</target>
        </trans-unit>
        <trans-unit id="4f44d0f99b2e9f9e75bd7d13f005f42ba7ac90d3" translate="yes" xml:space="preserve">
          <source>Look at the first three elements of a sequence</source>
          <target state="translated">시퀀스의 처음 세 요소를보십시오</target>
        </trans-unit>
        <trans-unit id="036e3fb15ef00e480fa4d3acf7a733a4ca5f5561" translate="yes" xml:space="preserve">
          <source>Look for the exact match on the name in the built-in command list.</source>
          <target state="translated">내장 명령 목록에서 이름과 정확히 일치하는지 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1c5a3aaf89cbcab1e2d9dd0a759cbcb475301525" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">인터페이스 파일에서 함수를 찾은 다음 pragma의 세 번째 필드를 찾으십시오. 이 말을해야 &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; . ⟨string⟩은 함수 인수의 엄격 성을 제공합니다 . 엄격 표기법에 대한 설명은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;GHC 주석&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a08e53663e845cc46457faaa8a00f1851876f2c" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">인터페이스 파일에서 함수를 찾은 다음 pragma에서 세 번째 필드를 찾습니다. &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; 되어야합니다 . ⟨string⟩은 함수 인수의 엄격함을 제공합니다 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;GHC 주석&lt;/a&gt; 참조 . 엄격 성 표기법에 대한 설명은 을 .</target>
        </trans-unit>
        <trans-unit id="646113c2b824e740bba103f465367c553a9eb4ec" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database, and fail if it's not defined.</source>
          <target state="translated">terminfo 데이터베이스에서 부울 기능을 찾고 정의되지 않은 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4c0a18679ef62e4477ab6e7f74f367ea337ce4c" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 부울 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="7a72d8f66e8e9faaac46b9deb897bfc7808a27e2" translate="yes" xml:space="preserve">
          <source>Look up a constructor by its representation</source>
          <target state="translated">표현으로 생성자를 조회</target>
        </trans-unit>
        <trans-unit id="c01e8f2c42ad48d0b20e9f727f7dd206fb60685a" translate="yes" xml:space="preserve">
          <source>Look up a numeric capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 숫자 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="586b4cdd798272f8e1ea61b1bc18f4217842421c" translate="yes" xml:space="preserve">
          <source>Look up a string capability in the terminfo database. NOTE: This function is deprecated; use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">terminfo 데이터베이스에서 문자열 기능을 찾으십시오. 참고 :이 기능은 더 이상 사용되지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="a9c5ab2d2d0139456f33ef943c0b402c0ecc56ca" translate="yes" xml:space="preserve">
          <source>Look up an output capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 출력 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9021c22f55a1940644c0487372237fc2b4baba0e" translate="yes" xml:space="preserve">
          <source>Look up an output capability which takes a fixed number of parameters (for example, &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt;).</source>
          <target state="translated">고정 된 수의 매개 변수 (예 : &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt; )를 사용 하는 출력 기능을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="f90efbcd7f1eeff6426b782004bd5ca5f919386e" translate="yes" xml:space="preserve">
          <source>Look up the control sequence for a given function sequence. For example, &lt;code&gt;functionKey 12&lt;/code&gt; retrieves the &lt;code&gt;kf12&lt;/code&gt; capability.</source>
          <target state="translated">주어진 기능 순서에 대한 제어 순서를 찾으십시오. 예를 들어, &lt;code&gt;functionKey 12&lt;/code&gt; 는 &lt;code&gt;kf12&lt;/code&gt; 기능을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="fee394d0e5a9ad0f8eab2e63dc20d9771d2d9b1c" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (type namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">현재 스플 라이스 범위의 (유형 네임 스페이스)에서 지정된 이름을 찾습니다. 자세한 내용은 &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1a8bb741760af7e3cd92aaa2b183fc9d4090ffa" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (value namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">현재 스플 라이스 범위의 (값 네임 스페이스)에서 지정된 이름을 찾습니다. 자세한 내용은 &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c27f2b60d886938ddc087b401729fa285ab4f28" translate="yes" xml:space="preserve">
          <source>Look up the named Unicode encoding. May fail with</source>
          <target state="translated">명명 된 유니 코드 인코딩을 찾습니다. 실패 할 수있다</target>
        </trans-unit>
        <trans-unit id="ba28f2554c741d83cd517f5e544d7d36306b57bc" translate="yes" xml:space="preserve">
          <source>Look-ahead: returns the part of the input that is left, without consuming it.</source>
          <target state="translated">Look-ahead : 남은 입력 부분을 소비하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5eb4c34799d13148c8206bca4c92597220f71e0b" translate="yes" xml:space="preserve">
          <source>Looks up a &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; by its &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">업 외모 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 의에 의해 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="b233a4c41641797d29c66ebedda9a193a0f05643" translate="yes" xml:space="preserve">
          <source>Lookup a constructor via a string</source>
          <target state="translated">문자열을 통해 생성자 조회</target>
        </trans-unit>
        <trans-unit id="9b088da5659869d545bfc9a0cf4258116c580743" translate="yes" xml:space="preserve">
          <source>LossOfPrecision</source>
          <target state="translated">LossOfPrecision</target>
        </trans-unit>
        <trans-unit id="853c95f571d7fa18c42a8e831393f2dd7e6ab65b" translate="yes" xml:space="preserve">
          <source>Low level CString conversions</source>
          <target state="translated">저수준 CString 변환</target>
        </trans-unit>
        <trans-unit id="9a62bf48cdec4e2fa80fc92d8d939e62810d8f8d" translate="yes" xml:space="preserve">
          <source>Low level conversions</source>
          <target state="translated">저수준 전환</target>
        </trans-unit>
        <trans-unit id="e5145ff9d1cf255f56081e2cfd62251c784c3336" translate="yes" xml:space="preserve">
          <source>Low level execution</source>
          <target state="translated">저수준 실행</target>
        </trans-unit>
        <trans-unit id="163304e093070531fe3b7fc36d57bfbdbc31b649" translate="yes" xml:space="preserve">
          <source>Low level imperative construction</source>
          <target state="translated">저수준 명령 구조</target>
        </trans-unit>
        <trans-unit id="50d7d6709a31a0dba951b8a2031b80d349c3b9d0" translate="yes" xml:space="preserve">
          <source>Low level interaction with CStrings</source>
          <target state="translated">CString과의 낮은 수준의 상호 작용</target>
        </trans-unit>
        <trans-unit id="6177301b8c0f30b2a86ceb3d0093fdce68f18734" translate="yes" xml:space="preserve">
          <source>Low level operations</source>
          <target state="translated">저수준 운영</target>
        </trans-unit>
        <trans-unit id="972a48160fb1f24ef39460baab7e378aa636e944" translate="yes" xml:space="preserve">
          <source>Low word of signed integer multiply.</source>
          <target state="translated">부호있는 정수의 하위 단어 곱하기.</target>
        </trans-unit>
        <trans-unit id="0cabfc67ff1de7a21583a2681ad3451d8a86cf31" translate="yes" xml:space="preserve">
          <source>Low-level action that performs the real close.</source>
          <target state="translated">실제 근접을 수행하는 저수준 작업.</target>
        </trans-unit>
        <trans-unit id="0b24e544fe7febd646c007e1db09a744758b8a8c" translate="yes" xml:space="preserve">
          <source>Low-level capabilities</source>
          <target state="translated">저수준 기능</target>
        </trans-unit>
        <trans-unit id="f7ce8d6baf61dc38e2ccf714c9bc7f73b9b6975e" translate="yes" xml:space="preserve">
          <source>Low-level creation of the ParsecT type. You really shouldn't have to do this.</source>
          <target state="translated">ParsecT 유형의 저수준 작성. 당신은 정말로 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ee648a6dd68992ea5cde1cd8d86b7c63d4484d6" translate="yes" xml:space="preserve">
          <source>Low-level manipulation</source>
          <target state="translated">저수준 조작</target>
        </trans-unit>
        <trans-unit id="9a08a2849208613a25ed31a1dac45b5fb6adb67f" translate="yes" xml:space="preserve">
          <source>Low-level operations</source>
          <target state="translated">저수준 작업</target>
        </trans-unit>
        <trans-unit id="13fab495e207628ea2444c309679bf776f4535b0" translate="yes" xml:space="preserve">
          <source>Low-level support for text I/O.</source>
          <target state="translated">텍스트 I / O에 대한 저수준 지원.</target>
        </trans-unit>
        <trans-unit id="f00047587dbdef15842bce850c4a2657569cb360" translate="yes" xml:space="preserve">
          <source>Low-level unpacking of the ParsecT type. To run your parser, please look to runPT, runP, runParserT, runParser and other such functions.</source>
          <target state="translated">ParsecT 유형의 저수준 포장 풀기. 파서를 실행하려면 runPT, runP, runParserT, runParser 및 기타 기능을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bf0c3ee8ad72ff8c9d2eb19ea3532abdb2e4b477" translate="yes" xml:space="preserve">
          <source>Lowercase pattern syntax functions</source>
          <target state="translated">소문자 패턴 구문 함수</target>
        </trans-unit>
        <trans-unit id="a6b810d16a3b6d530ef202b4a2d4f83a9f2052b1" translate="yes" xml:space="preserve">
          <source>LowercaseLetter</source>
          <target state="translated">LowercaseLetter</target>
        </trans-unit>
        <trans-unit id="3f339b0acbc3595803d9353e1c9001e104dfb4d7" translate="yes" xml:space="preserve">
          <source>Lt: Letter, Titlecase</source>
          <target state="translated">Lt : 편지, 타이틀 케이스</target>
        </trans-unit>
        <trans-unit id="fae8b46afcb632cf202e5b21df13474f2135a227" translate="yes" xml:space="preserve">
          <source>Lu: Letter, Uppercase</source>
          <target state="translated">루 : 편지, 대문자</target>
        </trans-unit>
        <trans-unit id="76ecaf2a4852a8a6204487921c653426552025b4" translate="yes" xml:space="preserve">
          <source>Luckily, we know of a function that takes an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; and returns an &lt;code&gt;(m a)&lt;/code&gt;: &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt;, enabling us to run the program and see the expected results:</source>
          <target state="translated">운 좋게도 우리는 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 를 받고 &lt;code&gt;(m a)&lt;/code&gt; : &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 를 반환하는 함수를 알고 있습니다 . 이를 통해 프로그램을 실행하고 예상되는 결과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d00f67258bac7b9cebb726f8da4dc1bfbef425" translate="yes" xml:space="preserve">
          <source>M1</source>
          <target state="translated">M1</target>
        </trans-unit>
        <trans-unit id="b215a5a119a163d59cea8f190c2384c43d8ef927" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL LEFT WHITE SQUARE BRACKET</source>
          <target state="translated">수학적 왼쪽 흰색 사각형 브래킷</target>
        </trans-unit>
        <trans-unit id="3040721941e3243f84460b3f75c97496f9d468d1" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL RIGHT WHITE SQUARE BRACKET</source>
          <target state="translated">MATHEMATICAL RIGHT WHITE 스퀘어 브라켓</target>
        </trans-unit>
        <trans-unit id="b4d743ca88772a1217c91cba52116bdb88ef5d73" translate="yes" xml:space="preserve">
          <source>MArray</source>
          <target state="translated">MArray</target>
        </trans-unit>
        <trans-unit id="4b3e60b5afe51211e63fc50f1522b81c9ed52c4b" translate="yes" xml:space="preserve">
          <source>MBlock size</source>
          <target state="translated">MBlock 크기</target>
        </trans-unit>
        <trans-unit id="66d7b21255c88198fbbcee4794e30cfb5de722f2" translate="yes" xml:space="preserve">
          <source>MOUSEINPUT</source>
          <target state="translated">MOUSEINPUT</target>
        </trans-unit>
        <trans-unit id="2dafde4ace7cf035bd8fac9346bb5f75c97c5928" translate="yes" xml:space="preserve">
          <source>MVar</source>
          <target state="translated">MVar</target>
        </trans-unit>
        <trans-unit id="fb09978b40c384ebd545f0a9a7fcdec83351ee76" translate="yes" xml:space="preserve">
          <source>MVar#</source>
          <target state="translated">MVar#</target>
        </trans-unit>
        <trans-unit id="46d2f54777058d8f461ec0e1349a0d4dfc5ea0e9" translate="yes" xml:space="preserve">
          <source>MVars</source>
          <target state="translated">MVars</target>
        </trans-unit>
        <trans-unit id="ff6912e2f0ea1f0a272acab877e81da5e3f73b0e" translate="yes" xml:space="preserve">
          <source>Magenta</source>
          <target state="translated">Magenta</target>
        </trans-unit>
        <trans-unit id="6c6f4a44e9e83aafaa5023b2c1c354521ec83aa4" translate="yes" xml:space="preserve">
          <source>MagicHash</source>
          <target state="translated">MagicHash</target>
        </trans-unit>
        <trans-unit id="597dbcc3afd445131f986826cdf6caa30f1f99dd" translate="yes" xml:space="preserve">
          <source>Maintainer</source>
          <target state="translated">Maintainer</target>
        </trans-unit>
        <trans-unit id="9ed930864a951ac93cbc26664a2297c407da9c9e" translate="yes" xml:space="preserve">
          <source>Maintaining variable bindings, or other shared environment.</source>
          <target state="translated">변수 바인딩 또는 기타 공유 환경 유지</target>
        </trans-unit>
        <trans-unit id="a8a516b79965afb8ee743e8779110117c528ae43" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, stop GHC eta-expanding through a case expression, which is good for performance, but bad if you are using &lt;code&gt;seq&lt;/code&gt; on partial applications.</source>
          <target state="translated">바닥 처리에 대해 GHC를 더 정확하게 만듭니다 (그러나 &lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; 참조&lt;/a&gt; ). 특히 케이스 표현식을 통해 GHC eta-expanding을 중지하십시오. 이는 성능에는 좋지만, 부분 애플리케이션에서 &lt;code&gt;seq&lt;/code&gt; 를 사용하는 경우에는 나쁩니다 .</target>
        </trans-unit>
        <trans-unit id="d7420d41204c439a4f517471040fab645169f4e5" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, GHC will not eta-expand through a case expression.</source>
          <target state="translated">바닥 처리에 대해 GHC를 더 정확하게 만듭니다 (그러나 &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; 참조&lt;/a&gt; ). 특히, GHC는 사례 발현을 통해 에타-팽창되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="2fdef1410de7bb1f110ecf15d30ac3c953aad457" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">문자열 을 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 토큰 유형 의 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 인스턴스로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2d2d3352f83dfd1c05932c3401d3d788e9213d3c" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">Strings 를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 토큰 유형 의 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 인스턴스로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d1084fe0dfb8f51c0fc8e30373108ff6994595e4" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">Strings 를 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 토큰 유형 의 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 인스턴스로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c8574286f1db7f5674cdca2f0f347f3d37fbe842" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가비지 수집 시 실행할 두 번째 인수를 종료 자로 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3c9caff43c15f5f5ce07d7d17ceba770b1aed418" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 마지막 인수로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터 만들기</target>
        </trans-unit>
        <trans-unit id="59b220e362957ec29f398b074092e745f5e98507" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="43736e995d33c8137a44869b4d0d5452ba4e560a" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="172869b1cbc85f865a41d6b19398e157d00b6ffc" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행할 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a8478949c5b16ca6a4c0c847407471a72f503c5" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bb1e49e8f1341ae8024c59aa4dfd0a0ff98889ea" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; from an existing file descriptor. Fails if the FD refers to a directory. If the FD refers to a file, &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; locks the file according to the Haskell 2010 single writer/multiple reader locking semantics (this is why we need the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; argument too).</source>
          <target state="translated">기존 파일 설명자에서 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 를 만듭니다 . FD가 디렉토리를 참조하면 실패합니다. FD가 파일을 참조하는 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; 는 Haskell 2010 단일 작성기 / 다중 판독기 잠금 시맨틱에 따라 파일을 잠급니다 (이 때문에 &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 인수도 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="c7f75d66c23f2c823051ed78b549c0dc321c99c1" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 마지막 인수로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="90c73ab748e0e00da22596dbc5fd000f5f781ad2" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">두 번째 인수를 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 가비지 수집 시 실행할 최종 자로 사용하여 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="68976173fa646f3a0550c955065f1d56dd3d0c9c" translate="yes" xml:space="preserve">
          <source>Make a StablePtr that can be passed to the C function &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. The RTS wants a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt;, but a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; can only refer to lifted types, so we have to cheat by coercing.</source>
          <target state="translated">C 함수 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 전달할 수있는 StablePtr을 작성하십시오 . RTS는 기본 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 을 원 하지만 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; 은 해제 된 유형 만 참조 할 수 있으므로 강제로 속임수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="340793623e1a085d7b8da534d1c4b5daea514359" translate="yes" xml:space="preserve">
          <source>Make a mutable array immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 배열을 변경 불가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c7e012d6c09327d0dafcfeae27a661402dd25db0" translate="yes" xml:space="preserve">
          <source>Make a mutable array of arrays immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 배열의 배열을 변경할 수 없게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="698be6d083fa7f3ca40015a52bb017297e592080" translate="yes" xml:space="preserve">
          <source>Make a mutable byte array immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 바이트 배열을 변경할 수 없도록 만듭니다.</target>
        </trans-unit>
        <trans-unit id="46fdb0fb8e4b555aaff57055206c3612f29ab2c3" translate="yes" xml:space="preserve">
          <source>Make a path absolute, normalize the path, and remove as many indirections from it as possible. Any trailing path separators are discarded via &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt;. Additionally, on Windows the letter case of the path is canonicalized.</source>
          <target state="translated">절대 경로를 만들고 경로를 정규화하고 가능한 많은 간접 경로를 제거하십시오. 후행 경로 구분 기호는 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt; 를 통해 삭제됩니다 . 또한 Windows에서는 경로의 대소 문자가 정식화됩니다.</target>
        </trans-unit>
        <trans-unit id="186ec7bfc50eae0a8d365be8aba8bea7326758f0" translate="yes" xml:space="preserve">
          <source>Make a reference to a local value that we can send remotely. This reference will keep the value that it refers to alive until &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">원격으로 보낼 수있는 로컬 값을 참조하십시오. 이 참조는 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; 가 호출 될 때까지 참조하는 값을 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="3c87f88ba73344e1ab783a73a9a5979fecf885d2" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 리턴 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 디렉토리의 경로이며 6 개의 임의 문자로 채워집니다. 인수는 작성할 임시 디렉토리의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="8d3ca167e4c389a68d7893e4900b4c3fb3ba06a9" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 6 개의 임의 문자로 채워진 생성 된 디렉터리의 경로입니다. 인수는 생성 할 임시 디렉토리 파일 경로의 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="c74d346c4da5940c1912b0eac5540bbe7a580ada" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 6 개의 임의 문자로 채워진 생성 된 디렉토리의 경로입니다. 인수는 생성 할 임시 디렉토리 파일 경로의 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="81daa0d04fc3934a4c048011fb03208252f865cf" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 리턴 된 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 디렉토리의 경로이며 6 개의 임의 문자로 채워집니다. 인수는 작성할 임시 디렉토리의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="6a7af8c778c02a1f594bc3983b00324c16ab69b7" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 임의의 6 자로 채워집니다. 인수는 작성할 임시 파일의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="330d0dcda662cdafbb50eaf0cfa0b95ff8c0f42d" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 6 개의 임의 문자로 채워집니다. 인수는 생성 할 임시 파일의 파일 경로에 대한 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="510be01a4433f345cddd74c7e143b3b18d7042bb" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 6 개의 임의 문자로 채워집니다. 인수는 생성 할 임시 파일의 파일 경로에 대한 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="55c11d94c0f07317aebbc90457dbda2e57127b10" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 리턴 된 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 파일의 (상대적으로) 경로이며 임의의 6 자로 채워집니다. 인수는 작성할 임시 파일의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="f72f7ad8e05097abb6ee289f5eba19d0e1965f5c" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">지정된 접두사와 접미사를 사용하여 고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 접두사와 접미사 사이에 6 개의 임의 문자가 들어 있습니다. 첫 번째 인수는 작성할 임시 파일의 파일 경로 접 두부입니다. 두 번째 인수는 작성할 임시 파일의 접미 부입니다.</target>
        </trans-unit>
        <trans-unit id="95866426633d8275aa8fda94a7e85fdc02e90eb7" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">주어진 접두사와 접미사로 고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 접두사와 접미사 사이에 6 개의 임의 문자를 포함하는 생성 된 파일의 (상대적) 경로입니다. 첫 번째 인수는 생성 할 임시 파일의 파일 경로에 대한 원하는 접두사입니다. 두 번째 인수는 만들 임시 파일의 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="1c2d72bf515d3058a7049dde45a964b650627ffb" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">주어진 접두사와 접미사로 고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 접두사와 접미사 사이에 6 개의 임의 문자를 포함하는 생성 된 파일의 (상대적 일 수 있음) 경로입니다. 첫 번째 인수는 만들 임시 파일의 파일 경로에 대한 원하는 접두사입니다. 두 번째 인수는 만들 임시 파일의 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="3855d0f70cdfe996ae50f55037d364c1d1456c5b" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="393f21690a4ea611c6c45f302e4ee432d74df383" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82f94594233f4381e0de2f863949173a4888fe87" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c15a521855fa1db7d583391896bbe67487efc38" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0efc78aad57ab0b135f7ad0c2ee2f1ea5372a73a" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d033fcc13dd280fccc1b69e179fcb458f3b3db2" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86ec4e16e20a04abfbb1ac99cdbce02e8ced1057" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a77491851c6d1ffca83dc5af796a06989b259ab9" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d654a324a0882e03ad1f59875092013e6ecc780a" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지 하면서 스레드가 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 패밀리 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 를 수신하도록 허용하려면 이 작업을 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용되어 스레드를 차단 해제 할 수 있으므로 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f678ce0a5f94456a91a790fc3be2c2ec6925020" translate="yes" xml:space="preserve">
          <source>Make an immutable array mutable, without copying.</source>
          <target state="translated">복사하지 않고 불변 배열을 변경 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="df39c3ecba9f1a1d5927f8873184709183484ed4" translate="yes" xml:space="preserve">
          <source>Make bindings in the current module strict by default.</source>
          <target state="translated">기본적으로 현재 모듈의 바인딩을 엄격하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b462570effd4237ee90c797f361ccb9ef392f0ca" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;</source>
          <target state="translated">접미사가 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 인 파일을 접미사 가있는 인터페이스 파일에 의존한다고 선언하는 종속성을 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9d645523fe749f3d314ba22eb6324344c7aca9" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;, or (for &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports) on &lt;code&gt;.hi-boot&lt;/code&gt;. Multiple &lt;code&gt;-dep-suffix&lt;/code&gt; flags are permitted. For example, &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; will make dependencies for &lt;code&gt;.hs&lt;/code&gt; on &lt;code&gt;.hi&lt;/code&gt;, &lt;code&gt;.a_hs&lt;/code&gt; on &lt;code&gt;.a_hi&lt;/code&gt;, and &lt;code&gt;.b_hs&lt;/code&gt; on &lt;code&gt;.b_hi&lt;/code&gt;. Note that you must provide at least one suffix; if you do not want a suffix then pass &lt;code&gt;-dep-suffix ''&lt;/code&gt;.</source>
          <target state="translated">만들기 종속성을 선언하는 접미사를 가진 파일 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 접미사 인터페이스 파일에 의존 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt; , 또는 (위해 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 수입)에 &lt;code&gt;.hi-boot&lt;/code&gt; . 여러 개의 &lt;code&gt;-dep-suffix&lt;/code&gt; 플래그가 허용됩니다. 예를 들어, &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; 는 &lt;code&gt;.hs&lt;/code&gt; on &lt;code&gt;.hi&lt;/code&gt; , &lt;code&gt;.a_hs&lt;/code&gt; on &lt;code&gt;.a_hi&lt;/code&gt; 및 &lt;code&gt;.b_hs&lt;/code&gt; on &lt;code&gt;.b_hi&lt;/code&gt; 에 대한 종속성 을 작성 합니다. 최소한 하나 이상의 접미사를 제공해야합니다. 접미사를 원하지 않으면 &lt;code&gt;-dep-suffix ''&lt;/code&gt; 를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f58245b56849264d71b5f006aa40914e92e5165" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict</source>
          <target state="translated">사전을 엄격하게 만들기</target>
        </trans-unit>
        <trans-unit id="f7e4637506fdb1c126cf33d58aefa19e41c7d250" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict.</source>
          <target state="translated">사전을 엄격하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="5455661e420f1ccaf72cf9dabbbfecf771d7db4a" translate="yes" xml:space="preserve">
          <source>Make dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">사전 값 표현을 최적화 프로그램에 저렴하게 보이게하십시오.</target>
        </trans-unit>
        <trans-unit id="6f85a3e8f6df876856512758475047874462d99e" translate="yes" xml:space="preserve">
          <source>Make fields of data types defined in the current module strict by default.</source>
          <target state="translated">현재 모듈에 정의 된 데이터 유형의 필드를 기본적으로 엄격하게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="af0e48df1414b6d5a7855574141f6461c5ce4805" translate="yes" xml:space="preserve">
          <source>Make suggestions for mis-spelled names.</source>
          <target state="translated">철자가 틀린 이름을 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="88ce76b97dc5f41df8b9eb8175635106d378b209" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
