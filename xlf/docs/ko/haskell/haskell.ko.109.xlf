<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="4764bca69c81c35d030020e51edddf17222f768e" translate="yes" xml:space="preserve">
          <source>Int32Rep</source>
          <target state="translated">Int32Rep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">정수 결과</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">정수 나누기를 지원하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">일체형</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">포인터와의 무손실 변환이 가능한 정수 유형</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">고정 배열과 함께 사용하도록 고안되었습니다. 그렇지 않으면 매우 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">대화식 모드-일반적으로 &lt;code&gt;ghci&lt;/code&gt; 를 실행하여 사용됩니다 . &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용을&lt;/a&gt; 참조하십시오 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ghci&lt;/strong&gt; 로도 사용할 수있는 대화식 모드 . 대화식 모드는 &lt;a href=&quot;ghci#ghci&quot;&gt;GHCi 사용에&lt;/a&gt; 자세히 설명되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">대화식 세션</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">Haskell 컴파일러가 생성 한 중간 C 파일.</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">처리 파이프 라인의 중간 결과.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">argv의 내부 인코딩</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">스파크를 실행하기 위해 RTS에서 사용하는 내부 기능.</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">내부 구현</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">내부 모듈은 항상 버전마다 변경 될 수 있습니다. 이 모듈의 내용은 플랫폼에 따라 다르므로 Hackage 설명서에 표시된 내용은 시스템에서 실제로 사용 가능한 내용과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">ShortByteString의 내부 표현</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">내부 자료 : ByteString FilePath 지원</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC 내부는 아직 세 번째 평등 관계 &lt;code&gt;(~#)&lt;/code&gt; 입니다. 이기종 ( &lt;code&gt;~~&lt;/code&gt; 같은 )이며 내부적으로 만 사용됩니다. &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 일&lt;/a&gt; 때만 오류 메시지 및 기타 출력에 나타날 수 있습니다. 가 활성화 된 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 버퍼 채우기 기능입니다. 그것들은 채워질 실제 버퍼를 제공 하는 &lt;em&gt;드라이버에&lt;/em&gt; 의해 실행됩니다 . 버퍼로 호출되면 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는이를 채우고 드라이버에 신호를 리턴하여 완료되었거나 현재 버퍼를 채우거나 메모리 청크에 대한 참조를 직접 삽입하려고 함을 알려줍니다. 마지막 두 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 드라이버가 다음 버퍼를 채우기 위해 호출 할 수 있는 연속 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 여기서는 거의 모든 사용 사례를 만족시키는 두 가지 드라이버를 제공합니다. 미세 조정에 대한 정보는 &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">내부적으로 빌더는 배열을 하나씩 채우면서 게으른 &lt;code&gt;Text&lt;/code&gt; 를 구성합니다 . 각 버퍼가 채워지면 결과적으로 게으른 &lt;code&gt;Text&lt;/code&gt; 의 새로운 덩어리가되도록 '팝 오프'됩니다 . 이 모든 것은 &lt;code&gt;Builder&lt;/code&gt; 사용자에게 숨겨져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 유형은 &lt;code&gt;Word16&lt;/code&gt; UTF-16 코드 단위 의 배열로 표시됩니다 . 생성자의 오프셋 및 길이 필드 는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 단위가 &lt;em&gt;아닌&lt;/em&gt; 이러한 단위 입니다.</target>
        </trans-unit>
        <trans-unit id="52f341c327dc6a2b9f9f6adb900102322209af62" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">내부적으로이 함수는 하위 레벨 버퍼링 추상화에서 한 번에 청크를 읽고 전체 파일을 읽은 후에 청크를 단일 문자열로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; 모듈의 내부</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">네이티브 코드와의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 을 1 비트 비트 필드로 해석</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">통역사 모나드</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">플래그를 구체적인 값으로 해석</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">옵션 레코드의 변환으로 플래그 해석</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">인터럽트 가능한 작업</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">소개 및 제거 &lt;code&gt;ByteString&lt;/code&gt; 의 들</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">정량화 된 제약 조건을 도입하면 두 가지 주요 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">죽은 STG 레지스터를 쓰레기로 채우는 LLVM 도입</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">직관적으로 이것은 첫 번째와 두 번째 인수가 공변량 인 이중 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">직관적으로 공변량 유형이 &lt;em&gt;생성&lt;/em&gt; 되고 공변량 유형이 사용 &lt;em&gt;됩니다&lt;/em&gt; . Haskell의 대부분 유형은 공변량이지만 함수 유형의 왼쪽은 분산을 뒤집는 점에서 함수 유형이 특별합니다. 함수 타입 인 경우 &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 공변 위치에 표시 (예 &lt;code&gt;CovFun1&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; contravariant 위치에 있고 &lt;code&gt;b&lt;/code&gt; 공변 위치에있다. 만약 마찬가지로, &lt;code&gt;a -&amp;gt; b&lt;/code&gt; contravariant 위치에 표시 (예 &lt;code&gt;CovFun2&lt;/code&gt; 이상) 후, &lt;code&gt;a&lt;/code&gt; 이다 공변 위치와 &lt;code&gt;b&lt;/code&gt; contravariant 위치에있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">고정 : &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 이 사용되며 iff 값이 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt; 맞지 않습니다</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">모든 기능이 유지해야하는 불변량 :</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">입니다 &lt;code&gt;Tricky Nom Age&lt;/code&gt; 에 representationally 동일한 &lt;code&gt;Tricky Nom Int&lt;/code&gt; ? 아니! 전자는 &lt;code&gt;Char&lt;/code&gt; 를 저장 하고 후자는 &lt;code&gt;Bool&lt;/code&gt; 을 저장합니다 . 이에 대한 해결책은 변수를 입력하기 위해 모든 매개 변수가 역할 명목을 갖도록 요구하는 것입니다. 따라서, GHC는 대한 역할 표상을 추론 할 뿐만 역할 명목 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">FilePath가 유효합니까? 예를 들어 이와 같은 파일을 만들 수 있습니까? 이 함수는 유효하지 않은 이름과 유효하지 않은 문자를 검사하지만 일반적으로 파일 시스템에 따라 길이 제한이 초과되었는지 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">경로는 상대적입니까, 아니면 루트에 고정되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">드라이브 요소</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">항목이 디렉토리이거나 마지막 문자가 경로 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">이벤트 추적이 가능합니까?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 IOError . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 를 정의해야 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스)</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형과 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우 및 기타 여러 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (더 이상 사용되지 않는 &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우 , 당신은 또한을 정의 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스를)</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">오류 정보 유형 및 모나드 유형 생성자에 대해 매개 변수화됩니다. 오류 설명이 문자열 형식을 취하는 오류 모나드의 모나드 유형 생성자로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 을 사용하는 것이 일반적 입니다. 이 경우와 다른 많은 일반적인 경우 결과 모나드는 이미 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스 의 인스턴스로 정의되어 있습니다. 고유 한 오류 유형을 정의하거나 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 이외의 모나드 유형 생성자를 사용할 수도 있습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 명시 적으로 정의해야합니다 . (사용되지 않는&lt;a href=&quot;control-monad-error&quot;&gt; Control.Monad.Error&lt;/a&gt; 또는 &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error를&lt;/a&gt; 사용하는 경우, &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 인스턴스 를 정의해야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">문자가 파일 구분자입니까?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">캐릭터가 확장 캐릭터입니까?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">핸들이 터미널에 연결되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 가 리턴 한 인스턴스 목록이 비어 있지 않습니까?</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">이것은 삽입 함수&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;또는 뱅 패턴 이있는&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;의 정의입니까? GHC는이 모호성을 후자에 유리하게 해결합니다. bang-patterns가 활성화 된 상태에서 &lt;code&gt;(!)&lt;/code&gt; 를 정의 하려면 접두사 표기법을 사용하여 정의 해야합니다.</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">고아 모듈입니까? &lt;code&gt;T&lt;/code&gt; 는 동일한 모듈에서 선언 되었기 때문에 분명히 아닙니다 . 그러나 클래스 &lt;code&gt;E&lt;/code&gt; 에 기능적 종속성이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">이 프로그램은 GHC RTS와 연결되어 있습니까? (항상&amp;ldquo;예&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">이 시간대는 여름에만 지속됩니까?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">Proleptic Gregorian 달력에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">Proleptic Julian 일정에 따르면 올해는 윤년입니까?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">로 변환되어</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">모나 딕 계산 내에서 예외 처리를 시작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">고정 된 바이트 수로 작동하도록 디코더를 분리하고 더 적은 바이트를 사용하거나 더 많은 바이트를 사용하려고하면 실패합니다. 주어진 디코더가 실패하면 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 도 실패합니다. &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; 의 오프셋 은 입력의 절대 값이 아니라 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 시작에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">컴파일중인 모듈이 -XTrustworthy로 표시되었지만보다 유익한 범위 인 -XSafe로 표시 될 수있는 경우 경고를 발행하십시오. 종속성이 업데이트됨에 따라 Safe Haskell 바운드를 개선 할 수있는 경우 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하다고 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="translated">컴파일중인 모듈이 안전한 것으로 간주되면 경고를 발행합니다. 안전 추론을 사용할 때 모듈의 안전 유형을 확인하는 데 사용해야합니다. 모듈이 명시 적으로 안전하다고 표시되면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">컴파일중인 모듈이 안전하지 않은 것으로 간주되면 경고를 발행하십시오. 안전한 유추를 사용할 때 안전 유형의 모듈을 확인하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">사용 된 하나 이상의 사용 된 변수를 바인딩하는 바인딩의 오른쪽에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">유형 수준 함수의 오른쪽에 배치하여 잘못된 경우에 오류를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">또한 &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f * : platform-independent flags 참조&lt;/a&gt; )와 함께 사용하면 생성자에서 엄격한 필드를 언팩하거나 언 박스 할 수 있으며 하나 이상의 간접 레벨이있을 수 있습니다. 제거하십시오. 언 패킹은 단일 생성자 데이터 유형에 대해서만 발생합니다 ( &lt;code&gt;Int&lt;/code&gt; 는 좋은 후보입니다).</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">어떤 방식 으로든 슈퍼 클래스와 메서드를 사용하여 구현할 수 있습니다. 그러나 추상 클래스에 의존하는 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않습니다 . &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;# 13086&lt;/a&gt; 참조 ). 이러한 선언은 &lt;code&gt;Constraint&lt;/code&gt; 종류의 유형 동의어로 구현할 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하는 경우이 유형 동의어는 위의 서명의 유효한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">수퍼 클래스 및 메소드 세트를 사용하여 어떤 방식 으로든 구현할 수 있습니다. 그러나 추상 클래스에 따른 모듈은 인스턴스를 정의 할 수 없습니다 (GHC 8.2에서이 제한은 확인되지 않음, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;이슈 # 13086&lt;/a&gt; 참조 ). 이러한 선언은 종류 &lt;code&gt;Constraint&lt;/code&gt; 유형 동의어에 의해 구현 될 수 있습니다 . 함수의 제약 조건을 매개 변수화하려는 경우 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ConstraintKinds&lt;/code&gt; 확장을 사용하면이 형식 동의어는 위의 서명을 올바르게 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">복합 모나드를 구성하기 위해 일련의 모나드 변압기가 적용될 수있는베이스 모나드로 사용될 수 있습니다. 대부분의 모나드 변압기 모듈에는 변압기를 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 에 적용하는 특별한 경우가 포함됩니다 . 예를 들어 &lt;code&gt;State s&lt;/code&gt; 는 &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">functor 또는 monad 클래스에 의해 매개 변수화 된 함수와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">유효한 구멍 맞춤의 이름과 유형이 맞춤의 의미를 실현하기에 충분하지 않은 경우가 있습니다. 이 플래그는 문서가 사용 가능한 경우 (및 함수가 제공되는 모듈이 &lt;code&gt;-haddock&lt;/code&gt; 플래그 로 컴파일 된 경우) 메시지에 적합한 문서를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">실재적으로 바인딩 된 유형 변수 &lt;em&gt;가&lt;/em&gt; 범위 내에 &lt;em&gt;있지&lt;/em&gt; 않아야 하는 것은 이상해 보입니다 . 일반적으로 이름 바인딩은 동일한 이름의 외부 변수 범위에서 단순히 그림자를 만듭니다 ( '구멍 만들기'). 그러나 이러한 유형 변수를 범위 내로 가져올 수 &lt;em&gt;있는&lt;/em&gt; 방법이 있어야합니다 . 그렇지 않으면 후속 유형 시그니처에서 기존에 바인딩 된 유형 변수의 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용될를. &lt;a href=&quot;#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">그것은 수 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 스레드 멀티 프로세서 또는 멀티 코어 시스템에서 병렬로 실행할 수 있습니다 사용되는 RTS 옵션을. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">그것은 진행하기 전에 약한 머리 정상 형태에 각각의 힘을 가한 결과를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 보다 메모리 오버 헤드가 낮으며 힙 조각화에 기여하지 않습니다. 문자열 데이터를 복사하는 비용으로 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 또는 ByteString 에서 변환 할 수 있습니다 . 다른 작업은 거의 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="translated">압축 영역으로 복사되었습니다. &lt;code&gt;ghc-compact&lt;/code&gt; 및 &lt;code&gt;compact&lt;/code&gt; 에 대한 문서 는이 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">윤초를 무시하므로 반드시 고정 된 양의 클럭 시간 일 필요는 없습니다. 예를 들어 윤초가 개입되었는지 여부에 관계없이 23:00 UTC + 2 시간의 NominalDiffTime = 01:00 UTC (+ 1 일)입니다.</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">이다 &lt;em&gt;귀하의 책임&lt;/em&gt; 있는지 확인하기 위해 &lt;code&gt;intLookup&lt;/code&gt; 이 정말의 전문 버전으로 동작 &lt;code&gt;genericLookup&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;루트 세트&lt;/em&gt; 의 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 . &lt;em&gt;groupBy&lt;/em&gt; 보다 약 40 % 빠릅니다 &lt;em&gt;(==)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우로 , 프로그래머가 자체 동등성 테스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">이는 프로그래머가 자체 동등성 테스트를 제공 할 수있는 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로 , 프로그래머가 자체 평등 테스트를 제공 할 수 있습니다. 요소가 첫 번째 목록과 두 번째 목록 모두에서 발견되면 첫 번째 목록의 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 개체입니다.</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">라이브러리 작성자가 GHC에게 콜 패턴 전문화를 매우 적극적으로 수행하도록 지시 할 수도 있습니다. 이것은 전문화의 수 또는 코드 크기에 관계없이 전문화하려는 일부 고도로 최적화 된 라이브러리에 필요합니다. 예를 들어, &lt;code&gt;vector&lt;/code&gt; 라이브러리 에서 단순화 된 사용 사례를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">전기에 의해 프로파일을 제한하여 다른 기준으로 하나 이상의 이러한 상태에서 힙을 분류 할 수도 있습니다. 예를 들어, 생산자에 의해 드래그 또는 빈 상태의 힙 부분을 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">런타임 정수 또는 문자열 값을 해당 유형 레벨 리터럴로 변환 할 수도 있습니다. 물론 결과 형식 리터럴은 컴파일 타임에 알 수 없으므로 기존 형식으로 숨겨집니다. 변환을 이용하여 수행 될 수있다 &lt;code&gt;someNatVal&lt;/code&gt; 을 정수와 위해 &lt;code&gt;someSymbolVal&lt;/code&gt; 문자열 :</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">레코드 생성자와 똑같이 동작하는 패턴 동의어를 정의 할 수도 있습니다. 이를 수행하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">내보내기 목록에서 특수 토큰 &lt;code&gt;..&lt;/code&gt; 을 사용하여 현재 번들로 생성 된 모든 생성자를 의미 할 수도 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 와 같은 고차 상황에서도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="translated">&lt;code&gt;qualified&lt;/code&gt; 가 사전 및 사후 양성 위치에 모두 나타나면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 일체형 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">이 제한은 미래에 완화 될 것으로 생각되지만,이 시나리오와 관련된 어려움이 이론적인지 (이러한 의존성이 우리 유형 시스템에 주요 유형이 없음을 의미 할 것임) 또는 단순히 실제적인지 여부는 (작성 당시) 불분명합니다. (GHC의 구현을 고려할 때 이러한 의존성을 추론하는 것은 어렵다). 따라서 GHC는 손쉬운 방법으로 사용자의 도움을 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">현재 &lt;code&gt;Array ix (TVar e)&lt;/code&gt; 로 구현되어 있지만 향후보다 효율적인 구현으로 대체 될 수 있습니다 (그러나 인터페이스는 동일하게 유지됨 ).</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">약한 포인터 객체가 아닌 도달 가능한 객체가 직접 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">확장명 &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma로 사용 가능합니다. (같은 확장자로 &lt;code&gt;mdo&lt;/code&gt; - notation과 &lt;code&gt;do&lt;/code&gt; 표현식 안에서 &lt;code&gt;rec&lt;/code&gt; 블록을 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">그것은 동일합니다 &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 때 &lt;code&gt;n&lt;/code&gt; 은 아니다 &lt;code&gt;_|_&lt;/code&gt; ( &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 는 더 일반적인의 인스턴스 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 되는, &lt;code&gt;n&lt;/code&gt; 은 임의의 일체형 일 수도있다.</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">이 연산자는 &lt;code&gt;e&lt;/code&gt; 에서 다형성이어야 하며 (명령에 대한 환경 입력과 하위 명령에 대한 환경 입력을 나타냄) 해당하는 고유 특성을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">이 작업은 향후 Haskell 개정판에서 대체 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">내보내거나</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">그것은이 될 괜찮지 &lt;em&gt;전위&lt;/em&gt; (두 선언 (A) 및 (B), 발언권을 포함하여)의 오버랩; 특정 제약 조건이 둘 이상 일치하는 경우에만 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">것이 중요합니다 &lt;code&gt;-O*&lt;/code&gt; 플래그의 조합과 거의 동등 &lt;code&gt;-f*&lt;/code&gt; 플래그. 이러한 이유로 &lt;code&gt;-O*&lt;/code&gt; 및 &lt;code&gt;-f*&lt;/code&gt; 플래그 의 효과 는 명령 행에서 발생하는 순서에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="translated">큽니다. 현재 GHC는 대형 객체를 4KB 블록의 80 % 이상 (즉, 3277 바이트 이상)으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 가 형식이 안전하지 않다는 것은 잘 알려져 있지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">방정식 함수 정의를 사용하는 대신 사례를 반복해야합니다. 그리고 &lt;code&gt;t&lt;/code&gt; 와의 매칭 이 다른 패턴 안에 깊숙이 묻히면 상황이 더욱 악화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">그것은 사용하는 것보다 더 빠른 없다 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 를 사용하는 것보다 빠르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">항상 모든 일반 표현 유형에 대한 인스턴스를 제공 할 필요는 없지만 인스턴스를 생략하면 함수가 작동 할 데이터 유형 세트가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">종료자가 결국 실행된다는 보장은 없으며 프로그램이 종료 될 때 미해결 종료자를 실행하려고 시도하지 않습니다. 따라서 종료자는 리소스를 정리하는 데 의존해서는 안됩니다. 종료 자와 함께 다른 방법 (예 : 예외 처리기)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">Makefile의 모든 내용을 소스 파일로 옮기는 것은 좋지 않지만 경우에 따라 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma가 올바른 것입니다. (당신이 사용하는 경우 &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt; 하고있는 &lt;code&gt;OPTION&lt;/code&gt; 모듈에 플래그의 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 는 생성에 넣어 얻을 것이다 &lt;code&gt;.hc&lt;/code&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">함께 이러한 기능을 사용하는 것이 편리하다 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">로드 된 모듈에도 해당 옵션을 적용하지 않고도 대화식 옵션을 변경하는 것이 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">새로운 &lt;code&gt;IsList&lt;/code&gt; 인스턴스를 선언하는 것이 좋습니다 . 따라서리스트 표기법은 완전히 새로운 데이터 유형에 유용합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">GADT 스타일 구문을 사용하여 일반적인 대수 데이터 형식을 선언 할 수 있습니다. GADT를 GADT로 만드는 것은 구문이 아니라 결과 유형이 &lt;code&gt;T a b&lt;/code&gt; 가 아닌 데이터 생성자의 존재입니다 .</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">스플 라이스는 스플 라이스 사이트에 포함되지 않은 이름이 포함 된 표현식으로 확장 될 수 있습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">연관된 유형을 정의하는 클래스가 연관된 유형 인스턴스의 기본값을 지정할 수 있습니다. 예를 들어, 이것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">패키지를 사용하면 동일한 이름을 가진 두 개의 모듈을 포함하는 프로그램으로 끝날 수 있습니다. 아마도 &lt;em&gt;숨겨진&lt;/em&gt; 모듈 &lt;code&gt;M&lt;/code&gt; 이있는 패키지 &lt;code&gt;P&lt;/code&gt; 를 사용했고 프로그램에 모듈 &lt;code&gt;M&lt;/code&gt; 이있을 수도 있습니다. 또는 사용한 패키지의 종속성에 일부 중복 모듈이 포함되어있을 수 있습니다. 다른 패키지의 종속성으로 인해 프로그램에 특정 패키지의 여러 버전이 포함되어있을 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">RTS에 자체 정보를 제공하도록 요청할 수 있습니다. 이렇게하려면 &lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; 플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 유형을 사용하여 모든 예외를 포착 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; 블록을 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 로 연결하는 것이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">형식 또는 클래스 선언에 도입 된 형식 변수간에 복잡한 종속성을 얻을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; 가 런타임 통계에서 얼마나 잘 작동 하는지에 대한 약간의 정보를 얻을 수 있습니다 . &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;가비지 수집기를 제어하는 ​​RTS 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">Haskell로 작성되지 않은 다른 프로그램에서 GHC에 의해 생성 된 공유 라이브러리를로드 할 수 있으므로 플러그인으로 사용하기에 적합합니다. 물론 플러그인을 구성하려면 FFI를 사용하여 C 함수를 내보내고 RTS 초기화에 대한 규칙을 따라야합니다. &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;외부 코드에서 호출 할 수있는 Haskell 라이브러리 만들기를&lt;/a&gt; 참조하십시오 . 특히 Haskell 함수가 호출되기 전에 플러그인을 초기화하기 위해 공유 라이브러리에서 C 함수를 내보내고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt; 를 사용하여 실제 번역을 볼 수 있지만 출력이 매우 장황하다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">디버거를 사용하여 함수 값을 검사 할 수 있습니다. 우리가 중단 점에 있고 함수가 범위 내에 있으면 디버거가 소스 코드를 표시 할 수 없습니다. 그러나 정보를 일부 인수에 적용하고 결과를 관찰하여 일부 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">구문 적으로 CUSK (위의 규칙에 따라)가 있지만 실제로 약간의 추론이 필요한 데이터 유형을 작성할 수 있습니다. 매우 고안된 예로써,</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">소스 파일의 이름을 모듈과 동일하게 가정하면 GHC와 함께 사용할 &lt;code&gt;Makefile&lt;/code&gt; 을 설정하는 것이 합리적 입니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 은 binary 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 바이너리 및 &lt;code&gt;BlockBuffering&lt;/code&gt; 모드로 설정하는 것이 좋습니다 . &lt;code&gt;hSetBinaryMode&lt;/code&gt; 및 &lt;code&gt;hSetBuffering&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉, &lt;code&gt;C&lt;/code&gt; 에 대한 마지막 누락 인수 는 &lt;code&gt;C&lt;/code&gt; 의 메소드 에서 명목상의 역할로 사용되지 않습니다 . &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 각 방법을 강제하는 것이 안전합니다 . 즉,에 누락 된 마지막 인자 &lt;code&gt;C&lt;/code&gt; 는 의 어떤에서 소액의 역할에서 사용되지 않는 &lt;code&gt;C&lt;/code&gt; 의 방법. ( &lt;a href=&quot;#roles&quot;&gt;역할을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">GHC는 외래 전화를 선점하지 않기 때문에 외래 전화 중 일시적으로 부동 소수점 단위 상태를 수정하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 느립니다. 장점은 C와 호환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 을&lt;/a&gt; 통해 인스턴스를 파생시킬 때 추가 언어 확장을 활성화해야하는 경우가 있습니다. 예를 들어 &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; 구문을 사용하는 간단한 클래스 및 인스턴스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 을 사용하여 인수 이름을 구성 하여 올바른 네임 스페이스에서 수정하는 것이 유용한 경우 가 있습니다. 예를 들어,이 맥락에서 :</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">가능하면이 모듈의 명시 적 상태 관리 기능보다는 &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt; 의보다 안전한 monadic API를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">메모리에 많은 짧은 문자열을 유지해야하는 코드의 내부 표현으로 사용하기에 적합하지만 교환 유형으로 사용 &lt;em&gt;해서는 안됩니다&lt;/em&gt; . 즉, 일반적으로 퍼블릭 API에서 사용해서는 안됩니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 종류는 일반적으로 인터페이스에 사용하기에 적합하다; 보다 유연하고 광범위한 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">순수한 코드에 사용하기에 적합합니다. IO 컨텍스트에서는 대신 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">키에 도달 할 수있는 약한 포인터 객체의 값 또는 종료 자입니다.</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">이 예외를받는 스레드는 정의되어 있지 않습니다. GHC는 현재 이것을 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 를받는 동일한 스레드로 던지지 만, 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 f 가 최종적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 인라인 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 &lt;em&gt;최적화 된&lt;/em&gt; 버전의 &lt;code&gt;f&lt;/code&gt; 를 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS에 함수를 노출시키는 것입니다. 이러한 함수가 최적화되지 않았다면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">인라인되지 않은 &lt;code&gt;f&lt;/code&gt; 의 버전 이 궁극적으로 호출 되는 경우 GHC가 다른 비 &lt;code&gt;INLINE&lt;/code&gt; 함수 와 마찬가지로 INLINE 함수 &lt;code&gt;f&lt;/code&gt; 의 정의를 최적화하는 것이 유용합니다 . 그러나 우리는 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;최적화 된&lt;/em&gt; 버전 을 인라인하고 싶지 않습니다 . &lt;code&gt;INLINE&lt;/code&gt; pragma 의 주된 이유 는 재 작성 규칙이 있는 &lt;code&gt;f&lt;/code&gt; 의 RHS 에서 함수를 노출하기 위한 것입니다. 이러한 함수가 최적화되어 있으면 좋지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 비동기 예외를 완전히 방지하는 방법이 아니라 비동기 모드에서 폴링 모드로 전환하는 방법 으로 생각하면 유용 합니다. 비동기 예외의 주된 어려움은 일반적으로 어디에서나 발생할 수 있지만 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내에서 인터럽트 가능한 작업 (또는 다른 인터럽트 가능한 작업 호출)에 의해서만 비동기 예외가 발생한다는 것입니다. 대부분의 경우 이러한 작업 자체는 I / O 오류와 같은 예외를 발생시킬 수 있으므로 일반적으로 호출자는 작업에서 발생하는 예외를 처리 할 준비가됩니다. &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 내부의 비동기 예외에 대해 명시 적 폴링을 수행하려면 &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; 가&lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 데이터의 가족을 제공하는 데 필요한 자신과 관련된 종류의 반환 &lt;code&gt;TYPE&lt;/code&gt; 등으로, &lt;code&gt;FooKey&lt;/code&gt; 및 &lt;code&gt;BarType&lt;/code&gt; 의 위의 예제를. 확장은 위의 &lt;code&gt;FooKeyBoolC&lt;/code&gt; 및 &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; 와 같은 &lt;code&gt;newtype instance&lt;/code&gt; 선언 에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">각 패키지가 단일 공유 객체 파일로 빌드 될 때 공유 객체에 주목할 필요가 있습니다. 공유 객체에 대한 참조는 추가 간접 비용이 들기 때문에 패키지 내 참조는 패키지 간 참조보다 저렴합니다. 물론 이것은 &lt;code&gt;main&lt;/code&gt; 패키지 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">Haskell 스레드를 강제로 종료하는 것이 항상 가능한 것은 아닙니다. 예를 들어 스레드가 현재 외래 호출을 실행 중일 수 있으므로 외래 호출을 강제로 완료 할 방법이 없습니다. 게다가, 런타임은 최악의 경우 Haskell 코드와 런타임이 메모리에서 제거 될 예정이라고 가정해야합니다 (예를 들어, 이것이 &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt; 이면 &lt;code&gt;hs_exit()&lt;/code&gt; 은 DLL을 언로드하기 전에 정상적으로 호출됩니다). 따라서 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 모든 미해결 외래 호출이 리턴 될 때까지 기다려야 자체 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8458bc24663504817189be36256a7f90d9fdfdc9" translate="yes" xml:space="preserve">
          <source>It loops indefinitely; every time a key is pressed, it will print that key as it was recognized by Haskeline. Pressing Ctrl-C will stop the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">또한 Haskell 모듈이 컴파일 될 C 코드와 C 파일로 C 코드에 포함되는 C 헤더와 함께 프로그램에 링크 될 추가 C 함수를 포함하는 C 파일을 출력 할 수 있습니다. . 이 두 파일은 &lt;code&gt;#def&lt;/code&gt; 구문이 사용될 때 생성 됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 은 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 는 (참조 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;# 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">그것은 사용하는 유혹 나타날 수 &lt;code&gt;DllMain&lt;/code&gt; 을 호출하는 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; 을 (당신이 컴파일 할 경우 특히,하지만이 작동하지 않습니다 &lt;code&gt;-threaded&lt;/code&gt; ). 이 작업 동안 수행 될 수있는 심각한 제한이 있습니다 &lt;code&gt;DllMain&lt;/code&gt; 이 , 그리고 &lt;code&gt;hs_init&lt;/code&gt; 가 시작하는 동안 동결 당신의 DLL로 이어질 수 이러한 제한을 위반 (참조 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;이슈 # 3605&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">추측하는 것이 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; 및 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; 는 비슷한 작업을 수행 하는 것처럼 보일 수 있습니다. 둘 다 사용하여 모듈을 범위로 가져올 수 있습니다. 그러나 매우 중요한 차이점이 있습니다. GHCi는 두 가지 모듈 세트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 또한 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;c&lt;/code&gt; 의 종류로 암시 적으로 선언됩니다 . 따라서 일반적인 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 같은 종류 여야합니다 . 있음을 유의하십시오 &lt;code&gt;b&lt;/code&gt; 는 암시 적으로 선언 된 &lt;code&gt;c&lt;/code&gt; 의 종류. 따라서 일반 원칙에 따라 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;앞에&lt;/em&gt; 와야합니다 . 그러나 &lt;code&gt;b&lt;/code&gt; &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 에&lt;em&gt;의존합니다&lt;/em&gt; . 따라서 적절한 오류 메시지와 함께 &lt;code&gt;T2&lt;/code&gt; 를 거부 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">실제로 읽은 바이트 수를 반환합니다. 데이터를 읽기 전에 EOF에 도달 한 경우 (또는 &lt;code&gt;count&lt;/code&gt; 가 0 인 경우) 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 다른 호출의 내부 상태를 유지하는 역할을 &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 가 서로 분리 된 호출의 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">이러한 재귀 바인딩은 실제로 다양한 모나드에 대해 의미가 있지만 모든 것은 아닙니다. 특히 이런 의미에서 재귀에는 다음과 같이 &lt;code&gt;Control.Monad.Fix&lt;/code&gt; 에 정의 된 &lt;code&gt;MonadFix&lt;/code&gt; 클래스 의 &lt;code&gt;mfix&lt;/code&gt; 메소드로 캡처 한 기본 모나드에 대한 고정 소수점 연산자가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newPinnedByteArray#&lt;/code&gt; 의해 할당되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">GHCi가 시작된 현재 폴더에 &lt;code&gt;.ghci-history&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">그런 다음 개별 항목과 항목 쌍을 &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; 또는 &lt;code&gt;f&lt;/code&gt; 에 적절하게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">GHCi가 각 모듈의 기본 설정을 기록하고 '현재'모듈의 설정을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">원격으로 마운트 된 디스크를 사용하여 빠른 컴퓨터 에서 &lt;em&gt;컴파일&lt;/em&gt; 하는 것이 합리적 입니다. 그런 다음 디스크가 직접 장착 된 느린 시스템에 &lt;em&gt;연결&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; 가로&lt;/a&gt; 드 된 모듈에도 적용되는 경우 바람직하지 않습니다 . 컴파일 오류가 발생할 수 있지만 GHC는 플래그가 변경되어 모듈을 다시 컴파일해야한다고 생각하기 때문에 추가 재 컴파일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">단일 생성자 유형 (데이터 생성자가 하나 뿐인 유형 (예 : 튜플은 단일 생성자 유형))에서 함수가 엄격한 경우 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">다음 예제와 같이 새 &lt;code&gt;rec&lt;/code&gt; 키워드를 사용하여 상호 재귀 바인딩을 가질 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">&lt;code&gt;a==b&lt;/code&gt; 또는 &lt;code&gt;p==q&lt;/code&gt; 라고해도 괜찮지 만 &lt;code&gt;a==q&lt;/code&gt; 는 두 &lt;code&gt;Baz1&lt;/code&gt; 생성자 에서 발생하는 두 가지 유형이 같기 때문에 잘못되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">추악하고 느립니다.</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 현재 msbf에서 큰 정수로 변환하여 &lt;code&gt;mpz_export()&lt;/code&gt; 를 호출 하므로 작은 정수에 대해 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 를 호출하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">일부 &lt;code&gt;(x,y)&lt;/code&gt; 의 경우 &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt; 경우 결과 크기가 더 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">아이템 (IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">반복 건설</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">J. Nievergelt와 EM Reingold, &quot; 1973 년 3 월 SIAM 컴퓨팅 저널 2 (1),&quot; &lt;em&gt;경계 균형의 이진 탐색 트리&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">요한 티벨 &amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">드라이브와 나머지 경로를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">경로 요소를 다시 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell의 일반적인 파생 메커니즘&lt;/a&gt; . Haskell (Haskell'2010), pp. 37-48, ACM, 2010에서 세 번째 ACM Haskell 심포지엄의 절차.</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring 및 Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell에 대한 일반적인 파생 메커니즘&lt;/a&gt; . Haskell에 관한 세 번째 ACM Haskell 심포지엄 (Haskell'2010), pp. 37-48, ACM, 2010.</target>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">줄스 헤지스 &quot;역 추적 검색을위한 모나드 변압기&quot;. 에서 &lt;em&gt;MSFP 2014 논문집&lt;/em&gt; . &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 각 요소에 슬래시를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;A.hs&lt;/code&gt; 를 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi&lt;/code&gt; 와 객체 파일 &lt;code&gt;A.o&lt;/code&gt; 생성되는 &lt;code&gt;A.hs-boot&lt;/code&gt; 컴파일 하면 인터페이스 파일 &lt;code&gt;A.hi-boot&lt;/code&gt; 와 의사 오브젝트 파일 &lt;code&gt;A.o-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">Template Haskell ( &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; ) 의 경우와 마찬가지로 GHC는 두 번째 문자가 따옴표 인 데이터 생성자 앞에 따옴표를 넣으면 혼란스러워집니다. 이 경우 프로모션 견적과 데이터 생성자 사이에 공백을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">타입 추론에서와 마찬가지로, 재귀 타입에 대한 친절한 추론은 &lt;em&gt;단형의&lt;/em&gt; 재귀 만 사용할 수 있습니다 . 이 (고려 된) 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">do-notation을 사용하여 &lt;code&gt;Monad&lt;/code&gt; 인스턴스를 정의하지 않는 것처럼 do-notation을 사용하여 ( &lt;code&gt;ApplicativeDo&lt;/code&gt; 사용시 ) &lt;code&gt;Functor&lt;/code&gt; 또는 &lt;code&gt;Applicative&lt;/code&gt; 인스턴스를 정의하지 않아야 합니다. &lt;code&gt;Monad&lt;/code&gt; 와 관련하여 이러한 인스턴스를 정의하는 올바른 방법 은 &lt;code&gt;Monad&lt;/code&gt; 작업을 직접 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">값 수준 바인딩의 서명과 마찬가지로 패턴 동의어 서명은 둘 이상의 패턴에 적용될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 플러그인과 마찬가지로, &lt;code&gt;-fplugin-opt&lt;/code&gt; 플래그 를 사용하여 지정할 수있는 일부 옵션을 취하고 사용할 수있는 &lt;code&gt;DynFlags&lt;/code&gt; 플러그인을 작성할 수 있습니다 . 위의 &lt;code&gt;DynFlagsPlugin&lt;/code&gt; 코드에서 해당 옵션은 &lt;code&gt;hooksP&lt;/code&gt; 의 &lt;code&gt;opts&lt;/code&gt; 인수 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">unsafePerformIO와 마찬가지로 인라인합니다. 더 많은 인라인에 노출되는 많은 성능을 제공합니다. &lt;em&gt;매우 안전하지 않습니다&lt;/em&gt; . 특히, &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 블록 내에서 메모리 할당을하지 않아야합니다 . 포옹에서 이것은 단지 &lt;code&gt;unsafePerformIO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">x =&amp;gt;만으로 주어진 모드로 파일을 생성합니다. Nothing =&amp;gt; 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">&lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; 를 통한 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.hc&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.hc&lt;/code&gt; 파일은 &lt;a href=&quot;codegens#unreg&quot;&gt;등록되지 않은&lt;/a&gt; 컴파일러에 의해서만 생성됨 ).</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.hi&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.hi&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-hi-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM을&lt;/a&gt; 통해 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 컴파일을 수행 할 때 중간 &lt;code&gt;.ll&lt;/code&gt; 파일을 유지하십시오 (참고 : &lt;code&gt;.ll&lt;/code&gt; 파일은 기본 코드 생성기를 사용할 때 생성되지 않으므로 &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt; 을 사용하여 파일 을 강제로 생성해야 할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.o&lt;/code&gt; 파일을 유지하십시오 . 이것이 기본값입니다. &lt;code&gt;.o&lt;/code&gt; 파일에 관심이 없으면 &lt;code&gt;-no-keep-o-files&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">중간 &lt;code&gt;.s&lt;/code&gt; 파일을 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">클래스 중 하나 이상이 &lt;strong&gt;대화 형 클래스 인&lt;/strong&gt; 그룹 만 유지하십시오 (아래에 정의 됨).</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">&lt;code&gt;CPP&lt;/code&gt; 전 처리기 단계 의 출력을 &lt;code&gt;.hscpp&lt;/code&gt; 파일 로 유지 하십시오. &lt;code&gt;.hscpp&lt;/code&gt; 의 모듈이 컴파일 및 C의 전처리를 사용 들어가면 파일은, 생성된다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">주요 인수는 WHNF에 평가됩니다</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이기종 명제 평등. 추천 &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;a :~~: b&lt;/code&gt; 경우에만, 종료 값 살고 &lt;code&gt;a&lt;/code&gt; 동일한 타입 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">충전 또는 패딩 종류.</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">종류 표현</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="translated">종류 변수는 &lt;em&gt;보이는&lt;/em&gt; 위치 에서도 정량화 할 수 있습니다 . 다음 두 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">예를 들어 종류 평등은 연기 될 수 없다</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">모나드의 Kleisli 화살.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 테일</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">왼쪽 화살표 더블 테일</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">LLVM 코드 &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;생성기&lt;/a&gt; 의 LLVM 코드</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">LLVM 코드 생성기</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">디코더에 라벨을 붙입니다. 디코더가 실패하면 오류 메시지 문자열에 새 줄에 레이블이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">라벨링 나무</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">언어 확장 조회</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">언어 확장</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">GHC에 알려진 언어 확장</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">언어 옵션은 두 가지 방법으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">언어 옵션은 명령 행 옵션 &lt;code&gt;-Xblah&lt;/code&gt; 또는 파일 자체 의 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma에 의해 사용 가능합니다. &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;언어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Cabal이 인식하는 언어 옵션은 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma를 사용하여 활성화 할 수도 있으므로 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; ( &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal은 GHC와 Template Haskell의 통합에 내부적으로 사용되는 몇 가지 추가 기능을 제공합니다. 이것은 공개 API의 일부가 아니므로이 모듈에 대한 API 보증은 버전마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 플래그로 설정된 일반 할당 영역에서 큰 개체가 할당되지 않으므로 이러한 개체에 대해 별도의 제한이 있습니다. 큰 개체는 작은 개체보다 훨씬 드물기 때문에 대부분의 프로그램 은 &lt;code&gt;-AL&lt;/code&gt; 한계 보다 &lt;code&gt;-A&lt;/code&gt; 한계에 도달합니다. 그러나 &lt;code&gt;-A&lt;/code&gt; 한계는 &lt;code&gt;-AL&lt;/code&gt; 이며, -AL 한계는 전역이므로 &lt;code&gt;-N&lt;/code&gt; 이 커질수록 &lt;code&gt;-AL&lt;/code&gt; 한계에 먼저 도달 할 가능성이 높아집니다 . 이를 방지하려면 큰 &lt;code&gt;-N&lt;/code&gt; 을 사용할 때 더 큰 &lt;code&gt;-AL&lt;/code&gt; 한계 를 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">마지막으로 선언의 일반 유형 변수가 온다.</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">마지막으로,이 모든 것은 스톡 파생이 적용되는 &lt;code&gt;Read&lt;/code&gt; , &lt;code&gt;Show&lt;/code&gt; , &lt;code&gt;Typeable&lt;/code&gt; 및 &lt;code&gt;Data&lt;/code&gt; 이외의 클래스에만 적용됩니다 (Haskell 보고서의 섹션 4.3.3.). 표준 클래스 &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 및 &lt;code&gt;Bounded&lt;/code&gt; 의 경우 스톡 방법을 사용하는지 또는 여기에 설명 된 방법을 사용하는지 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">그런 다음 레이아웃 필드는 겹치므로 최종 레이아웃은 가능한 한 작습니다. 예를 들어 상자에없는 합계가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">멀티 웨이 레이아웃은 다른 레이아웃 컨텍스트와 동일한 방식으로 작동하지만 멀티 웨이에서 가드 사이의 세미콜론은 선택 사항입니다. 따라서 모든 보호대를 같은 열에 배치 할 필요는 없습니다. 이것은 가드가 함수 정의 및 대소 문자 표현에서 작동하는 방식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 의 모든 사용자 입력을 단일 문자열로 느리게 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9c161543e3be3df002213096ec26355269feb4c2" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 의 나머지 내용을 느리게 읽습니다 . &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 읽기 완료 후 또는 오류에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4161b76a8d82e2a67a0cc9182fd41736687ceb1c" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">값을 파일에 느리게 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 는 생성 된 지연의 꼬리으로 사용할 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">오류가 발생해야하는 Haskell 98 사양과 달리 오류가 발생하면 Lazy I / O에서 예외가 발생합니다 (Haskell 98 보고서의 섹션 21.2.2 참조). throw되는 예외는 실패한 IO 작업이 IO 모나드에서 수행되고 &lt;code&gt;System.IO.Error.catch&lt;/code&gt; 또는 &lt;code&gt;Control.Exception.catch&lt;/code&gt; 에 의해 잡힐 수있는 일반적인 IO 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">게으른 RWS 모나드.</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">게으른 리더-라이터 상태 모나드</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">지연 상태 모나드는 계산을 통해 업데이트 가능한 상태를 전달합니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">게으른 상태 모나드.</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">게으른 작가 모나드.</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">구조에 왼쪽 연관 모나 딕 이중 체.</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">좌익</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">왼쪽 수축 (또는 조임)</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">구조의 왼쪽 연관 접힘이지만 연산자를 엄격하게 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">구조의 왼쪽 연관 접힘.</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">생성자 응용 프로그램에 대한 왼쪽 연결 접기 작업</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">좌우 구성</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">Kleisli 화살표의 왼쪽에서 오른쪽으로 구성.</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">레거시 폴드</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">SIMD 벡터 유형의 길이</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">레나르트 콜 모딘</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">레나르트 콜 모딘 로스 패터슨</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; 의 CSV 테이블 렌더링 예제에서 이러한 개선 사항을 설명하겠습니다 . &quot;핫 코드&quot;는 테이블 셀의 렌더링으로, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API 의 함수 만 사용하여 다음과 같이 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">먼저 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">간단한 예를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">Hello World 프로그램을 만들어서 컴파일하고 실행 해 봅시다. 먼저 Haskell 코드가 포함 된 &lt;code&gt;hello.hs&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">먼저이 프로그램을 통해 실행이 어떻게 진행되는지 봅시다. 우리는 GHC에게 디버그 정보를 원한다고 말하면서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">예제 GHCi 세션부터 시작하겠습니다. ghci 명령으로 &lt;code&gt;ghci&lt;/code&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">위에서 예제를 가져 와서 독립형 C 프로그램에서 호출 해 봅시다. C 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">퀵 정렬을 실행 예제로 사용합시다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">여기에 표시된 이진 데이터를 디코딩합시다. 이 예에서 값은 리틀 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">먼저 많은 &lt;code&gt;Trade&lt;/code&gt; 를 해독하는 함수를 정의 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">정교하게 인쇄 된 출력의 세부 수준. 레벨 0이 가장 자세하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46ea3fc173ca6f3f7f2ab9f2d659dfe92c450434" translate="yes" xml:space="preserve">
          <source>Levity-polymorphic since &lt;em&gt;template-haskell-2.16.0.0&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25799598a4e8c42a83738d367f796323e13b7b18" translate="yes" xml:space="preserve">
          <source>Lexeme</source>
          <target state="translated">Lexeme</target>
        </trans-unit>
        <trans-unit id="46ace3bdab1ce2e35c935ef17a0a57edf4886910" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;angles p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in angle brackets ('&amp;lt;' and '&amp;gt;'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;angles p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 각괄호 ( '&amp;lt;'와 '&amp;gt;')의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cc7d61ad991ca5dc420dbacf991b3321c23b4f3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;braces p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in braces ('{' and '}'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;braces p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 동봉 중괄호 ( &quot;{&quot;와 &quot;}&quot;)의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b05508eef449259c3da847ba5b8908b337a57ef" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;brackets p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in brackets ('[' and ']'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;brackets p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 괄호 ([및])의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6f01f6fd61a8c0bb200b1113e901859689cb574" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;colon&lt;/code&gt; parses the character ':' and skips any trailing white space. Returns the string &quot;:&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;colon&lt;/code&gt; 은 문자 ':'를 구문 분석하고 후행 공백을 건너 뜁니다. 문자열 &quot;:&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="906be22b3485d6af088c4586447a23867836a78c" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;comma&lt;/code&gt; parses the character ',' and skips any trailing white space. Returns the string &quot;,&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;comma&lt;/code&gt; 는 문자 ','를 구문 분석하고 후행 공백을 건너 뜁니다. &quot;,&quot;문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8fa5d226b4524a8f2606ab3fb7b4e7c3152035a2" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;commaSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8f0383ea5ef26d7b618c08586a182319e06433ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;commaSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3b0f682fe5ecece9ab074d848ae3efde0075785f" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commaSep1 p&lt;/code&gt; 구문 분석기 commaSep1 p 는 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 된 &lt;em&gt;하나&lt;/em&gt; 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다. &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1527e1889e4d9db5a2a2a401431c80198a7ad8ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commaSep1 p&lt;/code&gt; 구문 분석기 commaSep1 p 는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 된 &lt;em&gt;하나&lt;/em&gt; 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다. &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a06e52077d648a539ce51fcce5464792168d2116" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;dot&lt;/code&gt; parses the character '.' and skips any trailing white space. Returns the string &quot;.&quot;.</source>
          <target state="translated">Lexeme 파서 &lt;code&gt;dot&lt;/code&gt; 는 문자 '.'를 구문 분석합니다. 후행 공백을 건너 뜁니다. 문자열 &quot;.&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c625c13a8a270d65b20ce25a79ef5d1e88e0c01" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;parens p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in parenthesis, returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;parens p&lt;/code&gt; 파싱 &lt;code&gt;p&lt;/code&gt; 둘러싼 괄호의 값을 반환하는 &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09775ca66fe1940d621ab83bb334774f062130fc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1fde367cf1acc73ec6e48dd7f44d104f7a0066d3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep p&lt;/code&gt; 파싱은 &lt;em&gt;제로&lt;/em&gt; 또는 그 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a56558ecec4b9b3865d84f3538f50974882790bc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep1 p&lt;/code&gt; 는 파싱 &lt;em&gt;하나 개&lt;/em&gt; 의 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f226487b67eb839b478eae118624bbb75f343207" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">어휘 분석기 &lt;code&gt;semiSep1 p&lt;/code&gt; 는 파싱 &lt;em&gt;하나 개&lt;/em&gt; 의 이상의 발생 &lt;code&gt;p&lt;/code&gt; 는 에 의해 분리 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 반환 한 값 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71ba5db9cf8b9d035392754516d0f0d298c6b31e" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;symbol s&lt;/code&gt; parses &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; and skips trailing white space.</source>
          <target state="translated">어휘 파서 &lt;code&gt;symbol s&lt;/code&gt; 파싱 된 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 후행 공백 문자는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1cae647ca5dc3e8507fd8b9a75e7e569807d779e" translate="yes" xml:space="preserve">
          <source>Lexeme parser |semi| parses the character ';' and skips any trailing white space. Returns the string &quot;;&quot;.</source>
          <target state="translated">Lexeme 파서 | semi | 문자 ';'를 구문 분석합니다 후행 공백을 건너 뜁니다. 문자열 &quot;;&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a85bb6bdbe773df37163bd57f9f3cbce90e0583" translate="yes" xml:space="preserve">
          <source>Lexical type variables may be alpha-renamed freely, without changing the program.</source>
          <target state="translated">어휘 유형 변수는 프로그램을 변경하지 않고 자유롭게 알파 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfd3fae981ce83b9a78f156f575113d42a472b8" translate="yes" xml:space="preserve">
          <source>LiberalTypeSynonyms</source>
          <target state="translated">LiberalTypeSynonyms</target>
        </trans-unit>
        <trans-unit id="150017bb5be516efb13183274c04717c3913f12c" translate="yes" xml:space="preserve">
          <source>Library functions</source>
          <target state="translated">라이브러리 기능</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8f40b70f72540e03b88378ef3507f6d84f38b8e2" translate="yes" xml:space="preserve">
          <source>Licensed under a BSD-style license (see top of the page).</source>
          <target state="translated">BSD 스타일 라이센스에 따라 라이센스가 부여되었습니다 (페이지 상단 참조).</target>
        </trans-unit>
        <trans-unit id="7c040e16c5971eb5c4f65496f4403ed7de94405d" translate="yes" xml:space="preserve">
          <source>Licensed under the Glasgow Haskell Compiler License.</source>
          <target state="translated">Glasgow Haskell 컴파일러 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="efd0976a0ad531b6453a3782b50f0f3ff5363b1e" translate="yes" xml:space="preserve">
          <source>Lift</source>
          <target state="translated">Lift</target>
        </trans-unit>
        <trans-unit id="69bd6ed6019d0841a40b7376c8be9d0e00a15a4a" translate="yes" xml:space="preserve">
          <source>Lift &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="28a4c297cb17de5189cf531fb8cff2247893efd7" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 을 BoundedPrim 으로 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b11a06f969ecc3525b7fd7eb5bd850c961745651" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 을 BoundedPrim 으로 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77ad9a4be8766f89114fe4a089c39d2885ba04cb" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="57350b28e0ae1579635d1c5f5bfee71f12dc8af6" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 &lt;code&gt;callCC&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="e69559f09d367723fe7abf1f50e359886a0e8931" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;catchE&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">&lt;code&gt;catchE&lt;/code&gt; 조작을 새 모나드로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="9c3605ce5319733a98246b58994a1c7a3b22a3dc" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;listen&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 모나드에 대한 &lt;code&gt;listen&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="898de1bff1c29cda9790c0fed24117c87b00c641" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;pass&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">새 모나드 로 &lt;code&gt;pass&lt;/code&gt; 조작을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="0d0feda6a4614b667af6e9eb00a72f0992d75a5c" translate="yes" xml:space="preserve">
          <source>Lift a IO operation</source>
          <target state="translated">IO 작업을 들어 올리십시오</target>
        </trans-unit>
        <trans-unit id="b9039d9d95aa49349189305fdf5c0f23de8d10bb" translate="yes" xml:space="preserve">
          <source>Lift a binary function to actions.</source>
          <target state="translated">이진 함수를 동작으로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="4fdb7ea3c747b4ff83d8fd93dbad25981db51967" translate="yes" xml:space="preserve">
          <source>Lift a computation from the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 모나드 에서 계산을 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="6fb4cfd1308d8bc1fc2b8075cc399da8778ef019" translate="yes" xml:space="preserve">
          <source>Lift a computation from the argument monad to the constructed monad.</source>
          <target state="translated">인수 모나드에서 생성 된 모나드로 계산을 들어 올립니다.</target>
        </trans-unit>
        <trans-unit id="755e2bbeb43333564e4df3721333f2c5cb05f108" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">기능을 행동으로 들어 올리십시오. 이 함수는 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65540f13b21961e922b1b042f1d167b1c9a2abf6" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">기능을 행동으로 들어 올리십시오. 이 함수는 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 의 값으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3306c8d28d88915bd946a2603ec45578ecd138e" translate="yes" xml:space="preserve">
          <source>Lift a function to an arrow.</source>
          <target state="translated">기능을 화살표로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="34e1005428b4115e3bdc892cb79d78caeaad7d73" translate="yes" xml:space="preserve">
          <source>Lift a precedence-insensitive &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">우선 순위에 영향을받지 않는 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 를 ReadPrec 으로 들어 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a927363c52ab42f8173b13c6038ee007ad8a17e" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="9bff245d149ddf1ae6d16d98ebd9221f1ea4340f" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="a1f4ae6d40699215f86ae7acc6dbd638b4d640c8" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="ef6d5d2890f728fc0dec424db983bea6034793d1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="f3a10c09a2df5ee40736eca77b005327c3f502e1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="55317bb47900a6c531bb57912283090eb69391dc" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">로 반군 리프트 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 성형 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 따른 &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt; &quot;상관 반군의 &lt;code&gt;S&lt;/code&gt; 는 모노 이드로 전환 될 수있다 단순히 소자에 인접하여 &lt;code&gt;e&lt;/code&gt; 하지 &lt;code&gt;S&lt;/code&gt; 및 정의 &lt;code&gt;e*e = e&lt;/code&gt; 및 &lt;code&gt;e*s = s = s*e&lt;/code&gt; 모두 &lt;code&gt;s &amp;isin; S&lt;/code&gt; . &quot;</target>
        </trans-unit>
        <trans-unit id="b18efdb14898a61cd6bf3e53b88908b07c899338" translate="yes" xml:space="preserve">
          <source>Lift a ternary function to actions.</source>
          <target state="translated">삼항 함수를 동작으로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="1c6cfea669eba5bd426957f891847f721512f382" translate="yes" xml:space="preserve">
          <source>Lift a unary operation to the new monad.</source>
          <target state="translated">단항 조작을 새 모나드로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="46b3af654500c45d1bbe42552320fbf9acf7d7ab" translate="yes" xml:space="preserve">
          <source>Lift a value.</source>
          <target state="translated">가치를 높이십시오.</target>
        </trans-unit>
        <trans-unit id="1a088c3e62edefbbd612558fe95e26c16929b0cf" translate="yes" xml:space="preserve">
          <source>Lift an IO operation</source>
          <target state="translated">IO 작업을 들어 올리십시오</target>
        </trans-unit>
        <trans-unit id="f3531bf1113fe8b33ad38c7a7731990c8b025668" translate="yes" xml:space="preserve">
          <source>Lift an equality test through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 동등성 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d59a4331fe2b228402b5f804879977d4d2bdbdf8" translate="yes" xml:space="preserve">
          <source>Lift equality tests through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 동등성 테스트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ba141aacd2971ab64cd183f644499403aa27baf6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="2a5c11e919022ea17cf3e50538bb0b39ab267ca8" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">타입 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="a22f0b12039df26e38242ef4e1b27fd9a2aca7c5" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="cef4fc8589a89ebe3dab70e8896098b35542b102" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="81beb3415733b0127f91ccfbc68d75371f1bc17c" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="faeb2e4ce6194f3ee4155e1efd45893a2e939961" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="053aeb1412e2444b0b1a20409a35603dc721e057" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="408cf02de66cc6b705154fd2c661de60e644f5b6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="3004afec47fb6a84cae4d9e49047dab3af9ecdbb" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">형식 생성자를 통해 표준 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 함수를 들어 올리십시오 .</target>
        </trans-unit>
        <trans-unit id="f4fbea4d9b31cd33d7694749c6476d3a1af9a3ab" translate="yes" xml:space="preserve">
          <source>Lifted product of functors.</source>
          <target state="translated">펑터의 상승 된 제품.</target>
        </trans-unit>
        <trans-unit id="3b10925916ee44f531f851144318a3b5ce0f20aa" translate="yes" xml:space="preserve">
          <source>Lifted sum of functors.</source>
          <target state="translated">펑터의 합계를 올렸습니다.</target>
        </trans-unit>
        <trans-unit id="babef654d32e20b79299fbdb4e3acce1da353228" translate="yes" xml:space="preserve">
          <source>Lifted, heterogeneous equality. By lifted, we mean that it can be bogus (deferred type error). By heterogeneous, the two types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; might have different kinds. Because &lt;code&gt;~~&lt;/code&gt; can appear unexpectedly in error messages to users who do not care about the difference between heterogeneous equality &lt;code&gt;~~&lt;/code&gt; and homogeneous equality &lt;code&gt;~&lt;/code&gt;, this is printed as &lt;code&gt;~&lt;/code&gt; unless &lt;code&gt;-fprint-equality-relations&lt;/code&gt; is set.</source>
          <target state="translated">이기종 평등이 해제되었습니다. 해제하면 가짜 일 수 있습니다 (지연된 유형 오류). 이종으로 인해 두 유형 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 서로 다른 종류를 가질 수 있습니다. 때문에 &lt;code&gt;~~&lt;/code&gt; 이 이기종 평등의 차이에 대한 상관 없어 사용자에게 오류 메시지가 예기치 않게 나타날 수 있습니다 &lt;code&gt;~~&lt;/code&gt; 균일 평등 &lt;code&gt;~&lt;/code&gt; 이 같이 인쇄됩니다 &lt;code&gt;~&lt;/code&gt; 하지 않는 &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4bfbdd16cc189cc5129a0d8ec953d2317a224b0" translate="yes" xml:space="preserve">
          <source>LiftedRep</source>
          <target state="translated">LiftedRep</target>
        </trans-unit>
        <trans-unit id="12c2f75c3b26c4edac3b33e5c51db3b8e36394c9" translate="yes" xml:space="preserve">
          <source>Lifting an applicative</source>
          <target state="translated">응용 프로그램 해제</target>
        </trans-unit>
        <trans-unit id="e2c3b2b741daea57fdd436a0412a6ba2f18b6f68" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="44895603faea79f05cd37173f6a4597b6953146e" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="e0a82371cc12bbf7738745a43b619731d3611950" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="7d9b6f54af0f5e9694ecfd7ee7add7a2cc652087" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="ae55fc1bef97cadc36b9661bf1e25f7f4c7e352d" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="86c660f1a1c56586cead2935de6c64b3ef5324c5" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="b2e9206d787342e53328d0f894bfa7fc5940af4a" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">이진 형식 생성자로 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="d56ab180af5b8c6b67cd1de105953549f78976c7" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">단항 타입 생성자로 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 클래스 해제</target>
        </trans-unit>
        <trans-unit id="ef79daca18c86fc7acb004897eb034a72769183c" translate="yes" xml:space="preserve">
          <source>Lifting other operations</source>
          <target state="translated">다른 작업 해제</target>
        </trans-unit>
        <trans-unit id="70b315b20d2f0763f381b07677fe5fcdd427769f" translate="yes" xml:space="preserve">
          <source>Liftings of Prelude classes</source>
          <target state="translated">Prelude 클래스의 리프팅</target>
        </trans-unit>
        <trans-unit id="bbd32f90f691094d13a835f9d8bc070165c84480" translate="yes" xml:space="preserve">
          <source>Liftings of the &lt;code&gt;NFData&lt;/code&gt; class</source>
          <target state="translated">NFData 클래스 의 &lt;code&gt;NFData&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf36ebf7919530abaa3b7a585d3a7f483fb9666d" translate="yes" xml:space="preserve">
          <source>Liftings of the Prelude classes &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; to unary and binary type constructors.</source>
          <target state="translated">단항 및 이진 형식 생성자 에 대한 Prelude 클래스 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9662e4165cf70bc0656fd852ce8badb4bccd421" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98068ced479359302008df12305e0fa6226acf9" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533e09a9bf33161ccd152904f791f9b0ccd0dfa2" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f90827cfa26ca646d28cee985138fed19cc82be" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">리프트 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; 어떠한에 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea5fc5a99bc5f43e32f54299e4add38a5941b11" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, but options set with &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; affect only expressions and commands typed at the prompt, and not modules loaded with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; (in contrast, options set with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; apply everywhere). See &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; 로&lt;/a&gt; 설정된 옵션 은 프롬프트에 입력 된 표현식과 명령에만 영향을 미치며 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 로&lt;/a&gt; 로드 된 모듈에는 영향을 미치지 않습니다 (반대로 &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 으로 설정된&lt;/a&gt; 옵션 은 모든 곳에 적용됨). &lt;a href=&quot;#ghci-interactive-options&quot;&gt;대화식 평가를위한 옵션 설정 만&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3eb1542266aa6e78b551f4a66f99dca63eb84c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="3ee688d5e3686106a78a8c11143028e7c7c2d867" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 이진 모드로 엽니 다. 자세한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 은 openBinaryFile 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="171756990cca268601ff47e149f013f10d1f0b1d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="3e5d1ae0b75edd09252cda3ae684b700669426cc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 바이너리 모드로 파일을 엽니 다. 더 많은 주석은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e95f6be3cd220d7c265e9ff2d6eb81b829a783d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="315f04774b37e903ccef1fd017cf5e6c8fb19cad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="26af205331dd385348a903a75489cae5ac1bc8a2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, this sparks off a new thread to run the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation passed as the first argument, and returns the &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; of the newly created thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 , 이것은 새로운 스레드를 시작 하여 첫 번째 인수로 전달 된 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 계산 을 실행 하고 새로 작성된 스레드 의 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e51a2d5c390f6fe2c3f06d7a141e356abf36b260" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is a bound thread, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 바운드 스레드 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5a0feb98209de5e446543c7ee38359b8a7b02e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894deb520e4932d4ccd6a7678d392f4657ad389a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 작업은 비동기 예외가 마스크되어 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b23d745348276319c0475e801e641228506e2414" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 작업은 비동기 예외가 마스크 된 상태로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cbaf69411b6e48d7f755fce6152d35bbf2f5117d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 두 번째 인수 의 &lt;code&gt;IO&lt;/code&gt; 동작은 비동기 예외가 마스크 된 상태로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf1b2d2d7438a64e06e7288f0b784895fdb2d25" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; but the function is a simple state transition that can return a side value which is passed on as the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; 와 유사 하지만이 함수는 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 의 결과로 전달되는 부수 값을 반환 할 수있는 간단한 상태 전이입니다 .</target>
        </trans-unit>
        <trans-unit id="c85aa7d7cdb5b9edc279fc62b53487dd9aa084bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the in-between computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 있지만 단지 그 사이 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="428edc72ad0acbe121d8494d1d65e4193ca597f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 있지만 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="58d823ae8a2d7d414c0d42e7b802e79575732ed8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ,하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="6caf66653eb22b299f52b1089ebb3605f273b200" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 있지만 마스크 연산 (참조 : 인터럽트없는 &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; ). 스레드 가 어떤 이유로 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 마스크에서 실행되는 스레드 인 경우 스레드 (및 아마도 주 스레드 인 경우 프로그램)가 응답하지 않고 종료 할 수 없으므로 GREAT CARE와 함께 사용해야합니다 . 이 기능은 인터럽트 가능한 작업 주위의 예외를 마스크해야하는 경우에만 필요하며 인터럽트 가능한 작업이 단기간 동안 만 차단되도록 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d8e2c728be8dff68d64c2a9d4e55d7a3457b7d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="d0c2cdb316924ad0cfcfbad4c5a54c0b89f7946f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b96efb08972b89ea81a161e65a91a252070d9475" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b6ab6604b14c9e57db46ecf0ddcd0256f914b9e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if an error is thrown by the in-between computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a432005495b7136cfdf428a9a6ea3acfc5248a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af33929c8b3cdd326c411d0878af278835603f2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. WARNING: Only use if you need to mask exceptions around an interruptible operation AND you can guarantee the interruptible operation will only block for a short period of time. Otherwise you render the program/thread unresponsive and/or unkillable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f3eb839ad43d64884f153d8e4355f1395cdc6c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cdc9f7942398d4390de39bd760476640cca3cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">전체 요청을 충족시키기 위해 즉시 사용 가능한 바이트가 충분하지 않은 경우 더 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 리턴 될 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 과 유사 합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="22204fd64f738ebaf8d59795481095728e60cafd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">전체 요청을 충족시키기 위해 즉시 사용 가능한 바이트가 충분하지 않은 경우 더 짧은 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 이 리턴 될 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 과 유사 합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 은 사용 가능한 데이터가없고 EOF에 아직 도달하지 않은 경우에만 차단합니다.</target>
        </trans-unit>
        <trans-unit id="88bc8146cfaa55c674a416c3250cf7fde75cab90" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; but instead of giving the final size of the ByteString, it is just an upper bound. The inner action returns the actual size. Unlike &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; the ByteString is not reallocated if the final size is less than the estimated size.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 ByteString 의 최종 크기를 제공하는 대신 상한입니다. 내부 동작은 실제 크기를 반환합니다. &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; 과 달리 최종 크기가 예상 크기보다 작 으면 ByteString이 재 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5d3796594fc3ab685a758f79230f2378e0d143a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returning unit in an arbitrary &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context. Allows for convenient use in do-notation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 임의뿐만 돌아 단위 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 상황. do-notation에서 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14b22297f44f3b23085789ee54f433e3be99756" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returns the message instead of a third value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 세 번째 값 대신 메시지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94f249d85e854bd365a2caf558548ba6a48c90f7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; ,하지만 사용은 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; A를 변환 할 수있는 인수에 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bda17b6fe85f48913bc5a5c73b83bf25335feb15" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 인수에 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4d4f7e6d83c6d859a27421bd667669770d5a90e1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; but returns the shown value instead of a third value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 세 번째 값 대신 표시된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3388029e6ebab6adb5dbdc535cdaa4a63773ee6d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7201461e77cbbffbf975483dea651ac9f115ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="61b50bda211ddddaf8be8d611e3ac6aceb8f889d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7debe615da856622a94fda2ea5817fa207e70f78" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="64ed7e2ac88ad404c757ebe2bf247c490e1bb7f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="86170fb3c040fb17cc898e1ff2e2691ab6d6babd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 특수 종료 요소를 보유 할 추가 위치를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1ab9de75683278e54e5c08a09c39dc2659dca6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 할당 된 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="31e8f4f3a29d9ebfdb6b5dd33afab7987daa7fac" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 특수 종료 요소를 보유 할 추가 위치를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e8798d35982e07ff23b6d4dd4f9bdb7568df53ad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 할당 된 메모리는 값이 0 인 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="56fea7f011d519c7d258e88b7f3d4ae54477fc85" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종결자는 배열이 끝나는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f5dc7b1ce9daa64f13a0b057b2f35119ac5cd95" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but the action gets the number of values as an additional parameter</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 액션은 추가 매개 변수로 값 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e4b7f2fe78306ea129c2aaf255ab760c2af8b59" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 종결자는 배열이 끝나는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="789fc518616c7bbb0baf7f9f6873e5ac8d47ec18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt; 처럼 결과를 버립니다</target>
        </trans-unit>
        <trans-unit id="c8a36a8d0834f745b3ab8c875279421ca4121094" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt; 하지만, 그 결과를 폐기</target>
        </trans-unit>
        <trans-unit id="6a1b2b22a37fbf26bc19da6800d4f4f4c18e9196" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , 값 범위가 확인하지 않고.</target>
        </trans-unit>
        <trans-unit id="fd6ed34fe3d856c29ed47ef21309ed222b27e308" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8a1ab1b4c3fc6205f7cbc119a5029f50c82ecfa2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="36c33ff708aca6f019cd5e4f36eb986bb33a1c42" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7e718907739536fc11ccba60be322ece4a576f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 스레드를 실행할 기능을 지정할 수 있습니다. 달리 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드에 의해 만들어진 스레드 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 전체 수명에 대해 동일한 기능에 남아있을 것입니다 ( &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 의 스레드 스케줄링 정책에 따라 기능 사이에서 마이그레이션 할 수 있습니다). &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 은 스레드를 가장 잘 분배하는 방법을 미리 알고있을 때 스케줄링 정책을 대체하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="06b626d6d4d9cc23806065fb84e761850f571140" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 자식 스레드에는 비동기 예외를 마스크 해제하는 데 사용할 수있는 함수가 전달됩니다. 이 기능은 일반적으로 다음과 같은 방식으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="2074e4e1e1d435d659723420ae5b7066c75304a9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 하지만 자식 스레드와 마찬가지로, 주어진 CPU에 고정됩니다 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03378dafea3e612ebd75747dbec79dd54212c74e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3f4ecabff6e19ca899a6be2fc7069356485a28" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 종료자가 추가 환경 매개 변수를 전달하여 종료 자에 전달되도록합니다. finalizer로 전달 된 환경은 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 의 두 번째 인수로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce27041c32b2c7b9dd00240cd18dbacb3f46271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, there is a class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; that defines a representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; and conversion functions &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt;, only that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; ranges over types of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. (More generally, it can range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;, if the &lt;code&gt;PolyKinds&lt;/code&gt; extension is enabled. More on this later.) The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class is also derivable.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; , 클래스가 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 표현 정의 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 및 변환 기능 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt; 단 것으로, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 가 가지 유형 이상의 범위 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; . (일반적으로 &lt;code&gt;PolyKinds&lt;/code&gt; 확장이 활성화 된 경우 모든 종류의 &lt;code&gt;k&lt;/code&gt; 에 대해 종류 k- &lt;code&gt;k -&amp;gt; *&lt;/code&gt; 의 범위를 지정할 수 있습니다 . 나중에 더 자세히 설명합니다.) &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 클래스도 파생 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c6bccda987e33fe0bbf298a851536cd1b5e84ab8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ,하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="aad2536126d6403f4616d23d084d88d2eb347131" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 있지만 마스크 연산 (참조 : 인터럽트없는 &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception을&lt;/a&gt; ). 스레드 가 어떤 이유로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 마스크에서 실행되는 스레드 인 경우 스레드 (및이 프로그램이 기본 스레드 인 경우 프로그램)가 응답하지 않고 종료 할 수 없으므로 GREAT CARE와 함께 사용해야합니다 . 이 기능은 인터럽트 가능한 작업 주위의 예외를 마스크해야하는 경우에만 필요하며 인터럽트 가능한 작업이 단기간 동안 만 차단되도록 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad819e37fccd377f4f7ea98ffe39aaa59462a5e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 하지만 통과하지 않습니다 &lt;code&gt;restore&lt;/code&gt; 인수에 대한 조치를.</target>
        </trans-unit>
        <trans-unit id="8f34379fe53a8f49eef2d4d51e196bbfce89ed5a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 하지만, 바이너리 모드로 파일을 엽니 다. Windows에서 텍스트 모드 (기본값)에서 파일을 읽으면 CRLF가 LF로 변환되고 기록하면 LF가 CRLF로 변환됩니다. 이것은 일반적으로 텍스트 파일로 원하는 것입니다. 이진 파일의 경우 이는 바람직하지 않습니다. 또한 Microsoft 운영 체제에서 평소와 같이 텍스트 모드는 control-Z를 EOF로 취급합니다. 이진 모드는 줄 끝 및 파일 끝 문자의 모든 특수 처리를 끕니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6e447be1c8c5966385a7af2bdc9dacccc9d0191" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but opens the file in ordinary blocking mode. This can be useful for opening a FIFO for writing: if we open in non-blocking mode then the open will fail if there are no readers, whereas a blocking open will block until a reader appear.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 일반 차단 모드로 엽니 다. 쓰기를 위해 FIFO를 여는 데 유용 할 수 있습니다. 비 차단 모드에서 열면 리더가 없으면 열기가 실패하지만 리더가 나타날 때까지 차단 열기가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="d11ed8ec1f7d4a4f76c34befc3bc8a8f2cef6d9c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-ix#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11412198fb2aebb6ae9a4f43a11db80ce5c58256" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; (expand escape characters using Haskell escape conventions), but * break the string into multiple lines * wrap the entire thing in double quotes Example: &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; : 예 (하스켈 탈출 규칙을 사용하여 이스케이프 문자를 확장),하지만 * * 따옴표로 전체 일을 감싸는 여러 행으로 문자열을 깰 &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; 반환 &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c39ac872c5a458945a6a2759691e5bcbdb98387" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but in the event of an exception that causes an exit, we don't shut down the system cleanly, we just exit. This is useful in some cases, because the safe exit version will give other threads a chance to clean up first, which might shut down the system in a different way. For example, try</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 종료를 일으키는 예외가 발생하면 시스템을 완전히 종료하지 않고 종료합니다. 안전 종료 버전은 다른 스레드가 먼저 정리할 수있는 기회를 제공하므로 시스템이 다른 방식으로 종료 될 수 있기 때문에 일부 경우에 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="92a361d777b7468b2f4fc3ce94a02dd7971e288e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 있지만 계산 제기 예외가 발생했을 경우, 최종 동작을 수행한다.</target>
        </trans-unit>
        <trans-unit id="d3dcb0071e2c488b5032fe8ef982a6ce42d875b4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, but can also read arguments supplied via response files.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 유사 하지만 응답 파일을 통해 제공된 인수를 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="524c7a43bda4a60c5d96c8d591c7b926a8919edd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;, but allows blank environment values and mimics the function signature of &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;unix&lt;/code&gt; package.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; ,하지만 빈 환경 가치와 모방을의 함수 서명 허용 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 로부터를 &lt;code&gt;unix&lt;/code&gt; 패키지 .</target>
        </trans-unit>
        <trans-unit id="b797f1a70d1f88521b8770e48825b66c385a7740" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt;, but allows for the removal of blank environment variables. May throw an exception if the underlying platform doesn't support unsetting of environment variables.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 비슷 하지만 빈 환경 변수를 제거 할 수 있습니다. 기본 플랫폼이 환경 변수 설정 해제를 지원하지 않으면 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8431a8f9693c397e4ecffa5b03a89b83f5c963c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt; 비슷 하지만 기본 파일 권한을 사용합니다</target>
        </trans-unit>
        <trans-unit id="ddc8a70da72ad8f7b98007cd07b86322fc708d18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 하지만, 바이너리 모드로 파일을 엽니 다. Windows에서 텍스트 모드 (기본값)에서 파일을 읽으면 CRLF가 LF로 변환되고 기록하면 LF가 CRLF로 변환됩니다. 이것은 일반적으로 텍스트 파일로 원하는 것입니다. 이진 파일의 경우 이는 바람직하지 않습니다. 또한 Microsoft 운영 체제에서 평소와 같이 텍스트 모드는 control-Z를 EOF로 취급합니다. 이진 모드는 줄 끝 및 파일 끝 문자의 모든 특수 처리를 끕니다. &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="445dbb3aac3b63578f83ae7ca3264f9470654614" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 유사 하지만 파일을 이진 모드로 엽니 다. 자세한 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 은 openBinaryFile 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42d2371aba08fe3ad0e461bdd5e9243b5d4ff47c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 과 비슷 하지만 기본 파일 권한을 사용합니다</target>
        </trans-unit>
        <trans-unit id="68e487cc9bcc812ffdd024d2959aeef2edcaff91" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 타임 스탬프는 1 초 미만의 해상도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd41ba6952859aa302482f390cdfdfc026468ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">처럼 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf41494a113002bf4517831272153ccf7cd29c3d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0b8c47891569804ad6ed4ae6fd8eda019375adc3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 처럼하지만 타임 스탬프는 1 초 미만의 해상도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33961ae29501aef7bf09af455c8576676e24ac35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5bbeb7f8e03e4906f3490fc206720d0eab71a223" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; 처럼 하지만 기호 링크를 따르지 않습니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="662c747da0f04cde3ce2ca5a423c4b7f959d2f5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt; 하지만, 구문 분석 중 하나 이상 발생 &lt;code&gt;p&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f8ce7731553d62994a654a2d708daf3c75a28d74" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt; 와 비슷 하지만 하나 이상의 &lt;code&gt;p&lt;/code&gt; 발생을 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="6fee7ff8239ed3fa9381ad7aca490952c09c187d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; ,하지만 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="b3dabdc0b676ddd52428d8521d1cc42a6a7a8ded" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt; 하지만, 폐기 결과.</target>
        </trans-unit>
        <trans-unit id="a81f5f54f0cb0d0d364aaedc68e2c63bc094834c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;INLINE&lt;/code&gt;, the &lt;code&gt;INLINABLE&lt;/code&gt; pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.</source>
          <target state="translated">마찬가지로 &lt;code&gt;INLINE&lt;/code&gt; 의 &lt;code&gt;INLINABLE&lt;/code&gt; 프라그 무관 RHS의 사이즈, 인터페이스 파일에서 인라인 상업적 일본어 RHS의 복사 및 지속하여이를 보유한다.</target>
        </trans-unit>
        <trans-unit id="be5585db37b6a8bd5e1a92603fdbe92c2af65ed4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;compactAdd#&lt;/code&gt;, but retains sharing and cycles during compaction.</source>
          <target state="translated">&lt;code&gt;compactAdd#&lt;/code&gt; 처럼 만 유지 공유하고 압축하는 동안 사이클.</target>
        </trans-unit>
        <trans-unit id="ee95b6c97dc7c4bdba6a1af63ea6a5ab1b1b563e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; bindings, name shadowing is not allowed within an &lt;code&gt;mdo&lt;/code&gt;-expression or a &lt;code&gt;rec&lt;/code&gt;-block; that is, all the names bound in a single &lt;code&gt;rec&lt;/code&gt; must be distinct. (GHC will complain if this is not the case.)</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;where&lt;/code&gt; 바인딩 과 마찬가지로 이름 섀도 잉은 &lt;code&gt;mdo&lt;/code&gt; -expression 또는 &lt;code&gt;rec&lt;/code&gt; -block 내에서 허용되지 않습니다 . 즉, 하나의 &lt;code&gt;rec&lt;/code&gt; 에 묶인 모든 이름 은 고유해야합니다. 그렇지 않은 경우 온실 가스가 불만을 제기합니다.</target>
        </trans-unit>
        <trans-unit id="a0a24c56e1b9f366848073186782d64a2635b134" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;seq&lt;/code&gt;, the argument of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; can have an unboxed type.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 인수 는 unboxed 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cafc4e6a3f71e112837260dfb933a8b2509697" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;setFileTimesHiRes&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;setFileTimesHiRes&lt;/code&gt; 처럼 하지만 경로 대신 파일 디스크립터를 사용합니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e4c941a2f6f4373225d42fc487a0f7d303ff143f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;touchFile&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">&lt;code&gt;touchFile&lt;/code&gt; 과 유사 하지만 경로 대신 파일 설명자를 사용합니다. 이 작업이 모든 플랫폼에서 지원되는 것은 아닙니다. 이러한 플랫폼에서이 기능은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="99cd3e5d292b4b23332a6b2a47c1eadf4be20341" translate="yes" xml:space="preserve">
          <source>Like all other GHCi commands, the output is always displayed in the current GHCi scope (&lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;).</source>
          <target state="translated">다른 모든 GHCi 명령과 마찬가지로 출력은 항상 현재 GHCi 범위에 표시됩니다 ( &lt;a href=&quot;#ghci-scope&quot;&gt;프롬프트의 범위는 무엇입니까?&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef089d2aac5aa17ae2f559d2e25f348c4bd6fbfe" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc84715575b0fa376556544c5d2ef3d4d3ec50fb" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">다른 많은 Haskell 데이터 구조와 마찬가지로 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 도 게으 릅니다 . 즉, 값 비싼 평가되지 않은 썽크를 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 안에 넣으면 그것을 생성 한 스레드가 아니라 소비하는 스레드에 의해 평가됩니다. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 적절한 정규 형식 으로 배치 할 값 을 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 하거나 엄격 동시성 패키지가 제공하는 엄격한 MVar를 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="37c17ec186b7de612cb654acafdf92b9e7cdfb9b" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">다른 pragma와 마찬가지로 &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; pragma는 항상 범위 오류가 있는지 확인하고 유형 확인합니다. 유형 검사는 규칙의 LHS 및 RHS가 유형 검사되고 동일한 유형을 가져야 함을 의미합니다. 그러나 규칙은 &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt; 플래그가 켜져있는 경우 에만 &lt;em&gt;활성화&lt;/em&gt; 됩니다 ( &lt;a href=&quot;#rule-semantics&quot;&gt;시맨틱&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3447df87a2c63f15a9f31c14cbaf487254b0da44" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;code&gt;RULE&lt;/code&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">다른 pragma와 마찬가지로 &lt;code&gt;RULE&lt;/code&gt; pragma는 항상 범위 오류를 확인하고 형식을 확인합니다. 유형 검사는 규칙의 LHS 및 RHS가 유형 검사되며 동일한 유형을 가져야 함을 의미합니다. 그러나 &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt; 플래그가 켜져있는 경우 에만 규칙이 &lt;em&gt;활성화&lt;/em&gt; 됩니다 ( &lt;a href=&quot;#rule-semantics&quot;&gt;시맨틱&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8cd118e46b9ceb5fcb2a8499ea3916b27ce3f424" translate="yes" xml:space="preserve">
          <source>Like the function &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, but appends a stack trace to the error message if one is available.</source>
          <target state="translated">기능 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 처럼 하지만 스택 추적이있는 경우 오류 추적에 스택 추적을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2b393f82e4729c2fe510cc4df3e3b9d2a29de00f" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, it is possible to explicitly bind type and kind variables in default declarations with a &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">&lt;a href=&quot;#assoc-inst&quot;&gt;Associated 인스턴스&lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; 언어 확장 을 사용하여 &lt;code&gt;forall&lt;/code&gt; 을 사용하여 기본 선언의 유형 및 종류 변수를 명시 적으로 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24d948e4bdbe5b8224bbc0dfbab1923fab00b98e" translate="yes" xml:space="preserve">
          <source>Limit</source>
          <target state="translated">Limit</target>
        </trans-unit>
        <trans-unit id="70044be8751bf68d4de8b7945e5586e80acb7cb2" translate="yes" xml:space="preserve">
          <source>Limit the number of lines stored in the history.</source>
          <target state="translated">히스토리에 저장된 라인 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="ea9676003762818513c636984faeaa0ae356839a" translate="yes" xml:space="preserve">
          <source>Line</source>
          <target state="translated">Line</target>
        </trans-unit>
        <trans-unit id="16fd51c8ab5fd356a1d23d48f4531237b879e504" translate="yes" xml:space="preserve">
          <source>Line and character position</source>
          <target state="translated">선과 문자 위치</target>
        </trans-unit>
        <trans-unit id="702b953a8e73a9c6b4402eb231caf05c182af7f6" translate="yes" xml:space="preserve">
          <source>Line length.</source>
          <target state="translated">줄 길이.</target>
        </trans-unit>
        <trans-unit id="054f11de365cf7821b8d7f5863692c6cc9051ab6" translate="yes" xml:space="preserve">
          <source>Line number information necessary to map instruction addresses to line numbers in the source program.</source>
          <target state="translated">명령 프로그램 주소를 소스 프로그램의 행 번호에 매핑하는 데 필요한 행 번호 정보.</target>
        </trans-unit>
        <trans-unit id="8087784b605286ef9ef2960647bad3300431de2b" translate="yes" xml:space="preserve">
          <source>LineBuffering</source>
          <target state="translated">LineBuffering</target>
        </trans-unit>
        <trans-unit id="281752024edc1ab9c1f92c79633d55bc44eacd94" translate="yes" xml:space="preserve">
          <source>LineSeparator</source>
          <target state="translated">LineSeparator</target>
        </trans-unit>
        <trans-unit id="e3b93cdf9997876ced65e2c007d6364b7d627da6" translate="yes" xml:space="preserve">
          <source>LinesAffected</source>
          <target state="translated">LinesAffected</target>
        </trans-unit>
        <trans-unit id="eb1cda622d5b91f2847faea4f7c037e360353e7a" translate="yes" xml:space="preserve">
          <source>Link all passed files into a static library suitable for linking. To control the name, use the &lt;code&gt;-o ⟨file⟩&lt;/code&gt; option as usual. The default name is &lt;code&gt;liba.a&lt;/code&gt;.</source>
          <target state="translated">전달 된 모든 파일을 링크에 적합한 정적 라이브러리에 링크하십시오. 이름을 제어하려면 평소와 같이 &lt;code&gt;-o ⟨file⟩&lt;/code&gt; 옵션을 사용하십시오 . 기본 이름은 &lt;code&gt;liba.a&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f4a6bdd90ed3ff452ae2e2964b9b2c357b03f32" translate="yes" xml:space="preserve">
          <source>Link in library ⟨lib⟩</source>
          <target state="translated">라이브러리의 링크 ⟨lib⟩</target>
        </trans-unit>
        <trans-unit id="d9cd1bd51d029ba12d6908919f6358ef8b55fb4f" translate="yes" xml:space="preserve">
          <source>Link in the ⟨lib⟩ library. On Unix systems, this will be in a file called &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; or &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; which resides somewhere on the library directories path.</source>
          <target state="translated">⟨lib⟩ 라이브러리에 링크하십시오. Unix 시스템에서는 라이브러리 디렉토리 경로의 어딘가에있는 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; 또는 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; 라는 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcaae5f3f12bcb52dc5f90152a65e0bdbec2c943" translate="yes" xml:space="preserve">
          <source>Link the program with a debugging version of the runtime system. The debugging runtime turns on numerous assertions and sanity checks, and provides extra options for producing debugging output at runtime (run the program with &lt;code&gt;+RTS -?&lt;/code&gt; to see a list).</source>
          <target state="translated">프로그램을 런타임 시스템의 디버깅 버전과 연결하십시오. 디버깅 런타임은 수많은 어설 션 및 온 전성 검사를 설정하고 런타임에 디버깅 출력을 생성하기위한 추가 옵션을 제공합니다 ( &lt;code&gt;+RTS -?&lt;/code&gt; 목록을 보려면 로 하십시오).</target>
        </trans-unit>
        <trans-unit id="aa02a71e52144b5208df7f7113d1f3bb6b6ff3a1" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;eventlog&amp;rdquo; version of the runtime system. A program linked in this way can generate a runtime trace of events (such as thread start/stop) to a binary file &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt;, which can then be interpreted later by various tools. See &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;Tracing&lt;/a&gt; for more information.</source>
          <target state="translated">프로그램을 런타임 시스템의 &quot;eventlog&quot;버전과 연결하십시오. 이러한 방식으로 링크 된 프로그램은 스레드 시작 / 중지와 같은 이벤트의 런타임 추적을 이진 파일 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; 에 생성 한 다음 나중에 다양한 도구로 해석 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;추적&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74630b9250c4419175d9406e09096a825645aee9" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;threaded&amp;rdquo; version of the runtime system. The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded.</source>
          <target state="translated">프로그램을 &quot;스레드&quot;버전의 런타임 시스템과 연결하십시오. 스레드 된 런타임 시스템은 단일 스레드 인 기본 런타임 시스템과 달리 여러 OS 스레드를 관리하기 때문에 소위 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a0ad1ef7b6972d54e70158733112a5d174213f28" translate="yes" xml:space="preserve">
          <source>LinkCount</source>
          <target state="translated">LinkCount</target>
        </trans-unit>
        <trans-unit id="05669bed092bbe0873ad6674e013a8667f68fe04" translate="yes" xml:space="preserve">
          <source>LinkLimit</source>
          <target state="translated">LinkLimit</target>
        </trans-unit>
        <trans-unit id="9fa999dc4d8eab9b8471e5d9aa06c5de2dbcdca7" translate="yes" xml:space="preserve">
          <source>Linking type and value level</source>
          <target state="translated">연결 유형 및 값 수준</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="2be1eb803afe605ac5bf0ed36710e67b7cf3ad56" translate="yes" xml:space="preserve">
          <source>List all enabled language extensions.</source>
          <target state="translated">사용 가능한 모든 언어 확장을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="4ada7d3f43f0d02ac75493517b3e3afc1c377d07" translate="yes" xml:space="preserve">
          <source>List all of the files or folders beginning with this path.</source>
          <target state="translated">이 경로로 시작하는 모든 파일 또는 폴더를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c60e0858274aa75bbb19a9a06cc630a1d46b1c" translate="yes" xml:space="preserve">
          <source>List all types collected for expressions and (local) bindings currently loaded (while &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; was active) with their respective source-code span, e.g.</source>
          <target state="translated">각각의 소스 코드 범위와 함께 현재로드 된 (로컬) 바인딩 ( &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt; 가 활성화 된 동안)에 대해 수집 된 모든 유형을 나열합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="ba8a89a77fc9557b8e8c8d251c8ead9fbdaeb7a1" translate="yes" xml:space="preserve">
          <source>List comprehensions</source>
          <target state="translated">목록 이해</target>
        </trans-unit>
        <trans-unit id="3f051a8062e5fac28d61cc364f9f1acc708cd461" translate="yes" xml:space="preserve">
          <source>List index (subscript) operator, starting from 0. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt;, which takes an index of any integral type.</source>
          <target state="translated">0부터 시작하여 인덱스 (첨자) 연산자를 나열합니다.보다 일반적인 &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 의 인스턴스이며, 정수 유형의 인덱스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="754adb8bd3be1191610eae9f21f2c4cd71a1162d" translate="yes" xml:space="preserve">
          <source>List notation, such as &lt;code&gt;[x,y]&lt;/code&gt; or &lt;code&gt;[m..n]&lt;/code&gt; can also be treated via rebindable syntax if you use &lt;code&gt;-XOverloadedLists&lt;/code&gt;; see &lt;a href=&quot;#overloaded-lists&quot;&gt;Overloaded lists&lt;/a&gt;.</source>
          <target state="translated">같은 표기에서, &lt;code&gt;[x,y]&lt;/code&gt; 또는 &lt;code&gt;[m..n]&lt;/code&gt; 가 또한 사용할 경우 rebindable 구를 통해 처리 될 수 &lt;code&gt;-XOverloadedLists&lt;/code&gt; 을 ; &lt;a href=&quot;#overloaded-lists&quot;&gt;오버로드 된 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="920d73e463b5cf5eed14ea6d6e2da4031afeaa2c" translate="yes" xml:space="preserve">
          <source>List of associations</source>
          <target state="translated">협회 목록</target>
        </trans-unit>
        <trans-unit id="6b46c2d4b10caadfeb5b6a9c62ffb97de0f2b1d4" translate="yes" xml:space="preserve">
          <source>List of elements of a structure, from left to right.</source>
          <target state="translated">왼쪽에서 오른쪽으로 구조의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">목록 작업</target>
        </trans-unit>
        <trans-unit id="5f897200e3f1c653befd6edfbddc4172f95a6a57" translate="yes" xml:space="preserve">
          <source>List patterns are also overloaded. When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, these definitions are desugared as follows</source>
          <target state="translated">목록 패턴도 오버로드됩니다. 때 &lt;code&gt;OverloadedLists&lt;/code&gt; 을 확장이 설정되어 다음과 같이 이러한 정의는 desugared된다</target>
        </trans-unit>
        <trans-unit id="76603bea3fde9f607769b026d910df0dfc04acfc" translate="yes" xml:space="preserve">
          <source>List the active breakpoints.</source>
          <target state="translated">활성 중단 점을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="bb72cfc84c631772e908d5b0c3a4205d0c9649a0" translate="yes" xml:space="preserve">
          <source>List the active evaluations that are stopped at breakpoints.</source>
          <target state="translated">중단 점에서 중지 된 활성 평가를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="d92d0a195ad4655dbddbf91fc436d0a6b999cd58" translate="yes" xml:space="preserve">
          <source>List the frames of a stack trace.</source>
          <target state="translated">스택 추적의 프레임을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b46a3709f9c0d5af2b972568db4b210d8669456f" translate="yes" xml:space="preserve">
          <source>List transformations</source>
          <target state="translated">리스트 변환</target>
        </trans-unit>
        <trans-unit id="105d6ef74784f6217af666c539a87096be10b1b3" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="f8e9efe55b79317a3e563e7e8e801673f73f1521" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="db73b7893f3af8f6c05605cf9251be842b275f8d" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 목록 버전</target>
        </trans-unit>
        <trans-unit id="482dfe339c4f0977581fe5ee524fa53adc1e28ed" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="cfafdd602fb158738556497c46c51d6d60df9768" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="20bd5a0e4fabf718ca894fcb17f676efec0307ae" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ceba6d840aab502457ce42ae3fbfeab1ecc2414" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="66e7277f4ef344564d58e60d6ea51d7adf033fef" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3158aef4933628130f67b89a618bc8b174d8978" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="745ee4c2660329c820454e1ba2a47f402e1ce21f" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 의 목록 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="5594bce20a5038736c0afcf0c55e2622caf81f60" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d0b7f90f7aacdb031c45cf80cdd404adafbe362" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 버전을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="33a93596bb8da89147bd59e3fe1b97c2d66a5038" translate="yes" xml:space="preserve">
          <source>ListT</source>
          <target state="translated">ListT</target>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="781623c2be49bc87bb9e5a34fe84e216baf4b8b9" translate="yes" xml:space="preserve">
          <source>Lists the source code around the definition of ⟨identifier⟩ or the current breakpoint if not given. This requires that the identifier be defined in an interpreted module. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">지정되지 않은 경우 &quot;identifier&quot;정의 또는 현재 중단 점 주위의 소스 코드를 나열합니다. 이를 위해서는 식별자가 해석 된 모듈에서 정의되어야합니다. 출력 장치가 지원하는 경우 GHCi는 활성 하위 표현식을 굵게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="808589d62b1e1bf49e41bd4b6a92d4dc1a0d0f3a" translate="yes" xml:space="preserve">
          <source>Lists the source code around the given line number of ⟨module⟩. This requires that the module be interpreted. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">주어진 ⟨module⟩ 줄 번호 주위의 소스 코드를 나열합니다. 이를 위해서는 모듈을 해석해야합니다. 출력 장치가 지원하는 경우 GHCi는 활성 하위 표현식을 굵게 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4a7facfa8bfb2e9078fe2cd6adc3a55c36788e6" translate="yes" xml:space="preserve">
          <source>Lists, but with an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor based on zipping.</source>
          <target state="translated">목록이지만 압축 기반 의 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 케이 션 펑터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c730a293f109c2c9fe03256794b5a680b2406f1" translate="yes" xml:space="preserve">
          <source>Lit</source>
          <target state="translated">Lit</target>
        </trans-unit>
        <trans-unit id="1d45d75d6a3cc51b4987b3781a45f5c1345a4a98" translate="yes" xml:space="preserve">
          <source>LitSort</source>
          <target state="translated">LitSort</target>
        </trans-unit>
        <trans-unit id="3c7167176c55c32edbdb72649b122c134066cd84" translate="yes" xml:space="preserve">
          <source>Little-endian</source>
          <target state="translated">Little-endian</target>
        </trans-unit>
        <trans-unit id="0877eccb7ffb8474ab69b0fcf579d9b84daccdd0" translate="yes" xml:space="preserve">
          <source>Little-endian decoding</source>
          <target state="translated">리틀 엔디안 디코딩</target>
        </trans-unit>
        <trans-unit id="c7273f034919f3ef6168c89cba26b3bce836ba9e" translate="yes" xml:space="preserve">
          <source>Little-endian primitives</source>
          <target state="translated">리틀 엔디안 프리미티브</target>
        </trans-unit>
        <trans-unit id="1c321830ed633cc94628e1e65216ff4ba6a6ed76" translate="yes" xml:space="preserve">
          <source>Little-endian writes</source>
          <target state="translated">리틀 엔디안</target>
        </trans-unit>
        <trans-unit id="6fc67654e4796ae3f37595e79dd2e45c3625e5e5" translate="yes" xml:space="preserve">
          <source>LittleEndian</source>
          <target state="translated">LittleEndian</target>
        </trans-unit>
        <trans-unit id="2e67c31b2f3fdce36aeeb1f20caff4b304f70567" translate="yes" xml:space="preserve">
          <source>Ll: Letter, Lowercase</source>
          <target state="translated">Ll : 문자, 소문자</target>
        </trans-unit>
        <trans-unit id="58382029ac6f1e5383d7bade61f6a456488c6bbd" translate="yes" xml:space="preserve">
          <source>Llike &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">mallocBytes와 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 하지만 메모리는 0 값의 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4288785885201e9bb76e1d0199483effb5fe9f71" translate="yes" xml:space="preserve">
          <source>Lm: Letter, Modifier</source>
          <target state="translated">Lm : 문자, 수정 자</target>
        </trans-unit>
        <trans-unit id="2fdaaab4868bf18d8a809e1f5f7e47a37f964d96" translate="yes" xml:space="preserve">
          <source>Lo: Letter, Other</source>
          <target state="translated">Lo : 편지, 기타</target>
        </trans-unit>
        <trans-unit id="8accbc10b359e949cb147175bb580bf3e07dc786" translate="yes" xml:space="preserve">
          <source>Load a plugin exported by a given module</source>
          <target state="translated">지정된 모듈에서 내 보낸 플러그인로드</target>
        </trans-unit>
        <trans-unit id="51fa1bf18d44ef1d1248c602fa8dd72c62735eea" translate="yes" xml:space="preserve">
          <source>Load the plugin in the given module. The module must be a member of a package registered in GHC&amp;rsquo;s package database.</source>
          <target state="translated">주어진 모듈에 플러그인을로드하십시오. 모듈은 GHC의 패키지 데이터베이스에 등록 된 패키지의 구성원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="19f77727de15c8eb41a9504fa18fee15c5c48b61" translate="yes" xml:space="preserve">
          <source>Load-balancing shares out the work of GC between the available cores. This is a good idea when the heap is large and we need to parallelise the GC work, however it is also pessimal for the short young-generation collections in a parallel program, because it can harm locality by moving data from the cache of the CPU where is it being used to the cache of another CPU. Hence the default is to do load-balancing only in the old-generation. In fact, for a parallel program it is sometimes beneficial to disable load-balancing entirely with &lt;code&gt;-qb&lt;/code&gt;.</source>
          <target state="translated">로드 균형 조정은 사용 가능한 코어간에 GC 작업을 공유합니다. 힙이 크고 GC 작업을 병렬화해야하는 경우에 좋은 아이디어이지만 병렬 프로그램의 짧은 젊은 세대 콜렉션에도 적합합니다. 이는 CPU 캐시에서 데이터를 이동하여 로컬 성을 해칠 수 있기 때문입니다. 다른 CPU의 캐시에 사용되는 곳은 어디입니까? 따라서 기본값은 이전 세대에서만로드 밸런싱을 수행하는 것입니다. 사실, 병렬 프로그램의 경우 &lt;code&gt;-qb&lt;/code&gt; 로 로드 밸런싱을 완전히 비활성화하는 것이 때로는 유리합니다 .</target>
        </trans-unit>
        <trans-unit id="5baeca2bd84e4324195dfc5aa4a5d2fe832d33c9" translate="yes" xml:space="preserve">
          <source>Loading a multi-module program is just as straightforward; just give the name of the &amp;ldquo;topmost&amp;rdquo; module to the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command (hint: &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be abbreviated to &lt;code&gt;:l&lt;/code&gt;). The topmost module will normally be &lt;code&gt;Main&lt;/code&gt;, but it doesn&amp;rsquo;t have to be. GHCi will discover which modules are required, directly or indirectly, by the topmost module, and load them all in dependency order.</source>
          <target state="translated">멀티 모듈 프로그램을로드하는 것은 간단합니다. &quot;loadest&quot;모듈의 이름을 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 명령에 지정하십시오 (힌트 : &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;:l&lt;/code&gt; 로 축약 될 수 있음 ). 최상위 모듈은 일반적으로 &lt;code&gt;Main&lt;/code&gt; 이지만 반드시 그럴 필요는 없습니다. GHCi는 최상위 모듈이 직간접 적으로 어떤 모듈을 필요로하는지 발견하고 모든 모듈을 종속성 순서대로로드합니다.</target>
        </trans-unit>
        <trans-unit id="3ca542db8dd842ccea2e2f49600e491d4a676f0a" translate="yes" xml:space="preserve">
          <source>Loc</source>
          <target state="translated">Loc</target>
        </trans-unit>
        <trans-unit id="94637a234d4833c0a67b7a4f6b5d70bd1cdd5712" translate="yes" xml:space="preserve">
          <source>Local Time</source>
          <target state="translated">현지 시각</target>
        </trans-unit>
        <trans-unit id="ab3cb665e2195c48dc51ad950c912c0fa2cb8e4a" translate="yes" xml:space="preserve">
          <source>Local allocation</source>
          <target state="translated">로컬 할당</target>
        </trans-unit>
        <trans-unit id="0478f8de1f3f270ad9e2bf09aa44262b4422de07" translate="yes" xml:space="preserve">
          <source>Local name bound outside of the TH AST</source>
          <target state="translated">TH AST 외부에 바인딩 된 로컬 이름</target>
        </trans-unit>
        <trans-unit id="93c22935b426d63080a636bc51d84b1a5c5cca31" translate="yes" xml:space="preserve">
          <source>Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used.</source>
          <target state="translated">로컬, 독점, 왼쪽 바이어스 선택 : 왼쪽 구문 분석기가 로컬로 결과를 생성하는 경우 오른쪽 구문 분석기가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478df254596a4a4a51b18fe7c43423e110e9c8b9" translate="yes" xml:space="preserve">
          <source>LocalMode</source>
          <target state="translated">LocalMode</target>
        </trans-unit>
        <trans-unit id="9cb40f7cd87e6348d6d2464d28eeaa1636f17835" translate="yes" xml:space="preserve">
          <source>LocalTime</source>
          <target state="translated">LocalTime</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="c72c9f7a9c187a5da0f209dc188fa32ae35d17f4" translate="yes" xml:space="preserve">
          <source>Locale representing American usage.</source>
          <target state="translated">미국 사용법을 나타내는 로케일.</target>
        </trans-unit>
        <trans-unit id="b7a9db328cdf327a87303972030f518b2e1143a4" translate="yes" xml:space="preserve">
          <source>Locale support</source>
          <target state="translated">로케일 지원</target>
        </trans-unit>
        <trans-unit id="6f1b4ce09e502ee2cc257e3b65eb100b21e07dcd" translate="yes" xml:space="preserve">
          <source>LocaleTestFlags</source>
          <target state="translated">LocaleTestFlags</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="04685f4c01bb7310cd3e866073d0858b658078ed" translate="yes" xml:space="preserve">
          <source>Location information about an address from a backtrace.</source>
          <target state="translated">역 추적의 주소에 대한 위치 정보.</target>
        </trans-unit>
        <trans-unit id="5131787646387f0d5f88f17ccb4880dde6ba21d3" translate="yes" xml:space="preserve">
          <source>Lock the semaphore, blocking until it becomes available. Since this is done through a system call, this will block the *entire runtime*, not just the current thread. If this is not the behaviour you want, use semThreadWait instead.</source>
          <target state="translated">세마포어를 잠그고 사용 가능해질 때까지 차단하십시오. 이는 시스템 호출을 통해 수행되므로 현재 스레드뿐만 아니라 * 전체 런타임 *을 차단합니다. 이것이 원하는 동작이 아닌 경우 semThreadWait를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79ad9e43cfdad7f13ded5dc73bb870eee73c9832" translate="yes" xml:space="preserve">
          <source>LockMode</source>
          <target state="translated">LockMode</target>
        </trans-unit>
        <trans-unit id="031e1faa819e43723677621db8e08752f93d196c" translate="yes" xml:space="preserve">
          <source>LockRequest</source>
          <target state="translated">LockRequest</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="db36a6985ae81e7f06f9b77a678b760e42fb6c81" translate="yes" xml:space="preserve">
          <source>Log base 2 (round down) of natural numbers. &lt;code&gt;Log 0&lt;/code&gt; is undefined (i.e., it cannot be reduced).</source>
          <target state="translated">자연수의 밑수 2 (내림차순)입니다. &lt;code&gt;Log 0&lt;/code&gt; 은 정의되어 있지 않습니다 (즉, 줄일 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="705364a478cdab0540a4c25854746a42ccf2183f" translate="yes" xml:space="preserve">
          <source>Log events as text to standard output, instead of to the &lt;code&gt;.eventlog&lt;/code&gt; file. The ⟨flags⟩ are the same as for &lt;code&gt;-l&lt;/code&gt;, with the additional option &lt;code&gt;t&lt;/code&gt; which indicates that the each event printed should be preceded by a timestamp value (in the binary &lt;code&gt;.eventlog&lt;/code&gt; file, all events are automatically associated with a timestamp).</source>
          <target state="translated">이벤트를 &lt;code&gt;.eventlog&lt;/code&gt; 파일 대신 표준 출력에 텍스트로 기록 하십시오. ⟨flags⟩는 &lt;code&gt;-l&lt;/code&gt; 과 동일하며 추가 옵션 &lt;code&gt;t&lt;/code&gt; 는 인쇄 된 각 이벤트 앞에 타임 스탬프 값이 와야 함을 나타냅니다 (이진 &lt;code&gt;.eventlog&lt;/code&gt; 파일에서 모든 이벤트는 자동으로 타임 스탬프와 연결됨 ).</target>
        </trans-unit>
        <trans-unit id="8c0b83ca797348a57e601331a800396f17173e34" translate="yes" xml:space="preserve">
          <source>Log events in binary format. Without any ⟨flags⟩ specified, this logs a default set of events, suitable for use with tools like ThreadScope.</source>
          <target state="translated">이진 형식으로 이벤트를 기록합니다. &quot;플래그&quot;를 지정하지 않으면 ThreadScope와 같은 도구와 함께 사용하기에 적합한 기본 이벤트 세트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="f61cb07b41e23ab1a79f15c05c0f8ba5b477ab22" translate="yes" xml:space="preserve">
          <source>Logarithmic-time access to any element with &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt; 를 사용하여 모든 요소에 로그 타임 액세스 , &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4382c3d779a065ce766f6771a0eda14473b0c8a" translate="yes" xml:space="preserve">
          <source>Logarithmic-time concatenation with &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 와의 로그 시간 연결</target>
        </trans-unit>
        <trans-unit id="c70a3bed95e2afdacbd2edd9f3abf4bff06b5635" translate="yes" xml:space="preserve">
          <source>Logarithmic-time splitting with &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">와 대수 시간 분할 &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cebebf8637724ae58cb90aacf5d8022fb2074f2" translate="yes" xml:space="preserve">
          <source>Look at the Core syntax!</source>
          <target state="translated">핵심 구문을보십시오!</target>
        </trans-unit>
        <trans-unit id="4f44d0f99b2e9f9e75bd7d13f005f42ba7ac90d3" translate="yes" xml:space="preserve">
          <source>Look at the first three elements of a sequence</source>
          <target state="translated">시퀀스의 처음 세 요소를보십시오</target>
        </trans-unit>
        <trans-unit id="036e3fb15ef00e480fa4d3acf7a733a4ca5f5561" translate="yes" xml:space="preserve">
          <source>Look for the exact match on the name in the built-in command list.</source>
          <target state="translated">내장 명령 목록에서 이름과 정확히 일치하는지 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1c5a3aaf89cbcab1e2d9dd0a759cbcb475301525" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">인터페이스 파일에서 함수를 찾은 다음 pragma의 세 번째 필드를 찾으십시오. 이 말을해야 &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; . ⟨string⟩은 함수 인수의 엄격 성을 제공합니다 . 엄격 표기법에 대한 설명은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;GHC 주석&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a08e53663e845cc46457faaa8a00f1851876f2c" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">인터페이스 파일에서 함수를 찾은 다음 pragma에서 세 번째 필드를 찾습니다. &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; 되어야합니다 . ⟨string⟩은 함수 인수의 엄격함을 제공합니다 : &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;GHC 주석&lt;/a&gt; 참조 . 엄격 성 표기법에 대한 설명은 을 .</target>
        </trans-unit>
        <trans-unit id="646113c2b824e740bba103f465367c553a9eb4ec" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database, and fail if it's not defined.</source>
          <target state="translated">terminfo 데이터베이스에서 부울 기능을 찾고 정의되지 않은 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4c0a18679ef62e4477ab6e7f74f367ea337ce4c" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 부울 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="7a72d8f66e8e9faaac46b9deb897bfc7808a27e2" translate="yes" xml:space="preserve">
          <source>Look up a constructor by its representation</source>
          <target state="translated">표현으로 생성자를 조회</target>
        </trans-unit>
        <trans-unit id="c01e8f2c42ad48d0b20e9f727f7dd206fb60685a" translate="yes" xml:space="preserve">
          <source>Look up a numeric capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 숫자 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="586b4cdd798272f8e1ea61b1bc18f4217842421c" translate="yes" xml:space="preserve">
          <source>Look up a string capability in the terminfo database. NOTE: This function is deprecated; use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">terminfo 데이터베이스에서 문자열 기능을 찾으십시오. 참고 :이 기능은 더 이상 사용되지 않습니다. 사용 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 을 대신.</target>
        </trans-unit>
        <trans-unit id="a9c5ab2d2d0139456f33ef943c0b402c0ecc56ca" translate="yes" xml:space="preserve">
          <source>Look up an output capability in the terminfo database.</source>
          <target state="translated">terminfo 데이터베이스에서 출력 기능을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9021c22f55a1940644c0487372237fc2b4baba0e" translate="yes" xml:space="preserve">
          <source>Look up an output capability which takes a fixed number of parameters (for example, &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt;).</source>
          <target state="translated">고정 된 수의 매개 변수 (예 : &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt; )를 사용 하는 출력 기능을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="f90efbcd7f1eeff6426b782004bd5ca5f919386e" translate="yes" xml:space="preserve">
          <source>Look up the control sequence for a given function sequence. For example, &lt;code&gt;functionKey 12&lt;/code&gt; retrieves the &lt;code&gt;kf12&lt;/code&gt; capability.</source>
          <target state="translated">주어진 기능 순서에 대한 제어 순서를 찾으십시오. 예를 들어, &lt;code&gt;functionKey 12&lt;/code&gt; 는 &lt;code&gt;kf12&lt;/code&gt; 기능을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="fee394d0e5a9ad0f8eab2e63dc20d9771d2d9b1c" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (type namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">현재 스플 라이스 범위의 (유형 네임 스페이스)에서 지정된 이름을 찾습니다. 자세한 내용은 &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1a8bb741760af7e3cd92aaa2b183fc9d4090ffa" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (value namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">현재 스플 라이스 범위의 (값 네임 스페이스)에서 지정된 이름을 찾습니다. 자세한 내용은 &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c27f2b60d886938ddc087b401729fa285ab4f28" translate="yes" xml:space="preserve">
          <source>Look up the named Unicode encoding. May fail with</source>
          <target state="translated">명명 된 유니 코드 인코딩을 찾습니다. 실패 할 수있다</target>
        </trans-unit>
        <trans-unit id="ba28f2554c741d83cd517f5e544d7d36306b57bc" translate="yes" xml:space="preserve">
          <source>Look-ahead: returns the part of the input that is left, without consuming it.</source>
          <target state="translated">Look-ahead : 남은 입력 부분을 소비하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5eb4c34799d13148c8206bca4c92597220f71e0b" translate="yes" xml:space="preserve">
          <source>Looks up a &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; by its &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">업 외모 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 의에 의해 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="b233a4c41641797d29c66ebedda9a193a0f05643" translate="yes" xml:space="preserve">
          <source>Lookup a constructor via a string</source>
          <target state="translated">문자열을 통해 생성자 조회</target>
        </trans-unit>
        <trans-unit id="9b088da5659869d545bfc9a0cf4258116c580743" translate="yes" xml:space="preserve">
          <source>LossOfPrecision</source>
          <target state="translated">LossOfPrecision</target>
        </trans-unit>
        <trans-unit id="853c95f571d7fa18c42a8e831393f2dd7e6ab65b" translate="yes" xml:space="preserve">
          <source>Low level CString conversions</source>
          <target state="translated">저수준 CString 변환</target>
        </trans-unit>
        <trans-unit id="9a62bf48cdec4e2fa80fc92d8d939e62810d8f8d" translate="yes" xml:space="preserve">
          <source>Low level conversions</source>
          <target state="translated">저수준 전환</target>
        </trans-unit>
        <trans-unit id="e5145ff9d1cf255f56081e2cfd62251c784c3336" translate="yes" xml:space="preserve">
          <source>Low level execution</source>
          <target state="translated">저수준 실행</target>
        </trans-unit>
        <trans-unit id="163304e093070531fe3b7fc36d57bfbdbc31b649" translate="yes" xml:space="preserve">
          <source>Low level imperative construction</source>
          <target state="translated">저수준 명령 구조</target>
        </trans-unit>
        <trans-unit id="50d7d6709a31a0dba951b8a2031b80d349c3b9d0" translate="yes" xml:space="preserve">
          <source>Low level interaction with CStrings</source>
          <target state="translated">CString과의 낮은 수준의 상호 작용</target>
        </trans-unit>
        <trans-unit id="6177301b8c0f30b2a86ceb3d0093fdce68f18734" translate="yes" xml:space="preserve">
          <source>Low level operations</source>
          <target state="translated">저수준 운영</target>
        </trans-unit>
        <trans-unit id="972a48160fb1f24ef39460baab7e378aa636e944" translate="yes" xml:space="preserve">
          <source>Low word of signed integer multiply.</source>
          <target state="translated">부호있는 정수의 하위 단어 곱하기.</target>
        </trans-unit>
        <trans-unit id="0cabfc67ff1de7a21583a2681ad3451d8a86cf31" translate="yes" xml:space="preserve">
          <source>Low-level action that performs the real close.</source>
          <target state="translated">실제 근접을 수행하는 저수준 작업.</target>
        </trans-unit>
        <trans-unit id="0b24e544fe7febd646c007e1db09a744758b8a8c" translate="yes" xml:space="preserve">
          <source>Low-level capabilities</source>
          <target state="translated">저수준 기능</target>
        </trans-unit>
        <trans-unit id="f7ce8d6baf61dc38e2ccf714c9bc7f73b9b6975e" translate="yes" xml:space="preserve">
          <source>Low-level creation of the ParsecT type. You really shouldn't have to do this.</source>
          <target state="translated">ParsecT 유형의 저수준 작성. 당신은 정말로 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ee648a6dd68992ea5cde1cd8d86b7c63d4484d6" translate="yes" xml:space="preserve">
          <source>Low-level manipulation</source>
          <target state="translated">저수준 조작</target>
        </trans-unit>
        <trans-unit id="9a08a2849208613a25ed31a1dac45b5fb6adb67f" translate="yes" xml:space="preserve">
          <source>Low-level operations</source>
          <target state="translated">저수준 작업</target>
        </trans-unit>
        <trans-unit id="13fab495e207628ea2444c309679bf776f4535b0" translate="yes" xml:space="preserve">
          <source>Low-level support for text I/O.</source>
          <target state="translated">텍스트 I / O에 대한 저수준 지원.</target>
        </trans-unit>
        <trans-unit id="f00047587dbdef15842bce850c4a2657569cb360" translate="yes" xml:space="preserve">
          <source>Low-level unpacking of the ParsecT type. To run your parser, please look to runPT, runP, runParserT, runParser and other such functions.</source>
          <target state="translated">ParsecT 유형의 저수준 포장 풀기. 파서를 실행하려면 runPT, runP, runParserT, runParser 및 기타 기능을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bf0c3ee8ad72ff8c9d2eb19ea3532abdb2e4b477" translate="yes" xml:space="preserve">
          <source>Lowercase pattern syntax functions</source>
          <target state="translated">소문자 패턴 구문 함수</target>
        </trans-unit>
        <trans-unit id="a6b810d16a3b6d530ef202b4a2d4f83a9f2052b1" translate="yes" xml:space="preserve">
          <source>LowercaseLetter</source>
          <target state="translated">LowercaseLetter</target>
        </trans-unit>
        <trans-unit id="3f339b0acbc3595803d9353e1c9001e104dfb4d7" translate="yes" xml:space="preserve">
          <source>Lt: Letter, Titlecase</source>
          <target state="translated">Lt : 편지, 타이틀 케이스</target>
        </trans-unit>
        <trans-unit id="fae8b46afcb632cf202e5b21df13474f2135a227" translate="yes" xml:space="preserve">
          <source>Lu: Letter, Uppercase</source>
          <target state="translated">루 : 편지, 대문자</target>
        </trans-unit>
        <trans-unit id="f6d00f67258bac7b9cebb726f8da4dc1bfbef425" translate="yes" xml:space="preserve">
          <source>M1</source>
          <target state="translated">M1</target>
        </trans-unit>
        <trans-unit id="b215a5a119a163d59cea8f190c2384c43d8ef927" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL LEFT WHITE SQUARE BRACKET</source>
          <target state="translated">수학적 왼쪽 흰색 사각형 브래킷</target>
        </trans-unit>
        <trans-unit id="3040721941e3243f84460b3f75c97496f9d468d1" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL RIGHT WHITE SQUARE BRACKET</source>
          <target state="translated">MATHEMATICAL RIGHT WHITE 스퀘어 브라켓</target>
        </trans-unit>
        <trans-unit id="b4d743ca88772a1217c91cba52116bdb88ef5d73" translate="yes" xml:space="preserve">
          <source>MArray</source>
          <target state="translated">MArray</target>
        </trans-unit>
        <trans-unit id="4b3e60b5afe51211e63fc50f1522b81c9ed52c4b" translate="yes" xml:space="preserve">
          <source>MBlock size</source>
          <target state="translated">MBlock 크기</target>
        </trans-unit>
        <trans-unit id="66d7b21255c88198fbbcee4794e30cfb5de722f2" translate="yes" xml:space="preserve">
          <source>MOUSEINPUT</source>
          <target state="translated">MOUSEINPUT</target>
        </trans-unit>
        <trans-unit id="2dafde4ace7cf035bd8fac9346bb5f75c97c5928" translate="yes" xml:space="preserve">
          <source>MVar</source>
          <target state="translated">MVar</target>
        </trans-unit>
        <trans-unit id="fb09978b40c384ebd545f0a9a7fcdec83351ee76" translate="yes" xml:space="preserve">
          <source>MVar#</source>
          <target state="translated">MVar#</target>
        </trans-unit>
        <trans-unit id="46d2f54777058d8f461ec0e1349a0d4dfc5ea0e9" translate="yes" xml:space="preserve">
          <source>MVars</source>
          <target state="translated">MVars</target>
        </trans-unit>
        <trans-unit id="ff6912e2f0ea1f0a272acab877e81da5e3f73b0e" translate="yes" xml:space="preserve">
          <source>Magenta</source>
          <target state="translated">Magenta</target>
        </trans-unit>
        <trans-unit id="6c6f4a44e9e83aafaa5023b2c1c354521ec83aa4" translate="yes" xml:space="preserve">
          <source>MagicHash</source>
          <target state="translated">MagicHash</target>
        </trans-unit>
        <trans-unit id="597dbcc3afd445131f986826cdf6caa30f1f99dd" translate="yes" xml:space="preserve">
          <source>Maintainer</source>
          <target state="translated">Maintainer</target>
        </trans-unit>
        <trans-unit id="9ed930864a951ac93cbc26664a2297c407da9c9e" translate="yes" xml:space="preserve">
          <source>Maintaining variable bindings, or other shared environment.</source>
          <target state="translated">변수 바인딩 또는 기타 공유 환경 유지</target>
        </trans-unit>
        <trans-unit id="a8a516b79965afb8ee743e8779110117c528ae43" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, stop GHC eta-expanding through a case expression, which is good for performance, but bad if you are using &lt;code&gt;seq&lt;/code&gt; on partial applications.</source>
          <target state="translated">바닥 처리에 대해 GHC를 더 정확하게 만듭니다 (그러나 &lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; 참조&lt;/a&gt; ). 특히 케이스 표현식을 통해 GHC eta-expanding을 중지하십시오. 이는 성능에는 좋지만, 부분 애플리케이션에서 &lt;code&gt;seq&lt;/code&gt; 를 사용하는 경우에는 나쁩니다 .</target>
        </trans-unit>
        <trans-unit id="d7420d41204c439a4f517471040fab645169f4e5" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, GHC will not eta-expand through a case expression.</source>
          <target state="translated">바닥 처리에 대해 GHC를 더 정확하게 만듭니다 (그러나 &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; 참조&lt;/a&gt; ). 특히, GHC는 사례 발현을 통해 에타-팽창되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="2fdef1410de7bb1f110ecf15d30ac3c953aad457" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">문자열 을 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 토큰 유형 의 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 인스턴스로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2d2d3352f83dfd1c05932c3401d3d788e9213d3c" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">Strings 를 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 토큰 유형 의 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 인스턴스로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c8574286f1db7f5674cdca2f0f347f3d37fbe842" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가비지 수집 시 실행할 두 번째 인수를 종료 자로 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3c9caff43c15f5f5ce07d7d17ceba770b1aed418" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 마지막 인수로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터 만들기</target>
        </trans-unit>
        <trans-unit id="59b220e362957ec29f398b074092e745f5e98507" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="43736e995d33c8137a44869b4d0d5452ba4e560a" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 종료 자로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bb1e49e8f1341ae8024c59aa4dfd0a0ff98889ea" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; from an existing file descriptor. Fails if the FD refers to a directory. If the FD refers to a file, &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; locks the file according to the Haskell 2010 single writer/multiple reader locking semantics (this is why we need the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; argument too).</source>
          <target state="translated">기존 파일 설명자에서 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 를 만듭니다 . FD가 디렉토리를 참조하면 실패합니다. FD가 파일을 참조하는 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; 는 Haskell 2010 단일 작성기 / 다중 판독기 잠금 시맨틱에 따라 파일을 잠급니다 (이 때문에 &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 인수도 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="c7f75d66c23f2c823051ed78b549c0dc321c99c1" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 가 가비지 수집 될 때 실행되는 마지막 인수로 두 번째 인수를 사용하여 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="90c73ab748e0e00da22596dbc5fd000f5f781ad2" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">두 번째 인수를 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 가비지 수집 시 실행할 최종 자로 사용하여 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 포인터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="68976173fa646f3a0550c955065f1d56dd3d0c9c" translate="yes" xml:space="preserve">
          <source>Make a StablePtr that can be passed to the C function &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. The RTS wants a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt;, but a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; can only refer to lifted types, so we have to cheat by coercing.</source>
          <target state="translated">C 함수 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 전달할 수있는 StablePtr을 작성하십시오 . RTS는 기본 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 을 원 하지만 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; 은 해제 된 유형 만 참조 할 수 있으므로 강제로 속임수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="340793623e1a085d7b8da534d1c4b5daea514359" translate="yes" xml:space="preserve">
          <source>Make a mutable array immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 배열을 변경 불가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c7e012d6c09327d0dafcfeae27a661402dd25db0" translate="yes" xml:space="preserve">
          <source>Make a mutable array of arrays immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 배열의 배열을 변경할 수 없게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="698be6d083fa7f3ca40015a52bb017297e592080" translate="yes" xml:space="preserve">
          <source>Make a mutable byte array immutable, without copying.</source>
          <target state="translated">복사하지 않고 변경 가능한 바이트 배열을 변경할 수 없도록 만듭니다.</target>
        </trans-unit>
        <trans-unit id="46fdb0fb8e4b555aaff57055206c3612f29ab2c3" translate="yes" xml:space="preserve">
          <source>Make a path absolute, normalize the path, and remove as many indirections from it as possible. Any trailing path separators are discarded via &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt;. Additionally, on Windows the letter case of the path is canonicalized.</source>
          <target state="translated">절대 경로를 만들고 경로를 정규화하고 가능한 많은 간접 경로를 제거하십시오. 후행 경로 구분 기호는 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt; 를 통해 삭제됩니다 . 또한 Windows에서는 경로의 대소 문자가 정식화됩니다.</target>
        </trans-unit>
        <trans-unit id="186ec7bfc50eae0a8d365be8aba8bea7326758f0" translate="yes" xml:space="preserve">
          <source>Make a reference to a local value that we can send remotely. This reference will keep the value that it refers to alive until &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">원격으로 보낼 수있는 로컬 값을 참조하십시오. 이 참조는 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; 가 호출 될 때까지 참조하는 값을 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="3c87f88ba73344e1ab783a73a9a5979fecf885d2" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 리턴 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 디렉토리의 경로이며 6 개의 임의 문자로 채워집니다. 인수는 작성할 임시 디렉토리의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="8d3ca167e4c389a68d7893e4900b4c3fb3ba06a9" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 6 개의 임의 문자로 채워진 생성 된 디렉터리의 경로입니다. 인수는 생성 할 임시 디렉토리 파일 경로의 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="81daa0d04fc3934a4c048011fb03208252f865cf" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">고유 한 디렉토리를 만드십시오. 리턴 된 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 디렉토리의 경로이며 6 개의 임의 문자로 채워집니다. 인수는 작성할 임시 디렉토리의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="6a7af8c778c02a1f594bc3983b00324c16ab69b7" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 임의의 6 자로 채워집니다. 인수는 작성할 임시 파일의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="330d0dcda662cdafbb50eaf0cfa0b95ff8c0f42d" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 6 개의 임의 문자로 채워집니다. 인수는 생성 할 임시 파일의 파일 경로에 대한 원하는 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="55c11d94c0f07317aebbc90457dbda2e57127b10" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 리턴 된 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 는 작성된 파일의 (상대적으로) 경로이며 임의의 6 자로 채워집니다. 인수는 작성할 임시 파일의 파일 경로 접 두부입니다.</target>
        </trans-unit>
        <trans-unit id="f72f7ad8e05097abb6ee289f5eba19d0e1965f5c" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">지정된 접두사와 접미사를 사용하여 고유 한 파일 이름을 만들고 읽고 쓰기 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 생성 된 파일의 (상대적) 경로이며 접두사와 접미사 사이에 6 개의 임의 문자가 들어 있습니다. 첫 번째 인수는 작성할 임시 파일의 파일 경로 접 두부입니다. 두 번째 인수는 작성할 임시 파일의 접미 부입니다.</target>
        </trans-unit>
        <trans-unit id="95866426633d8275aa8fda94a7e85fdc02e90eb7" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">주어진 접두사와 접미사로 고유 한 파일 이름을 만들고 읽기 / 쓰기를 위해 엽니 다. 반환 된 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 는 접두사와 접미사 사이에 6 개의 임의 문자를 포함하는 생성 된 파일의 (상대적) 경로입니다. 첫 번째 인수는 생성 할 임시 파일의 파일 경로에 대한 원하는 접두사입니다. 두 번째 인수는 만들 임시 파일의 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="3855d0f70cdfe996ae50f55037d364c1d1456c5b" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393f21690a4ea611c6c45f302e4ee432d74df383" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c15a521855fa1db7d583391896bbe67487efc38" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc78aad57ab0b135f7ad0c2ee2f1ea5372a73a" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86ec4e16e20a04abfbb1ac99cdbce02e8ced1057" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77491851c6d1ffca83dc5af796a06989b259ab9" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 약한 포인터를 만듭니다 . 스레드가 여전히 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 군 (예 : &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ) 을 수신하도록 허용하면서 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 에 대한 참조를 유지하려는 경우이를 수행하는 것이 중요 할 수 있습니다 . 일반 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 참조를 보유하면 참조가 언제든지 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 의 대상으로 사용될 수 있으므로 스레드를 차단 해제 할 수 있기 때문에 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 예외 가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f678ce0a5f94456a91a790fc3be2c2ec6925020" translate="yes" xml:space="preserve">
          <source>Make an immutable array mutable, without copying.</source>
          <target state="translated">복사하지 않고 불변 배열을 변경 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="df39c3ecba9f1a1d5927f8873184709183484ed4" translate="yes" xml:space="preserve">
          <source>Make bindings in the current module strict by default.</source>
          <target state="translated">기본적으로 현재 모듈의 바인딩을 엄격하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b462570effd4237ee90c797f361ccb9ef392f0ca" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;</source>
          <target state="translated">접미사가 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 인 파일을 접미사 가있는 인터페이스 파일에 의존한다고 선언하는 종속성을 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9d645523fe749f3d314ba22eb6324344c7aca9" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;, or (for &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports) on &lt;code&gt;.hi-boot&lt;/code&gt;. Multiple &lt;code&gt;-dep-suffix&lt;/code&gt; flags are permitted. For example, &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; will make dependencies for &lt;code&gt;.hs&lt;/code&gt; on &lt;code&gt;.hi&lt;/code&gt;, &lt;code&gt;.a_hs&lt;/code&gt; on &lt;code&gt;.a_hi&lt;/code&gt;, and &lt;code&gt;.b_hs&lt;/code&gt; on &lt;code&gt;.b_hi&lt;/code&gt;. Note that you must provide at least one suffix; if you do not want a suffix then pass &lt;code&gt;-dep-suffix ''&lt;/code&gt;.</source>
          <target state="translated">만들기 종속성을 선언하는 접미사를 가진 파일 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 접미사 인터페이스 파일에 의존 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt; , 또는 (위해 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 수입)에 &lt;code&gt;.hi-boot&lt;/code&gt; . 여러 개의 &lt;code&gt;-dep-suffix&lt;/code&gt; 플래그가 허용됩니다. 예를 들어, &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; 는 &lt;code&gt;.hs&lt;/code&gt; on &lt;code&gt;.hi&lt;/code&gt; , &lt;code&gt;.a_hs&lt;/code&gt; on &lt;code&gt;.a_hi&lt;/code&gt; 및 &lt;code&gt;.b_hs&lt;/code&gt; on &lt;code&gt;.b_hi&lt;/code&gt; 에 대한 종속성 을 작성 합니다. 최소한 하나 이상의 접미사를 제공해야합니다. 접미사를 원하지 않으면 &lt;code&gt;-dep-suffix ''&lt;/code&gt; 를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f58245b56849264d71b5f006aa40914e92e5165" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict</source>
          <target state="translated">사전을 엄격하게 만들기</target>
        </trans-unit>
        <trans-unit id="f7e4637506fdb1c126cf33d58aefa19e41c7d250" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict.</source>
          <target state="translated">사전을 엄격하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="5455661e420f1ccaf72cf9dabbbfecf771d7db4a" translate="yes" xml:space="preserve">
          <source>Make dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">사전 값 표현을 최적화 프로그램에 저렴하게 보이게하십시오.</target>
        </trans-unit>
        <trans-unit id="6f85a3e8f6df876856512758475047874462d99e" translate="yes" xml:space="preserve">
          <source>Make fields of data types defined in the current module strict by default.</source>
          <target state="translated">현재 모듈에 정의 된 데이터 유형의 필드를 기본적으로 엄격하게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="af0e48df1414b6d5a7855574141f6461c5ce4805" translate="yes" xml:space="preserve">
          <source>Make suggestions for mis-spelled names.</source>
          <target state="translated">철자가 틀린 이름을 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="88ce76b97dc5f41df8b9eb8175635106d378b209" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="d84ebfc6fbaa58496dbe73b158b5610e0f005524" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="156fd7ebd73ad9d7d9ba6f146870be0be3263cef" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">let-floating ( &lt;code&gt;-fno-full-laziness&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 거나 unsafePerformIO에 대한 호출 이 람다 외부 로 떠오를 수 없는지 확인하십시오. 예를 들어 &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; 라고하면 &lt;code&gt;f&lt;/code&gt; 에 대한 모든 호출간에 하나의 참조 셀만 공유 될 수 있습니다 . 나은 것이다 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 이제 람다 외부 부유 할 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="4240c3ab8260bb583d13050ed2064bbaae7bc43b" translate="yes" xml:space="preserve">
          <source>Make the interface loader be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">인터페이스 로더 가 최신 상태에 대해 &lt;em&gt;실제&lt;/em&gt; 대화가되게하십시오.</target>
        </trans-unit>
        <trans-unit id="4358699704291b8174b75e1e492414b400dba246" translate="yes" xml:space="preserve">
          <source>Make the pattern match exhaustiveness checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">패턴 일치 철저 검사기 는 그것이 무엇인지에 대해 &lt;em&gt;진정한&lt;/em&gt; 대화가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="d42a1e2a4e6f039639430d0f8ec96b5efe794a51" translate="yes" xml:space="preserve">
          <source>Make the renamer be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">이름 바꾸기가 될 수 있도록 &lt;em&gt;실제&lt;/em&gt; 는 최대 무엇인지에 대해 수다.</target>
        </trans-unit>
        <trans-unit id="8cd12a9927ea510906e14322831e59cfe0a4baca" translate="yes" xml:space="preserve">
          <source>Make the type checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">타입 체커 는 그것이 무엇인지에 대해 &lt;em&gt;진정한&lt;/em&gt; 대화가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="15d9abd622590033f2c411d33953dd776c5be50c" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 개체에 대한 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 첫 번째 인수로 전달 된 객체는 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 에 의해 평가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c12968a0552ecdcf1b9de9b4f5c5bede7e5bbb53" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">임의의 개체에 대한 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 첫 번째 인수로 전달 된 객체는 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 에 의해 평가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aa32c2b4fd707872dac37cc6dbc8a7e855f28d02" translate="yes" xml:space="preserve">
          <source>Makes a binary Handle. This is for historical reasons; it should probably be a text Handle with the default encoding and newline translation instead.</source>
          <target state="translated">이진 핸들을 만듭니다. 이것은 역사적인 이유로 인한 것입니다. 대신 기본 인코딩 및 줄 바꿈 변환이 포함 된 텍스트 핸들이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e61217ddb45f4a69f77fed47cefb695ba63354" translate="yes" xml:space="preserve">
          <source>Makes a constructor for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 의 생성자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="675f8bacbe562ad639f450df630ba3e1d4142613" translate="yes" xml:space="preserve">
          <source>Makes a pointer to a field struct. It will have the type &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt;.</source>
          <target state="translated">필드 구조체에 대한 포인터를 만듭니다. 유형은 &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15d722c20f3a7b347acb5b13726b5fa9b1a3a525" translate="yes" xml:space="preserve">
          <source>Makes a specific warning into a fatal error. The warning will be enabled if it hasn&amp;rsquo;t been enabled yet. Can be reversed with &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">치명적인 오류로 특정 경고를 표시합니다. 아직 활성화되지 않은 경우 경고가 활성화됩니다. &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b11cc1ed06b4ae510e6c368934b3332b8443ad9c" translate="yes" xml:space="preserve">
          <source>Makes any warning into a fatal error. Useful so that you don&amp;rsquo;t miss warnings when doing batch compilation. To reverse &lt;code&gt;-Werror&lt;/code&gt; and stop treating any warnings as errors use &lt;code&gt;-Wwarn&lt;/code&gt;, or use &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; to stop treating specific warnings as errors.</source>
          <target state="translated">치명적인 오류로 경고합니다. 배치 컴파일을 수행 할 때 경고를 놓치지 않도록 유용합니다. &lt;code&gt;-Werror&lt;/code&gt; 를 되돌리고 오류로 경고 처리를 중지하려면 &lt;code&gt;-Wwarn&lt;/code&gt; 을 사용하거나 &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 를 사용하여 특정 경고를 오류로 처리하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="bbf1ed151ae759b693edba02d868a0ae08a8295e" translate="yes" xml:space="preserve">
          <source>Makes the second handle a duplicate of the first handle. The second handle will be closed first, if it is not already.</source>
          <target state="translated">두 번째 핸들을 첫 번째 핸들의 복제본으로 만듭니다. 두 번째 핸들이 아직 닫히면 먼저 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="610ca9a4f461051b57571e94ee46024ad1945482" translate="yes" xml:space="preserve">
          <source>Making functors whose elements are notionally in the reverse order from the original functor.</source>
          <target state="translated">원래 functor와 개념적으로 역순으로 요소가있는 functors 만들기.</target>
        </trans-unit>
        <trans-unit id="de10c11c39a04c2dd93935591757ad821f0de619" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스로 functors 만들기</target>
        </trans-unit>
        <trans-unit id="289b3ce3f004eadb698cbe23952c8692f75647d6" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">역순으로 작업을 수행 하는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 인스턴스로 펑터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="155fd1571bb064a261bef3cb9235ad72ee317621" translate="yes" xml:space="preserve">
          <source>Malloc some data and return a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; to it</source>
          <target state="translated">Malloc 일부 데이터 및 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; 을 반환</target>
        </trans-unit>
        <trans-unit id="357e8ecf448ec27f6c58902a75153131236e9618" translate="yes" xml:space="preserve">
          <source>Manage separate memory pools for each node.</source>
          <target state="translated">각 노드에 대해 별도의 메모리 풀을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="27a837f8eed8146ea6300d174b2ba753bef518d3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">조작 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 사용 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 작업을. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 과 동일한 속도로 실행될 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8d02698e3a7db40c93071ad0130d603170bdbf3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f6f1aebfb4c2d76356eff64760ef8d083e1ea9b" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;em&gt;lazy &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 과 동일한 속도로 실행될 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="0938573170c5ad64ab547628da8f4334a36723ce" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 연산을 사용하여 &lt;em&gt;게으른 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 조작 합니다. 모든 문자는 8 비트로 잘립니다. 이러한 함수는 &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 에 해당하는 것과 동일한 속도로 실행될 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21b2945c3b95e9ba030912e565f7997d2afceb6a" translate="yes" xml:space="preserve">
          <source>Many codecs are not stateful, and in these case the state can be represented as &lt;code&gt;()&lt;/code&gt;. Other codecs maintain a state. For example, UTF-16 recognises a BOM (byte-order-mark) character at the beginning of the input, and remembers thereafter whether to use big-endian or little-endian mode. In this case, the state of the codec would include two pieces of information: whether we are at the beginning of the stream (the BOM only occurs at the beginning), and if not, whether to use the big or little-endian encoding.</source>
          <target state="translated">많은 코덱은 상태 저장이 아니며이 경우 상태는 &lt;code&gt;()&lt;/code&gt; 로 표현 될 수 있습니다 . 다른 코덱은 상태를 유지합니다. 예를 들어 UTF-16은 입력 시작시 BOM (바이트 순서 표시) 문자를 인식 한 후 빅 엔디안 모드 또는 리틀 엔디안 모드를 사용할지 기억합니다. 이 경우 코덱 상태에는 두 가지 정보가 포함됩니다. 즉, 스트림의 시작 위치에 있는지 (BOM은 시작 부분에만 발생), 그렇지 않은 경우에는 빅 엔디안 또는 리틀 엔디안 인코딩을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="24d0ab19e4e99147773dbcbe9263cdf0c945a575" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List의&lt;/a&gt; 함수와 이름이 같습니다 . 거의 모든 경우에 이러한 기능은 유사하게 작동합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 그 동일하게 시퀀스를 필터링 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 목록을 필터링합니다. 유일한 주요 예외는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 함수입니다.이 함수 는 &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; 의 이름이 아니라 &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap의&lt;/a&gt; 해당 이름에 따른 함수를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c62b5fa473677017f2721ca5795d98e992c22e65" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; 또는 &lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List의&lt;/a&gt; 함수와 이름이 같습니다 . 거의 모든 경우에 이러한 기능은 유사하게 작동합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 와 똑같은 방식으로 시퀀스를 필터링합니다 . 필터 는 목록을 필터링합니다. 유일한 주요 예외는 &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; 의 이름이 아닌 &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap의&lt;/a&gt; 해당 이름의 함수를 기반으로 하는 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="a54ffbaf5c6091b870718ed3779391643593140a" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">많은 작업이 최악의 경우 O (min (n, W))의 복잡성을 갖습니다. 이는 최대 &lt;em&gt;W를&lt;/em&gt; 가진 요소 수에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수로 작업이 선형화 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="98a01da62d47f087f540e76f8d5b26b5e49b62ce" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">대부분의 작업은 최악의 경우 복잡성이 O (min (n, W))입니다. 이는 연산이 최대 &lt;em&gt;W&lt;/em&gt; 인 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 또는 64) 의 비트 수인 요소 수에서 선형이 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="2b7b80f10f3a81cda5d3d90fed79ebb948d0265b" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;'\r\n'&lt;/code&gt; into &lt;code&gt;'\n'&lt;/code&gt; on input, and &lt;code&gt;'\n'&lt;/code&gt; to the native newline represetnation on output. This mode can be used on any platform, and works with text files using any newline convention. The downside is that &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; might yield a different file.</source>
          <target state="translated">지도 &lt;code&gt;'\r\n'&lt;/code&gt; 에 &lt;code&gt;'\n'&lt;/code&gt; 입력에, 그리고 &lt;code&gt;'\n'&lt;/code&gt; 출력의 기본 개행 represetnation에. 이 모드는 모든 플랫폼에서 사용할 수 있으며 모든 줄 바꿈 규칙을 사용하여 텍스트 파일과 함께 작동합니다. 단점은 &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; 이 다른 파일을 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d55454f009aa8f95f75c772db0fb5ae0e9a9272" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">지도 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d73f39524fe5ef1af56ec8e22806ecc515086be" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">지도 &lt;code&gt;m2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9983700cca6f292aa903742f89b52d541c8d933e" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; - safe 값에 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="18e38d5e5d89b044de0e37bb9b26db6369ce574d" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0766fa419be24fb2dc55e7497743d52826668e62" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="15035b59f86fdfce06c5503b47c04b11e811e80d" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="b46e7ebb5140a1447b3c89113a3d9ae22bb0b79b" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="6903ae5c580a3f2ab80be5d8534af3c46567f965" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 에 함수를 매핑 하고 결과를 연결</target>
        </trans-unit>
        <trans-unit id="9f9558286be8174c824362eb946ace711872dbf8" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; stream.</source>
          <target state="translated">비 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 스트림에 함수를 맵핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="21fd99a4595253dffd079844b719d83735a7905f" translate="yes" xml:space="preserve">
          <source>Map a function over a list and concatenate the results.</source>
          <target state="translated">함수를 목록에 매핑하고 결과를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="9800e72be66dc6c45d2ad289e20ef1a9a51d98ad" translate="yes" xml:space="preserve">
          <source>Map a function over a stream that results in a stream and concatenate the results.</source>
          <target state="translated">스트림을 생성하는 함수를 스트림에 맵핑하고 결과를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="ad689681c3a3649d48f9aaad672101632605a134" translate="yes" xml:space="preserve">
          <source>Map a function over all the elements of a container and concatenate the resulting lists.</source>
          <target state="translated">컨테이너의 모든 요소에 함수를 맵핑하고 결과 목록을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="1a8247db8adfeefa619b1655afff9beae6787d09" translate="yes" xml:space="preserve">
          <source>Map a user interaction by modifying the base monad computation.</source>
          <target state="translated">기본 모나드 계산을 수정하여 사용자 상호 작용을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="7edbce9966aa6d05b4981154c3d88123653a0c5d" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 계산 사이를 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="712af23920428aa8ce829c6c9a926052d19c882a" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 계산 사이를 매핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="45e2cd283ebb4c611280d82cee74660fbe85bf94" translate="yes" xml:space="preserve">
          <source>Map both the return value and final state of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 반환 값과 계산의 최종 상태를 모두 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="4273e77ff1728ba48d1f840696e743d1da1ee755" translate="yes" xml:space="preserve">
          <source>Map both the return value and output of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 계산의 반환 값과 출력을 모두 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="803e1322fde156db8cc3128774fd2f8d4c99abec" translate="yes" xml:space="preserve">
          <source>Map capabilities to NUMA nodes. Capability C is mapped to NUMA node C mod N.</source>
          <target state="translated">기능을 NUMA 노드에 맵핑하십시오. 기능 C는 NUMA 노드 C mod N에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="21de922b618d81f2e317aafc9cbebc99176766bc" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="aa119e405295642a5bcf3b77b05b9cefc544c124" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="7245e811517b83cae4b9adf19d8a5924072530a7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="09e23d7bb6cd983f23a248d179ee216a8f59e394" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="2569c1d7ccbe6013b4e6c78fb8e786a9a6095e76" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt; 위에 반항적으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="a14103f7c1f26a2fcbb71bbe285a99bdcde54ff7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt; 위에 반항적으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="a8eb552837e87415b9d4df127dcd174fef924114" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt;.</source>
          <target state="translated">이상 covariantly지도 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bcbb877a60019cf521e9ab67aa98b003657bfd" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt; 에 대해 공변량으로 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="b9d6ab9d11a41a76d9162b3143fae97f6b16f455" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="3f706796547b811fccb9bd7e5484d305853862eb" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="80246f23eba01c63a2b57d2f1b0b002711c39d9f" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="a5cd585d64a0c1fc4c937dd0ee8ee4b052b09370" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="ce99df6d5a6c7da2f980fb998d55fe0e027d1fd2" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="2de75aa8ae3777dc3c106e78b70228d497cabfb4" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 에 대해 공변량으로 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="1414775fb27f647a11edd9afbabc9f1f96d002c5" translate="yes" xml:space="preserve">
          <source>Map covariantly over the first argument.</source>
          <target state="translated">첫 번째 인수에 대해 공변량으로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="d189acaf26502066081e31e150c1693816dae853" translate="yes" xml:space="preserve">
          <source>Map covariantly over the second argument.</source>
          <target state="translated">두 번째 인수에 대해 공변량으로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="a3b66d8ea2cb272c74911fcfbdc7cf4ca77953fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나 딕 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가 한 후 결과를 수집합니다. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02dfb7e92c38e4214d51e2b9595047ff1b8f9b31" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 모나 딕 동작에 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29efd3765dfabc72142232cb82d864034ee72729" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 수집하십시오. 결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d22dd22b104dd621f77d9d5650ccd532318e02da" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 무시하십시오. 결과를 무시하지 않는 버전의 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43e6de6decbbed7c2a5b1c6751631f378ba334b2" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 작업에 매핑하고 이러한 작업을 왼쪽에서 오른쪽으로 평가하고 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4417d32b4f323c831d7b4ced61e67f600e01b3fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구조의 각 요소를 조치에 맵핑하고 이러한 조치를 왼쪽에서 오른쪽으로 평가 한 후 결과를 무시하십시오. 결과를 무시하지 않는 버전의 경우 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c124d6dfa5bddefa553c4516b6211d2cf0661762" translate="yes" xml:space="preserve">
          <source>Map each element of a structure using one of two actions, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 동작 중 하나를 사용하여 구조의 각 요소를 매핑하고 이러한 동작을 왼쪽에서 오른쪽으로 평가 한 다음 결과를 무시합니다. 결과를 무시하지 않는 버전은 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e14cd9471b9b06b4f5f3069e4de360f95948a3" translate="yes" xml:space="preserve">
          <source>Map each element of the structure to a monoid, and combine the results.</source>
          <target state="translated">구조의 각 요소를 단일체에 맵핑하고 결과를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="cb44df1644994b6e9bedbd4295f2ba757e01b134" translate="yes" xml:space="preserve">
          <source>Map leap-second values to the start of the following second. The resulting &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; will always be in the range 0 to 1E9-1.</source>
          <target state="translated">윤초 값을 다음 초의 시작 부분에 매핑합니다. 결과 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; 는 항상 0에서 1E9-1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="f67b9485e617340983ccecc0a0a8ab8a5398d3f1" translate="yes" xml:space="preserve">
          <source>Map over both arguments at the same time.</source>
          <target state="translated">두 인수를 동시에 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="820bfb2b876cadb7ba21577ea1191e745febb6e2" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="042a8e608fdbf1be1815be0ba68d9d8129c0d45e" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7446b734119c67e4a15eea3901f43f333f1d45b7" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="f20f45f5901d5da69a8a8bd25afdefdf94fb0463" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하여 선택적으로 일부를 제거하십시오. 이것은 가장 강력한 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 전술이지만 다른 것들은 일반적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="27b9407877fd74e4c60e5bb3f11429e5468cc32d" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="4972444ee92a42eeb10783a738cee55cc20ccb73" translate="yes" xml:space="preserve">
          <source>Map the inner computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 내부 계산을 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="f01bd56150a44e5c1e36c99b2ce32a4952f1afda" translate="yes" xml:space="preserve">
          <source>Map the return value, final state and output of a computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 반환 값, 최종 상태 및 계산 결과를 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="611b5e106ea059979f2f1779bbc5d5819342b37e" translate="yes" xml:space="preserve">
          <source>Map the unwrapped computation using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 래핑되지 않은 계산을 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="9a3aa11de5ca9a6bdbea1dfb4fae341156bcff0a" translate="yes" xml:space="preserve">
          <source>Map type</source>
          <target state="translated">지도 유형</target>
        </trans-unit>
        <trans-unit id="1810f098d7eac5bae7e2406903ecfc11787e8374" translate="yes" xml:space="preserve">
          <source>MapCRtoLF</source>
          <target state="translated">MapCRtoLF</target>
        </trans-unit>
        <trans-unit id="28b80a5d51a036d17e03dadde928449b953d85da" translate="yes" xml:space="preserve">
          <source>MapLFtoCR</source>
          <target state="translated">MapLFtoCR</target>
        </trans-unit>
        <trans-unit id="0f7287b611e3434635c4078dcc64979ba53c31bb" translate="yes" xml:space="preserve">
          <source>MapiFlag</source>
          <target state="translated">MapiFlag</target>
        </trans-unit>
        <trans-unit id="509e216767250bbf0cec7134cc87bd8db88ff863" translate="yes" xml:space="preserve">
          <source>MapiFreeBufferType</source>
          <target state="translated">MapiFreeBufferType</target>
        </trans-unit>
        <trans-unit id="f6693d804c9943e70a4a0323060d0df51aa65dfa" translate="yes" xml:space="preserve">
          <source>MapiFuncs</source>
          <target state="translated">MapiFuncs</target>
        </trans-unit>
        <trans-unit id="cd9c46f0be135a23d65b90dc10dbdb8e6bf7bb43" translate="yes" xml:space="preserve">
          <source>MapiLoaded</source>
          <target state="translated">MapiLoaded</target>
        </trans-unit>
        <trans-unit id="fa7f40372f1e4c545567caf67dc788efc58735dc" translate="yes" xml:space="preserve">
          <source>MapiLogoffType</source>
          <target state="translated">MapiLogoffType</target>
        </trans-unit>
        <trans-unit id="36cb3aec5c1c5fe73d8e8e0fc96d8a25e6742274" translate="yes" xml:space="preserve">
          <source>MapiLogonType</source>
          <target state="translated">MapiLogonType</target>
        </trans-unit>
        <trans-unit id="7a12682bc39d4a4b9b85256454d88deeb97151f5" translate="yes" xml:space="preserve">
          <source>MapiRecipDesc</source>
          <target state="translated">MapiRecipDesc</target>
        </trans-unit>
        <trans-unit id="dd6f6d1599d7119a2a1666a29fe8913e02817cc0" translate="yes" xml:space="preserve">
          <source>MapiResolveNameType</source>
          <target state="translated">MapiResolveNameType</target>
        </trans-unit>
        <trans-unit id="e806730edd68685562cf8c1233b6d49d37ab11ba" translate="yes" xml:space="preserve">
          <source>MapiSendMailType</source>
          <target state="translated">MapiSendMailType</target>
        </trans-unit>
        <trans-unit id="09e81b0440d9e7e7c46c283e70fc598be2643acd" translate="yes" xml:space="preserve">
          <source>Mapped object, from withMappedFile</source>
          <target state="translated">withMappedFile에서 매핑 된 객체</target>
        </trans-unit>
        <trans-unit id="782e4fafad5e3beb16ef35319d6126950de58292" translate="yes" xml:space="preserve">
          <source>MappedObject</source>
          <target state="translated">MappedObject</target>
        </trans-unit>
        <trans-unit id="6f8944015d37918b217a17f41aec65c11bca6197" translate="yes" xml:space="preserve">
          <source>Mapping of C types to corresponding Haskell types.</source>
          <target state="translated">C 유형을 해당 Haskell 유형에 매핑</target>
        </trans-unit>
        <trans-unit id="bfccc2a90a967ca2c9726fa59c31448b51ea07bc" translate="yes" xml:space="preserve">
          <source>Maps an old state to a new state inside a state monad. The old state is thrown away.</source>
          <target state="translated">상태 모나드 내에서 이전 상태를 새 상태로 매핑합니다. 오래된 상태는 버려집니다.</target>
        </trans-unit>
        <trans-unit id="0a1978af85dd59fcc87cee4e7808720188940a44" translate="yes" xml:space="preserve">
          <source>Maps area into memory.</source>
          <target state="translated">영역을 메모리에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="12d3f218c041a3e94409cd521a65703707ec7d30" translate="yes" xml:space="preserve">
          <source>Maps file fully and returns ForeignPtr and length of the mapped area. The mapped file is opened read-only and shared reading.</source>
          <target state="translated">파일을 완전히 매핑하고 ForeignPtr과 매핑 된 영역의 길이를 반환합니다. 매핑 된 파일은 읽기 전용 및 공유 읽기로 열립니다.</target>
        </trans-unit>
        <trans-unit id="3936cc3f677a76a2eedb9a68dae98afcd381cc69" translate="yes" xml:space="preserve">
          <source>Mark a module as unsafe so that it can&amp;rsquo;t be imported by code compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Also enable the Safe Import extension so that a module can require a dependency to be trusted.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; 로&lt;/a&gt; 컴파일 된 코드로 가져올 수 없도록 모듈을 안전하지 않은 것으로 표시하십시오 . 또한 안전 가져 오기 확장을 활성화하여 모듈의 신뢰를 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2469915cb8350f4b45d32b9fb09eae8014a2fd7" translate="yes" xml:space="preserve">
          <source>MarkParityErrors</source>
          <target state="translated">MarkParityErrors</target>
        </trans-unit>
        <trans-unit id="cf1e479bca0990aa370eb4cace42655c1749155a" translate="yes" xml:space="preserve">
          <source>Markers let us do this: we can annotate the program to emit a marker at an appropriate point during execution and then see that in a profile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbfae789a5691468edf927d3fcc545f317911943" translate="yes" xml:space="preserve">
          <source>Marks a capability flushing its local update remembered set accumulator.</source>
          <target state="translated">로컬 업데이트 기억 세트 누산기를 플러시하는 기능을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="749ef48ee39365b34972946cb74471d0eed9c084" translate="yes" xml:space="preserve">
          <source>Marks if the datatype is actually a newtype</source>
          <target state="translated">데이터 유형이 실제로 새로운 유형인지 표시</target>
        </trans-unit>
        <trans-unit id="2e31ff5a5bf802580a8893f8699ba55f6d3ac5b7" translate="yes" xml:space="preserve">
          <source>Marks if this constructor is a record</source>
          <target state="translated">이 생성자가 레코드인지 표시</target>
        </trans-unit>
        <trans-unit id="c3400456e0dc9b11aa991afcb8dd85aa615efa2c" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a heap profile sample.</source>
          <target state="translated">힙 프로필 샘플의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dfdb9356e7d55128f5fe9e41f811cbba7086dbb4" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a time profile.</source>
          <target state="translated">시간 프로필의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="11481cc8464a72c6d603970383a2b8035b849cba" translate="yes" xml:space="preserve">
          <source>Marks the beginning of marking by the concurrent collector.</source>
          <target state="translated">동시 수집기의 표시 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c5867d7dd9a19fc447a637c38b43c98746f7ab60" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">동시 가비지 수집기의 포스트 마크 동기화 단계의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7e14a218bcc85c7d4dcb33742d978559eff47dc5" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">동시 가비지 수집기의 스윕 단계의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="be5ce64099ae9eb2d5c99a4e160328562b3336ca" translate="yes" xml:space="preserve">
          <source>Marks the creation of a Haskell thread.</source>
          <target state="translated">Haskell 스레드의 생성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06e940d86df5e1c669573ec00f380d2004c19a2e" translate="yes" xml:space="preserve">
          <source>Marks the creation of a task.</source>
          <target state="translated">작업 생성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e3821a3cd57a76c02636f3ef5d01798bb2876d2d" translate="yes" xml:space="preserve">
          <source>Marks the end of a heap profile sample.</source>
          <target state="translated">힙 프로필 샘플의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e59b472cf539a835c888dd89568d8c7535aa244" translate="yes" xml:space="preserve">
          <source>Marks the end of concurrent scavenging.</source>
          <target state="translated">동시 청소의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="57bb2a224b54670e5e30b20bb4395fd09c0df40e" translate="yes" xml:space="preserve">
          <source>Marks the end of marking by the concurrent collector.</source>
          <target state="translated">동시 수집기의 표시 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="640deea39fa19db976a137734b54b69c77f77688" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">동시 가비지 수집기의 포스트 마크 동기화 단계의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ff67171565b14a0ac19b21e97b897585fbd8895f" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">동시 가비지 수집기의 스윕 단계의 끝을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="769d2819dbb6bff931272f20731d9d45442d5b36" translate="yes" xml:space="preserve">
          <source>Marks the migration of a task to a new capability.</source>
          <target state="translated">작업을 새 기능으로 마이그레이션하는 것을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2a1e650924ea24ab3b1b0f295ccf2fdea9b1307a" translate="yes" xml:space="preserve">
          <source>Marks the start of concurrent scavenging.</source>
          <target state="translated">동시 청소의 시작을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7e626c3e7759a64e59e9a89ccd39a484ef5b02cf" translate="yes" xml:space="preserve">
          <source>Marshal a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a C string encoded as UTF-8 in temporary storage, with explicit length information. The encoded string may contain NUL bytes, and is not followed by a trailing NUL byte.</source>
          <target state="translated">명시적인 길이 정보를 사용하여 임시 저장소에서 UTF-8로 인코딩 된 C 문자열로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 를 마샬링합니다 . 인코딩 된 문자열에는 NUL 바이트가 포함될 수 있으며 뒤에 NUL 바이트가 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e194c0bfa99200c6de46b0a0dae4f141264ffb6b" translate="yes" xml:space="preserve">
          <source>Marshal a C string with explicit length into a Haskell string.</source>
          <target state="translated">명시 적 길이의 C 문자열을 Haskell 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="50198af1318b58c7e70f40d2d8b8dc415ec720f2" translate="yes" xml:space="preserve">
          <source>Marshal a C wide string with explicit length into a Haskell string.</source>
          <target state="translated">명시적인 길이의 C 와이드 문자열을 Haskell 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="3c5b68516d82d4c37cb3d40678d4531758ba74e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information.</source>
          <target state="translated">명시 적 길이 정보를 사용하여 Haskell 문자열을 임시 저장소의 C 문자열 (예 : 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="062175c88aeda03668433b163d83cb6364af626e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) with explicit length information.</source>
          <target state="translated">Haskell 문자열을 명시적인 길이 정보를 사용하여 C 문자열 (즉, 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="912dd885ff9b0a2ea4a16995e74ae7cc0940d45e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">명시 적 길이 정보를 사용하여 임시 저장 공간에서 Haskell 문자열을 C 와이드 문자열 (예 : 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="f77c471f3c7f74d5609487ca9b39a6878b13f8dd" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (ie, wide character array) with explicit length information.</source>
          <target state="translated">Haskell 문자열을 명시 적 길이 정보를 사용하여 C 와이드 문자열 (즉, 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="c98ce6c5f02b8c9585848448e89dbd65dcaf47e3" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열을 NUL 종료 C 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="fdda91a4f111ed1a0fc6f2a8775b98e089fe921b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string.</source>
          <target state="translated">Haskell 문자열을 NUL 종료 C 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4a04b9cb2051b02b522faee9650a0d495e9ac7e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열을 NUL 종료 C 와이드 문자열에 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4054981272596d06fac239f84b099d399356e48b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string.</source>
          <target state="translated">Haskell 스트링을 NUL 종료 C 와이드 스트링에 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="09d48aea89cc33b11ec8033bc15b6483354cf103" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C string into a Haskell string.</source>
          <target state="translated">NUL로 종료 된 C 문자열을 Haskell 문자열로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="4311d7c39509b4fe039bef36ba55dfd320cecd73" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C wide string into a Haskell string.</source>
          <target state="translated">NUL 종료 C 와이드 문자열을 Haskell 문자열로 마샬링하십시오.</target>
        </trans-unit>
        <trans-unit id="4c47a3a8839a6fd68ae9716c3fa1ce5197fbd8d4" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">더미 하스켈 문자열을 명시적인 길이 정보와 함께 임시 저장소의 C 와이드 문자열 (즉, 와이드 문자 배열)로 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="6d86041ec3d2e84d33ddd1dd6cfc24550f14836a" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">임시 스토리지를 사용하여 더미 Haskell 문자열을 NUL 종료 C 와이드 문자열에 마샬링합니다.</target>
        </trans-unit>
        <trans-unit id="e0dade00c021cdaf9d0ee91f43d69115b6f80912" translate="yes" xml:space="preserve">
          <source>Marshal a list of Haskell strings into an array of NUL terminated C strings using temporary storage.</source>
          <target state="translated">임시 저장소를 사용하여 Haskell 문자열 목록을 NUL 종료 C 문자열 배열에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cc6b108a5f57dc6b9a05c1b127e58f7eca9629cd" translate="yes" xml:space="preserve">
          <source>Marshalling</source>
          <target state="translated">Marshalling</target>
        </trans-unit>
        <trans-unit id="f0ad063d68044737957ed0f797a2cae2aa208116" translate="yes" xml:space="preserve">
          <source>Marshalling arrays</source>
          <target state="translated">마샬링 배열</target>
        </trans-unit>
        <trans-unit id="36c846ee62dfe999f6767389bfae195bd57e0465" translate="yes" xml:space="preserve">
          <source>Marshalling lists of storable objects</source>
          <target state="translated">저장 가능한 객체의 마샬링 목록</target>
        </trans-unit>
        <trans-unit id="0dba1cb48010c84cd2d29279809f66a88be05516" translate="yes" xml:space="preserve">
          <source>Marshalling of Boolean values (non-zero corresponds to &lt;code&gt;True&lt;/code&gt;)</source>
          <target state="translated">부울 값의 마샬링 (0이 아닌 값은 &lt;code&gt;True&lt;/code&gt; 에 해당 )</target>
        </trans-unit>
        <trans-unit id="ab71dfd4eb06d44348ff90d0b69db22a5328f47d" translate="yes" xml:space="preserve">
          <source>Marshalling of Maybe values</source>
          <target state="translated">아마도 가치의 마샬링</target>
        </trans-unit>
        <trans-unit id="239b1e2996122625ab9c3b095db2c1aaf212e151" translate="yes" xml:space="preserve">
          <source>Marshalling support</source>
          <target state="translated">마샬링 지원</target>
        </trans-unit>
        <trans-unit id="2768b4d93d7521d0bb9c22088cc6e109b9cb0751" translate="yes" xml:space="preserve">
          <source>Marshalling support. Unsafe API.</source>
          <target state="translated">마샬링 지원. 안전하지 않은 API.</target>
        </trans-unit>
        <trans-unit id="2ac6f66636ae68e7acfa888a200b00a6c8d691d3" translate="yes" xml:space="preserve">
          <source>Marshalling support: routines allocating, storing, and retrieving Haskell lists that are represented as arrays in the foreign language</source>
          <target state="translated">마샬링 지원 : 외국어로 배열로 표시되는 Haskell 목록을 할당, 저장 및 검색하는 루틴</target>
        </trans-unit>
        <trans-unit id="2eec1eaadfce2f2343fb8a58e72120839ce594dd" translate="yes" xml:space="preserve">
          <source>Martin Escardo and Paulo Oliva. &quot;Selection functions, bar recursion and backward induction&quot;, &lt;em&gt;Mathematical Structures in Computer Science&lt;/em&gt; 20:2 (2010), pp. 127-168. &lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</source>
          <target state="translated">마틴 에스 카르 도와 파울로 올리바. &quot;선택 기능, 막대 재귀 및 역 귀납법&quot;, &lt;em&gt;컴퓨터 과학의 수학적 구조&lt;/em&gt; 20 : 2 (2010), 127-168 쪽. &lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8aadf1657da58cb6e5ae063fb1322736bf6002e4" translate="yes" xml:space="preserve">
          <source>Mask</source>
          <target state="translated">Mask</target>
        </trans-unit>
        <trans-unit id="30b6cc635afcf7d59efbff7d871b3f85ca41ffeb" translate="yes" xml:space="preserve">
          <source>MaskedInterruptible</source>
          <target state="translated">MaskedInterruptible</target>
        </trans-unit>
        <trans-unit id="f8a86f7a0ad149ff28451b56d2a010763bd9ea96" translate="yes" xml:space="preserve">
          <source>MaskedUninterruptible</source>
          <target state="translated">MaskedUninterruptible</target>
        </trans-unit>
        <trans-unit id="55a3d416a9f5e2d65bbae417b235dd396b7e87d1" translate="yes" xml:space="preserve">
          <source>MaskingState</source>
          <target state="translated">MaskingState</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="d8e65ef19404e901265ea66bdd78cf07c84d55f3" translate="yes" xml:space="preserve">
          <source>Match &lt;code&gt;v1&lt;/code&gt; against &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt; against &lt;code&gt;p2&lt;/code&gt; and so on. If any of these matches fail or diverge, so does the whole match.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; 과 &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; 와 &lt;code&gt;p2&lt;/code&gt; 등을 일치 시킵니다. 이러한 일치 중 하나라도 실패하거나 분기되면 전체 일치도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6ceb6ea323bd13a9e935c2eb466741cf2f979c72" translate="yes" xml:space="preserve">
          <source>Match and Clause</source>
          <target state="translated">경기와 조항</target>
        </trans-unit>
        <trans-unit id="dd7924a1ec8896d061a233f605e42f91781e1add" translate="yes" xml:space="preserve">
          <source>Match the value &lt;code&gt;v&lt;/code&gt; against &lt;code&gt;p&lt;/code&gt;. If this match fails or diverges, so does the whole (pattern synonym) match. Otherwise the match against &lt;code&gt;p&lt;/code&gt; must bind the variables &lt;code&gt;x1 ... xn&lt;/code&gt;; let them be bound to values &lt;code&gt;v1 ... vn&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;v&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt; 를 일치시킵니다 . 이 일치가 실패하거나 분기되면 전체 (패턴 동의어) 일치합니다. 그렇지 않으면 &lt;code&gt;p&lt;/code&gt; 에 대한 일치 는 변수 &lt;code&gt;x1 ... xn&lt;/code&gt; 바인딩해야합니다 . 값 &lt;code&gt;v1 ... vn&lt;/code&gt; 바인딩되도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="6763e6cca4e80df18fa4d5f912665ef97a375c19" translate="yes" xml:space="preserve">
          <source>MatchQ</source>
          <target state="translated">MatchQ</target>
        </trans-unit>
        <trans-unit id="4895b24f6bce36c2cd9b44590b52713fb09b4922" translate="yes" xml:space="preserve">
          <source>Matching an expression &lt;code&gt;e&lt;/code&gt; against a pattern &lt;code&gt;!p&lt;/code&gt; is done by first evaluating &lt;code&gt;e&lt;/code&gt; (to WHNF) and then matching the result against &lt;code&gt;p&lt;/code&gt;. Example:</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt; 를 패턴 &lt;code&gt;!p&lt;/code&gt; 와 일치시키는 것은 먼저 &lt;code&gt;e&lt;/code&gt; 를 평가하고 (WHNF로) 그 결과를 &lt;code&gt;p&lt;/code&gt; 와 일치시킴으로써 수행됩니다 . 예:</target>
        </trans-unit>
        <trans-unit id="70016ff14223778abe33ce54933e1dcebf537bde" translate="yes" xml:space="preserve">
          <source>Matching function for the token to parse.</source>
          <target state="translated">구문 분석 할 토큰의 일치 기능</target>
        </trans-unit>
        <trans-unit id="469df59ba37712c09add7e5bdd4e7279148a045b" translate="yes" xml:space="preserve">
          <source>Matching is carried out on GHC&amp;rsquo;s intermediate language, which includes type abstractions and applications. So a rule only matches if the types match too. See &lt;a href=&quot;#rule-spec&quot;&gt;Specialisation&lt;/a&gt; below.</source>
          <target state="translated">매칭은 타입 추상화와 응용을 포함하는 GHC의 중간 언어에서 수행됩니다. 따라서 규칙도 유형이 일치하는 경우에만 일치합니다. 아래 &lt;a href=&quot;#rule-spec&quot;&gt;전문화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78b96c127877ae96cfefda73d72a8baba84838aa" translate="yes" xml:space="preserve">
          <source>Matching on &lt;code&gt;App&lt;/code&gt; directly is both hard to read and error prone to write. And the situation is even worse when the matching is nested:</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 직접 일치하는 것은 읽기가 어렵고 오류가 발생하기 쉽습니다. 그리고 일치하는 것이 중첩되면 상황이 더욱 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="042bacca5d8f713d47eab01491aa815bdbd55203" translate="yes" xml:space="preserve">
          <source>Matching the pattern &lt;code&gt;!pat&lt;/code&gt; against a value &lt;code&gt;v&lt;/code&gt; behaves as follows:</source>
          <target state="translated">패턴 &lt;code&gt;!pat&lt;/code&gt; 를 값 &lt;code&gt;v&lt;/code&gt; 와 일치 시키면 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3d675806f239e11d4b41b67aa65a5606104824d2" translate="yes" xml:space="preserve">
          <source>Matching: To the equations in Section 3.17.3 of the &lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt;, add the following:</source>
          <target state="translated">매칭 : &lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt; 3.17.3 섹션의 방정식에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e2376240265e2ddbf31297cb5bda027216f1ebd9" translate="yes" xml:space="preserve">
          <source>MathSymbol</source>
          <target state="translated">MathSymbol</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="c189943b0e68bf52ade04ebce38ce6c7c78d6eea" translate="yes" xml:space="preserve">
          <source>Maximum length of a line, in characters.</source>
          <target state="translated">한 줄의 최대 길이 (문자)</target>
        </trans-unit>
        <trans-unit id="144a9206977b57448e4faf5e1062274633d6193e" translate="yes" xml:space="preserve">
          <source>Maximum live data (including large objects + compact regions) in the heap. Updated after a major GC.</source>
          <target state="translated">힙의 최대 라이브 데이터 (큰 개체 + 컴팩트 영역 포함). 주요 GC 이후에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="159b778d9454be206f67d4893bca54a49e9b8c77" translate="yes" xml:space="preserve">
          <source>Maximum live data in compact regions</source>
          <target state="translated">컴팩트 한 지역에서 최대 라이브 데이터</target>
        </trans-unit>
        <trans-unit id="a16695344254fdba02129e66db3ad3e63cb1016e" translate="yes" xml:space="preserve">
          <source>Maximum live data in large objects</source>
          <target state="translated">큰 물체에서 최대 라이브 데이터</target>
        </trans-unit>
        <trans-unit id="240702bae0f29e273fb09ffdba7773ca8777719c" translate="yes" xml:space="preserve">
          <source>Maximum memory in use by the RTS</source>
          <target state="translated">RTS에서 사용중인 최대 메모리</target>
        </trans-unit>
        <trans-unit id="d8099e9d8479df145a140dbad71866cd985cafd7" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to read</source>
          <target state="translated">읽을 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="29145ea756091c42d8b8df72e4191a60b4a54c6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to write</source>
          <target state="translated">쓸 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="9e69850923d54429a417c753e43ca53a7ffd31d5" translate="yes" xml:space="preserve">
          <source>Maximum number of unmatched patterns to be shown in warnings generated by &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 경고에 표시되는 일치하지 않는 최대 패턴 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1f5b0947f46a97bb1ec7fe07a7eee8499d030c8e" translate="yes" xml:space="preserve">
          <source>Maximum of two size hints.</source>
          <target state="translated">최대 2 개의 힌트 크기.</target>
        </trans-unit>
        <trans-unit id="bdf18c00bb82701af0218115bcf257f5be6c13bb" translate="yes" xml:space="preserve">
          <source>Maximum slop</source>
          <target state="translated">최대 경사</target>
        </trans-unit>
        <trans-unit id="15683050ba4f95be274c22da707d4d37cc680acd" translate="yes" xml:space="preserve">
          <source>May be overlapped by more specific instances</source>
          <target state="translated">보다 구체적인 인스턴스와 겹칠 수 있음</target>
        </trans-unit>
        <trans-unit id="9d13a4f70e986c78366878d8a4b23da17275d3fb" translate="yes" xml:space="preserve">
          <source>May overlap a more general instance</source>
          <target state="translated">보다 일반적인 인스턴스와 겹칠 수 있음</target>
        </trans-unit>
        <trans-unit id="bc53972d25b2dda7267fd09725c8dd41aac97859" translate="yes" xml:space="preserve">
          <source>May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">이 설명이 잘못된 경우 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dd8d0bbe9dcb95403cd2c187064106af47af84" translate="yes" xml:space="preserve">
          <source>Maybe</source>
          <target state="translated">Maybe</target>
        </trans-unit>
        <trans-unit id="b92babb5409c0a6ec95584469ae7d91df0ca8969" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the leftmost non-Nothing value.</source>
          <target state="translated">가장 왼쪽이 아닌 값을 반환하는 monoid 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018b50df30620e3a51db9ef52260cf832edd1f4d" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the rightmost non-Nothing value.</source>
          <target state="translated">아마도 가장 오른쪽이 아닌 값을 반환하는 monoid 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0be6aa40a87f2c34d21604241fc126b3d008fc" translate="yes" xml:space="preserve">
          <source>Maybe type</source>
          <target state="translated">아마도 타입</target>
        </trans-unit>
        <trans-unit id="aa7807fd2f555e6dc07cae0194859e7c01ce8cb6" translate="yes" xml:space="preserve">
          <source>Maybe values</source>
          <target state="translated">아마도 가치</target>
        </trans-unit>
        <trans-unit id="e3265936ce333fe37c9404fe3bfe54fa2731aec4" translate="yes" xml:space="preserve">
          <source>MaybeT</source>
          <target state="translated">MaybeT</target>
        </trans-unit>
        <trans-unit id="3fbd96571113d60d1ec28c5fc4754c91f3088410" translate="yes" xml:space="preserve">
          <source>MbATOM</source>
          <target state="translated">MbATOM</target>
        </trans-unit>
        <trans-unit id="55d8534107e7b0b303e6aa4feb48079bd26d10e8" translate="yes" xml:space="preserve">
          <source>MbHANDLE</source>
          <target state="translated">MbHANDLE</target>
        </trans-unit>
        <trans-unit id="e5248b4829d90843e057bd4eca3e14ec6c01b898" translate="yes" xml:space="preserve">
          <source>MbHINSTANCE</source>
          <target state="translated">MbHINSTANCE</target>
        </trans-unit>
        <trans-unit id="863abdca342d4cbfd84104bbc0ff83f945b49e3b" translate="yes" xml:space="preserve">
          <source>MbHMODULE</source>
          <target state="translated">MbHMODULE</target>
        </trans-unit>
        <trans-unit id="3d9c03cdc0330cc84e5101070b081063867dbc28" translate="yes" xml:space="preserve">
          <source>MbINT</source>
          <target state="translated">MbINT</target>
        </trans-unit>
        <trans-unit id="ecea6b01153b85a30965344164775b06fbcb69a4" translate="yes" xml:space="preserve">
          <source>MbLPCSTR</source>
          <target state="translated">MbLPCSTR</target>
        </trans-unit>
        <trans-unit id="e5be102041dc49217c1540606dd21365b89afc4f" translate="yes" xml:space="preserve">
          <source>MbLPCTSTR</source>
          <target state="translated">MbLPCTSTR</target>
        </trans-unit>
        <trans-unit id="53d96f8a97cd2285858b07956c5ce9cae6040aba" translate="yes" xml:space="preserve">
          <source>MbLPOVERLAPPED</source>
          <target state="translated">MbLPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="1bab356846186170a8b4b1f5b81a7ad37bab46a7" translate="yes" xml:space="preserve">
          <source>MbLPSECURITY_ATTRIBUTES</source>
          <target state="translated">MbLPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="48504feb90b785c6491d7d2c1926298c2bd30054" translate="yes" xml:space="preserve">
          <source>MbLPVOID</source>
          <target state="translated">MbLPVOID</target>
        </trans-unit>
        <trans-unit id="96d0adb31743d4f3821a0e34427fd9d3c6b05a6e" translate="yes" xml:space="preserve">
          <source>MbPos</source>
          <target state="translated">MbPos</target>
        </trans-unit>
        <trans-unit id="e4fd24ce7545ffe7c595a6b3e7a83dba23199af3" translate="yes" xml:space="preserve">
          <source>MbString</source>
          <target state="translated">MbString</target>
        </trans-unit>
        <trans-unit id="ce9329746fe501a099093f13e3edca7c47f40a51" translate="yes" xml:space="preserve">
          <source>Mc: Mark, Spacing Combining</source>
          <target state="translated">맥 : 마크, 간격 결합</target>
        </trans-unit>
        <trans-unit id="e2c8f4a8900f070fa946c771890c8638e1827848" translate="yes" xml:space="preserve">
          <source>Me: Mark, Enclosing</source>
          <target state="translated">나 : 마크, 동봉</target>
        </trans-unit>
        <trans-unit id="5613874632be97c00f6099463fe7f3e041473ea8" translate="yes" xml:space="preserve">
          <source>Meanings of specific keywords:</source>
          <target state="translated">특정 키워드의 의미 :</target>
        </trans-unit>
        <trans-unit id="1aedf6c2f14dc3df6a343ae9b734d4a0213e9822" translate="yes" xml:space="preserve">
          <source>Means &amp;ldquo;turn off all optimisation&amp;rdquo;, reverting to the same settings as if no &lt;code&gt;-O&lt;/code&gt; options had been specified. Saying &lt;code&gt;-O0&lt;/code&gt; can be useful if e.g. &lt;code&gt;make&lt;/code&gt; has inserted a &lt;code&gt;-O&lt;/code&gt; on the command line already.</source>
          <target state="translated">&lt;code&gt;-O&lt;/code&gt; 옵션이 지정 되지 않은 것과 동일한 설정으로 되돌아가는 &quot;모든 최적화 해제&quot;를 의미 합니다. 예를 들어 &lt;code&gt;make&lt;/code&gt; 가 이미 명령 줄에 &lt;code&gt;-O&lt;/code&gt; 를 삽입 한 경우 &lt;code&gt;-O0&lt;/code&gt; 을 말하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4aa9a4c3b5df0d65ca9349e71ddf30cd0d7394" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Apply every non-dangerous optimisation, even if it means significantly longer compile times.&amp;rdquo;</source>
          <target state="translated">의미 : &quot;컴파일 시간이 상당히 길어 지더라도 모든 위험하지 않은 최적화를 적용하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="c3bbe6c8c39ed5248e3ca18003eb3d6900b1a45b" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Generate good-quality code without taking too long about it.&amp;rdquo; Thus, for example: &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</source>
          <target state="translated">의미 : &quot;너무 오래 걸리지 않고 양질의 코드를 생성하십시오.&quot; 따라서 예를 들면 다음과 같습니다. &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe31d4f25bb8cbbdafdbd4fc62d7fc6cf17c7656" translate="yes" xml:space="preserve">
          <source>Mediate types and binary type constructors.</source>
          <target state="translated">유형과 이진 유형 생성자를 중재합니다.</target>
        </trans-unit>
        <trans-unit id="517ef4fa125305a5305a3a02844f3bb72b3175b5" translate="yes" xml:space="preserve">
          <source>Mediate types and unary type constructors.</source>
          <target state="translated">유형과 단항 유형 생성자를 중재하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bf368dfa41af6966ac27794caf5006abecc398" translate="yes" xml:space="preserve">
          <source>Memory Model</source>
          <target state="translated">메모리 모델</target>
        </trans-unit>
        <trans-unit id="49364f57d947f17b4af9ef59269db84acaef977a" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">메모리 주소는 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 유형의 값으로 표시되며 일부 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 에 대한 type 인수 는 FFI 코드에서 귀중한 유형 안전성을 제공하는 데 도움이되고 (명시 적 캐스트없이 다른 유형의 포인터를 혼합 할 수 없음) Haskell 유형 시스템이 주어진 포인터에 어떤 마샬링 방법이 필요한지 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ccc7c7227622171674639dfab2d7182af83111c" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">메모리 주소는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 유형의 값으로 표시되며 일부 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스입니다 . &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 에 대한 type 인수 는 FFI 코드에서 귀중한 유형 안전성을 제공하는 데 도움이되고 (명시 적 캐스트없이 다른 유형의 포인터를 혼합 할 수 없음) Haskell 유형 시스템이 주어진 포인터에 어떤 마샬링 방법이 필요한지 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="403b42e453dae36d100f182dddf88973e094f006" translate="yes" xml:space="preserve">
          <source>Memory containing the data to write</source>
          <target state="translated">쓸 데이터를 포함하는 메모리</target>
        </trans-unit>
        <trans-unit id="94713b6ce43e5b0b6c83500725c2f66aaf33bf20" translate="yes" xml:space="preserve">
          <source>Memory in which to put the data</source>
          <target state="translated">데이터를 넣을 메모리</target>
        </trans-unit>
        <trans-unit id="6dc9de36a01521f350aa26cecadb8b40753a93e7" translate="yes" xml:space="preserve">
          <source>Memory occupied by threads and their stacks is labelled as &amp;ldquo;TSO&amp;rdquo; and &amp;ldquo;STACK&amp;rdquo; respectively when displaying the profile by closure description or type description.</source>
          <target state="translated">스레드 및 해당 스택이 차지하는 메모리는 클로저 설명 또는 유형 설명으로 프로파일을 표시 할 때 각각 &quot;TSO&quot;및 &quot;STACK&quot;으로 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4c76fe9817202da64040fc649066dabc0e7eed8e" translate="yes" xml:space="preserve">
          <source>Memory overhead</source>
          <target state="translated">메모리 오버 헤드</target>
        </trans-unit>
        <trans-unit id="76cf8b1754b778b2d89d0e21d90207ed29dcf08d" translate="yes" xml:space="preserve">
          <source>Memory-related system things.</source>
          <target state="translated">메모리 관련 시스템 것들.</target>
        </trans-unit>
        <trans-unit id="d10533e6a3289c9df349dcd02b8d8d7f9c80176b" translate="yes" xml:space="preserve">
          <source>Merge immediately-nested case expressions that scrutinise the same variable. For example,</source>
          <target state="translated">동일한 변수를 면밀히 조사하는 즉시 중첩 된 대소 문자 표현을 병합합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5d3ef442f47f2ad90bddd19466398680ce25d8b8" translate="yes" xml:space="preserve">
          <source>Merge two maps.</source>
          <target state="translated">두 맵을 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="68f4145fee7dde76afceb910165924ad14cf0d00" translate="yes" xml:space="preserve">
          <source>Message</source>
          <target state="translated">Message</target>
        </trans-unit>
        <trans-unit id="024d721d7acc6f792bdb94402861b9353228512e" translate="yes" xml:space="preserve">
          <source>Messages sent back to GHC from GHCi.TH, to implement the methods of &lt;code&gt;Quasi&lt;/code&gt;. For an overview of how TH works with Remote GHCi, see Note [Remote Template Haskell] in GHCi.TH.</source>
          <target state="translated">메시지의 방법을 구현하기 위해, GHCi.TH에서 GHC로 다시 전송 &lt;code&gt;Quasi&lt;/code&gt; . TH가 Remote GHCi와 작동하는 방식에 대한 개요는 GHCi.TH의 참고 [Remote Template Haskell]을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="b4c38ae701ee7b9a08939eed835436caf60c6814" translate="yes" xml:space="preserve">
          <source>Meta information: &lt;code&gt;M1&lt;/code&gt;</source>
          <target state="translated">메타 정보 : &lt;code&gt;M1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbd5ac6aaff1e4e5e3680f3fcf71d0e95837cf76" translate="yes" xml:space="preserve">
          <source>Meta-information</source>
          <target state="translated">Meta-information</target>
        </trans-unit>
        <trans-unit id="1704ec077999acd78a98ea2ae7222e509894be96" translate="yes" xml:space="preserve">
          <source>Meta-information (constructor names, etc.)</source>
          <target state="translated">메타 정보 (생성자 이름 등)</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="1ce80809f59fb3e44fb71f48daaa5004423cdbcf" translate="yes" xml:space="preserve">
          <source>Methods for the RealFrac instances for &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, with specialised versions for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 전용 버전을 사용하여 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 용 RealFrac 인스턴스에 대한 메서드입니다 .</target>
        </trans-unit>
        <trans-unit id="056ba157b3837c9d7e53cf9a40b8f90212f59c28" translate="yes" xml:space="preserve">
          <source>Micro</source>
          <target state="translated">Micro</target>
        </trans-unit>
        <trans-unit id="064b3c6c13a563b40aaf45097d6cc83685cba7e9" translate="yes" xml:space="preserve">
          <source>Milan Straka 2014</source>
          <target state="translated">밀란 스트라 카 2014</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
