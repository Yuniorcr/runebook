<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="ef2cf419db4400f92d4c16bda25b7b49de7c246f" translate="yes" xml:space="preserve">
          <source>Evaluate the argument to weak head normal form.</source>
          <target state="translated">약한 머리 정상 형태에 대한 주장을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="6060f4f46d5f080bbe6d3a4e15ea7e03aae4d623" translate="yes" xml:space="preserve">
          <source>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt;.</source>
          <target state="translated">주어진 표현식 (또는 표현식이 제공되지 않은 경우 마지막 중단 점에서)을 평가하고 나중에 &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; 를&lt;/a&gt; 사용하여 나중에 검사하기위한 평가 단계를 기록 합니다. &lt;a href=&quot;#tracing&quot;&gt;추적 및 히스토리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bc4cf67d5d67cdacfaa5ff060fb29cd523c09db" translate="yes" xml:space="preserve">
          <source>Evaluates the relevant functions at each element in the structure, running the action, and builds a new structure with the same shape, using the results produced from sequencing the actions.</source>
          <target state="translated">구조의 각 요소에서 관련 기능을 평가하고 조치를 실행하고 조치 순서에서 생성 된 결과를 사용하여 동일한 모양의 새 구조를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="5600c714a91cbc3264f491ad475c86811b22d09a" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;f&lt;/code&gt; directly shows a call stack with a single entry, while evaluating &lt;code&gt;g&lt;/code&gt;, which also requests its call-site, shows two entries, one for each computation &amp;ldquo;annotated&amp;rdquo; with &lt;code&gt;HasCallStack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 를 평가 하면 단일 항목이있는 호출 스택이 직접 표시되고, 호출 사이트도 요청하는 &lt;code&gt;g&lt;/code&gt; 가 평가 되면 &lt;code&gt;HasCallStack&lt;/code&gt; 을 사용 하여 &quot;주석이 지정된 &quot;계산마다 하나씩 두 개의 항목이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="6de480eeff47d7212d5e046acac48253bd022e55" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th prefix takes \( O(\log(\min(i, n-i))) \), but evaluating every prefix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">\ (i \) 번째 접두사를 평가하려면 \ (O (\ log (\ min (i, ni))) \)가 필요하지만 시퀀스의 모든 접두사를 평가하려면 공유로 인해 \ (O (n) \)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6396b8883a4c5c234f705d6f1fbf827f38a7835a" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th suffix takes \( O(\log(\min(i, n-i))) \), but evaluating every suffix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">\ (i \) 번째 접미사를 평가하려면 \ (O (\ log (\ min (i, ni))) \)가 필요하지만 순서대로 모든 접미사를 평가하려면 공유로 인해 \ (O (n) \)가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ea09e351bce3db4c6389ffff16dcaf057265f37f" translate="yes" xml:space="preserve">
          <source>Evaluation has started on a spark.</source>
          <target state="translated">Evaluation has started on a spark.</target>
        </trans-unit>
        <trans-unit id="bcce67319f3801a5d8320bd2ddeb26734158769d" translate="yes" xml:space="preserve">
          <source>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</source>
          <target state="translated">데이터 패밀리가 최상위 선언으로 정의 되더라도 다른 패밀리 인스턴스에 대해 서로 다른 계산을 수행하는 함수는 여전히 클래스 유형의 메소드로 정의해야합니다. 특히 다음은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="712f436fb09e995690fe8d40968566162f8678b8" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;a&lt;/code&gt; is ill-typed, it is not used in the end, so if all that we&amp;rsquo;re interested in is &lt;code&gt;main&lt;/code&gt; it can be useful to be able to ignore the problems in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 형식이 잘못 되었지만 결국에는 사용되지 않으므로 관심있는 모든 것이 &lt;code&gt;main&lt;/code&gt; 경우의 문제를 무시할 수있는 &lt;code&gt;a&lt;/code&gt; 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c423833e7459f388f7a025deca957c83022894ae" translate="yes" xml:space="preserve">
          <source>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import &lt;code&gt;S(x)&lt;/code&gt; but not &lt;code&gt;T(x)&lt;/code&gt;, and then use &lt;code&gt;x&lt;/code&gt; unambiguously.</source>
          <target state="translated">필드 레이블이 해당 정의 모듈에 복제되어 있어도 다른 곳에서 선택기를 사용할 수 있습니다. 예를 들어, 다른 모듈은 &lt;code&gt;S(x)&lt;/code&gt; 가져올 수 있지만 &lt;code&gt;T(x)&lt;/code&gt; 는 가져올 수 없으며 &lt;code&gt;x&lt;/code&gt; 를 명확하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="852a6172c09d70538bebcbe548e6b3e70b6d5e28" translate="yes" xml:space="preserve">
          <source>Even though most of these examples are using the list monad, monad comprehensions work for any monad. The &lt;code&gt;base&lt;/code&gt; package offers all necessary instances for lists, which make &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; backward compatible to built-in, transform and parallel list comprehensions.</source>
          <target state="translated">이 예제들 대부분이리스트 모나드를 사용하고 있지만 모나드 이해는 모나드에 적용됩니다. &lt;code&gt;base&lt;/code&gt; 패키지 제공 할 목록에 대한 모든 필요한 경우, &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; 가&lt;/a&gt; 내장-에 이전 버전과 호환이, 변환 및 병렬 지능형리스트.</target>
        </trans-unit>
        <trans-unit id="1e2fd9aaf66af88d1fa27ea41b45f571960a585c" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">시프트 양이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 로 표현 되더라도 음의 시프트 양 에 대해서는 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a5f2b0889226d76221df5eba41dfdfd027c049a" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">시프트 양이 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 표시 되더라도 음수 시프트 양에 대해서는 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a98b3fabc4357473affe9eff5dad04c75f7f6eb" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">이 비록 거기에 &lt;code&gt;x&lt;/code&gt; 는 '범위에이야, 분명하다 &lt;code&gt;x&lt;/code&gt; 의 정의에서 패턴 &lt;code&gt;ok1&lt;/code&gt; 은 오직 필드 의미 할 수있다 &lt;code&gt;x&lt;/code&gt; 타입에서 &lt;code&gt;S&lt;/code&gt; 를 . 함수 &lt;code&gt;ok2&lt;/code&gt; 와 유사합니다 . 그러나의 레코드 업데이트에서 &lt;code&gt;bad1&lt;/code&gt; 와의 레코드 선택 &lt;code&gt;bad2&lt;/code&gt; 가하고자하는 두 가지 유형 중 어느 명확하지 않다.</target>
        </trans-unit>
        <trans-unit id="4622930c8ec60ffdcb4687bdfc5e61a4075cdba8" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">Even though there are two &lt;code&gt;x&lt;/code&gt; &amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt; . Similarly for the function &lt;code&gt;ok2&lt;/code&gt; . However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</target>
        </trans-unit>
        <trans-unit id="2711d7494e1ded0fd3622ca6129c265f52351d7e" translate="yes" xml:space="preserve">
          <source>Even when set to &lt;code&gt;ignore&lt;/code&gt;, a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt;&lt;code&gt;:script&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Even when set to &lt;code&gt;ignore&lt;/code&gt; , a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt; &lt;code&gt;:script&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="28e0cceb61d9188b63cc75de845a0be5868e83b8" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">&lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그를 사용하더라도 생성자 &lt;code&gt;T&lt;/code&gt; 의 필드는 압축이 풀리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73d7a0d774535278c1215097572fe0930f17dd2b" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그를 사용하더라도 생성자 &lt;code&gt;T&lt;/code&gt; 의 필드는 압축 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="0c619c8d6ba2035f81d9f010c08ec0b1177929e5" translate="yes" xml:space="preserve">
          <source>Event logging</source>
          <target state="translated">이벤트 로깅</target>
        </trans-unit>
        <trans-unit id="913641e09266e8cb48d5e95316fd86cbe16755ba" translate="yes" xml:space="preserve">
          <source>EventManager</source>
          <target state="translated">EventManager</target>
        </trans-unit>
        <trans-unit id="ff23fd7f42569a5bfa090dd486d103be85fd0164" translate="yes" xml:space="preserve">
          <source>Eventlog tracing</source>
          <target state="translated">이벤트 로그 추적</target>
        </trans-unit>
        <trans-unit id="c19ae7eba2908ba6569d481309090a0fda383fe3" translate="yes" xml:space="preserve">
          <source>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</source>
          <target state="translated">Eventlog 추적은 성능 프로파일 링 시스템입니다. 이 함수는 이벤트 로그에 추가 이벤트를 생성합니다. 이벤트 로그 프로파일 링 도구와 함께이 기능을 사용하여 실행을 모니터링하고 성능 문제를 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9202d6978f7b6c56daee6dab6c663c232e9764fd" translate="yes" xml:space="preserve">
          <source>Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</source>
          <target state="translated">Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</target>
        </trans-unit>
        <trans-unit id="82d16de768c1684f419fe23bd359b377e6758d1e" translate="yes" xml:space="preserve">
          <source>Every complete Haskell program must define &lt;code&gt;main&lt;/code&gt; in module &lt;code&gt;Main&lt;/code&gt; in package &lt;code&gt;main&lt;/code&gt;. Omitting the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag compiles code for package &lt;code&gt;main&lt;/code&gt;. Failure to do so leads to a somewhat obscure link-time error of the form:</source>
          <target state="translated">모든 완전한 하스켈 프로그램을 정의해야합니다 &lt;code&gt;main&lt;/code&gt; 모듈의 &lt;code&gt;Main&lt;/code&gt; 패키지에 &lt;code&gt;main&lt;/code&gt; . &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt; 플래그를 생략하면 &lt;code&gt;main&lt;/code&gt; 패키지에 대한 코드가 컴파일됩니다 . 그렇지 않으면 다음과 같은 형식의 링크 타임 오류가 다소 모호해집니다.</target>
        </trans-unit>
        <trans-unit id="d0912fd6d2a0271d302c52a4acaff179b0c6995b" translate="yes" xml:space="preserve">
          <source>Every cycle in the module import graph must be broken by a &lt;code&gt;hs-boot&lt;/code&gt; file. Suppose that modules &lt;code&gt;A.hs&lt;/code&gt; and &lt;code&gt;B.hs&lt;/code&gt; are Haskell source files, thus:</source>
          <target state="translated">모듈 가져 오기 그래프의 모든주기는 &lt;code&gt;hs-boot&lt;/code&gt; 파일에 의해 중단되어야 합니다. 모듈 &lt;code&gt;A.hs&lt;/code&gt; 및 &lt;code&gt;B.hs&lt;/code&gt; 가 Haskell 소스 파일 이라고 가정하면 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="33d86826edcd97dcbde5f7c16a0f10d7e8256a5b" translate="yes" xml:space="preserve">
          <source>Every language extension can also be turned into a command-line flag by prefixing it with &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo;; for example &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt;. (Similarly, all &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo; flags can be written as &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas.)</source>
          <target state="translated">모든 언어 확장은 접두사&amp;ldquo; &lt;code&gt;-X&lt;/code&gt; &amp;rdquo; 를 사용하여 명령 줄 플래그로 전환 할 수도 있습니다 . 예를 들어 &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt; 입니다. 유사하게 모든 &quot; &lt;code&gt;-X&lt;/code&gt; &quot;플래그를 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b078eee456a9f087a6cc6922257a7666e3223df" translate="yes" xml:space="preserve">
          <source>Every language extension can be switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">모든 언어 확장은 명령 줄 플래그 &quot; &lt;code&gt;-X...&lt;/code&gt; &quot;(예 : &lt;code&gt;-XTemplateHaskell&lt;/code&gt; )로 켜고 &quot; &lt;code&gt;-XNo...&lt;/code&gt; &quot; 플래그로 끌 수 있습니다 . (예 : &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="89191834b0668388b7f06081ebe85c6fc7aa3ea9" translate="yes" xml:space="preserve">
          <source>Every language option can switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">모든 언어 옵션은 명령 줄 플래그 &quot; &lt;code&gt;-X...&lt;/code&gt; &quot;(예 : &lt;code&gt;-XTemplateHaskell&lt;/code&gt; )로 설정하고 플래그 &quot; &lt;code&gt;-XNo...&lt;/code&gt; &quot;로 해제 할 수 있습니다. (예 : &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c21e6f680a01c2f8b28c8d60711b7527a58afada" translate="yes" xml:space="preserve">
          <source>Every module has a &lt;em&gt;module name&lt;/em&gt; defined in its source code (&lt;code&gt;module A.B.C where ...&lt;/code&gt;).</source>
          <target state="translated">모든 모듈에는 소스 코드에 정의 된 &lt;em&gt;모듈 이름이&lt;/em&gt; 있습니다 ( &lt;code&gt;module A.B.C where ...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b9fd929db55af9188984a5b1f15ada92d9684dba" translate="yes" xml:space="preserve">
          <source>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</source>
          <target state="translated">모든 새로운 바인딩은 현재 모듈 컨텍스트의 범위에있는 엔티티를 포함하여 동일한 이름의 기존 바인딩을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="f7098378d870c69a4432ef9315748f42a7c6f2be" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="87fea7be991371f64729bc8780fc11210c633480" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="abfc0f0b13db0da312949b88776c9010f5397cef" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">모든 스레드에는 스레드가 할당 한 메모리 양을 추적하는 할당 카운터가 있습니다. 카운터는 0으로 초기화되고 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 는 현재 값을 설정합니다. 할당 카운터는 * down *을 카운트하므로 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 에 대한 호출이 없으면 해당 값은 스레드가 할당 한 메모리 바이트 수를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="2cdcb7a5f8b0e5da9d82d98917b19bde316858e5" translate="yes" xml:space="preserve">
          <source>Exactly the same reasoning applies to &lt;code&gt;ExNumPat&lt;/code&gt;: matching against &lt;code&gt;ExNumPat&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, and &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt;.</source>
          <target state="translated">똑같은 논리가 적용 &lt;code&gt;ExNumPat&lt;/code&gt; 대해 일치 : &lt;code&gt;ExNumPat&lt;/code&gt; 가&lt;em&gt;필요&lt;/em&gt; 제약을 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; 및 &lt;em&gt;제공하는&lt;/em&gt; 구속 &lt;code&gt;(Show b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b96d27d4acb5d7b08b44caf941f831bab1b616f" translate="yes" xml:space="preserve">
          <source>Exactly the same situation can arise in instance declarations themselves. Suppose we have</source>
          <target state="translated">인스턴스 선언 자체에서 정확히 동일한 상황이 발생할 수 있습니다. 우리가 가지고 있다고 가정</target>
        </trans-unit>
        <trans-unit id="fe669a2e98268a4e3f1914eea2b10b28c27678b1" translate="yes" xml:space="preserve">
          <source>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</source>
          <target state="translated">생성 된 프로파일 링 정보를 검사하고 해당 정보를 사용하여 프로그램을 최적화 한 후 필요에 따라 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="5ab5c95eb13c56a3fee4135ddda2d5191c14c8f0" translate="yes" xml:space="preserve">
          <source>Example 1: Custom Error Data Type</source>
          <target state="translated">예 1 : 사용자 정의 오류 데이터 유형</target>
        </trans-unit>
        <trans-unit id="9341e16e31da6f2a70822dbce4c15a6563123345" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Continuation Usage</source>
          <target state="translated">예 1 : 간단한 연속 사용법</target>
        </trans-unit>
        <trans-unit id="65d8343070f8245126756e9e6474efdb37e4866c" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Reader Usage</source>
          <target state="translated">예 1 : 간단한 리더 사용법</target>
        </trans-unit>
        <trans-unit id="e7b57a0dcf99e0a81e45002d7fa9585327408c44" translate="yes" xml:space="preserve">
          <source>Example 2: Modifying Reader Content With &lt;code&gt;local&lt;/code&gt;</source>
          <target state="translated">예 2 : &lt;code&gt;local&lt;/code&gt; 사용하여 판독기 내용 수정</target>
        </trans-unit>
        <trans-unit id="b7af5856636b2b3dd64495544e0d58ec7921152b" translate="yes" xml:space="preserve">
          <source>Example 2: Using &lt;code&gt;callCC&lt;/code&gt;</source>
          <target state="translated">예 2 : &lt;code&gt;callCC&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="3f1f4d7e09a4ce050bc861cd17fcfb325ccd1802" translate="yes" xml:space="preserve">
          <source>Example 2: Using ErrorT Monad Transformer</source>
          <target state="translated">예 2 : ErrorT Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="49670fce677705355449a0491c747c92f53b6377" translate="yes" xml:space="preserve">
          <source>Example 2: Using ExceptT Monad Transformer</source>
          <target state="translated">예 2 : ExceptT Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="3b38bf4f99b69316fc2cabc16fe8efbc23e17cdb" translate="yes" xml:space="preserve">
          <source>Example 3: &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">예 3 : &lt;code&gt;ReaderT&lt;/code&gt; Monad 변압기</target>
        </trans-unit>
        <trans-unit id="2f4dd83523e08d239122d5d7b82fdc40b87078e4" translate="yes" xml:space="preserve">
          <source>Example 3: Using &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">예 3 : &lt;code&gt;ContT&lt;/code&gt; Monad Transformer 사용</target>
        </trans-unit>
        <trans-unit id="589c32b6f4517cdf800a8b3876ce51a0178b7a54" translate="yes" xml:space="preserve">
          <source>Example type:</source>
          <target state="translated">예시 유형 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fa37f54302b03973bfbf2aa3fb535779d3383bb4" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">예제 (동작은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="790f2b42181ca616b7c127aef6e902fd9e8081ef" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">예 ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와 동일한 동작 포함 ) :</target>
        </trans-unit>
        <trans-unit id="d081741e630d4cf15f0c6ba49848ab7e7fafe785" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">예 ( &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와 동일한 동작 포함 ) :</target>
        </trans-unit>
        <trans-unit id="65ef181bf5a5a0563ded8a2fc63cfcae3d45812a" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와의 차이점의 예 :</target>
        </trans-unit>
        <trans-unit id="80e96827fe2478980a86e49ef7458c4629812185" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와의 차이점 예 :</target>
        </trans-unit>
        <trans-unit id="ddfe2a057d0d4bd32c75bee00a3afd1b7f3cd6fd" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 와의 차이점 예 :</target>
        </trans-unit>
        <trans-unit id="3e6a1dcd0a3510c1fa35b2c9952fa51f9d56da66" translate="yes" xml:space="preserve">
          <source>Examples of short-cicuit reduction include various boolean predicates that test whether some or all the elements of a structure satisfy a given condition. Because these don't necessarily consume the entire list, they typically employ &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; with an operator that is conditionally strict in its second argument. Once the termination condition is met the second argument (tail of the input structure) is ignored. No result is returned until that happens.</source>
          <target state="translated">단락 회로 감소의 예에는 구조의 일부 또는 모든 요소가 주어진 조건을 충족하는지 여부를 테스트하는 다양한 부울 술어가 포함됩니다. 이들은 반드시 전체 목록을 소비하는 것은 아니기 때문에 일반적으로 두 번째 인수에서 조건부로 엄격한 연산자와 함께 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 를 사용합니다. 종료 조건이 충족되면 두 번째 인수 (입력 구조의 꼬리)는 무시됩니다. 그 전까지는 결과가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="498245f3f1e8f9b6f80d7ed20c13e42f043f24d9" translate="yes" xml:space="preserve">
          <source>Except</source>
          <target state="translated">Except</target>
        </trans-unit>
        <trans-unit id="150f49a28cd9890f5d74255011dd9ae13178dd32" translate="yes" xml:space="preserve">
          <source>ExceptT</source>
          <target state="translated">ExceptT</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="53a706616e11935ca633fadc1928372183e733d2" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b1c0dab2d59aa101f6c17d2f3c37c8dbb32aef4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ca0b055b03c1b83f5d783045937b6b971fc2c7" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b8e6291d3f08aeaec124c66c6cff001d6c6ea4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">예외 전달은 소스 스레드와 대상 스레드간에 동기화 됩니다. 대상 스레드에서 예외가 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 때까지 throwTo 가 반환되지 않습니다. 따라서 호출 스레드는 대상 스레드가 예외를 수신했는지 확인할 수 있습니다. 예외 전달은 다른 예외와 관련하여 원 자성입니다. Atomicity는 경쟁 조건을 처리 할 때 유용한 속성입니다. 예를 들어 서로 죽일 수있는 두 개의 스레드가있는 경우 스레드 중 하나만 다른 스레드를 죽일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0356c4346732233d71d4ad17145a3a7d64d539e" translate="yes" xml:space="preserve">
          <source>Exception handling in the I/O monad</source>
          <target state="translated">I / O 모나드에서의 예외 처리</target>
        </trans-unit>
        <trans-unit id="4aba3643c6de6f96be69c3234f88f2d7abee91b2" translate="yes" xml:space="preserve">
          <source>Exception handling within STM actions.</source>
          <target state="translated">STM 조치 내에서 예외 처리</target>
        </trans-unit>
        <trans-unit id="eda52cb4b163a3d91ebc6efd255a35eb5c788dd0" translate="yes" xml:space="preserve">
          <source>Exception operations</source>
          <target state="translated">예외 연산</target>
        </trans-unit>
        <trans-unit id="1e0456156d2599fba71e66665c8effe9eb0cdf9b" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; 을 지원하지 않는 Windows 이외의 플랫폼에서 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 에 의해 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="ab0e1caad4d21b7759b69123f35074bf121ac468" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;hLock&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; 을 지원하지 않는 비 Windows 플랫폼에서 &lt;code&gt;hLock&lt;/code&gt; 에 의해 예외가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="8bcbec4a21f1200ac1b10210e0b80c9fa92ae9e7" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. pattern matching failure and &lt;code&gt;error&lt;/code&gt;) can be treated as breakpoints, to help locate the source of an exception in the program.</source>
          <target state="translated">예외 (예 : 패턴 일치 실패 및 &lt;code&gt;error&lt;/code&gt; )는 프로그램에서 예외의 소스를 찾는 데 도움이되는 중단 점으로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19252ae3666000a0b6f93913a391be3ee8a0b825" translate="yes" xml:space="preserve">
          <source>Exceptions and exception-handling functions.</source>
          <target state="translated">예외 및 예외 처리 기능.</target>
        </trans-unit>
        <trans-unit id="581d67742f82ff9913666449de206cda75556316" translate="yes" xml:space="preserve">
          <source>Exceptions generated by array operations</source>
          <target state="translated">배열 연산에 의해 생성 된 예외</target>
        </trans-unit>
        <trans-unit id="934839970d31235dc74d44785440bb7587cc9762" translate="yes" xml:space="preserve">
          <source>Exceptions that occur in the &lt;code&gt;IO&lt;/code&gt; monad. An &lt;code&gt;IOException&lt;/code&gt; records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 모나드 에서 발생하는 예외 . &lt;code&gt;IOException&lt;/code&gt; 이는 어쩌면 더 구체적인 오류 유형, 설명 문자열 및 오류가 플래그 때 사용 된 핸들을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="08dd9b4521175f2b7645b6d05dd66e3f5d1e5a7a" translate="yes" xml:space="preserve">
          <source>ExclusiveLock</source>
          <target state="translated">ExclusiveLock</target>
        </trans-unit>
        <trans-unit id="a9e5edeee4b6bddbc59b5bc41ce4029d4ec4727e" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 가능한 인수 또는 쉘 명령 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 인 경우 현재 작업 디렉토리와 관련하여 상대 경로가 분석됩니다. &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 제공되는 경우 상대 경로가 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 또는 현재 작업 디렉토리 와 관련하여 해결되는지 여부에 따라 구현에 따라 달라 지므로 이식성을 보장하기 위해 절대 경로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="42e1121c05300716bc1e0f10a008032170bf3cee" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 파일 및 인수 또는 셸 명령. 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 상대 경로는 현재 작업 디렉토리에 대한 해결됩니다. 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 제공되고, 그 구현에 의존 상대 경로에 대한 해결 여부 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 절대 경로는 이동성을 보장하기 위해 사용되어야하므로, 또는 현재 작업중 인 디렉토리.</target>
        </trans-unit>
        <trans-unit id="0d633fda1eda86ee2dbe83ca841bdba34c00b7fb" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 파일 및 인수 또는 셸 명령. 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 상대 경로는 현재 작업 디렉토리에 대한 해결됩니다. 경우 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 제공되고, 그 구현에 의존 상대 경로에 대한 해결 여부 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 절대 경로는 이동성을 보장하기 위해 사용되어야하므로, 또는 현재 작업중 인 디렉토리.</target>
        </trans-unit>
        <trans-unit id="da49c4c138af06cdc6e4ed0555a2d722ce3bbf8b" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 가능한 인수 또는 쉘 명령 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 인 경우 현재 작업 디렉토리와 관련하여 상대 경로가 분석됩니다. &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 가 제공되는 경우 상대 경로가 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 또는 현재 작업 디렉토리 와 관련하여 해결되는지 여부에 따라 구현에 따라 달라 지므로 이식성을 보장하기 위해 절대 경로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbbcf8ab79fd69b3cdf42660517413d00119f401" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 파일 및 인수 또는 셸 명령. 경우 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 상대 경로는 현재 작업 디렉토리에 대한 해결됩니다. 경우 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 제공되고, 그 구현에 의존 상대 경로에 대한 해결 여부 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 절대 경로는 이동성을 보장하기 위해 사용되어야하므로, 또는 현재 작업중 인 디렉토리.</target>
        </trans-unit>
        <trans-unit id="08446105cf0896c803b6a80b50cd0e07cfad78bd" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">실행 파일 및 인수 또는 셸 명령. 경우 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , 상대 경로는 현재 작업 디렉토리에 대한 해결됩니다. 경우 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 제공되고, 그 구현에 의존 상대 경로에 대한 해결 여부 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 절대 경로는 이동성을 보장하기 위해 사용되어야하므로, 또는 현재 작업중 인 디렉토리.</target>
        </trans-unit>
        <trans-unit id="82e45ade933abb2dbef129bbe667e5f06567379e" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 하고 생성 된 청크를 지연 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 . 작업은 게으른, 즉 게으른 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 청크 가 강제 될 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbdca60aa1528cc59e2424298bc2fbc065b117a6" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 를 실행 하고 생성 된 청크를 lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 반환합니다 . 작업은 lazy, 즉 lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 청크 가 강제 될 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="44cef8606c2d8d69b084ef725295c455661c70d1" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 실행 하고 생성 된 청크를 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 . 작업은 게으른, 즉 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 청크 가 강제 될 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d4c37228081ad690471866bfb49855698ac1573" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and return the computed result and the bytes written during the computation as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 을 실행 하고 계산 결과 및 계산 중에 쓴 바이트를 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a91780a4fbc0b4b5a96ff84d0f2ad27c4390b00" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; with a buffer-allocation strategy and a continuation. For example, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; is implemented as follows.</source>
          <target state="translated">버퍼 할당 전략과 연속으로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 을 실행하십시오 . 예를 들어 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; 은 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="34b863a511860977e79077de7a231a7aecf1ada7" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment</source>
          <target state="translated">수정 된 환경에서 계산 실행</target>
        </trans-unit>
        <trans-unit id="9074ee855e6397968c72ac1444df19911eaa577a" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 (더 일반적인 버전의 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ) 에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="9bad7ac26cf07893f9cefd43f5bb9c7a61a20d5d" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 (더 일반적인 버전의 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ) 에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="1c369096a8c214ef9f4515d93a67dbb9c70e723b" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 ( &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 전문화)에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="e148fe739f9c54b1accabc69b62a9d19fee91018" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수정 된 환경 ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 전문화)에서 계산을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="53f59c8f15736e3200571bde489e9c2748a0204d" translate="yes" xml:space="preserve">
          <source>Execute an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action, throwing a &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; if the predicate yields &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to the result returned by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. If no exception is raised, return the result of the computation.</source>
          <target state="translated">실행 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 를 던지는 행동을 &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; 을 술어가 산출하는 경우 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 결과에 적용 할 때 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 의 작업입니다. 예외가 발생하지 않으면 계산 결과를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="42c77fe8561e333489414079969807a39fd1e151" translate="yes" xml:space="preserve">
          <source>Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished.</source>
          <target state="translated">새 메모리 풀을 사용하여 작업을 실행합니다.이 작업은 작업이 완료된 후 내용을 포함하여 자동으로 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1262c3e03a483c6a9341f4b12dfc5bd8ac87a7c4" translate="yes" xml:space="preserve">
          <source>Executes a computation in a modified environment.</source>
          <target state="translated">수정 된 환경에서 계산을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8210b4609b3b832c81bcd8b6f74a6b3190413ae8" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">비동기 예외가 &lt;em&gt;마스크 된 상태&lt;/em&gt; 에서 IO 계산을 실행합니다 . 즉, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 스레드에서 예외를 발생시키려는 스레드는 비동기 예외가 다시 마스크 해제 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="46ec0e1cddb9075cc884b834b53f50ddc817ddcc" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</target>
        </trans-unit>
        <trans-unit id="60c9626b83b84fd2f338afec521f991b9505634c" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">&lt;em&gt;마스킹 된&lt;/em&gt; 비동기 예외를 사용하여 IO 계산을 실행합니다 . 즉, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 스레드에서 예외를 발생시키려는 모든 스레드는 비동기 예외가 다시 마스크 해제 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="778dbd9e9bf309d9af09860bc9150a182f094e04" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">비동기 예외가 &lt;em&gt;마스크 된 상태&lt;/em&gt; 에서 IO 계산을 실행합니다 . 즉, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 를 사용하여 현재 스레드에서 예외를 발생시키려는 스레드는 비동기 예외가 다시 마스크 해제 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt; ). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fbee69c7c6cc3983066537c6b9014eb13e8768e2" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. The syntax for file-name arguments respects shell quoting rules, i.e., file names containing spaces can be enclosed in double quotes or with spaces escaped with a backslash. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">일련의 GHCi 명령으로 파일의 행을 실행합니다. 파일 이름 인수의 구문은 쉘 인용 규칙을 따릅니다. 즉, 공백을 포함하는 파일 이름은 큰 따옴표로 묶거나 백 슬래시로 이스케이프 된 공백으로 묶을 수 있습니다. 이 명령은 &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt; 의해 설정된 여러 줄 문과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">파일의 행을 일련의 GHCi 명령으로 실행합니다. 이 명령은 &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt; 으로 설정 한 여러 줄 문장과 호환됩니다</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">쉘 명령 ⟨command⟩를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;IO String&lt;/code&gt; 유형의 계산으로 ⟨expr⟩ 을 실행 한 다음 결과 문자열을 GHCi 명령 목록으로 실행합니다. 여러 명령은 개행으로 구분됩니다. &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; 를&lt;/a&gt; 명령에 유용 &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">빌더 실행</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">외부 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">실행은 한 단계 씩 진행될 수 있습니다. 평가자는 거의 모든 축소 후에 실행을 일시 중단하여 로컬 변수를 검사 할 수 있습니다. 이는 프로그램의 모든 지점에서 중단 점을 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">실행은 평가 모드에서 발생하는 각 평가 단계를 기억하지만 실제 중단 점에 도달 할 때까지 실행을 중단하지 않는 추적 모드에서 실행될 수 있습니다. 이 경우 평가 단계 기록을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">중단 점에서 실행이 중지되었습니다. 프롬프트가 현재 중단 점에서 중지되었음을 표시하고 위치는 &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; 입니다. 위치를 더 명확히하기 위해 &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">실행 단계 마커</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">실행 전략</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">존재 테스트</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">iserv 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="cb193431524e4fae58710e9d90f4bc84b69056c1" translate="yes" xml:space="preserve">
          <source>ExitCaseAbort</source>
          <target state="translated">ExitCaseAbort</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">절대 파일 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">명시 &lt;code&gt;forall&lt;/code&gt; 항상 필요하지 않습니다 - 참조 &lt;a href=&quot;#pattern-equiv-form&quot;&gt;패턴 서명 해당하는&lt;/a&gt; 이 섹션의 예를 들면, 또는 &lt;a href=&quot;#pattern-type-sigs&quot;&gt;패턴 유형 서명을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">레이아웃 대신 명시 적 괄호와 세미콜론을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">명시 적 목록 (예 : &lt;code&gt;[True, False]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">명시 적으로 양방향</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">명시 적으로 양방향 패턴 동의어는 허용되는 구문 측면에서 암시 적으로 양방향 것보다 더 큰 유연성을 제공합니다. 예를 들어 다음은 법적으로 암시 적으로 양방향 패턴 동의어가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">명시 적으로과 관련된 finaliser 실행 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 . 종료 후이 값을 참조하면 유효하지 않은 메모리 참조가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">유형 수준의 자연의 지수.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">클래스 이름 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">클래스, 관련 유형 &lt;code&gt;GMap&lt;/code&gt; 및 멤버 함수를 &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;lookup&lt;/code&gt; 및 &lt;code&gt;insert&lt;/code&gt; 내보내기합니다 . 의 데이터 생성자 &lt;code&gt;GMap&lt;/code&gt; (이 경우 &lt;code&gt;GMapEither&lt;/code&gt; 는 ) 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">매우 크거나 재귀적인 기능에 대해서도 모든 전개를 공개하십시오.</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">id byunit-id⟩로 패키지 노출</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">패키지 노출 ⟨pkgpose</target>
        </trans-unit>
        <trans-unit id="81f3b1cdb0761f66a9a464a1c7c58d8507de68a8" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">패키지 ⟨pkg⟩를 노출하고 신뢰하지 않도록 설정합니다. &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">패키지 ⟨pkg⟩를 노출하고 불신으로 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11e656340a6337a3a218f8e6e5a6343ef2676dc0" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">패키지 ⟨pkg⟩를 노출하고 신뢰할 수 있도록 설정합니다. &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">⟨pkg⟩ 패키지를 공개하고 신뢰할 수 있도록 설정하십시오. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">플러그인을위한 ⟨pkg-id⟩ 노출</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">플러그인에 ⟨pkg⟩ 노출</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 플러그인 네임 스페이스에 패키지를 노출 하지만 패키지는 이름이 아닌 설치된 패키지 ID로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 플래그를 GHC에 전달합니다. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning 및 &lt;/a&gt;Renaming 모듈에 설명 된 Thinning 및 Renaming을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; 와 같은 패키지를 공개 하지만 패키지 이름은 이름이 아닌 단위 ID (즉 , 설치된 패키지 데이터베이스에있는 항목 의 &lt;code&gt;id&lt;/code&gt; 값 , 이전에 설치된 패키지 ID라고도 함)로 이름이 지정됩니다. 이는 패키지 이름을 지정하는보다 강력한 방법이며 섀도 잉 될 패키지를 선택하는 데 사용할 수 있습니다. Cabal은 &lt;code&gt;-package-id&lt;/code&gt; 플래그를 GHC에 전달합니다. &lt;code&gt;-package-id&lt;/code&gt; 는 &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning 및 Renaming 모듈에&lt;/a&gt; 설명 된 Thinning 및 Renaming을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟨pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수있는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">패키지 ⟩pkg⟩가 숨겨진 경우 노출하고 패키지 데이터베이스와 상관없이 신뢰할 수없는 패키지로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">표현식 인용은 대부분의 Haskell 언어 구문을 허용합니다. 그러나 표현식 인용이 현재 지원하지 않는 일부 GHC 특정 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">표현식 스플 라이스 : 익명 및 명명 된 와일드 카드를 표현식 서명에 사용할 수 있습니다. 정규식 서명과 마찬가지로 추가 제약 조건 와일드 카드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c356f5e7e4d5da3fa92f3a447cf549c220408dd" translate="yes" xml:space="preserve">
          <source>Expression type annotations</source>
          <target state="translated">식 유형 주석</target>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">식 평가 모드. 이것은 명령 행에 주어진 단일 표현식 (evaluateexpr⟩)이 있다는 점을 제외하고는 대화식 모드와 매우 유사합니다. 자세한 내용은 &lt;a href=&quot;#eval-mode&quot;&gt;식 평가 모드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">정교하게 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">확장 된 유클리드 알고리즘.</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 의 확장 버전</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">새로운 유형으로 확장</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">원 자성을 여러 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 로 확장하는 것은 문제가 있으므로 더 복잡한 작업을 수행해야하는 경우 대신 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">확장 가능한 예외</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">GHC의 Handle 구현을위한 외부 API</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 속성</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 속성</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">XHTML 프레임 셋의 추가 요소</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">XHTML Transitional의 추가 요소</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 생성 및 실행을위한 추가 기능 . 그것들은 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 의 성능을 응용 프로그램별로 미세 조정하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">추가 인스턴스</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">명령 행에서 normal &lt;code&gt;-llib&lt;/code&gt; 옵션을 사용하여 추가 라이브러리를 지정할 수 있습니다 . 여기에서 라이브러리 라는 용어 는 외부 객체 코드의 &lt;em&gt;라이브러리&lt;/em&gt; 를 의미합니다. Haskell 소스 코드의 라이브러리를 사용하려면 &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;모듈과 파일 이름을&lt;/a&gt; 참조하십시오 . 예를 들어 &quot;m&quot;라이브러리를로드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">추가 제약 조건 와일드 카드는 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추출 &lt;em&gt;N&lt;/em&gt; 번째의 (0- 기반) 사지 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; . &lt;em&gt;n&lt;/em&gt; 은 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; 의해보고 된대로 size보다 작아야합니다 .</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 을 추출하고 이에 대한 조치를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</target>
        </trans-unit>
        <trans-unit id="e1fa28e22bcf37a9620ff9632c0178f62249b64b" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 을 추출하고 이에 대한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 에서 호출 사이트 목록을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">두 가지 유형의 평등의 증거를 추출</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치의 단어에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 16 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 32 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">마스크로 지정된 위치에서 워드의 하위 8 비트에서 비트를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">적용된 유형의 동등성에서 인수의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">적용된 형식의 동등성에서 형식 생성자의 동등성을 추출</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 제외한 모든 것을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">비율의 분모를 축소 된 형태로 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">쌍의 첫 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">스트림의 첫 번째 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">스트림의 마지막 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">오류 메시지에서 메시지 문자열 추출</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">축소 된 형태로 비율의 분자를 추출하십시오. 분자와 분모는 공통 인자가 없으며 분모는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">라이터 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">누적 계산에서 출력을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">스트림의 비어있는 꼬리를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">쌍의 두 번째 구성 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="048e8268764c5263423031088d1cd0a66e5df985" translate="yes" xml:space="preserve">
          <source>Extract the untyped representation from the typed representation</source>
          <target state="translated">유형이 지정된 표현에서 유형이 지정되지 않은 표현을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">분수 성분 추출</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">서브리스트 추출</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">예외 모나드에서의 계산을위한 추출기. (를 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 반대 ).</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">누적 오류가있는 계산을위한 추출기.</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모두 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">목록에서 추출 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소. 모든 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 요소가 순서대로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 를 추출합니다 . 이 함수는 필요한 경우 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫고 쓰기 버퍼를 비우는 부작용이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; . This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</target>
        </trans-unit>
        <trans-unit id="12df19590e3fea55c64fb5d4077a86cd9854c08f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 를 추출합니다 . 이 함수는 필요한 경우 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫고 쓰기 버퍼를 플러시 하는 부작용이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">불변 배열의 경계를 추출합니다</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">소스 위치에서 열 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">복소수의 허수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">소스 위치에서 라인 번호를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">구문 분석 오류에서 오류 메시지 목록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">소스 위치에서 소스 이름을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">복소수의 실수 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">구문 분석 오류에서 소스 위치를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">F. Lundh : 빠른 검색 알고리즘. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">동시성을 사용하거나 필요로하는 FFI 데이터 유형 및 작업 (GHC 만 해당)</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">FFI 지원은 기본적으로 활성화되어 있지만 &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 명시 적으로 활성화하거나 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">SimpleMAPI와 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">Win32 보안과 상호 작용하는 FFI 바인딩</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">위에서 설명한 문제에 직면하여 일부 Haskell 프로그래머는 다음 버전의 클래스 선언과 같은 것을 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">실패는 실패의 원인 / 위치에 대한 정보를 기록합니다. 실패 값은 바운드 함수를 우회하고 다른 값은 바운드 함수의 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">패밀리 인스턴스는 클래스 인스턴스와 마찬가지로 암시 적으로 내보내집니다. 그러나 이것은 인스턴스의 헤드에만 적용되며 인스턴스가 정의한 데이터 생성자에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">팬인 : 두 개의 인수 화살표 사이에서 입력을 나누고 출력을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">팬 아웃 (Fanout) : 입력을 양쪽 화살표로 보내고 출력을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">기본 2에 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 빠른 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 로그 : integerLog2 # 및 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; 는 일반적으로 유용하며 나머지는 &lt;code&gt;fromRational&lt;/code&gt; 의 빠른 구현에만 필요합니다 . 그것들은 &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt; 에 필요 하므로이 모듈을 공개해야하지만 문서에는 표시되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">시스템 시계에 빠르게 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">빠른 문자 조작 기능.</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 에 대한 빠른 하위 문자열 검색 .</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">Boyer, Moore, Horspool, Sunday 및 Lundh의 작업을 기반으로 한 게으른 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 대한 빠른 하위 문자열 검색 . 엄격한 구현에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">빠르고 확인되지 않은 비트 시프 팅 기능.</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 가진 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 를 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="69e3b2b59aa4aebef05a2ee1ed5b935914ea9021" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="99b4648ed500c37b8a76ac1f7c07fc6a62b9d886" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">더 많은 입력을 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 공급하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 되어 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 가에 입력을 추가합니다 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사용되지 않은 입력.</target>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">인수 화살표를 통해 표시된 입력을 공급하고 나머지는 변경되지 않은 채로 출력에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">모나드 내 상태의 현재 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">환경의 가치를 이끌어냅니다.</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">가장 접근하기 어려운 절</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">가장 적은 중복 조항</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">가장 적발 된 조항</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="translated">Field CapNo</target>
        </trans-unit>
        <trans-unit id="03ded020bc6474da975890833ccd8f148e8a07d9" translate="yes" xml:space="preserve">
          <source>Field CapNo:</source>
          <target state="translated">필드 캡</target>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="translated">Field CapSetId</target>
        </trans-unit>
        <trans-unit id="fac78598db657aa0c38e0a7b064e261405764b90" translate="yes" xml:space="preserve">
          <source>Field CapSetId:</source>
          <target state="translated">필드 CapSetId :</target>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="translated">Field String</target>
        </trans-unit>
        <trans-unit id="a62e5ff1d5e101aeed17e5d052a10aaa3017be5b" translate="yes" xml:space="preserve">
          <source>Field String:</source>
          <target state="translated">필드 문자열 :</target>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="translated">Field TaskId</target>
        </trans-unit>
        <trans-unit id="a3803a8cbdbe813e945dd95bbdc4dffab8ccbfd7" translate="yes" xml:space="preserve">
          <source>Field TaskId:</source>
          <target state="translated">필드 TaskId :</target>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="translated">Field ThreadId</target>
        </trans-unit>
        <trans-unit id="c3a47467c208f9af64bcfa1d0225564748d7312c" translate="yes" xml:space="preserve">
          <source>Field ThreadId:</source>
          <target state="translated">필드 ThreadId :</target>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="translated">Field Word16</target>
        </trans-unit>
        <trans-unit id="cbcfd83bc4c9e590b27d81c7a0808713eab58ee9" translate="yes" xml:space="preserve">
          <source>Field Word16:</source>
          <target state="translated">필드 Word16 :</target>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="translated">Field Word32</target>
        </trans-unit>
        <trans-unit id="42f1a115395af35bce115c6c82b59e4a4a5087fa" translate="yes" xml:space="preserve">
          <source>Field Word32:</source>
          <target state="translated">필드 Word32 :</target>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="translated">Field Word32[]</target>
        </trans-unit>
        <trans-unit id="e59e9060dc4635660cb6bfaff4355ba8a486745a" translate="yes" xml:space="preserve">
          <source>Field Word32[]:</source>
          <target state="translated">필드 Word32 [] :</target>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="translated">Field Word64</target>
        </trans-unit>
        <trans-unit id="7cbbdf7e0b7dfdebe7dfe21d03bf00d60a18f320" translate="yes" xml:space="preserve">
          <source>Field Word64:</source>
          <target state="translated">필드 Word64 :</target>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="translated">Field Word8</target>
        </trans-unit>
        <trans-unit id="bb7b88f825a8de27b63373e28f7a77a5b201a208" translate="yes" xml:space="preserve">
          <source>Field Word8:</source>
          <target state="translated">필드 Word8 :</target>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="translated">Field [String]</target>
        </trans-unit>
        <trans-unit id="2a2dd2f21d7d7ea1bc52b694a50f6bf5a257e793" translate="yes" xml:space="preserve">
          <source>Field [String]:</source>
          <target state="translated">필드 [문자열] :</target>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">필드 명확성 제거는 punning과 결합 될 수 있습니다 (Puns &lt;a href=&quot;#record-puns&quot;&gt;기록&lt;/a&gt; 참조 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f697941f4e61d5357bc8e695debb7df5928ebe4" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">필드 명확성은 punning과 결합 될 수 있습니다 ( &lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt; 참조 ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">선택기 기능 또는 레코드 업데이트에 사용되는 필드 이름은 범위에 해당 필드가 하나뿐이거나 다음 섹션에 설명 된대로 유형 서명이 제공되므로 모호하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9a36bac12f2598c38413b503ceea750d14ea1043" translate="yes" xml:space="preserve">
          <source>Field selectors can be used in conjunction with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;. The type of a field selector is constructed by using the surrounding definition as context. This section provides a specification for how this construction works. We will explain it by considering three different forms of field selector, each of which is a minor variation of the same general theme.</source>
          <target state="translated">필드 선택기는 &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible 유형 응용 프로그램에&lt;/a&gt; 설명 된대로 &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 . 필드 선택기의 유형은 주변 정의를 컨텍스트로 사용하여 구성됩니다. 이 섹션에서는이 구성이 작동하는 방식에 대한 사양을 제공합니다. 우리는 세 가지 다른 형태의 필드 선택기를 고려하여 설명 할 것입니다. 각각은 동일한 일반 주제의 사소한 변형입니다.</target>
        </trans-unit>
        <trans-unit id="ebd7785607bbf364d54013deccebdf1687696229" translate="yes" xml:space="preserve">
          <source>Field selectors for GADT constructors (&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;) are slightly more involved. Consider the following example:</source>
          <target state="translated">GADT 생성자에 대한 필드 선택자 ( &lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;명시 적 생성자 서명으로 데이터 유형 선언&lt;/a&gt; )는 약간 더 관련이 있습니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">필드는 모호하지 않은 경우에만 선택기 함수로 사용될 수 있으므로 &lt;code&gt;S(x)&lt;/code&gt; 및 &lt;code&gt;T(x)&lt;/code&gt; 가 모두 범위에있는 경우 여전히 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 환경 변수의 경우 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; 이&lt;/a&gt; ⟨name⟩로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 이 옵션을 통과하면 &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">파일 &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; 은 현재 디렉토리 또는 상위 디렉토리 (그러나 사용자의 홈 디렉토리)에있는 경우.</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">파일 할당</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; , whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</target>
        </trans-unit>
        <trans-unit id="bd52e06d55d1bf7bfbc10d5c00841d3fab42c29d" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 정확한 의미가 운영 체제에 따라 달라지는 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값입니다 . 파일을 열고 해당 파일의 내용을 처리하는 데 사용할 수있는 핸들을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">파일 및 디렉토리 이름은 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 유형의 값이며 정확한 의미는 운영 체제에 따라 다릅니다. 파일을 열어 핸들을 만들어 해당 파일의 내용을 조작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">닫을 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">파일 확장자 문자</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">파일 잠금</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">파일 모드 (예 : 권한).</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">파일 이름 조작</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">파일 이름 템플릿. 템플리트가 &quot;foo.ext&quot;인 경우 작성된 ​​파일은 &quot;fooXXX.ext&quot;이며 여기서 XXX는 임의의 숫자입니다. 여기에는 경로 구분 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">&quot;의미있는&quot;접미사 (예 : &lt;code&gt;.lhs&lt;/code&gt; 또는 &lt;code&gt;.o&lt;/code&gt; )가 있는 파일 이름은 해당 파일에 &quot;올바른 일&quot;이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">파일 옵션</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">파일 상태</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">파일 동기화</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">환경 변수 &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt; 가 ⟨file⟩ 으로 설정된 경우 ⟨file⟩ 파일 .</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt; 옵션을 전달하면 ⟨file⟩ 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">파일 헤더 프라그 마는 파일을 사전 처리하기 전에 한 번만 읽습니다 (예 : cpp).</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">파일 이름 완성</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">(일반적으로 도트 (있는 경우 포함) 실행 파일의 파일 이름 확장자 &lt;code&gt;&quot;&quot;&lt;/code&gt; POSIX 시스템 및 &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; Windows 또는 OS / 2).</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">실행 파일 이름 (자세한 내용은 &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">파일 이름 / 디렉토리 기능</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">파일과 핸들</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">다른 접미사가있는 (또는 접미사가없는) 파일은 링커로 바로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 사용하여 BufferRange 를 채우 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">메모리 영역의 지정된 바이트 수를 바이트 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">필요한 값으로 메모리 영역 채우기</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 조치를 사용하여 다른 맵에서 키가 누락 된 항목을 필터링하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</target>
        </trans-unit>
        <trans-unit id="296c67f523b9ac6e28bfc4ebfa4d796103625519" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">일부 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 조치를 사용하여 다른 맵에서 키가 누락 된 항목을 필터링하십시오 .</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="86fec396e3e13493b2a91cd89771fd664be0f9b3" translate="yes" xml:space="preserve">
          <source>FinalPtr</source>
          <target state="translated">FinalPtr</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">최종 데이터 포인터</target>
        </trans-unit>
        <trans-unit id="4654b2a5f2578ac85eb620c7f87d7844f6e0bb05" translate="yes" xml:space="preserve">
          <source>Finalization</source>
          <target state="translated">Finalization</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">마무리 수단 (A)에 대한 후속 호출 준비 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 의 반환 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ; (b) 종료자를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">약한 포인터를 완성하십시오. 반환 값은 새로운 세계 상태와 &quot;unboxed Maybe&quot;를 포함하는 Unboxed 튜플이며 &lt;code&gt;Int#&lt;/code&gt; 및 (아마도 잘못된) 마무리 작업으로 표시됩니다. &lt;code&gt;Int#&lt;/code&gt; 의 &lt;code&gt;1&lt;/code&gt; 이 종료 자이 유효 함을 나타냅니다. 종료 기의 반환 값 &lt;code&gt;b&lt;/code&gt; 는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">Finalizer &lt;em&gt;는&lt;/em&gt; 명시 적으로 만들어지고 &lt;code&gt;IORef&lt;/code&gt; 및 &lt;code&gt;MVar&lt;/code&gt; 와 같은 ID를 가진 유형에 안정적으로 사용될 &lt;em&gt;수&lt;/em&gt; 있습니다 . 그러나 이러한 유형 중 하나에 종료자를 배치하려면 해당 유형에 제공된 특정 조작 (예 : &lt;code&gt;mkWeakIORef&lt;/code&gt; 및 &lt;code&gt;addMVarFinalizer&lt;/code&gt; )을 사용해야 합니다 (비 균일 성은 우연이 아닙니다). 이러한 작업 은 외부 상자가 컴파일러에 의해 최적화 될 때 종료자를 상자 자체에 연결하지 못하기 때문에 상자 내부의 기본 객체 (예 : &lt;code&gt;MutVar#&lt;/code&gt; 의 경우 MutVar # ) 에 &lt;code&gt;IORef&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="521c7faf6958e48a574367992f9c07725b55b76b" translate="yes" xml:space="preserve">
          <source>Finalizers are all C functions.</source>
          <target state="translated">종료자는 모두 C 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ce238574b6a6dbcd2a65c4596886dabb147b08b1" translate="yes" xml:space="preserve">
          <source>Finalizers are all Haskell functions.</source>
          <target state="translated">종료자는 모두 Haskell 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">마지막으로, GHC는 제약 조건 해결이 완료된 후 &lt;code&gt;tcPluginStop&lt;/code&gt; 을 호출 하여 플러그인이 할당 한 모든 자원을 처리 할 수 ​​있도록합니다 (예 : SMT 솔버 프로세스 종료).</target>
        </trans-unit>
        <trans-unit id="cc10bc2ea70467315012d5ca45b95d793b626303" translate="yes" xml:space="preserve">
          <source>Finally, after the &lt;code&gt;interruptible&lt;/code&gt; foreign call returns into Haskell, the Haskell code should allow exceptions to be raised (&lt;code&gt;Control.Exception&lt;/code&gt;&amp;lsquo;s &lt;code&gt;allowInterrupt&lt;/code&gt;, or &lt;code&gt;interruptible yield&lt;/code&gt; for non-&lt;code&gt;-threaded&lt;/code&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ghc/issues/8684&lt;/a&gt;), and implement the &lt;code&gt;EINTR&lt;/code&gt;-retrying in Haskell (e.g. using e.g. &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;).</source>
          <target state="translated">마지막으로 &lt;code&gt;interruptible&lt;/code&gt; 외래 호출이 Haskell로 반환 된 후 Haskell 코드는 예외가 발생하도록 허용해야합니다 ( &lt;code&gt;Control.Exception&lt;/code&gt; 의 &lt;code&gt;allowInterrupt&lt;/code&gt; 또는 &lt;code&gt;-threaded&lt;/code&gt; 가 아닌 경우 &lt;code&gt;interruptible yield&lt;/code&gt; 참조, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ 참조). ghc / issues / 8684&lt;/a&gt; ), Haskell 에서 &lt;code&gt;EINTR&lt;/code&gt; 재 시도를 구현합니다 (예 : &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">마지막으로, &lt;code&gt;readFile'&lt;/code&gt; 예제 의 예외 안전 변형이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">마지막으로 &lt;code&gt;-main-is&lt;/code&gt; 플래그 또는 &lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 다른 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="translated">Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; . In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">마지막으로 &lt;code&gt;Just&lt;/code&gt; 결과가 맵으로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="3ed43b18c0eb498b61dd7767854552765f4cd553" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; returns the pairs &lt;code&gt;(b, s)&lt;/code&gt; and &lt;code&gt;(c, s)&lt;/code&gt;. For monad transformers other than &lt;code&gt;StateT&lt;/code&gt;, this will be some other type representing the effects and values performed and returned by the &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; actions. The effect part of the &lt;code&gt;use&lt;/code&gt; result, in this case &lt;code&gt;_s2&lt;/code&gt;, usually needs to be discarded, since those effects have already been incorporated in the &lt;code&gt;release&lt;/code&gt; action.</source>
          <target state="translated">마지막으로 &lt;code&gt;generalBracket&lt;/code&gt; 의 &lt;code&gt;m&lt;/code&gt; 구현은 &lt;code&gt;(b, s)&lt;/code&gt; 및 &lt;code&gt;(c, s)&lt;/code&gt; 쌍을 반환합니다 . &lt;code&gt;StateT&lt;/code&gt; 이외의 모나드 변환기 의 &lt;code&gt;use&lt;/code&gt; 이는 사용 및 &lt;code&gt;release&lt;/code&gt; 작업에 의해 수행되고 반환되는 효과 및 값을 나타내는 다른 유형 입니다. &lt;code&gt;use&lt;/code&gt; 결과 의 효과 부분 ( 이 경우 &lt;code&gt;_s2&lt;/code&gt; )은 해당 효과가 이미 &lt;code&gt;release&lt;/code&gt; 작업에 통합되었으므로 일반적으로 버려야 합니다.</target>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">마지막으로 &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ 옵션 은 컴파일러 생성 중간 C 파일 의 &lt;code&gt;.hc&lt;/code&gt; 파일 접미사를 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="5463d0aeddf364c8fd3a47a2799ef56cd3b82670" translate="yes" xml:space="preserve">
          <source>Finally, there's one more special case, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt;, which can short-circuit when the monad &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, and the operator invokes &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마지막으로, 모나드 &lt;code&gt;m&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 이고 연산자가 &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt; 를 호출 할 때 단락 될 수있는 특별한 경우 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt; 이 하나 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">마지막으로 현재 실행을 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">마지막으로 단일 문자와 일치하는 기본 파서가 필요합니다.이 파서에서 임의로 복잡한 파서를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">마지막으로 디코더를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">대상 제약 조건 &lt;em&gt;과 일치&lt;/em&gt; 하는 모든 인스턴스 \ (I \)를 찾습니다 . 즉, 대상 제약 조건은 \ (I \)의 대체 인스턴스입니다. 이러한 인스턴스 선언이 &lt;em&gt;후보&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">해결되지 않은 모든 구속 조건을 찾으십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">나무의 깊이를 찾으십시오. 즉, 나무의 뿌리에서 가장 먼 잎까지의 가지 수 :</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">파일에 대한 시스템 별 제한 찾기</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">문자열에서 하위 문자열의 모든 (중복 될 수있는) 어커런스의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="113e5a7f7ef4741af748a8e459880c7c315f837d" translate="yes" xml:space="preserve">
          <source>Find the indices of all non-overlapping occurences of a substring in a string.</source>
          <target state="translated">문자열에서 하위 문자열이 겹치지 않는 모든 항목의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">트리에서 최대 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">형식은 그 사람 찾기 &lt;code&gt;(C a)&lt;/code&gt; 여기서 &lt;code&gt;a&lt;/code&gt; 형태 변수이며, 일반적인 유형의 변수 공유 그룹으로 그 제약을 분할 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">길이 찾기</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">회선 지향 사용자 상호 작용 세션을 완료하고 정리하십시오. &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 에 대한 기존 호출을 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">유한 그래프</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">유한 Int지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">유한 Int지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">유한 Int 세트</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">유한지도 (게으른 인터페이스)</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">유한지도 (엄격한 인터페이스)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">유한 세트</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">유한 시퀀스</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">첫 번째 인수는 후행 0을 잘라낼 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">결과의 첫 번째 성분은 &lt;code&gt;log2 n&lt;/code&gt; 이고 두 번째는 &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; 은 2의 거듭 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">첫 번째 목적지의 오프셋 (offset) &lt;em&gt;되지&lt;/em&gt; 사본 (즉, &lt;em&gt;하지&lt;/em&gt; 길이)</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">주어진 정량화되지 않은 제약 조건 &lt;code&gt;C t&lt;/code&gt; 가 있는지 확인하십시오 . 그렇다면 제약 조건을 해결하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">먼저 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 를 가져옵니다 . 이것은 안전하지 않은 모듈이지만 &lt;code&gt;M&lt;/code&gt; 은 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 로 컴파일 되었으므로 &lt;code&gt;P&lt;/code&gt; 의 작성자는 해당 가져 오기를 담당합니다. &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 저자를 신뢰하므로이 수입은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="translated">First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt; . This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt; &amp;rsquo;s author, so this import is fine.</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">먼저, 모듈을 GHCi에로드하십시오 :</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">먼저 정의 된 매크로에서 이름과 정확히 일치하는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">첫째, 이전에는 불가능했던 해상도를 종료 할 수 있습니다. 예를 들어 일반 장미 데이터 유형에 대한 다음 인스턴스 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">고정 크기 빌더 기본 요소</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">고정 크기 프리미티브</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">고정 너비 16 진수</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">데이터 생성자와 마찬가지로 형식 생성자 또는 클래스에 대한 고정도를 선언 할 수 있습니다. 그러나 고 정성 선언에서 둘을 구별 할 수는 없습니다. 고 정성 선언은 데이터 생성자와 해당 유형 생성자의 고 정성을 설정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">고정 선언은 Haskell에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">정착 성 조회</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">생성자의 고정</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">고정, 유형 동의어, 개방형 / 데이터 패밀리 선언은 일반적인 Haskell에서와 같이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">&quot;중지 후&quot;라고 말하는 깃발</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; 의 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 에 대한 플래그입니다 . 공지 사항 그 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 특정 플랫폼에서 사용하지 못할 수 있습니다! &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">다양한 서브 시스템에서 디버깅 출력 및 추가 검사를 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">엄격한 생성자 필드 병합</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포인터 크기의 표현으로 엄격한 생성자 필드를 병합합니다. &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="e4ccb090ca696917e5de23363132c4238087f15c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">뒤집힌 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aa9a79151c09f2b1c44f8f5b45f86e26536f4e8" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">뒤집힌 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12167983d0afff206c046e1d6d922143291d5f3e" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뒤집힌 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd78f746eff5d069a4c69da8e38598e4dcbf4a4c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뒤집힌 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a015af1d71e496c444ce3c462d153241cce86f16" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">뒤집힌 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dafc2e8e7144d1472eedd451318a1d1537aeb13" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">뒤집혀 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f081d19b6a1634db731d6fc797a0dd377b306de" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">뒤집혀 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전 .</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 의 뒤집힌 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">플로팅 렛 바인딩은 바인딩 사이트에 가깝습니다. 참조 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;하자 - 부동 : 바인딩을 이동하는 빠른 프로그램 (ICFP'96)을 얻었다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="translated">Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">플로트 방법</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">float / Int 변환, 랩핑 된 primops</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">플로팅 타입</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">제공된 쓰기 버퍼의 모든 데이터를 장치로 플러시합니다. 리턴 된 버퍼는 비어 있어야하며 쓰기 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; 의 버퍼를 비 웁니다 (있는 경우) . &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">제공된 쓰기 버퍼의 데이터를 차단하지 않고 장치로 플러시합니다. 쓴 바이트 수와 나머지 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">현재 버퍼를 비 웁니다. 이것은 청크 경계를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">버퍼 상태 플러시</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">암시 적 구문 분석 상태 플러시</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">monoid를 사용하여 목록을 접으십시오.</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">트리를 깊이 우선 순서대로 &quot;요약&quot;값으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">접어 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 대소 현명한 단지처럼 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 접습니다.</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="37d91c80ee36726ccf43b2e7f00be807a7045256" translate="yes" xml:space="preserve">
          <source>Foldable structures are reduced to a summary value by accumulating contributions to the result one element at a time.</source>
          <target state="translated">접을 수있는 구조는 한 번에 한 요소 씩 결과에 대한 기여를 누적하여 요약 값으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">접는 동작</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">접기 및 순회</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">키 증가 순서로 접습니다.</target>
        </trans-unit>
        <trans-unit id="8bd6a5b4641abf50c3fa996016c263fddb09d728" translate="yes" xml:space="preserve">
          <source>Folds of unbounded structures do not terminate when the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator is strict:</source>
          <target state="translated">제한되지 않은 구조의 접기는 monoid의 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 연산자가 엄격 할 때 종료되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">마크 존스 (Mark Jones)의 제안에 따라, 그의 논문은 &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Haskell에있는 Haskell 타이핑에서&lt;/a&gt; 보다 일반적인 체계를 구현합니다. GHC &lt;em&gt;에서 종속성 분석은 명시 적 유형 서명이있는 변수에 대한 참조를 무시합니다.&lt;/em&gt; . 이 세분화 된 종속성 분석의 결과로 종속성 그룹이 더 작아지고 더 많은 바인딩이 유형 검사됩니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">ISO-10646 표준에 따라 &lt;code&gt;maxBound :: Char&lt;/code&gt; GHC의 Char 는 &lt;code&gt;0x10FFFF&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt; 의 권장 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="24f8eb6fedbc854f6eb4756da6cd5c7a8c568aea" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt; 의 권장 사항을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="31d946127399c2228b066615f8fa0d54aa0a373b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt;, the &lt;em&gt;non-deterministic&lt;/em&gt; behaviour of &lt;code&gt;List&lt;/code&gt; is most easily seen in the case of a list of lists (of elements of some common fixed type). The result is a cross-product of all the sublists:</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 의 &lt;em&gt;비 결정적&lt;/em&gt; 의 행동 &lt;code&gt;List&lt;/code&gt; 가장 쉽게 (일반적인 고정 유형의 요소) 목록 목록의 경우에서 볼 수있다. 결과는 모든 하위 목록의 외적입니다.</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">들면 및 &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; , 그들의 최대 공약수를 계산 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; 및 계수 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 만족 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; + &lt;em&gt;B &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g을&lt;/em&gt; . &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffDays&lt;/code&gt; (및 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;CalendarDiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">들어 &lt;code&gt;Day&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">를 들면 &lt;code&gt;DayOfWeek&lt;/code&gt; (및 &lt;code&gt;Day&lt;/code&gt; 와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;LocalTime&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;NominalDiffTime&lt;/code&gt; 및 &lt;code&gt;DiffTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeOfDay&lt;/code&gt; (와 &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;UniversalTime&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">대한 &lt;code&gt;TimeZone&lt;/code&gt; (그리고 &lt;code&gt;ZonedTime&lt;/code&gt; 및 &lt;code&gt;UTCTime&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">대한 &lt;code&gt;UTCTime&lt;/code&gt; 하고 &lt;code&gt;ZonedTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용 &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; 및 &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 는 동의어이다 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">POSIX 사용자의 경우 이는 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">양방향 패턴 동의어의 경우, 패턴 동의어를 표현식으로 사용하는 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">클래스의 경우 모든 유형 변수는 종류로 주석을 달아야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">복소수를 들어 &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; 의 크기를 갖는 수이고 &lt;code&gt;z&lt;/code&gt; 반면, 그러나 실제 양 방향으로 배향 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 의 위상 갖는다 &lt;code&gt;z&lt;/code&gt; 하지만 단위 크기를.</target>
        </trans-unit>
        <trans-unit id="bde3bc31dcf2451837a45deb22082c15149b6c7b" translate="yes" xml:space="preserve">
          <source>For a comprehensive listing of supported platforms, please refer to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;</source>
          <target state="translated">지원되는 플랫폼의 전체 목록은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; : 최상위 레벨이있는 ​​데이터 유형의 경우 &lt;code&gt;::&lt;/code&gt; : 명시 적으로 정량화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">데이터 유형의 경우 모든 유형 변수는 종류로 주석을 달아야합니다. GADT 스타일 선언에는 종류 서명 ( 헤더에 최상위 수준 &lt;code&gt;::&lt;/code&gt; 이 있음)이있을 수도 있지만이 주석의 존재 여부는 선언에 완전한 서명이 있는지 여부에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">자세한 설명은 Levent Erkok의 논문, Monadic &lt;em&gt;Computations의 가치 재귀를&lt;/em&gt; 참조하십시오.&lt;em&gt;&lt;/em&gt; , Oregon Graduate Institute, 2002를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; 에서 사용되는 알고리즘의 전체 사양 은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;이 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">완전한 작동 예제 는 GHC 소스 트리에서 &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4c2f154344db246f733b27e08b4fac32576674c" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 다음과 의미 상 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 의미 적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb1a2ffe8319962a0d9758d8d5c92f844737e908" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">일반적인 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 구조의 경우 다음과 의미 상 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">주어진 힙 크기 ( &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 옵션 사용)의 경우 압축은 실제로 더 적은 GC를 수행함으로써 GC 비용을 줄일 수 있습니다. 이는 라이브 데이터 대 힙 크기의 비율이 높을 때 (예 : 30 % 이상) 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">실제 파일에 첨부 된 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 해당 파일의 크기를 8 비트 바이트로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">람다 바운드 또는 케이스 바운드 변수 x의 경우, 프로그래머는 x에 대해 명시적인 다형성 유형을 제공하거나 GHC의 유형 유추는 x의 유형에 그에 대한 전제가 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">모나 딕 버전은 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt; , all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</target>
        </trans-unit>
        <trans-unit id="4d8cf6ad049da3ffe486c394fe0bd5021d502284" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">newtype의 경우 &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 를 사용 하지 않는 한 규칙 은 데이터 유형과 동일 합니다. 함께 &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; 종류 서명이있는 경우, 입력 생성자 만 CUSK있다. 최고 수준의 데이터 타입과 마찬가지로 &lt;code&gt;::&lt;/code&gt; 후, 모든 종류의 변수를 도입 &lt;code&gt;::&lt;/code&gt; 명시 적으로 정량화해야</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">일반 &lt;code&gt;foreign export&lt;/code&gt; 의 경우 &lt;code&gt;M_stub.h&lt;/code&gt; 파일 에는 외국 수출 기능에 대한 C 프로토 타입이 포함됩니다. 예를 들어 다음 모듈을 컴파일하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">다품종 유형 군의 경우 유형과 유형이 다른지 확인합니다. 예를 들어 다음이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">읽기 전용 상태는 &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">읽을 수있는 핸들 &lt;code&gt;hdl&lt;/code&gt; 의 경우 , &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 은 &lt;code&gt;hdl&lt;/code&gt; 또는 실제 파일에 대한 추가 입력을 가져올 수없는 경우 현재 I / O 위치가 파일 길이와 같으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">인터페이스가 동일한 엄격한 버전은 &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">형식 동의어의 경우 모든 형식 변수와 결과 형식에 모두 종류가 주석으로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">단방향 레코드 패턴 동의어의 경우 레코드 선택기를 정의하지만 레코드 업데이트 또는 구성은 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">예외 값 범위를 허용하는 변형에 대해서는 &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">결과를 무시하는 버전은 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;지도 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 사용되는 기능에 대한 연습은 해당 &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;세트 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">모든 유형에 대해 (이 세 가지는 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 가 아니라 formatTime 에 의해 &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">거의 모든 현명한 프로그램의 경우 버그를 나타내며 다음과 같이 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">&quot;포장 할 수없는&quot; &lt;code&gt;U(...)&lt;/code&gt; 인수의 경우 내부 정보는 해당 구성 요소의 엄격 성을 알려줍니다. 따라서 인수가 쌍이고 &lt;code&gt;U(AU(LSS))&lt;/code&gt; 라고 표시되면 라고 표시되면&amp;ldquo;쌍의 첫 번째 구성 요소가 사용되지 않습니다. 두 번째 구성 요소는 세 개의 구성 요소 (첫 번째는 게으르고 두 번째 \ &amp;amp; 세 번째는 엄격함)로 포장 할 수 없습니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d1cb9e82bcd8a245aaf6652f2e48d70c05a6dea5" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; and a Traversable functor &lt;strong&gt;&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;, the type signatures of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; are rather similar:</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 펑의 &lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt; 및 통과 가능한 펑터 &lt;strong&gt; &lt;code&gt;t&lt;/code&gt; &lt;/strong&gt; , 유형의 서명 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 함수는 다소 유사하다 :</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">들어 &lt;em&gt;인코딩의 효율적인 구현&lt;/em&gt; , (a) 약간의 시간이 결과 바이트 시퀀스 하스켈 값 변환에 소요되는 것이 중요 &lt;em&gt;하고&lt;/em&gt; 생성 된 시퀀스의 표현이 효율적으로 소비 될 수있는 것을 (b). &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 (a) O (1) 연결 연산과 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 기타 표준 Haskell 값에 대한 기본 인코딩의 효율적인 구현을 제공하여 지원 합니다. 그들은 (b) 결과를 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 제공함으로써 내부적 으로 연속 된 원시 메모리 &lt;em&gt;청크&lt;/em&gt; 에 대한 포인터의 링크 된 목록입니다 . 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 파일에 쓰거나 네트워크 소켓을 통해 전송하는 기능에 의해 효율적으로 사용될 수 있습니다. 각 청크 경계는 청크 본문을 소비하는 데 소비 된 작업에 대해 상환되어야하는 값 비싼 추가 작업 (예 : 시스템 호출)을 발생시킵니다. 그러므로 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 평균 청크 크기가 충분히 커지도록 특별한주의를 기울입니다. 충분히 큰 의미는 응용 프로그램에 따라 다릅니다. 현재 구현은 4kb에서 32kb 사이의 평균 청크 크기로 조정되며 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; , which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</target>
        </trans-unit>
        <trans-unit id="3496a2b758ef763c20485808c9274b5b6efa235b" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">들어 &lt;em&gt;인코딩의 효율적인 구현&lt;/em&gt; , (a) 약간의 시간이 결과 바이트 시퀀스 하스켈 값 변환에 소요되는 것이 중요 &lt;em&gt;하고&lt;/em&gt; 생성 된 시퀀스의 표현이 효율적으로 소비 될 수있는 것을 (b). &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 O (1) 연결 연산과 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 및 기타 표준 Haskell 값에 대한 기본 인코딩의 효율적인 구현을 제공하여 (a)를 지원 합니다. 그들은 결과를 lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 으로 제공함으로써 (b)를 지원합니다 . 이는 내부적 으로 연속적인 원시 메모리 &lt;em&gt;청크&lt;/em&gt; 에 대한 포인터의 링크 된 목록입니다 . 게으른 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; s는 파일에 쓰거나 네트워크 소켓을 통해 보내는 함수에서 효율적으로 사용할 수 있습니다. 각 청크 경계는 청크 본문을 소비하는 데 소요되는 작업에 대해 상각되어야하는 값 비싼 추가 작업 (예 : 시스템 호출)을 발생시킵니다. 따라서 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 는 평균 청크 크기가 충분히 큰지 확인하기 위해 특별한주의를 기울입니다. 충분히 큰 것의 정확한 의미는 응용 프로그램에 따라 다릅니다. 현재 구현은 4kb에서 32kb 사이의 평균 청크 크기로 조정되어 대부분의 애플리케이션에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">열거의 경우, 0부터 n-1까지의 인덱스를 사용하여 nullary 생성자가 왼쪽에서 오른쪽으로 번호가 매겨지는 것으로 가정합니다. 이것은 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 클래스에서 정의한 것과 동일한 번호 입니다. 예를 들어 데이터 유형이 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">이것이 안전하지 않은 이유를 보여주는 예는 &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">예를 들어 &lt;code&gt;Recip.hs&lt;/code&gt; 라는 프로그램이 있습니다.이 프로그램 은 반복되는 부분을 괄호로 표시하여 역수의 정확한 십진수 표현을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">대화식 응용 프로그램의 경우 유휴 GC를 사용하는 것이 좋습니다. 이는 Haskell 계산이 수행되지 않을 때 유휴 시간에 종료자가 실행되고 교착 상태 스레드가 감지 될 수 있기 때문입니다. 또한 응용 프로그램이 사용 중일 때 GC가 발생할 가능성이 적으므로 응답 성이 향상 될 수 있습니다. 그러나 힙의 라이브 데이터 양이 특히 많으면 유휴 GC가 상당한 지연을 유발할 수 있으며 간격이 너무 작 으면 대화 형 응답성에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">가져온 모든 모듈의 경우 GHC에서는 가져 오기 명령문의 모듈 이름 &lt;a href=&quot;#search-path&quot;&gt;이 검색 경로에&lt;/a&gt; 지정된 전략을 사용하여 찾은 인터페이스 파일 (또는 소스 파일)의 모듈 이름과 정확히 일치해야 합니다 . 이는 대부분의 모듈에서 소스 파일 이름이 모듈 이름과 일치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">클래스의 인스턴스 인 모든 종류의 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; , 다음 개최한다 :</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">문자열 리터럴 많은 수의 애플리케이션의 경우, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 병목이 될 수 있습니다. 이러한 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC 만 해당) 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">문자열 리터럴 수가 많은 응용 프로그램의 경우 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">기존 make 스크립트와의 호환성을 위해 &lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 연결 단계가 생략됩니다 ( &lt;code&gt;--make -no-link&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 유형이 &lt;code&gt;forall&lt;/code&gt; 로 시작하더라도 종류 변수를 명시 적으로 바인딩 할 필요 &lt;em&gt;는 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">이진 생성자</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; 모두 에 대해 단계 번호에 인라인이 허용되는 시점이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">패턴 및 표현식 와일드 카드의 경우 &quot; &lt;code&gt;..&lt;/code&gt; &quot; &lt;em&gt;는 범위 내&lt;/em&gt; 누락 &lt;em&gt;된&lt;/em&gt; 레코드 필드로 확장 됩니다. 특히 &quot; &lt;code&gt;C {..}&lt;/code&gt; &quot; 의 확장 에는 다음 과 같은 경우에만 &lt;code&gt;f&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">상자 값 (포인터로 표시되는 값)의 경우 리프팅 된 유형 (&amp;perp;을 포함)과 리프팅되지 않은 유형 (하지 않은) 사이에 추가 구분이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">가변 길이 패딩을 포함 할 수있는 기능의 경우 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">For catching exceptions in pure (non- &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9a7a9bf985a5fc7968bcd7963a4107803bb41d4" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수 (비에 예외를 잡기위한 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 식, 함수가 참조 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순수한 (비 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ) 표현식 에서 예외를 포착 하려면 함수 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수 유형과의 단어 유형 ( &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; 참조 )을 강제 변환 하면 부호가 아닌 표현이 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">두 정수 유형을 강제 변환하려면 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; 을 사용하십시오. fromIntegral 은 모든 일반적인 경우에 적합하므로 충분히 빠릅니다. 정수형으로 또는 정수형으로 단어를 강제 변환하면 부호가 아닌 표현이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/etc/xdg&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">구성 파일 용. &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.config&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/etc&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;/usr/local/share/&lt;/code&gt; 및 &lt;code&gt;/usr/share/&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 또는 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (예 : &lt;code&gt;C:/ProgramData&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">데이터 파일 (예 : 이미지) &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.local/share&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%APPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ). 사용자 별 &lt;code&gt;/usr/share&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">간단한 외부 이진 형식 (예 : C 구조)을 디코딩하고 생성하기 위해 이진이 사용될 수 있지만 일반적으로 복잡한 프로토콜에는 적합하지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 프리미티브를 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="af244705c99bde3579744323c9a3a740b23bae24" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs.</source>
          <target state="translated">원격 GHCi에 대한 자세한 내용은 컴파일러 &lt;em&gt;GHC&lt;/em&gt; Runtime / Interpreter.hs의 참고 [Remote GHCi]를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">Remote GHCi에 대한 자세한 내용은 컴파일러 &lt;em&gt;ghci&lt;/em&gt; GHCi.hs의 참고 [Remote GHCi]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">합계 유형의 각 대안에 대해 이러한 필드로 구성된 레이아웃이 생성됩니다. 예를 들어 대안에 &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 필드가있는 경우 레이아웃에는 32 비트 워드, 32 비트 부동 소수점 및 포인터 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">각 가비지 콜렉션에 대해 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">각 수입 신고의 경우 &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; 의 &lt;code&gt;M&lt;/code&gt; 의 의존도 기록 라인 &lt;code&gt;M&lt;/code&gt; 에 &lt;code&gt;X&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">트리의 각 노드에 대해 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;rootLabel&lt;/code&gt; 에 적용하고 &lt;code&gt;f&lt;/code&gt; 를 각 &lt;code&gt;subForest&lt;/code&gt; 에 적용한 결과를 적용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">빈 데이터 유형의 경우 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 이 표현으로 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">이 주제에 대한 자세한 내용은 &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;SIGINT / SIGQUIT의 올바른 처리&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">이런 방식으로 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; &lt;code&gt;A.hs&lt;/code&gt; 모든 모듈 A.hs 에 대해 소스 파일 &lt;code&gt;A.hs-boot&lt;/code&gt; 가 있어야합니다 . 이 파일에는 약어 버전의 &lt;code&gt;A.hs&lt;/code&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">예를 들어, &lt;code&gt;-l-ag&lt;/code&gt; 는 GC 이벤트 ( &lt;code&gt;g&lt;/code&gt; )를 제외한 모든 이벤트 클래스 ( &lt;code&gt;-a&lt;/code&gt; )를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="e539a440aea70f6c1e340e284061ee3f7564fb32" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0faa4a03eb1b621e96ddafa75b4d631885ce8235" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="54977218cb67963281b7e0eb298f559214d3d420" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c5988831e8e7e699f73f0c98007bcd1ce68a11" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 는 해당 합계 목록을 생성하기 위해 두 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a52ed97184e92138a6e73030c8150e134f0bb680" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;Fixed 1000&lt;/code&gt; will give you a &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; with a resolution of 1000.</source>
          <target state="translated">예를 들어 &lt;code&gt;Fixed 1000&lt;/code&gt; 은 1000 의 해상도로 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7adc62b058c0496c81ae2687046d64f2c845f5f6" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; would be invalid base monads, but &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt; would be acceptable.</source>
          <target state="translated">예를 들어, &lt;code&gt;IO&lt;/code&gt; 또는 &lt;code&gt;Either&lt;/code&gt; 는 유효하지 않은 기본 모나드이지만 &lt;code&gt;Reader&lt;/code&gt; 또는 &lt;code&gt;State&lt;/code&gt; 는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">예를 들어, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; 는 크기가 1kb 이하인 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 복사하고 그렇지 않으면 직접 삽입합니다. 이는 직접 삽입 된 1025 바이트, 엄격한 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 사이에 항상 단일 바이트가있을 수 있기 때문에 생성 된 지연 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 평균 청크 크기는 513 바이트만큼 낮을 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; 는 &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; 아니라 f (\ a-&amp;gt; ab) 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 UTF-8은 유니 코드 문자를 일련의 바이트로 인코딩하는 것입니다. UTF-8 의 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="025997d25e9ad541ddb4bccc051a89bbfefa2c23" translate="yes" xml:space="preserve">
          <source>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</source>
          <target state="translated">예를 들어, 프로그램에는 각 단계에서 성능이나 리소스 동작이 다른 여러 단계가있을 수 있습니다. 프로필 그래프를 올바르게 해석하기 위해 우리는 각 단계가 시작되고 끝날 때를보고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">예를 들어, 처음 20 개의 정수와 2의 거듭 제곱을 인쇄하는 프로그램은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">예를 들어 트리의 사용자 정의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">예를 들어, GHC로 다음 모듈을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;foo&lt;/code&gt; 프로그램을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">예를 들어, 함수와 함께 사용하도록 의도되지 않은 유형 클래스를 고려해 보았지만 사용자는 실수로 함수 유형에서 함수를 사용했습니다. 그런 다음 누락 된 인스턴스에 대한 표준 GHC 메시지를받는 대신 EDSL에 고유 한보다 친숙한 메시지를 생성하는 것이 좋습니다. 마찬가지로, 유형 레벨 함수의 감소는 오류로 인해 중단 될 수 있습니다.이 시점에서 모호한 유형에 대한 일반적인 오류보다는 EDSL 특정 오류를보고하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">예를 들어, &lt;code&gt;:time&lt;/code&gt; 이라는 이름의 매크로 가 있고 쉘에 &lt;code&gt;:t 3&lt;/code&gt; 을 입력 한 경우 어떻게됩니까? 명령을 완료하는 데 사용하는 현재 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 다음과 같은 병렬 버전 인 이전 버전 인 &lt;code&gt;nfib&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">예를 들어 다음 정의를 고려하십시오 ( &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e3fcef7520fd5f38bbab6908aface3e182c9e1f" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">예를 들어 다음 정의를 고려하십시오 ( &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">예를 들어 데이터 유형이 주어지면</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 &lt;code&gt;hist&lt;/code&gt; 는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">예를 들어, 일부 색인 유형의 값 목록이 제공되면 hist는 지정된 범위 내에서 각 색인의 발생 횟수에 대한 히스토그램을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">예를 들어, 선언이 주어지면</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">예를 들어 다음은 GHC의 &lt;code&gt;nofib&lt;/code&gt; 벤치 마크 제품군 에서 &lt;code&gt;sphere&lt;/code&gt; 프로그램을 위해 생성 된 힙 프로파일입니다 .</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">예를 들어, 다음은 네트워크 소켓에서 클라이언트 연결을 수신하고 클라이언트 연결 핸들에서 클라이언트 입력을 에코하는 데 &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;에코 서버를&lt;/a&gt; 구현하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">예를 들어, GHC 가 &lt;code&gt;-odir&lt;/code&gt; 또는 &lt;code&gt;-hidir&lt;/code&gt; 플래그 없이 &lt;code&gt;src/A/B/C.hs&lt;/code&gt; 파일에서 &lt;code&gt;A.B.C&lt;/code&gt; 모듈을 컴파일하는 경우 인터페이스 파일은 &lt;code&gt;src/A/B/C.hi&lt;/code&gt; 및 오브젝트에 배치됩니다. 에서 파일 &lt;code&gt;src/A/B/C.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">예를 들어, 인터페이스가 가져온 값의 유형에 놓여 있다면 GHC는 가져 오기 모듈에 대한 더프 코드를 생성 할 수 있습니다. &lt;em&gt;이것은 인터페이스 내부의 pragma에도 적용됩니다! &lt;/em&gt;pragma가 거짓말을하는 경우 (예 : 값의 &quot;arity&quot;에 대해) 더프 코드가 발생할 수 있습니다. 또한 유형이 다르더라도 자질이 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">예를 들어 다음 데이터 유형이 범위 내에있는 경우</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">예를 들어, 패키지 스펙에서 Haskell 라이브러리를 &lt;code&gt;HSfoo&lt;/code&gt; 로 지정하면 GHC가 실제로 사용하는 다양한 라이브러리가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">예를 들어, 프로그램의 핵심을 검사하고 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 것을 관찰하는 경우 . &lt;code&gt;-dinline-check foo&lt;/code&gt; 를 전달 하면 &lt;code&gt;foo&lt;/code&gt; 가 인라인되지 않은 이유에 대한 보고서가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">예를 들어,이 동작이있는 80 열 터미널에서는 다음이 이중 간격 대신 단일 간격으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">예를 들어 다음 프로그램에서 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;f'&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">예를 들어, 항목은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">예를 들어, 동일한 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 을 여러 번 호출 하면 동일한 입력 히스토리가 공유됩니다. 반대로 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; 에 대한 여러 번의 호출 은 동일한 히스토리 파일을 공유하지 않는 한 고유 한 히스토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">예를 들어, 가능한 응용 프로그램 중 하나는 사전을 구체화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 기억이 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">예를 들어, 때때로 다음을 사용하여 &quot;클래스 동의어&quot;의 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">예를 들어, 검색 경로가 디렉토리가 있다고 가정 해 &lt;code&gt;d1&lt;/code&gt; , &lt;code&gt;d2&lt;/code&gt; 와 &lt;code&gt;d3&lt;/code&gt; , 우리는에 &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; 모듈의 소스 파일을 찾고 모드 &lt;code&gt;A.B.C&lt;/code&gt; . GHC는 &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; , &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; , &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; 등을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; 와 같이 &quot; &lt;code&gt;&quot;::&quot;&lt;/code&gt; 하위 문자열에서 분할하려는 문자열이 있다고 가정하십시오 . &lt;code&gt;&quot;::&quot;&lt;/code&gt; 의 색인을 검색하고 해당 색인 전후에 하위 문자열을 사용하는 대신 &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">예를 들어, 파일을 읽으려고하는데 파일이 없으면 &quot;&quot;가 포함 된 것처럼 계속 진행하십시오. 모든 예외를 포착하고 핸들러에서 &quot;&quot;를 반환하려는 유혹을받을 수 있습니다. 그러나 이것은 모든 종류의 바람직하지 않은 결과를 초래합니다. 예를 들어, 사용자가 적절한 순간에 control-C를 누르면 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 예외가 발생하고 파일에 &quot;&quot;가 포함되어 있다는 확신하에 프로그램이 계속 실행됩니다. 마찬가지로, 다른 스레드가 파일을 읽는 스레드를 종료하려고하면 &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 예외가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">예를 들어 다음 데이터 형식의 생성자 필드</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">예를 들어, 데이터 유형 &lt;code&gt;2 * A&lt;/code&gt; 및 &lt;code&gt;A + A&lt;/code&gt; 는 동형이지만 일부 계산은보다 자연스럽게 표현됩니다. 두 세계를 최대한 활용하기 위해 하나를 구현으로 선택한 다음 사용자가 원하는 경우 다른 표현을 사용할 수 있도록 패턴 동의어 세트를 제공 할 수 있습니다. 그런 다음 패턴 일치 검사기에 &lt;code&gt;LeftChoice&lt;/code&gt; 와 &lt;code&gt;RightChoice&lt;/code&gt; 모두에서 일치하는 함수 가 총계 임을 알리기 위해 &lt;code&gt;COMPLETE&lt;/code&gt; pragma 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">예를 들어, 다음 코드는 GHC에서 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">예를 들어, 다음 옵션은 &lt;code&gt;Branch&lt;/code&gt; 및 &lt;code&gt;Leaf&lt;/code&gt; 생성자로 제한된 리테이너 프로파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">예를 들어, 이것들은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">예를 &lt;code&gt;Monad&lt;/code&gt; 코드에는 Monad 제약 조건 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">예 를 &lt;code&gt;#fullname&lt;/code&gt; 인스턴스는 #fullname 을 사용하여 &lt;code&gt;Person&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 필드에 액세스 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">예를 들어 &lt;code&gt;f x&lt;/code&gt; 의 값을 반환 하지만 먼저 메시지를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">예를 들어, CFI를 사용하여 FFI 및 전처리를 활성화하려면 :</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">예를 들어 간단한 &lt;code&gt;ls&lt;/code&gt; 명령 을 실행하려면</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">예를 들어, &lt;code&gt;network&lt;/code&gt; 패키지를 사용하는 &lt;code&gt;Foo.o&lt;/code&gt; 및 &lt;code&gt;Main.o&lt;/code&gt; 객체로 구성된 프로그램을 연결 하려면 GHC에 &lt;code&gt;-package&lt;/code&gt; 플래그를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">예를 들어 &lt;code&gt;Main&lt;/code&gt; 모듈이 포함 된 Haskell 프로그램을로드하고 실행하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">예를 들어, YYYY-MM-DD 형식으로 날짜를 구문 분석하고 월과 날짜에 선택적 선행 0을 갖도록 허용하려면 ( &lt;code&gt;%m&lt;/code&gt; 및 &lt;code&gt;%d&lt;/code&gt; 사용 된 &lt;code&gt;-&lt;/code&gt; 수정 자에 유의 ) :</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">예를 들어, 프로세스를 시작하고 문자열을 stdin에 공급하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">예를 들어 문자열을 토큰 화하려면 구분 기호를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">예를 들어 직접 재귀를 사용하여 계승 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57a91fc90c21d96ad621001af54d878ab863159" translate="yes" xml:space="preserve">
          <source>For example, when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;(:)&lt;/code&gt;, all three cases return an immediate value, respectively &lt;code&gt;z&lt;/code&gt; or a &lt;em&gt;cons cell&lt;/em&gt; holding &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt;, with the remainder the structure, if any, encapsulated in a lazy thunk. This meets the expected efficient &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; behaviour of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;(:)&lt;/code&gt; 이면 세 가지 경우 모두 즉치 값, 각각 &lt;code&gt;z&lt;/code&gt; 또는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;l&lt;/code&gt; 을 보유 하는 &lt;em&gt;cons 셀&lt;/em&gt; 을 반환 하고 나머지 구조가 있으면 게으른 썽크에 캡슐화됩니다. 이것은 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 의 예상되는 효율적인 &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; 동작을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">예를 들어, 모듈 A를 컴파일 할 때 B가 A를 직접 또는 간접적으로 가져 오지 않으면 B에서 가져온 템플릿 Haskell 함수 만 실행할 수 있습니다. 그 이유는 분명해야합니다. B를 실행하려면 A를 컴파일하고 실행해야하지만 현재 A를 타입 검사하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 보기 흉하지만 문제가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">네 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z.z'&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 이고 __GLASGOW_HASKELL_PATCHLEVEL2__ 값은 정수 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">단사 형 가족에 대한 자세한 내용은 하스켈 심포지엄 2015 종이를 참조 &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;하스켈에 대한 단사 유형의 가족&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">그러나 숨겨진 패키지의 경우 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 플래그를 사용하여 패키지를로드하도록 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">역사적 이유로 보존 된 값은 / 강제 / 강제 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그들을 강제로 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 하려면 preserveMissing '을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="75f8792d57e48a774641d9734879dcb766f223ec" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="462ce6044e470f38fd8877b9aec9d317b89c01cb" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1265e702058729814c9070a553091ab6668e71f9" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b4e1b52d9313f4a64b67c682815f36e8dd1565" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우, 찾는 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 기본 구현이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4930b164ff12550352bb2ae49b0f3eafab2481e2" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우, 찾는 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 기본 구현이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce546ec8413f6538f8a26e19ca0ec25047ae9e5" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">무한 구조의 경우, 찾는 값이 구조의 왼쪽에서 유한 한 거리에 있으면 &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 의 기본 구현이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c30b64ae65331781837d75efd9f6decbae446e0c" translate="yes" xml:space="preserve">
          <source>For information on what bound threads are, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;.</source>
          <target state="translated">바인딩 된 스레드에 대한 자세한 내용은 &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">예를 들어 간단한 프로필은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">예를 들어 다음과 같은 유형의 제품군이있는 경우</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; 로 프로그램을 실행하면 &lt;code&gt;hello-world.hp&lt;/code&gt; 라는 힙 프로파일 과 hello-world.prof 라는 비용 중심 프로파일이 &lt;code&gt;hello-world.prof&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">예를 들어, &lt;code&gt;-fno-specialise -O1&lt;/code&gt; 의 예를 들어보십시오 . 에도 불구하고 &lt;code&gt;-fno-specialise&lt;/code&gt; 명령 줄에 나타나는 전문화는 여전히 활성화됩니다. &lt;code&gt;-O1&lt;/code&gt; 이 &lt;code&gt;-fspecialise&lt;/code&gt; 를 암시 하고 이전 플래그를 대체 하는 경우 입니다. 반대로 &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; 는 예상대로 전문화없이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">예를 들어, 형식 서명의 첫 번째 와일드 카드 는 다음과 같은 오류 메시지를 생성 &lt;code&gt;not'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">예를 들어, 우리의 응용 프로그램에 더 유용한 오류 메시지를 제공하기 위해이 인터페이스를 사용할 수있는 &lt;code&gt;show&lt;/code&gt; 같은 불포화 기능에,</target>
        </trans-unit>
        <trans-unit id="be75888101f27133692a26f5d016cfc15af97616" translate="yes" xml:space="preserve">
          <source>For lists we get the natural order of effects by using &lt;strong&gt;&lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt;&lt;/strong&gt; as the operator and &lt;strong&gt;&lt;code&gt;(traverse f as)&lt;/code&gt;&lt;/strong&gt; as the operand (the actual definition is written as an equivalent right fold in order to enable &lt;em&gt;fusion&lt;/em&gt; rules):</source>
          <target state="translated">목록의 경우 연산자로 &lt;strong&gt; &lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;(traverse f as)&lt;/code&gt; &lt;/strong&gt; 를 사용하고 피연산자로 ( &lt;strong&gt;f를 트래버스로)&lt;/strong&gt; 사용하여 효과의 자연스러운 순서를 얻습니다 (실제 정의는 &lt;em&gt;퓨전&lt;/em&gt; 규칙 을 활성화하기 위해 동등한 오른쪽 접기로 작성됩니다 ).</target>
        </trans-unit>
        <trans-unit id="e819cf0fe0a721d8aa2edb789360b689a7c6df8a" translate="yes" xml:space="preserve">
          <source>For lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; is the identity:</source>
          <target state="translated">목록의 경우 &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 는 ID입니다.</target>
        </trans-unit>
        <trans-unit id="cd75721614a832379340eb5515b1192ef0f86e97" translate="yes" xml:space="preserve">
          <source>For many structures reasonably efficient &lt;code&gt;Foldable&lt;/code&gt; instances can be derived automatically, by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC extension. When this works, it is generally not necessary to define a custom instance by hand. Though in some cases one may be able to get slightly faster hand-tuned code, care is required to avoid producing slower code, or code that is not sufficiently lazy, strict or &lt;em&gt;lawful&lt;/em&gt;.</source>
          <target state="translated">많은 구조의 경우 &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC 확장 을 활성화하여 합리적으로 효율적인 &lt;code&gt;Foldable&lt;/code&gt; 인스턴스를 자동으로 파생 할 수 있습니다 . 이것이 작동하면 일반적으로 사용자 지정 인스턴스를 직접 정의 할 필요가 없습니다. 어떤 경우에는 손으로 조정 한 코드를 약간 더 빠르게 얻을 수 있지만 느린 코드 나 충분히 게 으르거나 엄격하거나 &lt;em&gt;합법적&lt;/em&gt; 이지 않은 코드를 생성하지 않도록주의해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2512d10fb7fc1b9dbc0084916fcb3b49c0227bdb" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수년 동안 견적 유형은 'Q Exp'로 고정되었지만 최소 인터페이스를보다 정확하게 지정하면 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 와 상호 작용하지 않고 견적에서 순수하게 추출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15ee88f85580b5f1cfacfb67956f3e66087a0c8d" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수년 동안 견적 유형은 'Q Exp'로 고정되었지만 최소 인터페이스를보다 정확하게 지정하면 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 와 상호 작용하지 않고 견적에서 순수하게 추출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; 클래스 에 속하는 모나드의 경우 GHC는 재귀 바인딩을 허용하는 확장 된 do-notation 버전을 제공합니다. &lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt; (언어 프라 그마 : &lt;code&gt;RecursiveDo&lt;/code&gt; 는 ) 키워드를 도입, 필요한 구문 지원을 제공 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 각각 표기의 높고 낮은 수준. &lt;code&gt;do&lt;/code&gt; 표현식의 바인딩과 달리 &lt;code&gt;mdo&lt;/code&gt; 및 &lt;code&gt;rec&lt;/code&gt; 에 의해 도입 된 바인딩 은 일반적인 let-expression과 매우 유사하게 재귀 적으로 정의됩니다. 새로운 키워드 &lt;code&gt;mdo&lt;/code&gt; 로 인해이 표기법을 &lt;em&gt;mdo-notation이라고도&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">이 기능에 대한 자세한 내용은 Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones 및 Stephanie Weirich의 &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f223131e45f78084be7dce3cc5c1c0ae03a548a" translate="yes" xml:space="preserve">
          <source>For more details on the implementation see the Paper: &amp;ldquo;Extending the Haskell Foreign Function Interface with Concurrency&amp;rdquo;. Last known to be accessible &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">구현에 대한 자세한 내용은 &quot;동시성을 사용하여 Haskell 외부 함수 인터페이스 확장&quot;문서를 참조하십시오. 마지막으로 &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;여기에서&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki 페이지&lt;/a&gt; 또는 원본 &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b72896971c07169fb5840e32ce47aee311c5c705" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki 페이지&lt;/a&gt; 또는 원본 논문 &lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">자세한 내용은 Conor McBride 및 Ross Paterson의 &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">GHC에 의해 생성 된 디버그 정보에 대한 자세한 내용은 Peter Wortmann의 박사 논문, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;* 최적화 된 Haskell 프로파일 링 : 인과 분석 및 구현 *을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da91b931841e7893478b07acb85bd4ccd0928c7e" translate="yes" xml:space="preserve">
          <source>For more information about this type's representation, see the comments in its implementation.</source>
          <target state="translated">이 유형의 표현에 대한 자세한 내용은 해당 구현의 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">틱 틱틱 프로파일 링에 대한 자세한 내용은 &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;&quot;틱 키틱&quot;프로파일 링 사용 (구현 자용)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">API 사용과 샘플 및 참조에 대한 자세한 내용은 &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="586a78695eb0609dc531b936f637d0814cfd2fee" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">API 사용에 대한 자세한 정보와 더 많은 샘플 및 참조는 &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;이 Haskell.org 위키 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">자세한 내용 은이 라이브러리 디자인의 기초 가되는 &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 . 1995 년 고급 기능 프로그래밍에서 John Hughes의 / The Pretty-printing Library의 디자인 /.</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 새로운 SYB 위키 ( &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB)&lt;/a&gt; 를 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 클래스 설명서를 참조하십시오 . @since 4.9.0.0</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">더 많은 동기 부여와 세부 사항은 &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; 페이지 또는 &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;원본을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">대부분의 응용 프로그램에서는 다음 &lt;code&gt;Settings&lt;/code&gt; 플래그 를 대신 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">대부분의 응용 프로그램 (예 : REPL)의 경우 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 가 올바른 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">대부분의 배열 유형의 경우이 작업은 O ( &lt;em&gt;n&lt;/em&gt; )이며 여기서 &lt;em&gt;n&lt;/em&gt; 은 배열의 크기입니다. 그러나 diffarray 패키지는이 작업이 업데이트 수에있어 복잡성을 갖는 배열 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">대부분의 유형에는 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 의 기본 정의 가 사용되지만 특정 유형에 대해 최적화 된 버전을 제공 할 수 있도록 클래스 정의에 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">중첩 된 &lt;code&gt;foralls&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">newtypes를 들어, &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; 와 &lt;code&gt;Bounded&lt;/code&gt; 항상 사용 파생 &lt;code&gt;newtype&lt;/code&gt; 이란 도없이, 전략을 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 이 가능. (주식 전략을 사용하여 파생 된 인스턴스와 눈에 띄는 차이가 없어야합니다.)</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">필수가 아닌 파일 (예 : 캐시) &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 환경 변수를 사용합니다 . Windows 이외의 시스템에서 기본값은 &lt;code&gt;~/.cache&lt;/code&gt; 입니다. Windows에서 기본값은 &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (예 : &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ). 사용자 별 &lt;code&gt;/var/cache&lt;/code&gt; 에 해당하는 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Haskell finalizer를 이식 할 수없는 지원에 대해서는 &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3383003efe56493c3ba8ee51d572a1bd3e32533a" translate="yes" xml:space="preserve">
          <source>For now, this module is the API for working with type-level literals. However, please note that it is a work in progress and is subject to change. Once the design of the &lt;code&gt;DataKinds&lt;/code&gt; feature is more stable, this will be considered only an internal GHC module, and the programmer interface for working with type-level data will be defined in a separate library.</source>
          <target state="translated">현재이 모듈은 유형 수준 리터럴 작업을위한 API입니다. 그러나 진행중인 작업이며 변경 될 수 있습니다. &lt;code&gt;DataKinds&lt;/code&gt; 기능 의 디자인 이 더 안정되면 내부 GHC 모듈로만 간주되며 유형 수준 데이터 작업을위한 프로그래머 인터페이스는 별도의 라이브러리에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">개방형 및 폐쇄 형 패밀리의 경우 결과의 이름을 지정하지만 주입 주석을 건너 뛰어도됩니다. 주입 형 주석이없는 명명 된 결과가 연관된 유형 동의어 기본값으로 해석되는 연관된 유형 동의어의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">다른 모든 유형 클래스의 경우 :</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">다른 문서는 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91b1fc2b5558fcebb47a9cb90615ec89658550a4" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">기타 문서는 &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">1 부에서는 &lt;code&gt;Encode'&lt;/code&gt; 클래스를 정의합니다 . 놀랍게도이 클래스는 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 종류 의 유형 생성자 &lt;code&gt;f&lt;/code&gt; 에 대해 매개 변수화 됩니다. 이것은 기술입니다. 모든 표현 유형 생성자는 종류 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 를 기본 종류로 사용합니다. 그러나 type 인수는 사용되지 않습니다. 이것은 나중에 언젠가 변경 될 수 있습니다. 클래스는 하나의 방법이 있고, 우리는 우리가 우리의 최종적인 기능을 갖고 싶어 유형을 사용하지만, 우리는 제네릭 형식 인수의 발생 대체 와 &lt;code&gt;f p&lt;/code&gt; 합니다 ( &lt;code&gt;p&lt;/code&gt; 는 , 그것은 사용되지 않습니다 어떤 인수입니다). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">실수의 경우 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; (음수), &lt;code&gt;0&lt;/code&gt; (영) 또는 &lt;code&gt;1&lt;/code&gt; (양수)입니다.</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">필드가 많은 레코드의 경우와 같이 각 필드를 개별적으로 레코드 패턴으로 기록하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">단일 생성자 데이터 유형의 경우 파생 인스턴스 선언은 Haskell 2010 보고서의 19 장, 섹션 2 ( &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html)&lt;/a&gt; 에서 튜플에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">어떤 이유로 Mingw는 &lt;code&gt;readline&lt;/code&gt; 라이브러리 와 함께 제공 되지만 &lt;code&gt;readline&lt;/code&gt; 헤더 와 함께 제공되지 않습니다 . 결과적으로 GHC (Hugs와 같은)는 Windows에서 대화식 입력에 &lt;code&gt;readline&lt;/code&gt; 을 사용하지 않습니다 . emacs 쉘 ​​버퍼를 사용하여 정밀한 시뮬레이션을 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">일부 특수 사용 사례의 경우 어떤 이벤트가 포함되는지 더 세밀하게 제어 할 수 있습니다. ⟨플래그⟩는 기록 할 이벤트 클래스를 나타내는 0 개 이상의 문자 시퀀스입니다. 현재 활성화 / 비활성화 할 수있는 이벤트 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">일부 값의 경우 순서가 아닌 목록 내용에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">스파크 이벤트의 경우 샘플링 및 완전 정확도의 두 가지 모드가 있습니다. 각 스파크의 수명주기에는 다양한 이벤트가 있으며 일반적으로 생성 및 실행이지만 더 뛰어난 가능성이 있습니다. 샘플링 된 모드에서 각 종류의 스파크 이벤트 발생 횟수는 빈번한 간격으로 샘플링됩니다. 완전 정확한 모드에서는 모든 스파크 이벤트가 개별적으로 기록됩니다. 후자는 런타임 오버 헤드가 높으며 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">기술적 인 이유로 GHCi 는 해석되는 모듈에 대해서만 &lt;code&gt;*&lt;/code&gt; 양식을 지원할 수 있습니다 . 컴파일 된 모듈 및 패키지 모듈은 현재 범위에 대한 내보내기에만 기여할 수 있습니다. GHCi가 해석 된 버전의 모듈을 로드하도록하려면 모듈을로드 할 때 &lt;code&gt;*&lt;/code&gt; 를 추가하십시오 ( 예 &lt;code&gt;:load *M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">기술적 인 이유로 바이트 코드 컴파일러는 최적화 패스 중 하나와 잘 상호 작용하지 않으므로 인터프리터를 사용할 때 최적화를 비활성화했습니다. 이는 큰 손실이 아닙니다. 최적화가 설정된 상태에서 해석하는 대신 빠르게 진행해야하는 코드 비트를 컴파일하면 훨씬 더 큰 승리를 거둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Bad Int&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같이 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">파생 된 &lt;code&gt;Ex&lt;/code&gt; 인스턴스의 경우 GHC는 다음과 같은 것을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">첫 번째 트러스트 정의의 경우, GHC는 안전한 언어에 의해 부과 된 제한을 통해 트러스트 보증을 제공합니다. 신뢰의 두 번째 정의의 경우 보증은 처음에 모듈 작성자가 제공합니다. 그런 다음 클라이언트 C는 모듈이 상주하는 패키지를 신뢰 함을 표시하여 모듈 작성자를 신뢰하도록 설정합니다.이 신뢰 체인은 GHC가 &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; 컴파일 된 모듈을 보증하지 않으므로 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="060c8275f3511e9a847d9b963216480ea97ce2de" translate="yes" xml:space="preserve">
          <source>For the first two examples we show sequenceA fully evaluating a a structure and collecting the results.</source>
          <target state="translated">처음 두 가지 예에서는 구조를 완전히 평가하고 결과를 수집하는 sequenceA를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d323edf5bc66a27abef8680a58a3a1cdc8c8ab90" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">문자열 데이터 자체의 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 은 모두 가장 가까운 단어로 반올림 된 요소 당 1 바이트를 사용합니다. 예를 들어 오버 헤드를 포함하여 길이 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 은 32 비트 플랫폼에서 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 바이트 , 64 비트 플랫폼에서 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">문자열 데이터 자체의 경우 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;ByteString&lt;/code&gt; 은 요소 당 하나의 바이트를 사용하며 가장 가까운 단어로 반올림됩니다. 예를 들어 오버 헤드를 포함하여 길이 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 은 32 비트 플랫폼에서 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 바이트를, 64 비트 플랫폼에서 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">이 모나드 변압기의 경우 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 는 모나드 범주에서 자연스럽게 변환됩니다. 즉 모나드 변환 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a ,</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">이러한 이유로 GHC는 &lt;code&gt;tryPutMVar&lt;/code&gt; 에 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 에 대한 외부 API를 제공하며 C / C ++에서 Haskell 스레드를 저렴하고 비동기 적으로 깨울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5539b287ec186ea0d65a4fd7ea031c83904aceb1" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targeting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">따라서 GDB에서 제공하는 소스 위치를 해석 할 때주의해야합니다. 이러한 위치는 일반적으로 어떤 의미에서 &quot;올바른&quot;것이지만 항상 유용한 것은 아닙니다. 이것이 Haskell을 대상으로하는 프로파일 링 도구가 비용을 할당 할 때 GHC 특정 주석 ( &lt;code&gt;-g2&lt;/code&gt; 로 내보냄 )으로 표준 소스 위치 정보를 보완해야하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt; ) when assigning costs.</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">이러한 이유로 GDB가 제공하는 소스 위치를 해석 할 때는주의해야합니다. 이러한 위치는 일반적으로 &quot;정확한&quot;의미이지만 항상 유용한 것은 아닙니다. 이러한 이유로 Haskell을 대상으로하는 프로파일 링 도구는 비용을 할당 할 때 표준 소스 위치 정보를 GHC 특정 주석 ( &lt;code&gt;-g2&lt;/code&gt; 로 방출)으로 보완해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">세 부분으로 구성된 GHC 버전 번호 &lt;code&gt;x.y.z&lt;/code&gt; 의 경우 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 값은 정수 ⟨z⟩ 입니다.</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">튜플를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 에 제약 &lt;code&gt;a&lt;/code&gt; 는 첫 번째 값이 병합 방법을 결정합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">위 의 &lt;code&gt;foo2&lt;/code&gt; 의 서명과 같이 &lt;em&gt;둘 이상의 요소&lt;/em&gt; 의 유형 레벨 목록의 경우 , 그 의미가 모호하지 않기 때문에 인용 부호는 생략 될 수 있습니다. 그러나 &lt;code&gt;foo0&lt;/code&gt; 및 &lt;code&gt;foo1&lt;/code&gt; 에서 와 같이 하나 또는 제로 요소 목록의 경우 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;[Int]&lt;/code&gt; 유형 이 Haskell에서 기존 의미를 갖기 때문에 따옴표가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">유형과 클래스의 경우 GHCi는이를 언급하는 인스턴스도 요약합니다. 관련이없는 정보를 표시하지 않으려면 (a) 헤드가 ⟨name⟩을 언급하고 (b) 인스턴스에 언급 된 다른 모든 항목이 &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; 의 결과로 범위가 한정된 경우에만 표시됩니다 . 또는 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">단항 생성자</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 와 같은 제한되지 않은 유형의 경우 &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">GHCi와 함께 사용하려면 각 라이브러리에 객체 파일도 있어야합니다. 오브젝트 파일 이름 에는 &lt;code&gt;lib&lt;/code&gt; 접 두부 가 &lt;em&gt;없으며&lt;/em&gt; 플랫폼의 일반 오브젝트 접미 부가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">의 값 &lt;code&gt;n&lt;/code&gt; 1보다 큰 우리가 사용 &lt;code&gt;par&lt;/code&gt; 평가할 스레드를 촉발 &lt;code&gt;nfib (n-1)&lt;/code&gt; 다음과 같이 사용할 &lt;code&gt;pseq&lt;/code&gt; 을 평가하기 위해 부모 스레드를 강제로 &lt;code&gt;nfib (n-2)&lt;/code&gt; 이 두 함께 추가 가기 전에 하위 식. 이 분할 및 정복 방식에서는 계산의 한 분기에 대해서만 새 스레드를 생성합니다 (부모가 다른 분기를 평가하도록 두는 것). 또한 부모는 표현식 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 에서 &lt;code&gt;n1&lt;/code&gt; &lt;em&gt;보다 먼저 &lt;/em&gt; &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 평가 하도록 &lt;code&gt;pseq&lt;/code&gt; 를 사용해야합니다 . 식을 &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; 로 재정렬하는 것만으로는 충분하지 않습니다.&lt;em&gt;&lt;/em&gt;컴파일러는 추가 항목을 왼쪽에서 오른쪽으로 평가하는 코드를 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">버전 들어 &lt;code&gt;x.y.z&lt;/code&gt; GHC의 값 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 은 (⟨y⟩ 너무 GHC 버전 6.2 예를 들어, 선두 제로 첨가 한 자릿수이면, 정수 ⟨xyy⟩이다 &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ). &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC 버전 번호 지정 정책에&lt;/a&gt; 대한 추가 정보 .</target>
        </trans-unit>
        <trans-unit id="930d459a31fb0c473c8d3d450ef14232e956aa5e" translate="yes" xml:space="preserve">
          <source>ForallInvis</source>
          <target state="translated">ForallInvis</target>
        </trans-unit>
        <trans-unit id="fc5f64a4d6f12d0fb09adaae4cd55424315fc13f" translate="yes" xml:space="preserve">
          <source>ForallVis</source>
          <target state="translated">ForallVis</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">GHC가 값을 인라인하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">힘 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 일반적인 형태입니다.</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">다른 맵에서 키가 누락 된 항목을 강제 실행하고 변경되지 않은 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">TH를 통해 GHC가 지원하는 외국 형식</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">내부적으로 UTF-16을 사용하는 외부 함수 는 문자 대신 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 단위로 인덱스를 반환 할 수 있습니다 . 이러한 함수는 유니 코드 문자열의 유효성을 유지하기 위해 필요한 경우 오프셋을 조정하므로 이러한 인덱스와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f235bf33c8f99af06dcf27d617dccc24437bf4f1" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">내부적으로 UTF-16을 사용하는 외부 함수 는 문자 대신 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 단위로 인덱스를 반환 할 수 있습니다 . 이러한 함수는 유니 코드 문자열의 유효성을 유지하기 위해 필요한 경우 오프셋을 조정하므로 이러한 인덱스와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f04f5e4c57ead75bb6944301f5d150eaeca514" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">내부적으로 UTF-16을 사용하는 외부 함수 는 문자 대신 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 단위로 인덱스를 반환 할 수 있습니다 . 이러한 함수는 유니 코드 문자열의 유효성을 유지하기 위해 필요한 경우 오프셋을 조정하므로 이러한 인덱스와 함께 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">구성 가능한 인코딩으로 CString에 대한 외부 마샬링 지원</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">스레드를 포크하고 스레드가 종료 되려고 할 때 예외 또는 리턴 값으로 제공된 함수를 호출하십시오. 이 함수는 비동기 예외를 마스킹하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">포크와 실행</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">스레드를 포크하고 죽입니다.</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">포크와 같은</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">크기와 위상의 극 성분에서 복소수를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">공식적으로 말하면, Haskell 98에서 프로그램의 엔티티 (함수, 유형 또는 클래스)는 프로그램이 정의 된 모듈 이름 쌍과 이름으로 고유하게 식별됩니다. GHC에서 엔티티는 패키지, 모듈 및 이름의 트리플로 고유하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">공식적으로, 클래스 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 는 에서 bifunctor 나타냅니다 &lt;code&gt;Hask&lt;/code&gt; &amp;gt; - &lt;code&gt;Hask&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 을 행 목록으로 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">C 스타일의 형식화 문자열을 사용하여 가변 개수의 인수를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="6c1b349cc09f134d48d7a222aba9e73980432c3a" translate="yes" xml:space="preserve">
          <source>Format picture translation</source>
          <target state="translated">사진 번역 서식 지정</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">형식 문자열</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt; 에 따라 문자열을 형식화하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e7448bd68705edd6cbfa67e98ce2811cf8f693f" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt; 에 따라 형식 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">형식 문자열.</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 값의 포맷터입니다 .</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 값의 포맷터</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 값의 포맷터 .</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">서식 덤프</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">숫자를 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">숫자를 ASCII 텍스트로 형식화</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">두 정수의 비율을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">다행히 GHC는 두 가지 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">다행히도 디버거에는 일반 인쇄 명령 인 &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; 가 포함되어 변수의 실제 런타임 값을 검사하고 해당 유형을 재구성 할 수 있습니다. 우리가 &lt;code&gt;left&lt;/code&gt; 시도하면 :</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">분수 나누기.</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">분수 리터럴은 translation이 &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; 인 것을 제외하고는 동일한 방식으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">실수를 지원하는 분수.</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; 또는 &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt; 의 &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt; 함수 로 할당 된 메모리 블록을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; 에 의해 이전에 생성 된 무료 데이터</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">캐시 된 디버그 데이터를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="11a51d8a12071a090bc68657f6d6227b831062a8" translate="yes" xml:space="preserve">
          <source>Frees a function pointer to the window closure which has been set directly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; or indirectly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt;. You should call this function in your window closure's &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; case unless you delegate that case to &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; (e.g. as part of the default).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; 에 의해 직접 또는 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; 에 의해 간접적 으로 설정된 창 닫기에 대한 함수 포인터를 해제합니다 . 이 경우를 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; 에 위임하지 않는 한 (예 : 기본값의 일부로) 창 닫기의 &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; 케이스 에서이 함수를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">콜 스택을 고정하여 추가 콜 사이트가 추가되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">가변 배열을 고정시킵니다. 나중에 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 를 변경하지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">지정된 &lt;code&gt;CallStack&lt;/code&gt; 에서 스택을 고정하여 더 이상의 콜 사이트가 밀리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">신선한 이름</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">오름차순 목록에서</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">내림차순 목록에서</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">정렬되지 않은 목록에서</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; 와 다른 모듈에서</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">의미 적 관점에서 :</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">구문 관점에서 :</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">여기에서 정수 유형의 모든 인수에 f를 적용하고 결과를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">문자열에서 생성자로 또는 그 반대로 : 모든 데이터 유형</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">로부터 &lt;code&gt;x1==x2&lt;/code&gt; 우리 필요 &lt;code&gt;Eq a&lt;/code&gt; 미세하다. &lt;code&gt;c1==c2&lt;/code&gt; 부터 우리 는 오늘날 Haskell에서 &lt;em&gt;좋지 않은 &lt;/em&gt; &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; 가 &lt;em&gt;필요&lt;/em&gt; 합니다. 우리는 그러한 제약을 해결할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">부터 &lt;code&gt;x==x&lt;/code&gt; 우리가 필요로 &lt;code&gt;Eq (m Int)&lt;/code&gt; 제약 조건을하지만, 상황은 우리가 알아낼 수있는 방법 제공 &lt;code&gt;Ord (m a)&lt;/code&gt; 제약. 그러나 주어진 제약 조건에서 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; 우리는 모든 a에 대한 두 번째 주어진 제약을 도출 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; 이고, 그로부터 &lt;code&gt;Eq (m Int)&lt;/code&gt; 를 쉽게 풀 수 있습니다 . 이 프로세스는 슈퍼 클래스가 이미 작동하는 방식과 매우 유사합니다. &lt;code&gt;Ord a&lt;/code&gt; 제약이 주어지면 두 번째로 &lt;code&gt;Eq a&lt;/code&gt; 제약이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">초록에서 :</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="694096b3017c32a2a22ef4b2a40ca9ccd292d59e" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">관련된 유형 서명에서 이것은 하나의 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 값과 두 개의 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 할당해야하는 것처럼 보입니다 . 그러나 모듈이 GHC에서 최적화가 활성화 된 상태로 컴파일되면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 함수는 소스 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 을 통해 단일 루프로 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">관련된 형식 서명에서 &lt;code&gt;ByteString&lt;/code&gt; 값 하나 와 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값 두 개를 할당해야하는 것처럼 보입니다 . 그러나 GHC에서 최적화를 사용하여 모듈을 컴파일하면 두 개의 중간 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값이 최적화되고 소스 &lt;code&gt;ByteString&lt;/code&gt; 의 단일 루프로 함수가 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="9cba7ac0176caf9e0fd3fa137920b3f27031c36f" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">컴파일러 플러그인과 같은 프런트 엔드 플러그인은 등록 된 플러그인에서 내 보냅니다. 그러나 컴파일러 모듈과 달리 프런트 엔드 플러그인은 &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt; 유형 의 하나 이상의 식별자 &lt;code&gt;frontendPlugin&lt;/code&gt; 을 내보내는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">컴파일러 플러그인과 같은 프론트 엔드 플러그인은 등록 된 플러그인으로 내보내집니다. 그러나 컴파일러 모듈과 달리 프론트 엔드 플러그인은 &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; 유형의 최소한 하나의 식별자 &lt;code&gt;frontendPlugin&lt;/code&gt; 을 내보내는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="translated">Full list of currently supported flags:</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">기능 구성.</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">함수 포인터</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">가능한 완성 목록을 생성하는 기능. 첫 번째 인수는 단어 왼쪽의 줄 내용을 반대로 한 것입니다. 두 번째 주장은 완성 될 단어입니다.</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">코딩 오류 처리를위한 함수 유형 두 가지 입력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">기능 유형. 마지막 유형 매개 변수는 &lt;em&gt;공변량&lt;/em&gt; 위치 에서 발생하는 한 함수 유형의 어느 곳에 나 나타날 수 있습니다 . 이것이 의미하는 바를 설명하기 위해 다음 세 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f17265bebe4b2d092da403bdca66fa2464fc46" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">기능적 종속성은 &lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]&lt;/a&gt; 에서 Mark Jones가 설명한대로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">기능 종속성은 Mark Jones가 &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt; 에 설명 된대로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">기능적 의존성은 클래스 선언 구문에서 세로 막대로 소개됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">기능적 의존성은 문제를 복잡하게합니다. 우리가 가지고 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">튜플 데이터 형식과 관련된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="654ea9aec402ec9bb954f259abf37b24e92ef692" translate="yes" xml:space="preserve">
          <source>Functions called when a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is finalized. Note that C finalizers and Haskell finalizers cannot be mixed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 이 완료 될 때 호출되는 함수 입니다. C 종료 자와 Haskell 종료자는 혼합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">파일 시스템 조작 및 조회를 위해 POSIX 표준에 의해 정의 된 기능. 기본 POSIX 기능의 이름은 가능할 때마다 표시됩니다. 다양한 오류 조건에 대한 자세한 설명과 함께 POSIX 기능에 대한보다 완전한 문서는 일반적으로 시스템 매뉴얼 페이지 또는 &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (무료 등록 필요)에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">여러 표준 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="db91a2c7ff023def688156c0f6c192f7664fb169" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">여러 표준 인코딩을 사용하여 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 간에 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">몇 가지 표준 인코딩을 사용하여 지연 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 값을 지연 &lt;code&gt;ByteString&lt;/code&gt; 과 변환하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">추적 및 실행 모니터링 기능.</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">&lt;code&gt;GHC.Stack&lt;/code&gt; 모듈의 함수 는 현재 스택을 가져 와서 렌더링하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">MAPI DLL에서로드 된 함수</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">문자열의 함수</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">타입 리터럴의 함수</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">컴파일러에 의해 융합 될 수있는 함수는 &quot;융합 대상&quot;이라는 문구와 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">텍스트 데이터를 읽을 때 자주 사용되는 기능.</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">펑터 및 모나드 클래스</target>
        </trans-unit>
        <trans-unit id="5d9b79097d152d34620f656052ce7bc908e4adee" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right, performing an action on each element.</source>
          <target state="translated">왼쪽에서 오른쪽으로 이동할 수있는 데이터 구조를 나타내는 Functor는 각 요소에 대해 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">왼쪽에서 오른쪽으로 순회 할 수있는 데이터 구조를 나타내는 펑터.</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">이 &lt;code&gt;let&lt;/code&gt; 문에 추가 바인딩을 추가 할 수 있으므로 GHCi는 프롬프트를 변경하여 다음 줄이 이전 줄을 계속한다는 것을 나타냅니다. 참고 레이아웃은 지금이 더 바인딩을 추가, 효과에 있음을 &lt;code&gt;let&lt;/code&gt; 우리가 그들을 줄을있다 :</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">또한 모든 정의는 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt; &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; &lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 GHC를 사용하면 이벤트 로그 데이터 ( &lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; 참조 )가 사용자 정의 &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 를&lt;/a&gt; 통해 작성 되는 방식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66b3cc6f1053b257141eef62d3c7cec2ae3a9542" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; do not obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule when their type variables are not explicitly quantified:</source>
          <target state="translated">또한 &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite 규칙&lt;/a&gt; 은 형식 변수가 명시 적으로 수량화되지 않은 경우 &lt;code&gt;forall&lt;/code&gt; 또는 nothing 규칙을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec453e68989fa3914f8826d8c0c518b544aaa06f" translate="yes" xml:space="preserve">
          <source>Furthermore, GADT constructors do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; would be rejected, since it would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">또한 GADT 생성자는 &lt;code&gt;opt_forall&lt;/code&gt; 또는 &lt;code&gt;opt_ctxt&lt;/code&gt; 중 하나 이상을 사용하는 경우 가장 바깥 쪽 괄호를 허용하지 않습니다 . 예를 들어, &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; 는 &lt;code&gt;forall&lt;/code&gt; 을 중첩 된 것으로 취급하므로 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">또한 GHC는 메타 데이터로 소스 코드에 주석을 달 때 사용할 수있는 간단한 주석 메커니즘을 제공하며, 나중에 컴파일러 API 또는 컴파일러 플러그인으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">또한 GHCi는 다음과 같은 경우 I / O 작업 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">또한 아래 스케치와 같이 불안정한 인터페이스를 사용하여 컴파일 된 프로그램을 실행하는 데 큰 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">또한 별개의 어휘 유형 변수는 별개의 유형 변수를 나타냅니다. 이는 모든 프로그래머가 작성한 유형 서명 (자유 범위 지정 유형 변수를 포함하는 서명 포함)이 &lt;em&gt;엄격한&lt;/em&gt; 유형을 나타냅니다 . 즉, 유형은 유형 검사기에 완전히 알려져 있으며 추론이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">또한 모든 유형 생성자에 대해 유형 생성자 아래에서 강제 할 수있는 인스턴스가 있습니다. 예를 들어, &lt;code&gt;D&lt;/code&gt; 는 역할이 &lt;code&gt;nominal&lt;/code&gt; , &lt;code&gt;representational&lt;/code&gt; resp 를 갖는 세 가지 유형 인수를 가진 프로토 타입 유형 생성자 ( &lt;code&gt;data&lt;/code&gt; 또는 &lt;code&gt;newtype&lt;/code&gt; ) 라고하자 . &lt;code&gt;phantom&lt;/code&gt; . 그런 다음 양식의 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69b97115f19d41bf37478c44ac8035f4b89ab99" translate="yes" xml:space="preserve">
          <source>Furthermore, instance declarations types do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;instance (forall a. C a)&lt;/code&gt; would be rejected, since GHC would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">또한 인스턴스 선언 유형은 &lt;code&gt;opt_forall&lt;/code&gt; 또는 &lt;code&gt;opt_ctxt&lt;/code&gt; 중 하나 이상이 사용되는 경우 가장 바깥 쪽 괄호를 허용하지 않습니다 . 예를 들어, &lt;code&gt;instance (forall a. C a)&lt;/code&gt; 는 GHC가 &lt;code&gt;forall&lt;/code&gt; 을 중첩 된 것으로 취급하므로 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 작업은 다음과 관련이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">또한 닫는 &lt;code&gt;#-}&lt;/code&gt; 은 여는 &lt;code&gt;{-#&lt;/code&gt; 오른쪽의 열에서 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">또한, 유형 &lt;code&gt;t&lt;/code&gt; 는 &lt;code&gt;Typeable&lt;/code&gt; 인스턴스 를 갖도록 제한됩니다 . 따라서 다음은 불법입니다 :</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">또한 다음과 같은 기능을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">게으른 &lt;code&gt;Text&lt;/code&gt; 와 몇 가지 일반적인 인코딩 간에 변환하기위한 가용성 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 지향 함수</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">&lt;code&gt;integer_gmp&lt;/code&gt; 의 이후 버전은 더 이상 음수 &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 값을 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce2582f55bf244541fd784a5f9f776bd503eadbf" translate="yes" xml:space="preserve">
          <source>GADT constructor types are currently not permitted to have nested &lt;code&gt;forall&lt;/code&gt;s or &lt;code&gt;=&amp;gt;&lt;/code&gt;s. (e.g., something like &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; would be rejected.) As a result, &lt;code&gt;gadt_sig&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;. Note that higher-rank &lt;code&gt;forall&lt;/code&gt;s and &lt;code&gt;=&amp;gt;&lt;/code&gt;s are only permitted if they do not appear directly to the right of a function arrow in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. (e.g., something like &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; is allowed, since parentheses separate the &lt;code&gt;forall&lt;/code&gt; from the &lt;code&gt;-&amp;gt;&lt;/code&gt;.)</source>
          <target state="translated">GADT 생성자 유형은 현재 중첩이 허용되지 않습니다 &lt;code&gt;forall&lt;/code&gt; s 또는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 들. (예를 들어, 같은 &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; 거부 될 것입니다.) 그 결과, &lt;code&gt;gadt_sig&lt;/code&gt; 전면까지 모든 정량두고 제약 &lt;code&gt;opt_forall&lt;/code&gt; 및 &lt;code&gt;opt_context&lt;/code&gt; 을 . 더 높은 순위의 &lt;code&gt;forall&lt;/code&gt; s 및 &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 의 함수 화살표 오른쪽에 직접 나타나지 않는 경우에만 허용됩니다 . (예 : &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; 것이 허용됩니다. 괄호 가 &lt;code&gt;-&amp;gt;&lt;/code&gt; 와 &lt;code&gt;forall&lt;/code&gt; 을 구분하기 때문 입니다.)</target>
        </trans-unit>
        <trans-unit id="844bd170f572f4ec24f5e9600fd9f1281aa26e3c" translate="yes" xml:space="preserve">
          <source>GADT constructors are extra particular about their &lt;code&gt;forall&lt;/code&gt;s. In addition to adhering to the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, GADT constructors also forbid nested &lt;code&gt;forall&lt;/code&gt;s. For example, GHC would reject the following GADT:</source>
          <target state="translated">GADT 생성자는 &lt;code&gt;forall&lt;/code&gt; 에 대해 매우 특별 합니다. &lt;code&gt;forall&lt;/code&gt; 또는 nothing 규칙 을 준수하는 것 외에도 GADT 생성자는 중첩 된 &lt;code&gt;forall&lt;/code&gt; 을 금지 합니다. 예를 들어 GHC는 다음 GADT를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="translated">GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC 스타일 응답 파일.</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="translated">GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC는 (대부분) Haskell Foreign Function Interface를 따르며, 그 정의는 &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt; 의 Haskell Report의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="0064178248eb2eacd8d3ac6bab315de2aca56d04" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC ( 항상 그렇듯이 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 사용&lt;/a&gt; )는 &quot;충분히 작은&quot;함수 / 값을 인라인 (또는 &quot;펼치기&quot;)하려고하므로 호출 오버 헤드를 피하고 다른 더 멋진 최적화를 노출 할 수 있습니다. GHC에는 호출 사이트에서 함수를 인라인하는 것이 유리한시기를 결정하는 많은 벤치 마크를 사용하여 장기간에 걸쳐 조정 된 일련의 휴리스틱이 있습니다. 휴리스틱 스는 그렇게하는 것이 유익한 것처럼 보일 때 함수를 인라인하도록 설계되었지만 과도한 코드 부풀림을 유발하지 않습니다. 함수가 너무 커 보이면 인라인되지 않으며 특정 크기보다 큰 함수는 정의를 인터페이스 파일로 내보낼 수 없습니다. 이러한 경험적 결정을 제어하는 ​​일부 임계 값은 플래그를 사용하여 변경할 수 있습니다 ( &lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f * : 플랫폼 독립적 플래그 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC ( 항상 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 와 함께 )는 &quot;충분히 작은&quot;기능 / 값을 인라인 (또는 &quot;펼치기&quot;)하려고 시도하여 호출 오버 헤드를 피하고 다른 더 놀라운 최적화를 노출시킵니다. GHC에는 많은 벤치 마크를 사용하여 오랜 기간 동안 조정 된 휴리스틱 세트가 있으며 호출 사이트에서 함수를 인라인하는 것이 유리한 시점을 결정합니다. 휴리스틱은 함수가 유익 할 때 함수를 인라인하도록 설계되었지만 과도한 코드 팽창이 발생하지 않습니다. 함수가 너무 크게 보이면 인라인되지 않으며 특정 크기보다 큰 함수는 인터페이스 파일로 정의를 내 보내지 않아도됩니다. 이러한 휴리스틱 결정을 제어하는 ​​일부 임계 값은 플래그를 사용하여 변경할 수 있습니다 ( &lt;a href=&quot;using-optimisation#options-f&quot;&gt;플랫폼 독립 플래그 -f *&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8은 타입 레벨 자연수를 포함한 산술 표현을 평가할 수 있습니다. 이러한 표현은 유형, 가정 &lt;code&gt;(+), (*), (^)&lt;/code&gt; 하여 더하기, 곱하기 및 지수를 사용하여 구성 할 수 있습니다 . 번호를 사용하여 비교 될 수있다 &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; , 승격 부울 값, 또는 반환을 &lt;code&gt;(&amp;lt;=)&lt;/code&gt; , 제약으로 번호를 비교한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8은 종류와 종류가 실제로는 동일하다고 선언함으로써 종류 다형성의 아이디어를 확장합니다. GHC 내의 어떤 것도 유형과 종류를 구별하지 않습니다. 이것에 대해 생각하는 또 다른 방법은 &lt;code&gt;Bool&lt;/code&gt; 유형 과 &quot;promoted kind&quot; &lt;code&gt;Bool&lt;/code&gt; 이 실제로 동일하다는 것입니다. ( &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;'True&lt;/code&gt; ' 라는 용어 는 표현식에서 사용하고 후자는 유형에서 사용할 수 있기 때문에 여전히 구별됩니다.) 유형과 종류의 구별이 부족하다는 것은 의존적으로 유형이 지정된 언어의 특징입니다. 완전 의존적으로 유형이 지정된 언어는 표현과 유형의 차이를 제거하지만 GHC에서 수행하는 것은 다른 날의 이야기입니다.</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2는 모듈 서명 ( &lt;code&gt;hsig&lt;/code&gt; 파일)을 지원하므로 , 모듈 구현 대신 서명을 작성하여 나중에 구현 선택을 연기 할 수 있습니다. 이 기능은 &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 없이 사용할 수 없습니다 . 이 매뉴얼 항목은 서명의 구문과 의미에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="078f9d9639e0226176f8bd445a4da3cf27270446" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2는 모듈 서명 ( &lt;code&gt;hsig&lt;/code&gt; 파일)을 지원하므로 모듈 구현 대신 서명을 작성하여 구현 선택을 나중 시점까지 연기 할 수 있습니다. 이 기능은 &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; 없이는 사용할 수 없습니다 . 이 매뉴얼 항목은 서명의 구문과 의미에 초점을 맞출 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC 확장 : 이것은 GHC 특정 확장을 얻는 승인 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC 주 : 전화를하기 위해 &lt;code&gt;waitForProcess&lt;/code&gt; 을 시스템의 다른 모든 스레드를 차단하지 않고, 당신이 프로그램을 컴파일해야 &lt;code&gt;-threaded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">GHC는 현재 &lt;strong&gt;의심스러운 경우 거부를&lt;/strong&gt; 채택 합니다. 우리는 그것이 실제로 얼마나 고통 스러운지 알 수 있으며 필요하다면 더 야심 찬 것을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">GHC는 스레드가 &lt;code&gt;foreign export&lt;/code&gt; 를 통해 Haskell 함수를 호출 할 때 소량의 스레드 로컬 메모리를 할당합니다 . 이 메모리는 일반적으로 &lt;code&gt;hs_exit()&lt;/code&gt; 까지 해제되지 않습니다 . Haskell에 대한 후속 호출이 빠르도록 메모리가 캐시됩니다. 그러나 응용 프로그램이 오래 실행되고 Haskell을 호출하는 새 스레드가 반복적으로 생성되는 경우 Haskell 함수 호출을 완료 한 스레드에서이 메모리가 해제되도록 할 수 있습니다. 이렇게하려면 메모리를 해제 할 스레드에서 &lt;code&gt;hs_thread_done()&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC를 사용하면 레코드 구문과 함께 존재도 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC를 사용하면 숫자 리터럴을 10 진수, 8 진수, 16 진수, 2 진수 또는 부동 소수점 표기법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC는 독립형 수 &lt;code&gt;deriving&lt;/code&gt; 으로 사용 선언, &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC를 사용하면 형식 생성자, 클래스 및 형식 변수가 연산자가되고 식과 매우 유사하게 접두사가 작성 될 수 있습니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC는 또한 가시적 인 종류 적용을 허용하는데, 여기서 사용자는 종류 인수가 종류 다형성 경우에 인스턴스화되도록 선언 할 수 있습니다. 사용법은 위에서 지정한 것처럼 용어 수준에서 보이는 유형 응용 프로그램과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC는 두 종류의 잠재적으로 다른 종류와 관련된 &lt;em&gt;종류 이종의&lt;/em&gt; 평등 도 지원합니다 . 이기종 평등의 철자가 &lt;code&gt;~~&lt;/code&gt; 입니다. 차이점을 더 잘 이해하기 위해 &lt;code&gt;~&lt;/code&gt; 와 &lt;code&gt;~~&lt;/code&gt; 의 종류는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC는 항상 인스턴스 의 &lt;em&gt;마지막&lt;/em&gt; 매개 변수 ( 이 예에서는 &lt;code&gt;Foo&lt;/code&gt; )를 인스턴스가 파생되는 유형으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC는 두려운 단일 형성 제한 (Haskell 보고서의 섹션 4.5.5)을 암시 적 매개 변수에 적용합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC는 소스 파일이 ASCII 또는 UTF-8 전용이고 다른 인코딩은 인식되지 않는다고 가정합니다. 그러나 주석에서 유효하지 않은 UTF-8 시퀀스는 무시되므로 주석이 아닌 소스 코드가 ASCII 인 경우 Latin-1과 같은 다른 인코딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC는 가비지 수집기를 사용하여 스레드가 교착 상태가되는시기를 감지하려고합니다. 도달 할 수없는 스레드 (라이브 오브젝트의 포인터를 따라 찾을 수 없음)는 교착 상태 여야하며이 경우 스레드에 예외가 전송됩니다. 예외는 스레드가 교착 상태가되는 방식에 따라 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC는 가비지 수집기를 사용하여 스레드가 교착 상태를 감지하려고합니다. 도달 할 수없는 스레드 (실제 객체의 포인터를 따라 찾을 수 없음)는 교착 상태 여야하며이 경우 스레드에 예외가 전송됩니다. 스레드가 교착 상태에있는 방식에 따라 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 은 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="c272c9b0ad07c2ab3a7ed8c9cf27b583eb6bbea9" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC는 가비지 수집기를 사용하여 스레드가 교착 상태가되는시기를 감지하려고합니다. 도달 할 수없는 스레드 (라이브 오브젝트의 포인터를 따라 찾을 수 없음)는 교착 상태 여야하며이 경우 스레드에 예외가 전송됩니다. 예외는 스레드가 교착 상태가되는 방식에 따라 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC는 컴파일 할 때 Haskell 소스 파일에 대한 풍부한 정보를 작성합니다. 확장 인터페이스 파일은 IDE와 같은 외부 도구가 구문 분석, 유형 검사 및 이름 바꾸기를 피할 수 있도록이 정보 중 일부를 디스크에 유지하는 방법입니다. 이 파일들은</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC는 각 인터페이스 파일 및 인터페이스 파일 내의 각 선언에 대한 지문 (사실 MD5 해시)을 계산합니다. 또한 모든 인터페이스 파일에 파일을 마지막으로 컴파일 할 때 사용한 모든 지문 목록을 유지합니다. 소스 파일의 수정 날짜가 &lt;code&gt;.o&lt;/code&gt; 파일 날짜 보다 빠르면 (즉, 파일이 마지막으로 컴파일 된 이후 소스가 변경되지 않은 경우) 재 컴파일 검사가 켜져 있으면 GHC는 영리합니다. 이것은 이번에 필요한 것에 대한 지문과 마지막에 필요한 것에 대한 지문 (컴파일되는 모듈의 인터페이스 파일에서 수집)을 비교합니다. 모두 동일하면 &quot;컴파일이 필요하지 않습니다&quot;라는 프로세스의 초기에 컴파일이 중지됩니다. 정말 아름다운 광경입니다!</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="translated">GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; , which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC는 코드가 내보내지지 않았다는 것을 알고 있으면 좀 더 공격적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC는 많은 라이브러리와 함께 제공됩니다. 이것들은 별도의 문서에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC는 시간 및 공간 프로파일 링 시스템과 함께 제공되므로&amp;ldquo;프로그램이 왜 느린가요?&amp;rdquo;또는&amp;ldquo;프로그램이 왜 메모리를 많이 사용합니까?&amp;rdquo;와 같은 질문에 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC는 일부 프로그램 구성을 천천히 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC는 부동 소수점 환경을 완전히 무시하며 런타임은이를 수정하거나 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC 는 현재 디렉토리에 하위 디렉토리 &lt;code&gt;.hpc&lt;/code&gt; 를 생성하고 컴파일 된 각 모듈마다 하나씩 HPC 색인 ( &lt;code&gt;.mix&lt;/code&gt; ) 파일을 저장합니다. 이 파일들에 대해 걱정할 필요가 없습니다. 파일에는 프로그램 실행 후 컴파일 된 모듈의 적용 범위 데이터를 생성하기 위해 &lt;code&gt;hpc&lt;/code&gt; 도구에 필요한 정보 가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC는 현재 동의어를 확장하기 전에 종류 검사를 수행합니다 (변경 될 수도 있음).</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHC는 현재 규칙 LHS를 표현식과 일치시키기 위해 매우 간단한 구문 일치 알고리즘을 사용합니다. 그것은 LHS 및 발현을 구문 상으로 모듈로 알파 변환으로 만드는 치환을 추구한다. 필요한 경우 표현식이 아닌 패턴 (규칙)이 확장됩니다. (표현식을 확장하면 게으름 버그가 발생할 수 있습니다.) 그러나 베타 변환 (고차 매칭이라고 함)은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC 는이 이론적 근거에 근거하여 여러 개의 &lt;code&gt;COMPLETE&lt;/code&gt; 세트를 명확하게 설명합니다. 보다 정형화 된 것을 만들기 위해 패턴 일치 검사기가 일부 데이터 유형 생성자 &lt;code&gt;T&lt;/code&gt; 에 대한 생성자 세트를 요청 하면 검사기는 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC는 프로그램에서 어떤 구체적인 유형 수준 리터럴이 사용되고 있는지 알게 되 자마자 제약 조건을 해제합니다. 이것은 임의의 유형 표현식이 아닌 &lt;em&gt;리터럴&lt;/em&gt; 에만 작동합니다 . 예를 들어, 상기 형태의 제약 조건 &lt;code&gt;KnownNat (a + b)&lt;/code&gt; 것이다 &lt;em&gt;하지&lt;/em&gt; 단순화 될 &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; 대신, GHC는 &lt;code&gt;a + b&lt;/code&gt; 를 일정한 값으로 단순화 할 수있을 때까지 제약 조건을 그대로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC에서는 데이터 유형 매개 변수가 아닌 유형 변수를 언급하는 컨텍스트가있는 데이터 유형을 가질 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHC는 Haskell 98에 의해 요구되는 바에 따라 구문 분석하는 동안 표현에서 고정도 해결을 수행하지 않습니다 (하스켈 2010에서는 아님). 예를 들어, Haskell 98 보고서에 따르면 다음 표현은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">각 컴파일마다 GHC를 다시 시작할 필요가 없으므로 컴파일간에 정보를 캐시 할 수 있습니다. &lt;code&gt;ghc --make&lt;/code&gt; 를 사용하여 다중 모듈 프로그램을 컴파일하면 각 소스 파일에서 개별적으로 &lt;code&gt;ghc&lt;/code&gt; 를 실행하는 것보다 최대 2 배 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="translated">GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC는 완전한 게으름을 구현하지 않습니다. on에서 최적화되고 &lt;code&gt;-fno-full-laziness&lt;/code&gt; 가 제공되지 않으면 루프에서 반복 계산을 추출하는 것과 같이 공유를 증가시키는 일부 변환이 수행됩니다. 이것들은 완전히 게으른 구현과 동일한 변환입니다. 차이점은 GHC가 완전히 게으름을 지속적으로 적용하지 않으므로 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC는 인라인이 영원히 지속될 수 없음을 보장합니다. 모든 상호 재귀 그룹 은 절대 인라인되지 않은 하나 이상의 &lt;em&gt;루프 차단기에&lt;/em&gt; 의해 차단됩니다 ( &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;GHC 인라이너의 비밀, 2002 년 7 월 12 일 JFP 12 (4) 참조&lt;/a&gt; ). GHC는 &lt;code&gt;INLINE&lt;/code&gt; pragma를 루프 차단기로 사용하여 기능을 선택하지 않지만, 선택이 없으면 INLINE 기능도 선택할 수 있으며,이 경우 &lt;code&gt;INLINE&lt;/code&gt; pragma는 무시됩니다. 예를 들어, 자체 재귀 함수의 경우 루프 차단기는 함수 자체 만 될 수 있으므로 &lt;code&gt;INLINE&lt;/code&gt; pragma는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC는 내장 ghc 패키지를 통해 내부 API를 사용자에게 공개합니다. Haskell 코드를 프로그래밍 방식으로 분석하거나 컴파일하기 위해 GHC의 전체 컴파일 드라이버를 활용하는 프로그램을 작성할 수 있습니다. 또한, GHC는 GHC의 내부 중간 표현 인 Core를보고 변경할 수있는 모듈 인 컴파일 중에 컴파일러 플러그인을로드 할 수있는 기능을 제공합니다. 플러그인은 실험 최적화 또는 분석에 적합하며 많은 경우에 컴파일러 개발에 대한 진입 장벽을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC는 추가 호출 규칙 &lt;code&gt;prim&lt;/code&gt; 을 사용하여 FFI를 확장합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC는 자동으로 파생 될 수있는 몇 가지 클래스를 추가하여이 목록을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="b8da89741da234fc1301b6c98edbd981b7cba345" translate="yes" xml:space="preserve">
          <source>GHC generates case expressions without a default alternative in some cases:</source>
          <target state="translated">GHC는 경우에 따라 기본 대안없이 케이스 표현식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC에는 런타임시 공유 라이브러리를 찾는 데 사용되는 메소드를 선택하기 위한 &lt;code&gt;-dynload&lt;/code&gt; 링크 플래그가 있습니다. 현재 두 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC는 포괄적 인 옵티 마이저를 가지고 있으므로 실제로 사용하고 싶을 때 (그리고 여유 시간이있을 때) GHC는 매우 빠른 코드를 생성 할 수 있습니다. 또는 기본 옵션은 생성 된 코드를 최적화하기 위해 너무 많은 노력을 기울이지 않으면 서 가능한 한 빨리 컴파일하는 것입니다 (GHC는 아마도 빠른 컴파일러라고 설명하지는 않습니다 :-).</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC에는 &lt;code&gt;Typeable&lt;/code&gt; 클래스 와 관련된 제약 조건을 배출하는 사용자 정의 솔버가 있으며 필기 인스턴스는 금지되어 있습니다. 이를 통해 프로그래머는 가짜 인스턴스를 작성하여 형식 시스템을 전복시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC에는 특별한 동작을 가진 몇 가지 내장 기능이 있습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; , use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . To reverse &lt;code&gt;-Werror&lt;/code&gt; , which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC에는 컴파일 중에 생성 될 수있는 치명적이지 않은 오류 메시지 유형 (예 : 경고)을 선택하는 여러 옵션이 있습니다. 일부 옵션은 개별 경고를 제어하고 다른 옵션은 경고 모음을 제어합니다. 개인 경고 해제하려면 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; 사용 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . 모든 경고를 오류로 만드는``-Werror ''를 되돌리려면 -Wwarn을 사용 &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC는 서명 자체를 모듈로 내보내기하지 않고 서명에 명시 적 내보내기 목록이있을 때 사용되는 &lt;em&gt;시그너처 thinning&lt;/em&gt; 을 실험적으로 지원 합니다. 이 경우 내보내기 목록 &lt;em&gt;은&lt;/em&gt; 병합 &lt;em&gt;후&lt;/em&gt; 최종 내보내기 목록에 적용됩니다 . 특히 로컬 &lt;code&gt;hsig&lt;/code&gt; 파일 의 본문에 선언되지 않은 엔터티를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC는 매우 색다른 지원이 &lt;em&gt;impredicative 다형성&lt;/em&gt; 활성화, &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; 을&lt;/a&gt; . 이 일 경우,이는 것을 의미 &lt;em&gt;할 수&lt;/em&gt; 다형성 유형을 통해 다형성 다형성 유형의 기능과의 파라미터 데이터 구조를 호출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC에는 컴파일 타임에 컴파일러 플러그인을로드 할 수있는 기능이 있습니다. 이 기능은 &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; 에서 제공하는 기능과 유사하며 사용자가 제약 조건 솔버의 동작을 조정하고 컴파일 파이프 라인을 검사 및 수정하며 GHC의 중간 언어 인 Core를 변환 및 검사 할 수있는 플러그인을 작성할 수 있습니다. 플러그인은 실험 분석 또는 최적화에 적합하며 GHC의 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="22a7c64e218b3312ad9be925711deec4357a32a4" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC는 컴파일 타임에 컴파일러 플러그인을로드 할 수 있습니다. 이 기능은 &lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; 에서 제공하는 기능과 유사하며 사용자는 제약 조건 솔버의 동작을 조정하고 컴파일 파이프 라인을 검사 및 수정하고 GHC의 중간 언어 인 Core를 변환 및 검사 할 수있는 플러그인을 작성할 수 있습니다. 플러그인은 실험적 분석 또는 최적화에 적합하며 사용하기 위해 GHC의 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC는 사용자 제공, GHC 제공 및 시스템 제공 ( 예 : &lt;code&gt;-lm&lt;/code&gt; math 라이브러리)을 포함하여 다양한 라이브러리와 코드를 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC에는 GHCi &lt;a href=&quot;ghci#ghci&quot;&gt;사용에&lt;/a&gt; 설명 된 대화식 Haskell 인터프리터 (GHCi라고도 함) 와 &lt;a href=&quot;using#using-ghc&quot;&gt;GHC 사용&lt;/a&gt; 전체에 설명 된 배치 컴파일러가 있습니다. 실제로 GHC는 대화식 또는 배치 시스템을 제공하기 위해 다른 옵션으로 실행되는 단일 프로그램으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHC 홈페이지</target>
        </trans-unit>
        <trans-unit id="7b51be1ff5f1ddedfd931ac8c672d1058c111c02" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC는 최적화가 &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그 로 설정 될 때 어설 션을 무시합니다 . 즉, 형태의 표현 &lt;code&gt;assert pred e&lt;/code&gt; 로 다시 작성합니다 &lt;code&gt;e&lt;/code&gt; . &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 어설 션을 비활성화 할 수도 있습니다. &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하면 최적화가 켜져있는 경우에도 어설 션을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC는 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 최적화를 설정하면 어설 션을 무시합니다 . 즉, 형태의 표현 &lt;code&gt;assert pred e&lt;/code&gt; 로 다시 작성합니다 &lt;code&gt;e&lt;/code&gt; . &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 어설 션을 비활성화 할 수도 있습니다. &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; 옵션을 사용하면 최적화가 설정된 경우에도 어설 션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC는 Haskell 2010 보고서의 FFI 장에 대한 여러 GHC 특정 확장을 구현합니다. 이러한 확장은 &lt;a href=&quot;#ffi-ghcexts&quot;&gt;FHC 장에 대한 GHC 확장에&lt;/a&gt; 설명되어 있지만 이러한 기능을 사용하는 프로그램은 이식 가능하지 않습니다. 따라서 이러한 기능은 가능하면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="translated">GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt; . For example, the type</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC는 선점 형 멀티 태스킹을 구현합니다. 스레드 실행은 임의 방식으로 인터리브됩니다. 보다 구체적으로, 스레드는 일부 메모리를 할당 할 때마다 선점 될 수 있습니다. 불행히도 할당이없는 타이트 루프가 다른 스레드를 잠그는 경향이 있음을 의미합니다 (단, 병리학 적 벤치 마크 스타일 코드에서만 발생 함).</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC는 동시 및 병렬 프로그래밍을 지원하기 위해 Haskell에 대한 몇 가지 주요 확장 기능을 구현합니다. 먼저 용어를 설정합시다 :</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHC는 타입 함수 나 타입 변수가 관련 될 때이 테스트를 보수적으로 구현합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="0fc31183c1e70f82a9bdd1edfbb35d0be9ae0a6c" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;../phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC에는 컴파일 시간에 임의의 프로세스를 실행할 수있는 다양한 플래그가 포함되어 있습니다. 이러한 예 중 하나가 &lt;a href=&quot;../phases#pre-processor&quot;&gt;사용자 지정 전 처리기&lt;/a&gt; 플래그입니다. 다른 하나는 IO 작업을 포함하여 컴파일 타임에 Haskell 코드를 실행할 수있는 Template Haskell의 기능입니다. Safe Haskell &lt;em&gt;은이 위험을 해결하지 않습니다&lt;/em&gt; (템플릿 Haskell은 허용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC에는 컴파일 타임에 임의의 프로세스를 실행할 수있는 다양한 플래그가 포함되어 있습니다. 이러한 예 중 하나는 &lt;a href=&quot;phases#pre-processor&quot;&gt;사용자 지정 전 처리기&lt;/a&gt; 플래그입니다. 또 다른 하나는 템플릿 Haskell이 IO 작업을 포함하여 컴파일시 Haskell 코드를 실행하는 기능입니다. Safe Haskell &lt;em&gt;은 이러한 위험을 해결하지 못합니다&lt;/em&gt; (템플릿 Haskell은 허용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="d09bb52c1f872e95bf9ee5c47a2b96510a0df672" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC에는 대칭 공유 메모리 다중 프로세서 (SMP)에서 병렬로 Haskell 프로그램을 실행하기위한 지원이 포함되어 있습니다. 기본적으로 GHC는 하나의 프로세서에서 프로그램을 실행합니다. 당신이 병렬로 실행하려는 경우 당신은 당신의 프로그램을 연결해야 &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , 그리고 RTS와 실행 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션; &lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용&lt;/a&gt; 참조 ). 런타임은 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS 옵션으로 지정한만큼 병렬로 실행되는 사용 가능한 OS 스레드 사이에서 실행중인 Haskell 스레드를 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC에는 대칭 공유 메모리 다중 프로세서 (SMP)에서 Haskell 프로그램을 병렬로 실행할 수있는 기능이 포함되어 있습니다. 기본적으로 GHC는 하나의 프로세서에서 프로그램을 실행합니다. 당신이 병렬로 실행하려는 경우 당신은 당신의 프로그램을 연결해야 &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , 그리고 RTS와 실행 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 옵션; &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;SMP 병렬 처리 사용&lt;/a&gt; 참조 ). 런타임은 사용 가능한 OS 스레드 중에서 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS 옵션으로 지정한 수만큼 병렬로 실행중인 Haskell 스레드를 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 여러 단계로 구성된 대규모 프로그램입니다. 아래 나열된 &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; 플래그를 사용하여 다양한 컴파일 단계에서 정보를 덤프하도록 GHC에 지시 할 수 있습니다 . 이들 중 일부는 많은 출력을 생성하는 경향이 있습니다. &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; 을&lt;/a&gt; 전달하여 표준 출력이 막히지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC는 기본 데이터 유형과 작업에 기반을두고 있습니다. 하스켈 자체에서 정의 될 수 없다는 의미에서 &quot;원시적&quot;. 이 코드를 사용하여 빠른 코드를 작성할 수는 있지만 일반적으로 더 높은 수준의 언어 기능 및 라이브러리를 사용하는 것이 훨씬 덜 고통스럽고 장기적으로 더 만족 스럽습니다. 운 좋게도, 작성한 코드는 어떠한 경우에도 효율적인 언 박스 버전에 최적화됩니다. 그렇지 않다면, 우리는 그것에 대해 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC 자체는 Haskell 프로그램이므로 옵션을 GHC 런타임 시스템에 직접 전달해야하는 경우 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 묶을 수 있습니다 ( &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;컴파일 된 프로그램 실행&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHC는 놀랍게도 &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 가&lt;/a&gt; 없는 일반 컴파일에 적합합니다 !</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC는 작업 중복에 대해 매우 신중합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC는 인터페이스 파일에 매우 민감합니다. 예를 들어 비표준 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 선택하면 꽤 끔찍한 일이 발생합니다. 당신이 설정 한 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude 옵션 당신은 당신이 무엇을하고 있는지 알지 못한다면, 컴파일러는 거의 확실하게 죽을 것이다.</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC는 프로그램을 최적화 할 때 규칙을 계속 적용하려고합니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHC는 특히 두 가지 패키지 데이터베이스에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC를 사용하면 컴파일시 &lt;code&gt;-with-rtsopts&lt;/code&gt; 플래그 ( &lt;a href=&quot;phases#options-linker&quot;&gt;링크에 영향을주는 옵션&lt;/a&gt; )를 사용하여 프로그램의 기본 RTS 옵션을 변경할 수 있습니다 . 이를위한 일반적인 용도는 프로그램에 기본보다 큰 기본 힙 및 / 또는 스택 크기를 제공하는 것입니다. 예를 들어, 설정 &lt;code&gt;-H128m -K64m&lt;/code&gt; 와 링크 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHC를 사용하면 런타임 시스템에서 호출하는 &quot;후크&quot;를 컴파일하여 특정 프로그램에 대한 특정 RTS 설정을 기초적으로 제어 할 수 있습니다. RTS에는 이러한 후크에 대한 스텁 정의가 포함되어 있지만 자체 버전을 작성하고 GHC 명령 행에서 링크하면 기본값을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 언어 확장으로이 제한을 해제합니다 . 제한은 처음에는 꽤 어리석은 일이므로 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="026e2f888db92431c91e24d1a0558f32b93663ed" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC는 언어 확장 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 를 사용하여이 제한을 해제합니다 . 제한은 처음에는 꽤 어리석은 것이므로 &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; 에&lt;/a&gt; 의해 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC는 단일 생성자 데이터 유형을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC는 거주하는 모든 유형의 유형 (유형 생성자 또는 유형 레벨 데이터와 구별됨)이 해당 유형의 값의 런타임 표현을 알려주는 특성을 유지합니다. 이 데이터 유형은 런타임 값의 선택을 인코딩합니다. 참고 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; 의해 매개 변수화된다 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; 을 ; 이것은 타입의 종류가 런타임 표현을 인코딩한다는 사실에 의해 우리가 의미하는 바입니다.</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC는 규칙의 LHS와 RHS가 동일한 의미를 갖는지 검증하려고 시도하지 않습니다. 그것은 일반적으로 결정 불가능하며 가장 흥미로운 경우에는 불가능합니다. 책임은 전적으로 프로그래머의 책임입니다!</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC는 규칙이 합리적이거나 종료되는지 확인하려고 시도하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC는 &lt;code&gt;.debug_info&lt;/code&gt; 섹션 에서 다음 표준 DIE를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093f5ff97cdf917305aab74e98feadff3bea2477" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;../codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC는 C를 통해 컴파일 할 때 더 이상 외부 헤더 파일을 포함하지 않으므로이 검사는 수행되지 않습니다. &lt;a href=&quot;../codegens#native-code-gen&quot;&gt;네이티브 코드 생성기&lt;/a&gt; ( &lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; ) 와의 호환성을 위해 변경되었으며 FFI 호출이 매크로 확장 및 C 헤더 파일을 사용할 때 적용될 수있는 기타 CPP 변환의 영향을받지 않아야하는 FFI 사양을 엄격하게 준수하도록 변경되었습니다 . 이 접근 방식은 또한 모듈 및 패키지 경계를 넘어 외래 호출의 인라인을 단순화합니다. 인라인 된 버전의 외래 호출을 컴파일 할 때 헤더 파일을 사용할 필요가 없으므로 컴파일러는 모든 컨텍스트에서 외래 호출을 자유롭게 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">C를 통해 컴파일 할 때 GHC에 더 이상 외부 헤더 파일이 포함되지 않으므로이 검사는 수행되지 않습니다. &lt;a href=&quot;codegens#native-code-gen&quot;&gt;기본 코드 생성기&lt;/a&gt; ( &lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; )와 호환되고 FFI 사양을 엄격하게 준수하도록 변경되었습니다. FFI 호출에는 매크로 확장 및 C 헤더 파일을 사용할 때 적용될 수있는 기타 CPP 변환이 적용되지 않아야합니다. 이 접근 방식은 또한 모듈 및 패키지 경계에 걸쳐 외래 호출의 인라인을 단순화합니다. 외래 호출의 인라인 버전을 컴파일 할 때 헤더 파일을 사용할 필요가 없으므로 컴파일러는 어떤 상황에서도 외래 호출을 자유롭게 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC는 일반적으로 &lt;code&gt;Prelude.hi&lt;/code&gt; 파일을 가져옵니다 . 그렇지 않은 경우 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; 옵션을 지정하십시오. 아이디어는 Prelude를 직접 가져올 수 있다는 것입니다. 그러나 &lt;code&gt;Prelude&lt;/code&gt; 라고하지 마십시오 . Haskell 모듈 네임 스페이스는 단순하므로 Prelude 모듈과 충돌해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC 참고 : 가비지 수집기가 프로그램에 의해 참조되지 않은 것으로 감지되면 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 이 자동으로 닫힙니다. 그러나이 동작에 의존하는 것은 일반적으로 권장되지 않습니다. 가비지 수집기는 예측할 수 없습니다. 가능하면 명시 적 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 를 사용하여 더 이상 필요하지 않은 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 을 닫으십시오 . GHC는 현재 파일 디스크립터가 부족할 때 파일 디스크립터를 비우려고 시도하지 않으며, 이것이 발생하지 않도록하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC 참고 : 기능의 수 는 프로그램이 시작될 때 &lt;code&gt;+RTS -N&lt;/code&gt; 옵션으로 지정됩니다 . 기본 운영 체제에서 지원하는 경우 &lt;code&gt;+RTS -qa&lt;/code&gt; 를 사용하여 기능을 실제 프로세서 코어에 고정 할 수 있지만 실제로는 불필요하지만 (실제로 성능이 저하 될 수 있으며 실험이 권장됩니다).</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC 메모 : &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 은 GHC에서 최적화 된 구현을 가지고 있습니다. 가비지 수집 힙에서 고정 된 메모리를 사용하므로 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 은 메모리를 해제하기 위해 종료자가 필요하지 않습니다. 의 사용 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 및 관련 기능을 강하게에 우선 추천 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 파이널 라이저와 함께.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
